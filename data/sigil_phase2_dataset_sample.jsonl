{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse parking_lot::Mutex;\n\nuse crate::Config;\nuse crate::http::private::cookie;\n\n#[doc(inline)]\npub use self::cookie::{Cookie, SameSite, Iter};\n\n/// Collection of one or more HTTP cookies.\n///\n/// `CookieJar` allows for retrieval of cookies from an incoming request. It\n/// also tracks modifications (additions and removals) and marks them as\n/// pending.\n///\n/// # Pending\n///\n/// Changes to a `CookieJar` are _not_ visible via the normal [`get()`] and\n/// [`get_private()`] methods. This is typically the desired effect as a\n/// `CookieJar` always reflects the cookies in an incoming request. In cases\n/// where this is not desired, the [`get_pending()`] method is available, which\n/// always returns the latest changes.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::http::{CookieJar, Cookie};\n///\n/// #[get(\"/message\")]\n/// fn message(jar: &CookieJar<'_>) {\n///     jar.add((\"message\", \"hello!\"));\n///     jar.add(Cookie::build((\"session\", \"bye!\")).expires(None));\n///\n///     // `get()` does not reflect changes.\n///     assert!(jar.get(\"session\").is_none());\n///     assert_eq!(jar.get(\"message\").map(|c| c.value()), Some(\"hi\"));\n///\n///     // `get_pending()` does.\n///     let session_pending = jar.get_pending(\"session\");\n///     let message_pending = jar.get_pending(\"message\");\n///     assert_eq!(session_pending.as_ref().map(|c| c.value()), Some(\"bye!\"));\n///     assert_eq!(message_pending.as_ref().map(|c| c.value()), Some(\"hello!\"));\n///     # jar.remove(\"message\");\n///     # assert_eq!(jar.get(\"message\").map(|c| c.value()), Some(\"hi\"));\n///     # assert!(jar.get_pending(\"message\").is_none());\n/// }\n/// # fn main() {\n/// #     use rocket::local::blocking::Client;\n/// #     let client = Client::debug_with(routes![message]).unwrap();\n/// #     let response = client.get(\"/message\")\n/// #         .cookie((\"message\", \"hi\"))\n/// #         .dispatch();\n/// #\n/// #     assert!(response.status().class().is_success());\n/// # }\n/// ```\n///\n/// # Usage\n///\n/// A type of `&CookieJar` can be retrieved via its `FromRequest` implementation\n/// as a request guard or via the [`Request::cookies()`] method. Individual\n/// cookies can be retrieved via the [`get()`] and [`get_private()`] methods.\n/// Pending changes can be observed via the [`get_pending()`] method. Cookies\n/// can be added or removed via the [`add()`], [`add_private()`], [`remove()`],\n/// and [`remove_private()`] methods.\n///\n/// [`Request::cookies()`]: crate::Request::cookies()\n/// [`get()`]: #method.get\n/// [`get_private()`]: #method.get_private\n/// [`get_pending()`]: #method.get_pending\n/// [`add()`]: #method.add\n/// [`add_private()`]: #method.add_private\n/// [`remove()`]: #method.remove\n/// [`remove_private()`]: #method.remove_private\n///\n/// ## Examples\n///\n/// The following example shows `&CookieJar` being used as a request guard in a\n/// handler to retrieve the value of a \"message\" cookie.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::http::CookieJar;\n///\n/// #[get(\"/message\")]\n/// fn message<'a>(jar: &'a CookieJar<'_>) -> Option<&'a str> {\n///     jar.get(\"message\").map(|cookie| cookie.value())\n/// }\n/// # fn main() {  }\n/// ```\n///\n/// The following snippet shows `&CookieJar` being retrieved from a `Request` in\n/// a custom request guard implementation for `User`. A [private cookie]\n/// containing a user's ID is retrieved. If the cookie exists and the ID parses\n/// as an integer, a `User` structure is validated. Otherwise, the guard\n/// forwards.\n///\n/// [private cookie]: #method.add_private\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # #[cfg(feature = \"secrets\")] {\n/// use rocket::http::Status;\n/// use rocket::request::{self, Request, FromRequest};\n/// use rocket::outcome::IntoOutcome;\n///\n/// // In practice, we'd probably fetch the user from the database.\n/// struct User(usize);\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for User {\n///     type Error = std::convert::Infallible;\n///\n///     async fn from_request(request: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n///         request.cookies()\n///             .get_private(\"user_id\")\n///             .and_then(|c| c.value().parse().ok())\n///             .map(|id| User(id))\n///             .or_forward(Status::Unauthorized)\n///     }\n/// }\n/// # }\n/// # fn main() { }\n/// ```\n///\n/// # Private Cookies\n///\n/// _Private_ cookies are just like regular cookies except that they are\n/// encrypted using authenticated encryption, a form of encryption which\n/// simultaneously provides confidentiality, integrity, and authenticity. This\n/// means that private cookies cannot be inspected, tampered with, or\n/// manufactured by clients. If you prefer, you can think of private cookies as\n/// being signed and encrypted.\n///\n/// Private cookies can be retrieved, added, and removed from a `CookieJar`\n/// collection via the [`get_private()`], [`add_private()`], and\n/// [`remove_private()`] methods.\n///\n/// ## Encryption Key\n///\n/// To encrypt private cookies, Rocket uses the 256-bit key specified in the\n/// `secret_key` configuration parameter. If one is not specified, Rocket will\n/// automatically generate a fresh key. Note, however, that a private cookie can\n/// only be decrypted with the same key with which it was encrypted. As such, it\n/// is important to set a `secret_key` configuration parameter when using\n/// private cookies so that cookies decrypt properly after an application\n/// restart. Rocket will emit a warning if an application is run in production\n/// mode without a configured `secret_key`.\n///\n/// Generating a string suitable for use as a `secret_key` configuration value\n/// is usually done through tools like `openssl`. Using `openssl`, for instance,\n/// a 256-bit base64 key can be generated with the command `openssl rand -base64\n/// 32`.\npub struct CookieJar<'a> {\n    jar: cookie::CookieJar,\n    ops: Mutex<Vec<Op>>,\n    config: &'a Config,\n}\n\nimpl<'a> Clone for CookieJar<'a> {\n    fn clone(&self) -> Self {\n        CookieJar {\n            jar: self.jar.clone(),\n            ops: Mutex::new(self.ops.lock().clone()),\n            config: self.config,\n        }\n    }\n}\n\n#[derive(Clone)]\nenum Op {\n    Add(Cookie<'static>, bool),\n    Remove(Cookie<'static>, bool),\n}\n\nimpl Op {\n    fn cookie(&self) -> &Cookie<'static> {\n        match self {\n            Op::Add(c, _) | Op::Remove(c, _) => c\n        }\n    }\n}\n\nimpl<'a> CookieJar<'a> {\n    #[inline(always)]\n    pub(crate) fn new(config: &'a Config) -> Self {\n        CookieJar::from(cookie::CookieJar::new(), config)\n    }\n\n    pub(crate) fn from(jar: cookie::CookieJar, config: &'a Config) -> Self {\n        CookieJar { jar, config, ops: Mutex::new(Vec::new()) }\n    }\n\n    /// Returns a reference to the _original_ `Cookie` inside this container\n    /// with the name `name`. If no such cookie exists, returns `None`.\n    ///\n    /// **Note:** This method _does not_ observe changes made via additions and\n    /// removals to the cookie jar. To observe those changes, use\n    /// [`CookieJar::get_pending()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::CookieJar;\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     let cookie = jar.get(\"name\");\n    /// }\n    /// ```\n    pub fn get(&self, name: &str) -> Option<&Cookie<'static>> {\n        self.jar.get(name)\n    }\n\n    /// Retrieves the _original_ `Cookie` inside this collection with the name\n    /// `name` and authenticates and decrypts the cookie's value. If the cookie\n    /// cannot be found, or the cookie fails to authenticate or decrypt, `None`\n    /// is returned.\n    ///\n    /// **Note:** This method _does not_ observe changes made via additions and\n    /// removals to the cookie jar. To observe those changes, use\n    /// [`CookieJar::get_pending()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::CookieJar;\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     let cookie = jar.get_private(\"name\");\n    /// }\n    /// ```\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    pub fn get_private(&self, name: &str) -> Option<Cookie<'static>> {\n        self.jar.private(&self.config.secret_key.key).get(name)\n    }\n\n    /// Returns a reference to the _original or pending_ `Cookie` inside this\n    /// container with the name `name`, irrespective of whether the cookie was\n    /// private or not. If no such cookie exists, returns `None`.\n    ///\n    /// In general, due to performance overhead, calling this method should be\n    /// avoided if it is known that a cookie called `name` is not pending.\n    /// Instead, prefer to use [`CookieJar::get()`] or\n    /// [`CookieJar::get_private()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::CookieJar;\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     let pending_cookie = jar.get_pending(\"name\");\n    /// }\n    /// ```\n    pub fn get_pending(&self, name: &str) -> Option<Cookie<'static>> {\n        let ops = self.ops.lock();\n        for op in ops.iter().rev().filter(|op| op.cookie().name() == name) {\n            match op {\n                Op::Add(c, _) => return Some(c.clone()),\n                Op::Remove(_, _) => return None,\n            }\n        }\n\n        drop(ops);\n\n        #[cfg(feature = \"secrets\")] {\n            self.get_private(name).or_else(|| self.get(name).cloned())\n        }\n\n        #[cfg(not(feature = \"secrets\"))] {\n            self.get(name).cloned()\n        }\n    }\n\n    /// Adds `cookie` to this collection.\n    ///\n    /// Unless a value is set for the given property, the following defaults are\n    /// set on `cookie` before being added to `self`:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Strict`\n    ///\n    /// Furthermore, if TLS is enabled, the `Secure` cookie flag is set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::{Cookie, SameSite, CookieJar};\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     jar.add((\"first\", \"value\"));\n    ///\n    ///     let cookie = Cookie::build((\"other\", \"value_two\"))\n    ///         .path(\"/\")\n    ///         .secure(true)\n    ///         .same_site(SameSite::Lax);\n    ///\n    ///     jar.add(cookie);\n    /// }\n    /// ```\n    pub fn add<C: Into<Cookie<'static>>>(&self, cookie: C) {\n        let mut cookie = cookie.into();\n        Self::set_defaults(self.config, &mut cookie);\n        self.ops.lock().push(Op::Add(cookie, false));\n    }\n\n    /// Adds `cookie` to the collection. The cookie's value is encrypted with\n    /// authenticated encryption assuring confidentiality, integrity, and\n    /// authenticity. The cookie can later be retrieved using\n    /// [`get_private`](#method.get_private) and removed using\n    /// [`remove_private`](#method.remove_private).\n    ///\n    /// Unless a value is set for the given property, the following defaults are\n    /// set on `cookie` before being added to `self`:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Strict`\n    ///    * `HttpOnly`: `true`\n    ///    * `Expires`: 1 week from now\n    ///\n    /// Furthermore, if TLS is enabled, the `Secure` cookie flag is set. These\n    /// defaults ensure maximum usability and security. For additional security,\n    /// you may wish to set the `secure` flag.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::CookieJar;\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     jar.add_private((\"name\", \"value\"));\n    /// }\n    /// ```\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    pub fn add_private<C: Into<Cookie<'static>>>(&self, cookie: C) {\n        let mut cookie = cookie.into();\n        Self::set_private_defaults(self.config, &mut cookie);\n        self.ops.lock().push(Op::Add(cookie, true));\n    }\n\n    /// Removes `cookie` from this collection and generates a \"removal\" cookie\n    /// to send to the client on response. A \"removal\" cookie is a cookie that\n    /// has the same name as the original cookie but has an empty value, a\n    /// max-age of 0, and an expiration date far in the past.\n    ///\n    /// **For successful removal, `cookie` must contain the same `path` and\n    /// `domain` as the cookie that was originally set. The cookie will fail to\n    /// be deleted if any other `path` and `domain` are provided. For\n    /// convenience, a path of `\"/\"` is automatically set when one is not\n    /// specified.** The full list of defaults when corresponding values aren't\n    /// specified is:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Lax`\n    ///\n    /// <small>Note: a default setting of `Lax` for `SameSite` carries no\n    /// security implications: the removal cookie has expired, so it is never\n    /// transferred to any origin.</small>\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::{Cookie, CookieJar};\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     // `path` and `SameSite` are set to defaults (`/` and `Lax`)\n    ///     jar.remove(\"name\");\n    ///\n    ///     // Use a custom-built cookie to set a custom path.\n    ///     jar.remove(Cookie::build(\"name\").path(\"/login\"));\n    ///\n    ///     // Use a custom-built cookie to set a custom path and domain.\n    ///     jar.remove(Cookie::build(\"id\").path(\"/guide\").domain(\"rocket.rs\"));\n    /// }\n    /// ```\n    pub fn remove<C: Into<Cookie<'static>>>(&self, cookie: C) {\n        let mut cookie = cookie.into();\n        Self::set_removal_defaults(&mut cookie);\n        self.ops.lock().push(Op::Remove(cookie, false));\n    }\n\n    /// Removes the private `cookie` from the collection.\n    ///\n    /// **For successful removal, `cookie` must contain the same `path` and\n    /// `domain` as the cookie that was originally set. The cookie will fail to\n    /// be deleted if any other `path` and `domain` are provided. For\n    /// convenience, a path of `\"/\"` is automatically set when one is not\n    /// specified.** The full list of defaults when corresponding values aren't\n    /// specified is:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Lax`\n    ///\n    /// <small>Note: a default setting of `Lax` for `SameSite` carries no\n    /// security implications: the removal cookie has expired, so it is never\n    /// transferred to any origin.</small>\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::{CookieJar, Cookie};\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     // `path` and `SameSite` are set to defaults (`/` and `Lax`)\n    ///     jar.remove_private(\"name\");\n    ///\n    ///     // Use a custom-built cookie to set a custom path.\n    ///     jar.remove_private(Cookie::build(\"name\").path(\"/login\"));\n    ///\n    ///     // Use a custom-built cookie to set a custom path and domain.\n    ///     let cookie = Cookie::build(\"id\").path(\"/guide\").domain(\"rocket.rs\");\n    ///     jar.remove_private(cookie);\n    /// }\n    /// ```\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    pub fn remove_private<C: Into<Cookie<'static>>>(&self, cookie: C) {\n        let mut cookie = cookie.into();\n        Self::set_removal_defaults(&mut cookie);\n        self.ops.lock().push(Op::Remove(cookie, true));\n    }\n\n    /// Returns an iterator over all of the _original_ cookies present in this\n    /// collection.\n    ///\n    /// **Note:** This method _does not_ observe changes made via additions and\n    /// removals to the cookie jar.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::http::CookieJar;\n    ///\n    /// #[get(\"/\")]\n    /// fn handler(jar: &CookieJar<'_>) {\n    ///     for c in jar.iter() {\n    ///         println!(\"Name: {:?}, Value: {:?}\", c.name(), c.value());\n    ///     }\n    /// }\n    /// ```\n    pub fn iter(&self) -> impl Iterator<Item=&Cookie<'static>> {\n        self.jar.iter()\n    }\n\n    /// Removes all delta cookies.\n    #[inline(always)]\n    pub(crate) fn reset_delta(&self) {\n        self.ops.lock().clear();\n    }\n\n    /// TODO: This could be faster by just returning the cookies directly via\n    /// an ordered hash-set of sorts.\n    pub(crate) fn take_delta_jar(&self) -> cookie::CookieJar {\n        let ops = std::mem::take(&mut *self.ops.lock());\n        let mut jar = cookie::CookieJar::new();\n\n        for op in ops {\n            match op {\n                Op::Add(c, false) => jar.add(c),\n                #[cfg(feature = \"secrets\")]\n                Op::Add(c, true) => {\n                    jar.private_mut(&self.config.secret_key.key).add(c);\n                }\n                Op::Remove(mut c, _) => {\n                    if self.jar.get(c.name()).is_some() {\n                        c.make_removal();\n                        jar.add(c);\n                    } else {\n                        jar.remove(c);\n                    }\n                }\n                #[allow(unreachable_patterns)]\n                _ => unreachable!()\n            }\n        }\n\n        jar\n    }\n\n    /// Adds an original `cookie` to this collection.\n    #[inline(always)]\n    pub(crate) fn add_original(&mut self, cookie: Cookie<'static>) {\n        self.jar.add_original(cookie)\n    }\n\n    /// Adds an original, private `cookie` to the collection.\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    #[inline(always)]\n    pub(crate) fn add_original_private(&mut self, cookie: Cookie<'static>) {\n        self.jar.private_mut(&self.config.secret_key.key).add_original(cookie);\n    }\n\n    /// For each property mentioned below, this method checks if there is a\n    /// provided value and if there is none, sets a default value. Default\n    /// values are:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Strict`\n    ///\n    /// Furthermore, if TLS is enabled, the `Secure` cookie flag is set.\n    fn set_defaults(config: &Config, cookie: &mut Cookie<'static>) {\n        if cookie.path().is_none() {\n            cookie.set_path(\"/\");\n        }\n\n        if cookie.same_site().is_none() {\n            cookie.set_same_site(SameSite::Strict);\n        }\n\n        if cookie.secure().is_none() && config.tls_enabled() {\n            cookie.set_secure(true);\n        }\n    }\n\n    /// For each property below, this method checks if there is a provided value\n    /// and if there is none, sets a default value. Default values are:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Lax`\n    fn set_removal_defaults(cookie: &mut Cookie<'static>) {\n        if cookie.path().is_none() {\n            cookie.set_path(\"/\");\n        }\n\n        if cookie.same_site().is_none() {\n            cookie.set_same_site(SameSite::Lax);\n        }\n    }\n\n    /// For each property mentioned below, this method checks if there is a\n    /// provided value and if there is none, sets a default value. Default\n    /// values are:\n    ///\n    ///    * `path`: `\"/\"`\n    ///    * `SameSite`: `Strict`\n    ///    * `HttpOnly`: `true`\n    ///    * `Expires`: 1 week from now\n    ///\n    /// Furthermore, if TLS is enabled, the `Secure` cookie flag is set.\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    fn set_private_defaults(config: &Config, cookie: &mut Cookie<'static>) {\n        if cookie.path().is_none() {\n            cookie.set_path(\"/\");\n        }\n\n        if cookie.same_site().is_none() {\n            cookie.set_same_site(SameSite::Strict);\n        }\n\n        if cookie.http_only().is_none() {\n            cookie.set_http_only(true);\n        }\n\n        if cookie.expires().is_none() {\n            cookie.set_expires(time::OffsetDateTime::now_utc() + time::Duration::weeks(1));\n        }\n\n        if cookie.secure().is_none() && config.tls_enabled() {\n            cookie.set_secure(true);\n        }\n    }\n}\n\nimpl fmt::Debug for CookieJar<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let pending: Vec<_> = self.ops.lock()\n            .iter()\n            .map(|c| c.cookie())\n            .cloned()\n            .collect();\n\n        f.debug_struct(\"CookieJar\")\n            .field(\"original\", &self.jar)\n            .field(\"pending\", &pending)\n            .finish()\n    }\n\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types representing various errors that can occur in a Rocket application.\n\nuse std::{io, fmt};\nuse std::sync::{Arc, atomic::{Ordering, AtomicBool}};\nuse std::error::Error as StdError;\n\nuse yansi::Paint;\nuse figment::Profile;\n\nuse crate::{Rocket, Orbit};\n\n/// An error that occurs during launch.\n///\n/// An `Error` is returned by [`launch()`](Rocket::launch()) when launching an\n/// application fails or, more rarely, when the runtime fails after launching.\n///\n/// # Panics\n///\n/// A value of this type panics if it is dropped without first being inspected.\n/// An _inspection_ occurs when any method is called. For instance, if\n/// `println!(\"Error: {}\", e)` is called, where `e: Error`, the `Display::fmt`\n/// method being called by `println!` results in `e` being marked as inspected;\n/// a subsequent `drop` of the value will _not_ result in a panic. The following\n/// snippet illustrates this:\n///\n/// ```rust\n/// # let _ = async {\n/// if let Err(error) = rocket::build().launch().await {\n///     // This println \"inspects\" the error.\n///     println!(\"Launch failed! Error: {}\", error);\n///\n///     // This call to drop (explicit here for demonstration) will do nothing.\n///     drop(error);\n/// }\n/// # };\n/// ```\n///\n/// When a value of this type panics, the corresponding error message is pretty\n/// printed to the console. The following illustrates this:\n///\n/// ```rust\n/// # let _ = async {\n/// let error = rocket::build().launch().await;\n///\n/// // This call to drop (explicit here for demonstration) will result in\n/// // `error` being pretty-printed to the console along with a `panic!`.\n/// drop(error);\n/// # };\n/// ```\n///\n/// # Usage\n///\n/// An `Error` value should usually be allowed to `drop` without inspection.\n/// There are at least two exceptions:\n///\n///   1. If you are writing a library or high-level application on-top of\n///      Rocket, you likely want to inspect the value before it drops to avoid a\n///      Rocket-specific `panic!`. This typically means simply printing the\n///      value.\n///\n///   2. You want to display your own error messages.\npub struct Error {\n    handled: AtomicBool,\n    kind: ErrorKind\n}\n\n/// The kind error that occurred.\n///\n/// In almost every instance, a launch error occurs because of an I/O error;\n/// this is represented by the `Io` variant. A launch error may also occur\n/// because of ill-defined routes that lead to collisions or because a fairing\n/// encountered an error; these are represented by the `Collision` and\n/// `FailedFairing` variants, respectively.\n#[derive(Debug)]\n#[non_exhaustive]\npub enum ErrorKind {\n    /// Binding to the provided address/port failed.\n    Bind(io::Error),\n    /// An I/O error occurred during launch.\n    Io(io::Error),\n    /// A valid [`Config`](crate::Config) could not be extracted from the\n    /// configured figment.\n    Config(figment::Error),\n    /// Route collisions were detected.\n    Collisions(crate::router::Collisions),\n    /// Launch fairing(s) failed.\n    FailedFairings(Vec<crate::fairing::Info>),\n    /// Sentinels requested abort.\n    SentinelAborts(Vec<crate::sentinel::Sentry>),\n    /// The configuration profile is not debug but not secret key is configured.\n    InsecureSecretKey(Profile),\n    /// Shutdown failed.\n    Shutdown(\n        /// The instance of Rocket that failed to shutdown.\n        Arc<Rocket<Orbit>>,\n        /// The error that occurred during shutdown, if any.\n        Option<Box<dyn StdError + Send + Sync>>\n    ),\n}\n\nimpl From<ErrorKind> for Error {\n    fn from(kind: ErrorKind) -> Self {\n        Error::new(kind)\n    }\n}\n\nimpl Error {\n    #[inline(always)]\n    pub(crate) fn new(kind: ErrorKind) -> Error {\n        Error { handled: AtomicBool::new(false), kind }\n    }\n\n    #[inline(always)]\n    pub(crate) fn shutdown<E>(rocket: Arc<Rocket<Orbit>>, error: E) -> Error\n        where E: Into<Option<crate::http::hyper::Error>>\n    {\n        let error = error.into().map(|e| Box::new(e) as Box<dyn StdError + Sync + Send>);\n        Error::new(ErrorKind::Shutdown(rocket, error))\n    }\n\n    #[inline(always)]\n    fn was_handled(&self) -> bool {\n        self.handled.load(Ordering::Acquire)\n    }\n\n    #[inline(always)]\n    fn mark_handled(&self) {\n        self.handled.store(true, Ordering::Release)\n    }\n\n    /// Retrieve the `kind` of the launch error.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::error::ErrorKind;\n    ///\n    /// # let _ = async {\n    /// if let Err(error) = rocket::build().launch().await {\n    ///     match error.kind() {\n    ///         ErrorKind::Io(e) => println!(\"found an i/o launch error: {}\", e),\n    ///         e => println!(\"something else happened: {}\", e)\n    ///     }\n    /// }\n    /// # };\n    /// ```\n    #[inline]\n    pub fn kind(&self) -> &ErrorKind {\n        self.mark_handled();\n        &self.kind\n    }\n\n    /// Prints the error with color (if enabled) and detail. Returns a string\n    /// that indicates the abort condition such as \"aborting due to i/o error\".\n    ///\n    /// This function is called on `Drop` to display the error message. By\n    /// contrast, the `Display` implementation prints a succinct version of the\n    /// error, without detail.\n    ///\n    /// ```rust\n    /// # let _ = async {\n    /// if let Err(error) = rocket::build().launch().await {\n    ///     let abort = error.pretty_print();\n    ///     panic!(\"{}\", abort);\n    /// }\n    /// # };\n    /// ```\n    pub fn pretty_print(&self) -> &'static str {\n        self.mark_handled();\n        match self.kind() {\n            ErrorKind::Bind(ref e) => {\n                error!(\"Rocket failed to bind network socket to given address/port.\");\n                info_!(\"{}\", e);\n                \"aborting due to socket bind error\"\n            }\n            ErrorKind::Io(ref e) => {\n                error!(\"Rocket failed to launch due to an I/O error.\");\n                info_!(\"{}\", e);\n                \"aborting due to i/o error\"\n            }\n            ErrorKind::Collisions(ref collisions) => {\n                fn log_collisions<T: fmt::Display>(kind: &str, collisions: &[(T, T)]) {\n                    if collisions.is_empty() { return }\n\n                    error!(\"Rocket failed to launch due to the following {} collisions:\", kind);\n                    for &(ref a, ref b) in collisions {\n                        info_!(\"{} {} {}\", a, \"collides with\".red().italic(), b)\n                    }\n                }\n\n                log_collisions(\"route\", &collisions.routes);\n                log_collisions(\"catcher\", &collisions.catchers);\n\n                info_!(\"Note: Route collisions can usually be resolved by ranking routes.\");\n                \"aborting due to detected routing collisions\"\n            }\n            ErrorKind::FailedFairings(ref failures) => {\n                error!(\"Rocket failed to launch due to failing fairings:\");\n                for fairing in failures {\n                    info_!(\"{}\", fairing.name);\n                }\n\n                \"aborting due to fairing failure(s)\"\n            }\n            ErrorKind::InsecureSecretKey(profile) => {\n                error!(\"secrets enabled in non-debug without `secret_key`\");\n                info_!(\"selected profile: {}\", profile.primary().bold());\n                info_!(\"disable `secrets` feature or configure a `secret_key`\");\n                \"aborting due to insecure configuration\"\n            }\n            ErrorKind::Config(error) => {\n                crate::config::pretty_print_error(error.clone());\n                \"aborting due to invalid configuration\"\n            }\n            ErrorKind::SentinelAborts(ref errors) => {\n                error!(\"Rocket failed to launch due to aborting sentinels:\");\n                for sentry in errors {\n                    let name = sentry.type_name.primary().bold();\n                    let (file, line, col) = sentry.location;\n                    info_!(\"{} ({}:{}:{})\", name, file, line, col);\n                }\n\n                \"aborting due to sentinel-triggered abort(s)\"\n            }\n            ErrorKind::Shutdown(_, error) => {\n                error!(\"Rocket failed to shutdown gracefully.\");\n                if let Some(e) = error {\n                    info_!(\"{}\", e);\n                }\n\n                \"aborting due to failed shutdown\"\n            }\n        }\n    }\n}\n\nimpl std::error::Error for Error {  }\n\nimpl fmt::Display for ErrorKind {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorKind::Bind(e) => write!(f, \"binding failed: {}\", e),\n            ErrorKind::Io(e) => write!(f, \"I/O error: {}\", e),\n            ErrorKind::Collisions(_) => \"collisions detected\".fmt(f),\n            ErrorKind::FailedFairings(_) => \"launch fairing(s) failed\".fmt(f),\n            ErrorKind::InsecureSecretKey(_) => \"insecure secret key config\".fmt(f),\n            ErrorKind::Config(_) => \"failed to extract configuration\".fmt(f),\n            ErrorKind::SentinelAborts(_) => \"sentinel(s) aborted\".fmt(f),\n            ErrorKind::Shutdown(_, Some(e)) => write!(f, \"shutdown failed: {}\", e),\n            ErrorKind::Shutdown(_, None) => \"shutdown failed\".fmt(f),\n        }\n    }\n}\n\nimpl fmt::Debug for Error {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.mark_handled();\n        self.kind().fmt(f)\n    }\n}\n\nimpl fmt::Display for Error {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.mark_handled();\n        write!(f, \"{}\", self.kind())\n    }\n}\n\nimpl Drop for Error {\n    fn drop(&mut self) {\n        // Don't panic if the message has been seen. Don't double-panic.\n        if self.was_handled() || std::thread::panicking() {\n            return\n        }\n\n        panic!(\"{}\", self.pretty_print());\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{io, time::Duration};\nuse std::task::{Poll, Context};\nuse std::pin::Pin;\n\nuse bytes::{Bytes, BytesMut};\nuse pin_project_lite::pin_project;\nuse tokio::io::{AsyncRead, AsyncWrite, ReadBuf};\nuse tokio::time::{sleep, Sleep};\n\nuse futures::stream::Stream;\nuse futures::future::{self, Future, FutureExt};\n\npin_project! {\n    pub struct ReaderStream<R> {\n        #[pin]\n        reader: Option<R>,\n        buf: BytesMut,\n        cap: usize,\n    }\n}\n\nimpl<R: AsyncRead> Stream for ReaderStream<R> {\n    type Item = std::io::Result<Bytes>;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        use tokio_util::io::poll_read_buf;\n\n        let mut this = self.as_mut().project();\n\n        let reader = match this.reader.as_pin_mut() {\n            Some(r) => r,\n            None => return Poll::Ready(None),\n        };\n\n        if this.buf.capacity() == 0 {\n            this.buf.reserve(*this.cap);\n        }\n\n        match poll_read_buf(reader, cx, &mut this.buf) {\n            Poll::Pending => Poll::Pending,\n            Poll::Ready(Err(err)) => {\n                self.project().reader.set(None);\n                Poll::Ready(Some(Err(err)))\n            }\n            Poll::Ready(Ok(0)) => {\n                self.project().reader.set(None);\n                Poll::Ready(None)\n            }\n            Poll::Ready(Ok(_)) => {\n                let chunk = this.buf.split();\n                Poll::Ready(Some(Ok(chunk.freeze())))\n            }\n        }\n    }\n}\n\npub trait AsyncReadExt: AsyncRead + Sized {\n    fn into_bytes_stream(self, cap: usize) -> ReaderStream<Self> {\n        ReaderStream { reader: Some(self), cap, buf: BytesMut::with_capacity(cap) }\n    }\n}\n\nimpl<T: AsyncRead> AsyncReadExt for T { }\n\npub trait PollExt<T, E> {\n    fn map_err_ext<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n        where F: FnOnce(E) -> U;\n}\n\nimpl<T, E> PollExt<T, E> for Poll<Option<Result<T, E>>> {\n    /// Changes the error value of this `Poll` with the closure provided.\n    fn map_err_ext<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n        where F: FnOnce(E) -> U\n    {\n        match self {\n            Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),\n            Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(f(e)))),\n            Poll::Ready(None) => Poll::Ready(None),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\npin_project! {\n    /// Stream for the [`chain`](super::AsyncReadExt::chain) method.\n    #[must_use = \"streams do nothing unless polled\"]\n    pub struct Chain<T, U> {\n        #[pin]\n        first: T,\n        #[pin]\n        second: U,\n        done_first: bool,\n    }\n}\n\nimpl<T: AsyncRead, U: AsyncRead> Chain<T, U> {\n    pub(crate) fn new(first: T, second: U) -> Self {\n        Self { first, second, done_first: false }\n    }\n}\n\nimpl<T: AsyncRead, U: AsyncRead> Chain<T, U> {\n    /// Gets references to the underlying readers in this `Chain`.\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n}\n\nimpl<T: AsyncRead, U: AsyncRead> AsyncRead for Chain<T, U> {\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        let me = self.project();\n\n        if !*me.done_first {\n            let init_rem = buf.remaining();\n            futures::ready!(me.first.poll_read(cx, buf))?;\n            if buf.remaining() == init_rem {\n                *me.done_first = true;\n            } else {\n                return Poll::Ready(Ok(()));\n            }\n        }\n        me.second.poll_read(cx, buf)\n    }\n}\n\nenum State {\n    /// I/O has not been cancelled. Proceed as normal.\n    Active,\n    /// I/O has been cancelled. See if we can finish before the timer expires.\n    Grace(Pin<Box<Sleep>>),\n    /// Grace period elapsed. Shutdown the connection, waiting for the timer\n    /// until we force close.\n    Mercy(Pin<Box<Sleep>>),\n}\n\npin_project! {\n    /// I/O that can be cancelled when a future `F` resolves.\n    #[must_use = \"futures do nothing unless polled\"]\n    pub struct CancellableIo<F, I> {\n        #[pin]\n        io: Option<I>,\n        #[pin]\n        trigger: future::Fuse<F>,\n        state: State,\n        grace: Duration,\n        mercy: Duration,\n    }\n}\n\nimpl<F: Future, I: AsyncWrite> CancellableIo<F, I> {\n    pub fn new(trigger: F, io: I, grace: Duration, mercy: Duration) -> Self {\n        CancellableIo {\n            grace, mercy,\n            io: Some(io),\n            trigger: trigger.fuse(),\n            state: State::Active,\n        }\n    }\n\n    pub fn io(&self) -> Option<&I> {\n        self.io.as_ref()\n    }\n\n    /// Run `do_io` while connection processing should continue.\n    fn poll_trigger_then<T>(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        do_io: impl FnOnce(Pin<&mut I>, &mut Context<'_>) -> Poll<io::Result<T>>,\n    ) -> Poll<io::Result<T>> {\n        let mut me = self.as_mut().project();\n        let io = match me.io.as_pin_mut() {\n            Some(io) => io,\n            None => return Poll::Ready(Err(gone())),\n        };\n\n        loop {\n            match me.state {\n                State::Active => {\n                    if me.trigger.as_mut().poll(cx).is_ready() {\n                        *me.state = State::Grace(Box::pin(sleep(*me.grace)));\n                    } else {\n                        return do_io(io, cx);\n                    }\n                }\n                State::Grace(timer) => {\n                    if timer.as_mut().poll(cx).is_ready() {\n                        *me.state = State::Mercy(Box::pin(sleep(*me.mercy)));\n                    } else {\n                        return do_io(io, cx);\n                    }\n                }\n                State::Mercy(timer) => {\n                    if timer.as_mut().poll(cx).is_ready() {\n                        self.project().io.set(None);\n                        return Poll::Ready(Err(time_out()));\n                    } else {\n                        let result = futures::ready!(io.poll_shutdown(cx));\n                        self.project().io.set(None);\n                        return match result {\n                            Err(e) => Poll::Ready(Err(e)),\n                            Ok(()) => Poll::Ready(Err(gone()))\n                        };\n                    }\n                },\n            }\n        }\n    }\n}\n\nfn time_out() -> io::Error {\n    io::Error::new(io::ErrorKind::TimedOut, \"Shutdown grace timed out\")\n}\n\nfn gone() -> io::Error {\n    io::Error::new(io::ErrorKind::BrokenPipe, \"IO driver has terminated\")\n}\n\nimpl<F: Future, I: AsyncRead + AsyncWrite> AsyncRead for CancellableIo<F, I> {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        self.as_mut().poll_trigger_then(cx, |io, cx| io.poll_read(cx, buf))\n    }\n}\n\nimpl<F: Future, I: AsyncWrite> AsyncWrite for CancellableIo<F, I> {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        self.as_mut().poll_trigger_then(cx, |io, cx| io.poll_write(cx, buf))\n    }\n\n    fn poll_flush(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<io::Result<()>> {\n        self.as_mut().poll_trigger_then(cx, |io, cx| io.poll_flush(cx))\n    }\n\n    fn poll_shutdown(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<io::Result<()>> {\n        self.as_mut().poll_trigger_then(cx, |io, cx| io.poll_shutdown(cx))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        bufs: &[io::IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        self.as_mut().poll_trigger_then(cx, |io, cx| io.poll_write_vectored(cx, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.io().map(|io| io.is_write_vectored()).unwrap_or(false)\n    }\n}\n\nuse crate::http::private::{Listener, Connection, Certificates};\n\nimpl<F: Future, C: Connection> Connection for CancellableIo<F, C> {\n    fn peer_address(&self) -> Option<std::net::SocketAddr> {\n        self.io().and_then(|io| io.peer_address())\n    }\n\n    fn peer_certificates(&self) -> Option<Certificates> {\n        self.io().and_then(|io| io.peer_certificates())\n    }\n\n    fn enable_nodelay(&self) -> io::Result<()> {\n        match self.io() {\n            Some(io) => io.enable_nodelay(),\n            None => Ok(())\n        }\n    }\n}\n\npin_project! {\n    pub struct CancellableListener<F, L> {\n        pub trigger: F,\n        #[pin]\n        pub listener: L,\n        pub grace: Duration,\n        pub mercy: Duration,\n    }\n}\n\nimpl<F, L> CancellableListener<F, L> {\n    pub fn new(trigger: F, listener: L, grace: u64, mercy: u64) -> Self {\n        let (grace, mercy) = (Duration::from_secs(grace), Duration::from_secs(mercy));\n        CancellableListener { trigger, listener, grace, mercy }\n    }\n}\n\nimpl<L: Listener, F: Future + Clone> Listener for CancellableListener<F, L> {\n    type Connection = CancellableIo<F, L::Connection>;\n\n    fn local_addr(&self) -> Option<std::net::SocketAddr> {\n        self.listener.local_addr()\n    }\n\n    fn poll_accept(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>\n    ) -> Poll<io::Result<Self::Connection>> {\n        self.as_mut().project().listener\n            .poll_accept(cx)\n            .map(|res| res.map(|conn| {\n                CancellableIo::new(self.trigger.clone(), conn, self.grace, self.mercy)\n            }))\n    }\n}\n\npub trait StreamExt: Sized + Stream {\n    fn join<U>(self, other: U) -> Join<Self, U>\n        where U: Stream<Item = Self::Item>;\n}\n\nimpl<S: Stream> StreamExt for S {\n    fn join<U>(self, other: U) -> Join<Self, U>\n        where U: Stream<Item = Self::Item>\n    {\n        Join::new(self, other)\n    }\n}\n\npin_project! {\n    /// Stream returned by the [`join`](super::StreamExt::join) method.\n    pub struct Join<T, U> {\n        #[pin]\n        a: T,\n        #[pin]\n        b: U,\n        // When `true`, poll `a` first, otherwise, `poll` b`.\n        toggle: bool,\n        // Set when either `a` or `b` return `None`.\n        done: bool,\n    }\n}\n\nimpl<T, U> Join<T, U> {\n    pub(super) fn new(a: T, b: U) -> Join<T, U>\n        where T: Stream, U: Stream,\n    {\n        Join { a, b, toggle: false, done: false, }\n    }\n\n    fn poll_next<A: Stream, B: Stream<Item = A::Item>>(\n        first: Pin<&mut A>,\n        second: Pin<&mut B>,\n        done: &mut bool,\n        cx: &mut Context<'_>,\n    ) -> Poll<Option<A::Item>> {\n        match first.poll_next(cx) {\n            Poll::Ready(opt) => { *done = opt.is_none(); Poll::Ready(opt) }\n            Poll::Pending => match second.poll_next(cx) {\n                Poll::Ready(opt) => { *done = opt.is_none(); Poll::Ready(opt) }\n                Poll::Pending => Poll::Pending\n            }\n        }\n    }\n}\n\nimpl<T, U> Stream for Join<T, U>\n    where T: Stream,\n          U: Stream<Item = T::Item>,\n{\n    type Item = T::Item;\n\n    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<T::Item>> {\n        if self.done {\n            return Poll::Ready(None);\n        }\n\n        let me = self.project();\n        *me.toggle = !*me.toggle;\n        match *me.toggle {\n            true => Self::poll_next(me.a, me.b, me.done, cx),\n            false => Self::poll_next(me.b, me.a, me.done, cx),\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (left_low, left_high) = self.a.size_hint();\n        let (right_low, right_high) = self.b.size_hint();\n\n        let low = left_low.saturating_add(right_low);\n        let high = match (left_high, right_high) {\n            (Some(h1), Some(h2)) => h1.checked_add(h2),\n            _ => None,\n        };\n\n        (low, high)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![recursion_limit=\"256\"]\n\n#![doc(html_root_url = \"https://api.rocket.rs/v0.5\")]\n#![doc(html_favicon_url = \"https://rocket.rs/images/favicon.ico\")]\n#![doc(html_logo_url = \"https://rocket.rs/images/logo-boxed.png\")]\n#![cfg_attr(nightly, feature(doc_cfg))]\n#![cfg_attr(nightly, feature(decl_macro))]\n\n#![warn(rust_2018_idioms)]\n#![warn(missing_docs)]\n\n//! # Rocket - Core API Documentation\n//!\n//! Hello, and welcome to the core Rocket API documentation!\n//!\n//! This API documentation is highly technical and is purely a reference.\n//! There's an [overview] of Rocket on the main site as well as a [full,\n//! detailed guide]. If you'd like pointers on getting started, see the\n//! [quickstart] or [getting started] chapters of the guide.\n//!\n//! [overview]: https://rocket.rs/v0.5/overview\n//! [full, detailed guide]: https://rocket.rs/v0.5/guide\n//! [quickstart]: https://rocket.rs/v0.5/guide/quickstart\n//! [getting started]: https://rocket.rs/v0.5/guide/getting-started\n//!\n//! ## Usage\n//!\n//! Depend on `rocket` in `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! rocket = \"0.5.1\"\n//! ```\n//!\n//! <small>Note that development versions, tagged with `-dev`, are not published\n//! and need to be specified as [git dependencies].</small>\n//!\n//! See the [guide](https://rocket.rs/v0.5/guide) for more information on how\n//! to write Rocket applications. Here's a simple example to get you started:\n//!\n//! [git dependencies]: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories\n//!\n//! ```rust,no_run\n//! #[macro_use] extern crate rocket;\n//!\n//! #[get(\"/\")]\n//! fn hello() -> &'static str {\n//!     \"Hello, world!\"\n//! }\n//!\n//! #[launch]\n//! fn rocket() -> _ {\n//!     rocket::build().mount(\"/\", routes![hello])\n//! }\n//! ```\n//!\n//! ## Features\n//!\n//! To avoid compiling unused dependencies, Rocket gates certain features. With\n//! the exception of `http2`, all are disabled by default:\n//!\n//! | Feature   | Description                                             |\n//! |-----------|---------------------------------------------------------|\n//! | `secrets` | Support for authenticated, encrypted [private cookies]. |\n//! | `tls`     | Support for [TLS] encrypted connections.                |\n//! | `mtls`    | Support for verified clients via [mutual TLS].          |\n//! | `http2`   | Support for HTTP/2 (enabled by default).                |\n//! | `json`    | Support for [JSON (de)serialization].                   |\n//! | `msgpack` | Support for [MessagePack (de)serialization].            |\n//! | `uuid`    | Support for [UUID value parsing and (de)serialization]. |\n//!\n//! Disabled features can be selectively enabled in `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! rocket = { version = \"0.5.1\", features = [\"secrets\", \"tls\", \"json\"] }\n//! ```\n//!\n//! Conversely, HTTP/2 can be disabled:\n//!\n//! ```toml\n//! [dependencies]\n//! rocket = { version = \"0.5.1\", default-features = false }\n//! ```\n//!\n//! [JSON (de)serialization]: crate::serde::json\n//! [MessagePack (de)serialization]: crate::serde::msgpack\n//! [UUID value parsing and (de)serialization]: crate::serde::uuid\n//! [private cookies]: https://rocket.rs/v0.5/guide/requests/#private-cookies\n//! [TLS]: https://rocket.rs/v0.5/guide/configuration/#tls\n//! [mutual TLS]: crate::mtls\n//!\n//! ## Configuration\n//!\n//! Rocket offers a rich, extensible configuration system built on [Figment]. By\n//! default, Rocket applications are configured via a `Rocket.toml` file\n//! and/or `ROCKET_{PARAM}` environment variables, but applications may\n//! configure their own sources. See the [configuration guide] for full details.\n//!\n//! ## Testing\n//!\n//! The [`local`] module contains structures that facilitate unit and\n//! integration testing of a Rocket application. The top-level [`local`] module\n//! documentation and the [testing guide] include detailed examples.\n//!\n//! [configuration guide]: https://rocket.rs/v0.5/guide/configuration/\n//! [testing guide]: https://rocket.rs/v0.5/guide/testing/#testing\n//! [Figment]: https://docs.rs/figment\n\n// Allows using Rocket's codegen in Rocket itself.\nextern crate self as rocket;\n\n/// These are public dependencies! Update docs if these are changed, especially\n/// figment's version number in docs.\n#[doc(hidden)] pub use yansi;\n#[doc(hidden)] pub use async_stream;\npub use futures;\npub use tokio;\npub use figment;\npub use time;\n\n#[doc(hidden)]\n#[macro_use] pub mod log;\n#[macro_use] pub mod outcome;\n#[macro_use] pub mod data;\n#[doc(hidden)] pub mod sentinel;\npub mod local;\npub mod request;\npub mod response;\npub mod config;\npub mod form;\npub mod fairing;\npub mod error;\npub mod catcher;\npub mod route;\npub mod serde;\npub mod shield;\npub mod fs;\n\n// Reexport of HTTP everything.\npub mod http {\n    //! Types that map to concepts in HTTP.\n    //!\n    //! This module exports types that map to HTTP concepts or to the underlying\n    //! HTTP library when needed.\n\n    #[doc(inline)]\n    pub use rocket_http::*;\n\n    /// Re-exported hyper HTTP library types.\n    ///\n    /// All types that are re-exported from Hyper reside inside of this module.\n    /// These types will, with certainty, be removed with time, but they reside here\n    /// while necessary.\n    pub mod hyper {\n        #[doc(hidden)]\n        pub use rocket_http::hyper::*;\n\n        pub use rocket_http::hyper::header;\n    }\n\n    #[doc(inline)]\n    pub use crate::cookies::*;\n}\n\n#[cfg(feature = \"mtls\")]\n#[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\npub mod mtls;\n\n/// TODO: We need a futures mod or something.\nmod trip_wire;\nmod shutdown;\nmod server;\nmod ext;\nmod state;\nmod cookies;\nmod rkt;\nmod router;\nmod phase;\n\n#[doc(inline)] pub use crate::response::Response;\n#[doc(inline)] pub use crate::data::Data;\n#[doc(inline)] pub use crate::config::Config;\n#[doc(inline)] pub use crate::catcher::Catcher;\n#[doc(inline)] pub use crate::route::Route;\n#[doc(hidden)] pub use either::Either;\n#[doc(inline)] pub use phase::{Phase, Build, Ignite, Orbit};\n#[doc(inline)] pub use error::Error;\n#[doc(inline)] pub use sentinel::Sentinel;\n#[doc(inline)] pub use crate::request::Request;\n#[doc(inline)] pub use crate::rkt::Rocket;\n#[doc(inline)] pub use crate::shutdown::Shutdown;\n#[doc(inline)] pub use crate::state::State;\n#[doc(inline)] pub use rocket_codegen::*;\n\n/// Creates a [`Rocket`] instance with the default config provider: aliases\n/// [`Rocket::build()`].\npub fn build() -> Rocket<Build> {\n    Rocket::build()\n}\n\n/// Creates a [`Rocket`] instance with a custom config provider: aliases\n/// [`Rocket::custom()`].\npub fn custom<T: figment::Provider>(provider: T) -> Rocket<Build> {\n    Rocket::custom(provider)\n}\n\n/// Retrofits support for `async fn` in trait impls and declarations.\n///\n/// Any trait declaration or trait `impl` decorated with `#[async_trait]` is\n/// retrofitted with support for `async fn`s:\n///\n/// ```rust\n/// # use rocket::*;\n/// #[async_trait]\n/// trait MyAsyncTrait {\n///     async fn do_async_work();\n/// }\n///\n/// #[async_trait]\n/// impl MyAsyncTrait for () {\n///     async fn do_async_work() { /* .. */ }\n/// }\n/// ```\n///\n/// All `impl`s for a trait declared with `#[async_trait]` must themselves be\n/// decorated with `#[async_trait]`. Many of Rocket's traits, such as\n/// [`FromRequest`](crate::request::FromRequest) and\n/// [`Fairing`](crate::fairing::Fairing) are `async`. As such, implementations\n/// of said traits must be decorated with `#[async_trait]`. See the individual\n/// trait docs for trait-specific details.\n///\n/// For more details on `#[async_trait]`, see [`async_trait`](mod@async_trait).\n#[doc(inline)]\npub use async_trait::async_trait;\n\n/// WARNING: This is unstable! Do not use this method outside of Rocket!\n#[doc(hidden)]\npub fn async_run<F, R>(fut: F, workers: usize, sync: usize, force_end: bool, name: &str) -> R\n    where F: std::future::Future<Output = R>\n{\n    let runtime = tokio::runtime::Builder::new_multi_thread()\n        .thread_name(name)\n        .worker_threads(workers)\n        .max_blocking_threads(sync)\n        .enable_all()\n        .build()\n        .expect(\"create tokio runtime\");\n\n    let result = runtime.block_on(fut);\n    if force_end {\n        runtime.shutdown_timeout(std::time::Duration::from_millis(500));\n    }\n\n    result\n}\n\n/// WARNING: This is unstable! Do not use this method outside of Rocket!\n#[doc(hidden)]\npub fn async_test<R>(fut: impl std::future::Future<Output = R>) -> R {\n    async_run(fut, 1, 32, true, \"rocket-worker-test-thread\")\n}\n\n/// WARNING: This is unstable! Do not use this method outside of Rocket!\n#[doc(hidden)]\npub fn async_main<R>(fut: impl std::future::Future<Output = R> + Send) -> R {\n    // FIXME: We need to run `fut` to get the user's `Figment` to properly set\n    // up the async env, but we need the async env to run `fut`. So we're stuck.\n    // Tokio doesn't let us take the state from one async env and migrate it to\n    // another, so we need to use one, making this impossible.\n    //\n    // So as a result, we only use values from Rocket's figment. These\n    // values won't reflect swaps of `Rocket` in attach fairings with different\n    // config values, or values from non-Rocket configs. See tokio-rs/tokio#3329\n    // for a necessary resolution in `tokio`.\n    use config::bail_with_config_error as bail;\n\n    let fig = Config::figment();\n    let workers = fig.extract_inner(Config::WORKERS).unwrap_or_else(bail);\n    let max_blocking = fig.extract_inner(Config::MAX_BLOCKING).unwrap_or_else(bail);\n    let force = fig.focus(Config::SHUTDOWN).extract_inner(\"force\").unwrap_or_else(bail);\n    async_run(fut, workers, max_blocking, force, \"rocket-worker-thread\")\n}\n\n/// Executes a `future` to completion on a new tokio-based Rocket async runtime.\n///\n/// The runtime is terminated on shutdown, and the future's resolved value is\n/// returned.\n///\n/// # Considerations\n///\n/// This function is a low-level mechanism intended to be used to execute the\n/// future returned by [`Rocket::launch()`] in a self-contained async runtime\n/// designed for Rocket. It runs futures in exactly the same manner as\n/// [`#[launch]`](crate::launch) and [`#[main]`](crate::main) do and is thus\n/// _never_ the preferred mechanism for running a Rocket application. _Always_\n/// prefer to use the [`#[launch]`](crate::launch) or [`#[main]`](crate::main)\n/// attributes. For example [`#[main]`](crate::main) can be used even when\n/// Rocket is just a small part of a bigger application:\n///\n/// ```rust,no_run\n/// #[rocket::main]\n/// async fn main() {\n///     # let should_start_server_in_foreground = false;\n///     # let should_start_server_in_background = false;\n///     let rocket = rocket::build();\n///     if should_start_server_in_foreground {\n///         rocket::build().launch().await;\n///     } else if should_start_server_in_background {\n///         rocket::tokio::spawn(rocket.launch());\n///     } else {\n///         // do something else\n///     }\n/// }\n/// ```\n///\n/// See [Rocket#launching] for more on using these attributes.\n///\n/// # Example\n///\n/// Build an instance of Rocket, launch it, and wait for shutdown:\n///\n/// ```rust,no_run\n/// use rocket::fairing::AdHoc;\n///\n/// let rocket = rocket::build()\n///     .attach(AdHoc::on_liftoff(\"Liftoff Printer\", |_| Box::pin(async move {\n///         println!(\"Stalling liftoff for a second...\");\n///         rocket::tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n///         println!(\"And we're off!\");\n///     })));\n///\n/// rocket::execute(rocket.launch());\n/// ```\n///\n/// Launch a pre-built instance of Rocket and wait for it to shutdown:\n///\n/// ```rust,no_run\n/// use rocket::{Rocket, Ignite, Phase, Error};\n///\n/// fn launch<P: Phase>(rocket: Rocket<P>) -> Result<Rocket<Ignite>, Error> {\n///     rocket::execute(rocket.launch())\n/// }\n/// ```\n///\n/// Do async work to build an instance of Rocket, launch, and wait for shutdown:\n///\n/// ```rust,no_run\n/// use rocket::fairing::AdHoc;\n///\n/// // This line can also be inside of the `async` block.\n/// let rocket = rocket::build();\n///\n/// rocket::execute(async move {\n///     let rocket = rocket.ignite().await?;\n///     let config = rocket.config();\n///     rocket.launch().await\n/// });\n/// ```\npub fn execute<R, F>(future: F) -> R\n    where F: std::future::Future<Output = R> + Send\n{\n    async_main(future)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Rocket's logging infrastructure.\n\nuse std::fmt;\nuse std::str::FromStr;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nuse serde::{de, Serialize, Serializer, Deserialize, Deserializer};\nuse yansi::{Paint, Painted, Condition};\n\n/// Reexport the `log` crate as `private`.\npub use log as private;\n\n// Expose logging macros (hidden) for use by core/contrib codegen.\nmacro_rules! define_log_macro {\n    ($name:ident: $kind:ident, $target:expr, $d:tt) => (\n        #[doc(hidden)]\n        #[macro_export]\n        macro_rules! $name {\n            ($d ($t:tt)*) => ($crate::log::private::$kind!(target: $target, $d ($t)*))\n        }\n    );\n    ($name:ident ($indented:ident): $kind:ident, $target:expr, $d:tt) => (\n        define_log_macro!($name: $kind, $target, $d);\n        define_log_macro!($indented: $kind, concat!($target, \"::_\"), $d);\n    );\n    ($kind:ident, $indented:ident) => (\n        define_log_macro!($kind: $kind, module_path!(), $);\n        define_log_macro!($indented: $kind, concat!(module_path!(), \"::_\"), $);\n\n        pub use $indented;\n    );\n}\n\ndefine_log_macro!(error, error_);\ndefine_log_macro!(warn, warn_);\ndefine_log_macro!(info, info_);\ndefine_log_macro!(debug, debug_);\ndefine_log_macro!(trace, trace_);\ndefine_log_macro!(launch_meta (launch_meta_): info, \"rocket::launch\", $);\ndefine_log_macro!(launch_info (launch_msg_): warn, \"rocket::launch\", $);\n\n// `print!` panics when stdout isn't available, but this macro doesn't. See\n// rwf2/Rocket#2019 and rust-lang/rust#46016 for more.\n//\n// Unfortunately, `libtest` captures output by replacing a special sink that\n// `print!`, and _only_ `print!`, writes to. Using `write!` directly bypasses\n// this sink. As a result, using this better implementation for logging means\n// that test log output isn't captured, muddying `cargo test` output.\n//\n// As a compromise, we only use this better implementation when we're not\n// compiled with `debug_assertions` or running tests, so at least tests run in\n// debug-mode won't spew output. NOTE: `cfg(test)` alone isn't sufficient: the\n// crate is compiled normally for integration tests.\n#[cfg(not(any(debug_assertions, test, doctest)))]\nmacro_rules! write_out {\n    ($($arg:tt)*) => ({\n        use std::io::{Write, stdout, stderr};\n        let _ = write!(stdout(), $($arg)*).or_else(|e| write!(stderr(), \"{}\", e));\n    })\n}\n\n#[cfg(any(debug_assertions, test, doctest))]\nmacro_rules! write_out {\n    ($($arg:tt)*) => (print!($($arg)*))\n}\n\n#[derive(Debug)]\nstruct RocketLogger;\n\n/// Defines the maximum level of log messages to show.\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\npub enum LogLevel {\n    /// Only shows errors and warnings: `\"critical\"`.\n    Critical,\n    /// Shows everything except debug and trace information: `\"normal\"`.\n    Normal,\n    /// Shows everything: `\"debug\"`.\n    Debug,\n    /// Shows nothing: \"`\"off\"`\".\n    Off,\n}\n\npub trait PaintExt: Sized {\n    fn emoji(self) -> Painted<Self>;\n}\n\n// Whether a record is a special `launch_{meta,info}!` record.\nfn is_launch_record(record: &log::Metadata<'_>) -> bool {\n    record.target().contains(\"rocket::launch\")\n}\n\nimpl log::Log for RocketLogger {\n    #[inline(always)]\n    fn enabled(&self, record: &log::Metadata<'_>) -> bool {\n        match log::max_level().to_level() {\n            Some(max) => record.level() <= max || is_launch_record(record),\n            None => false\n        }\n    }\n\n    fn log(&self, record: &log::Record<'_>) {\n        // Print nothing if this level isn't enabled and this isn't launch info.\n        if !self.enabled(record.metadata()) {\n            return;\n        }\n\n        // Don't print Hyper, Rustls or r2d2 messages unless debug is enabled.\n        let max = log::max_level();\n        let from = |path| record.module_path().map_or(false, |m| m.starts_with(path));\n        let debug_only = from(\"hyper\") || from(\"rustls\") || from(\"r2d2\");\n        if log::LevelFilter::from(LogLevel::Debug) > max && debug_only {\n            return;\n        }\n\n        // In Rocket, we abuse targets with suffix \"_\" to indicate indentation.\n        let indented = record.target().ends_with('_');\n        if indented {\n            write_out!(\"   {} \", \">>\".bold());\n        }\n\n        // Downgrade a physical launch `warn` to logical `info`.\n        let level = is_launch_record(record.metadata())\n            .then(|| log::Level::Info)\n            .unwrap_or_else(|| record.level());\n\n        match level {\n            log::Level::Error if !indented => {\n                write_out!(\"{} {}\\n\", \"Error:\".red().bold(), record.args().red().wrap());\n            }\n            log::Level::Warn if !indented => {\n                write_out!(\"{} {}\\n\", \"Warning:\".yellow().bold(), record.args().yellow().wrap());\n            }\n            log::Level::Info => write_out!(\"{}\\n\", record.args().blue().wrap()),\n            log::Level::Trace => write_out!(\"{}\\n\", record.args().magenta().wrap()),\n            log::Level::Warn => write_out!(\"{}\\n\", record.args().yellow().wrap()),\n            log::Level::Error => write_out!(\"{}\\n\", &record.args().red().wrap()),\n            log::Level::Debug => {\n                write_out!(\"\\n{} \", \"-->\".blue().bold());\n                if let Some(file) = record.file() {\n                    write_out!(\"{}\", file.blue());\n                }\n\n                if let Some(line) = record.line() {\n                    write_out!(\":{}\\n\", line.blue());\n                }\n\n                write_out!(\"\\t{}\\n\", record.args());\n            }\n        }\n    }\n\n    fn flush(&self) {\n        // NOOP: We don't buffer any records.\n    }\n}\n\npub(crate) fn init_default() {\n    crate::log::init(&crate::Config::debug_default())\n}\n\npub(crate) fn init(config: &crate::Config) {\n    static ROCKET_LOGGER_SET: AtomicBool = AtomicBool::new(false);\n\n    // Try to initialize Rocket's logger, recording if we succeeded.\n    if log::set_boxed_logger(Box::new(RocketLogger)).is_ok() {\n        ROCKET_LOGGER_SET.store(true, Ordering::Release);\n    }\n\n    // Always disable colors if requested or if the stdout/err aren't TTYs.\n    let should_color = config.cli_colors && Condition::stdouterr_are_tty();\n    yansi::whenever(Condition::cached(should_color));\n\n    // Set Rocket-logger specific settings only if Rocket's logger is set.\n    if ROCKET_LOGGER_SET.load(Ordering::Acquire) {\n        log::set_max_level(config.log_level.into());\n    }\n}\n\nimpl From<LogLevel> for log::LevelFilter {\n    fn from(level: LogLevel) -> Self {\n        match level {\n            LogLevel::Critical => log::LevelFilter::Warn,\n            LogLevel::Normal => log::LevelFilter::Info,\n            LogLevel::Debug => log::LevelFilter::Trace,\n            LogLevel::Off => log::LevelFilter::Off\n        }\n    }\n}\n\nimpl LogLevel {\n    fn as_str(&self) -> &str {\n        match self {\n            LogLevel::Critical => \"critical\",\n            LogLevel::Normal => \"normal\",\n            LogLevel::Debug => \"debug\",\n            LogLevel::Off => \"off\",\n        }\n    }\n}\n\nimpl FromStr for LogLevel {\n    type Err = &'static str;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let level = match &*s.to_ascii_lowercase() {\n            \"critical\" => LogLevel::Critical,\n            \"normal\" => LogLevel::Normal,\n            \"debug\" => LogLevel::Debug,\n            \"off\" => LogLevel::Off,\n            _ => return Err(\"a log level (off, debug, normal, critical)\")\n        };\n\n        Ok(level)\n    }\n}\n\nimpl fmt::Display for LogLevel {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}\n\nimpl Serialize for LogLevel {\n    fn serialize<S: Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {\n        ser.serialize_str(self.as_str())\n    }\n}\n\nimpl<'de> Deserialize<'de> for LogLevel {\n    fn deserialize<D: Deserializer<'de>>(de: D) -> Result<Self, D::Error> {\n        let string = String::deserialize(de)?;\n        LogLevel::from_str(&string).map_err(|_| de::Error::invalid_value(\n            de::Unexpected::Str(&string),\n            &figment::error::OneOf( &[\"critical\", \"normal\", \"debug\", \"off\"])\n        ))\n    }\n}\n\nimpl PaintExt for &str {\n    /// Paint::masked(), but hidden on Windows due to broken output. See #1122.\n    fn emoji(self) -> Painted<Self> {\n        #[cfg(windows)] { Paint::new(\"\").mask() }\n        #[cfg(not(windows))] { Paint::new(self).mask() }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Support for mutual TLS client certificates.\n//!\n//! For details on how to configure mutual TLS, see\n//! [`MutualTls`](crate::config::MutualTls) and the [TLS\n//! guide](https://rocket.rs/v0.5/guide/configuration/#tls). See\n//! [`Certificate`] for a request guard that validated, verifies, and retrieves\n//! client certificates.\n\n#[doc(inline)]\npub use crate::http::tls::mtls::*;\n\nuse crate::request::{Request, FromRequest, Outcome};\nuse crate::outcome::{try_outcome, IntoOutcome};\nuse crate::http::Status;\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for Certificate<'r> {\n    type Error = Error;\n\n    async fn from_request(req: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n        let certs = req.connection.client_certificates.as_ref().or_forward(Status::Unauthorized);\n        let data = try_outcome!(try_outcome!(certs).chain_data().or_forward(Status::Unauthorized));\n        Certificate::parse(data).or_error(Status::Unauthorized)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Success, error, and forward handling.\n//!\n//! The `Outcome<S, E, F>` type is similar to the standard library's `Result<S,\n//! E>` type. It is an enum with three variants, each containing a value:\n//! `Success(S)`, which represents a successful outcome, `Error(E)`, which\n//! represents an erroring outcome, and `Forward(F)`, which represents neither a\n//! success or error, but instead, indicates that processing could not be\n//! handled and should instead be _forwarded_ to whatever can handle the\n//! processing next.\n//!\n//! The `Outcome` type is the return type of many of the core Rocket traits,\n//! including [`FromRequest`](crate::request::FromRequest), [`FromData`]\n//! [`Responder`]. It is also the return type of request handlers via the\n//! [`Response`](crate::response::Response) type.\n//!\n//! [`FromData`]: crate::data::FromData\n//! [`Responder`]: crate::response::Responder\n//!\n//! # Success\n//!\n//! A successful `Outcome<S, E, F>`, `Success(S)`, is returned from functions\n//! that complete successfully. The meaning of a `Success` outcome depends on\n//! the context. For instance, the `Outcome` of the `from_data` method of the\n//! [`FromData`] trait will be matched against the type expected by\n//! the user. For example, consider the following handler:\n//!\n//! ```rust\n//! # use rocket::post;\n//! # type S = String;\n//! #[post(\"/\", data = \"<my_val>\")]\n//! fn hello(my_val: S) { /* ... */  }\n//! ```\n//!\n//! The [`FromData`] implementation for the type `S` returns an `Outcome` with a\n//! `Success(S)`. If `from_data` returns a `Success`, the `Success` value will\n//! be unwrapped and the value will be used as the value of `my_val`.\n//!\n//! # Error\n//!\n//! An error `Outcome<S, E, F>`, `Error(E)`, is returned when a function\n//! fails with some error and no processing can or should continue as a result.\n//! The meaning of an error depends on the context.\n//!\n//! In Rocket, an `Error` generally means that a request is taken out of normal\n//! processing. The request is then given to the catcher corresponding to some\n//! status code. Users can catch errors by requesting a type of `Result<S, E>`\n//! or `Option<S>` in request handlers. For example, if a user's handler looks\n//! like:\n//!\n//! ```rust\n//! # use rocket::post;\n//! # type S = Option<String>;\n//! # type E = std::convert::Infallible;\n//! #[post(\"/\", data = \"<my_val>\")]\n//! fn hello(my_val: Result<S, E>) { /* ... */ }\n//! ```\n//!\n//! The [`FromData`] implementation for the type `S` returns an `Outcome` with a\n//! `Success(S)` and `Error(E)`. If `from_data` returns an `Error`, the `Error`\n//! value will be unwrapped and the value will be used as the `Err` value of\n//! `my_val` while a `Success` will be unwrapped and used the `Ok` value.\n//!\n//! # Forward\n//!\n//! A forward `Outcome<S, E, F>`, `Forward(F)`, is returned when a function\n//! wants to indicate that the requested processing should be _forwarded_ to the\n//! next available processor. Again, the exact meaning depends on the context.\n//!\n//! In Rocket, a `Forward` generally means that a request is forwarded to the\n//! next available request handler. For example, consider the following request\n//! handler:\n//!\n//! ```rust\n//! # use rocket::post;\n//! # type S = String;\n//! #[post(\"/\", data = \"<my_val>\")]\n//! fn hello(my_val: S) { /* ... */ }\n//! ```\n//!\n//! The [`FromData`] implementation for the type `S` returns an `Outcome` with a\n//! `Success(S)`, `Error(E)`, and `Forward(F)`. If the `Outcome` is a\n//! `Forward`, the `hello` handler isn't called. Instead, the incoming request\n//! is forwarded, or passed on to, the next matching route, if any. Ultimately,\n//! if there are no non-forwarding routes, forwarded requests are handled by the\n//! 404 catcher. Similar to `Error`s, users can catch `Forward`s by requesting\n//! a type of `Option<S>`. If an `Outcome` is a `Forward`, the `Option` will be\n//! `None`.\n\nuse std::fmt;\n\nuse yansi::{Paint, Color};\n\nuse crate::{route, request, response};\nuse crate::data::{self, Data, FromData};\nuse crate::http::Status;\n\nuse self::Outcome::*;\n\n/// An enum representing success (`Success`), error (`Error`), or forwarding\n/// (`Forward`).\n///\n/// See the [top level documentation](crate::outcome) for detailed information.\n#[must_use]\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash)]\npub enum Outcome<S, E, F> {\n    /// Contains the success value.\n    Success(S),\n    /// Contains the error error value.\n    Error(E),\n    /// Contains the value to forward on.\n    Forward(F),\n}\n\nimpl<S, E, F> Outcome<S, E, F> {\n    /// Unwraps the Outcome, yielding the contents of a Success.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is not `Success`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.unwrap(), 10);\n    /// ```\n    #[inline]\n    #[track_caller]\n    pub fn unwrap(self) -> S {\n        match self {\n            Success(val) => val,\n            _ => panic!(\"unwrapped a non-successful outcome\")\n        }\n    }\n\n    /// Unwraps the Outcome, yielding the contents of a Success.\n    ///\n    /// # Panics\n    ///\n    /// If the value is not `Success`, panics with the given `message`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.expect(\"success value\"), 10);\n    /// ```\n    #[inline]\n    #[track_caller]\n    pub fn expect(self, message: &str) -> S {\n        match self {\n            Success(val) => val,\n            _ => panic!(\"unwrapped a non-successful outcome: {}\", message)\n        }\n    }\n\n    /// Return true if this `Outcome` is a `Success`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.is_success(), true);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.is_success(), false);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.is_success(), false);\n    /// ```\n    #[inline]\n    pub fn is_success(&self) -> bool {\n        matches!(self, Success(_))\n    }\n\n    /// Return true if this `Outcome` is an `Error`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.is_error(), false);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.is_error(), true);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.is_error(), false);\n    /// ```\n    #[inline]\n    pub fn is_error(&self) -> bool {\n        matches!(self, Error(_))\n    }\n\n    /// Return true if this `Outcome` is a `Forward`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.is_forward(), false);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.is_forward(), false);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.is_forward(), true);\n    /// ```\n    #[inline]\n    pub fn is_forward(&self) -> bool {\n        matches!(self, Forward(_))\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Option<S>`.\n    ///\n    /// Returns the `Some` of the `Success` if this is a `Success`, otherwise\n    /// returns `None`. `self` is consumed, and all other values are discarded.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.succeeded(), Some(10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.succeeded(), None);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.succeeded(), None);\n    /// ```\n    #[inline]\n    pub fn succeeded(self) -> Option<S> {\n        match self {\n            Success(val) => Some(val),\n            _ => None\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Option<E>`.\n    ///\n    /// Returns the `Some` of the `Error` if this is an `Error`, otherwise\n    /// returns `None`. `self` is consumed, and all other values are discarded.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.failed(), None);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.failed(), Some(\"Hi! I'm an error.\"));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.failed(), None);\n    /// ```\n    #[inline]\n    pub fn failed(self) -> Option<E> {\n        match self {\n            Error(val) => Some(val),\n            _ => None\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Option<F>`.\n    ///\n    /// Returns the `Some` of the `Forward` if this is a `Forward`, otherwise\n    /// returns `None`. `self` is consumed, and all other values are discarded.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.forwarded(), None);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.forwarded(), None);\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.forwarded(), Some(25));\n    /// ```\n    #[inline]\n    pub fn forwarded(self) -> Option<F> {\n        match self {\n            Forward(val) => Some(val),\n            _ => None\n        }\n    }\n\n    /// Returns a `Success` value as `Ok()` or `value` in `Err`. Converts from\n    /// `Outcome<S, E, F>` to `Result<S, T>` for a given `T`.\n    ///\n    /// Returns `Ok` with the `Success` value if this is a `Success`, otherwise\n    /// returns an `Err` with the provided value. `self` is consumed, and all\n    /// other values are discarded.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.success_or(false), Ok(10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.success_or(false), Err(false));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.success_or(\"whoops\"), Err(\"whoops\"));\n    /// ```\n    #[inline]\n    pub fn success_or<T>(self, value: T) -> Result<S, T> {\n        match self {\n            Success(val) => Ok(val),\n            _ => Err(value)\n        }\n    }\n\n    /// Returns a `Success` value as `Ok()` or `f()` in `Err`. Converts from\n    /// `Outcome<S, E, F>` to `Result<S, T>` for a given `T` produced from a\n    /// supplied function or closure.\n    ///\n    /// Returns `Ok` with the `Success` value if this is a `Success`, otherwise\n    /// returns an `Err` with the result of calling `f`. `self` is consumed, and\n    /// all other values are discarded.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.success_or_else(|| false), Ok(10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.success_or_else(|| false), Err(false));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(25);\n    /// assert_eq!(x.success_or_else(|| \"whoops\"), Err(\"whoops\"));\n    /// ```\n    #[inline]\n    pub fn success_or_else<T, V: FnOnce() -> T>(self, f: V) -> Result<S, T> {\n        match self {\n            Success(val) => Ok(val),\n            _ => Err(f())\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Outcome<&S, &E, &F>`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.as_ref(), Success(&10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"Hi! I'm an error.\");\n    /// assert_eq!(x.as_ref(), Error(&\"Hi! I'm an error.\"));\n    /// ```\n    #[inline]\n    pub fn as_ref(&self) -> Outcome<&S, &E, &F> {\n        match *self {\n            Success(ref val) => Success(val),\n            Error(ref val) => Error(val),\n            Forward(ref val) => Forward(val),\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Outcome<&mut S, &mut E, &mut F>`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let mut x: Outcome<i32, &str, usize> = Success(10);\n    /// if let Success(val) = x.as_mut() {\n    ///     *val = 20;\n    /// }\n    ///\n    /// assert_eq!(x.unwrap(), 20);\n    /// ```\n    #[inline]\n    pub fn as_mut(&mut self) -> Outcome<&mut S, &mut E, &mut F> {\n        match *self {\n            Success(ref mut val) => Success(val),\n            Error(ref mut val) => Error(val),\n            Forward(ref mut val) => Forward(val),\n        }\n    }\n\n    /// Maps the `Success` value using `f`. Maps an `Outcome<S, E, F>` to an\n    /// `Outcome<T, E, F>` by applying the function `f` to the value of type `S`\n    /// in `self` if `self` is an `Outcome::Success`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    ///\n    /// let mapped = x.map(|v| if v == 10 { \"10\" } else { \"not 10\" });\n    /// assert_eq!(mapped, Success(\"10\"));\n    /// ```\n    #[inline]\n    pub fn map<T, M: FnOnce(S) -> T>(self, f: M) -> Outcome<T, E, F> {\n        match self {\n            Success(val) => Success(f(val)),\n            Error(val) => Error(val),\n            Forward(val) => Forward(val),\n        }\n    }\n\n    /// Maps the `Error` value using `f`. Maps an `Outcome<S, E, F>` to an\n    /// `Outcome<S, T, F>` by applying the function `f` to the value of type `E`\n    /// in `self` if `self` is an `Outcome::Error`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Error(\"hi\");\n    ///\n    /// let mapped = x.map_error(|v| if v == \"hi\" { 10 } else { 0 });\n    /// assert_eq!(mapped, Error(10));\n    /// ```\n    #[inline]\n    pub fn map_error<T, M: FnOnce(E) -> T>(self, f: M) -> Outcome<S, T, F> {\n        match self {\n            Success(val) => Success(val),\n            Error(val) => Error(f(val)),\n            Forward(val) => Forward(val),\n        }\n    }\n\n    /// Maps the `Forward` value using `f`. Maps an `Outcome<S, E, F>` to an\n    /// `Outcome<S, E, T>` by applying the function `f` to the value of type `F`\n    /// in `self` if `self` is an `Outcome::Forward`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Forward(5);\n    ///\n    /// let mapped = x.map_forward(|v| if v == 5 { \"a\" } else { \"b\" });\n    /// assert_eq!(mapped, Forward(\"a\"));\n    /// ```\n    #[inline]\n    pub fn map_forward<T, M: FnOnce(F) -> T>(self, f: M) -> Outcome<S, E, T> {\n        match self {\n            Success(val) => Success(val),\n            Error(val) => Error(val),\n            Forward(val) => Forward(f(val)),\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Outcome<T, E, F>` using `f` to map\n    /// `Success(S)` to `Success(T)`.\n    ///\n    /// If `self` is not `Success`, `self` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, bool> = Success(10);\n    ///\n    /// let mapped = x.and_then(|v| match v {\n    ///    10 => Success(\"10\"),\n    ///    1 => Forward(false),\n    ///    _ => Error(\"30\")\n    /// });\n    ///\n    /// assert_eq!(mapped, Success(\"10\"));\n    /// ```\n    #[inline]\n    pub fn and_then<T, M: FnOnce(S) -> Outcome<T, E, F>>(self, f: M) -> Outcome<T, E, F> {\n        match self {\n            Success(val) => f(val),\n            Error(val) => Error(val),\n            Forward(val) => Forward(val),\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Outcome<S, T, F>` using `f` to map\n    /// `Error(E)` to `Error(T)`.\n    ///\n    /// If `self` is not `Error`, `self` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, bool> = Error(\"hi\");\n    ///\n    /// let mapped = x.error_then(|v| match v {\n    ///    \"hi\" => Error(10),\n    ///    \"test\" => Forward(false),\n    ///    _ => Success(10)\n    /// });\n    ///\n    /// assert_eq!(mapped, Error(10));\n    /// ```\n    #[inline]\n    pub fn error_then<T, M: FnOnce(E) -> Outcome<S, T, F>>(self, f: M) -> Outcome<S, T, F> {\n        match self {\n            Success(val) => Success(val),\n            Error(val) => f(val),\n            Forward(val) => Forward(val),\n        }\n    }\n\n    /// Converts from `Outcome<S, E, F>` to `Outcome<S, E, T>` using `f` to map\n    /// `Forward(F)` to `Forward(T)`.\n    ///\n    /// If `self` is not `Forward`, `self` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, Option<bool>> = Forward(Some(false));\n    ///\n    /// let mapped = x.forward_then(|v| match v {\n    ///    Some(true) => Success(10),\n    ///    Some(false) => Forward(20),\n    ///    None => Error(\"10\")\n    /// });\n    ///\n    /// assert_eq!(mapped, Forward(20));\n    /// ```\n    #[inline]\n    pub fn forward_then<T, M: FnOnce(F) -> Outcome<S, E, T>>(self, f: M) -> Outcome<S, E, T> {\n        match self {\n            Success(val) => Success(val),\n            Error(val) => Error(val),\n            Forward(val) => f(val),\n        }\n    }\n\n    /// Converts `Outcome<S, E, F>` to `Result<S, E>` by identity mapping\n    /// `Success(S)` and `Error(E)` to `Result<T, E>` and mapping `Forward(F)`\n    /// to `Result<T, E>` using `f`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.ok_map_forward(|x| Ok(x as i32 + 1)), Ok(10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"hello\");\n    /// assert_eq!(x.ok_map_forward(|x| Ok(x as i32 + 1)), Err(\"hello\"));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(0);\n    /// assert_eq!(x.ok_map_forward(|x| Ok(x as i32 + 1)), Ok(1));\n    /// ```\n    #[inline]\n    pub fn ok_map_forward<M>(self, f: M) -> Result<S, E>\n        where M: FnOnce(F) -> Result<S, E>\n    {\n        match self {\n            Outcome::Success(s) => Ok(s),\n            Outcome::Error(e) => Err(e),\n            Outcome::Forward(v) => f(v),\n        }\n    }\n\n    /// Converts `Outcome<S, E, F>` to `Result<S, E>` by identity mapping\n    /// `Success(S)` and `Forward(F)` to `Result<T, F>` and mapping `Error(E)`\n    /// to `Result<T, F>` using `f`.\n    ///\n    /// ```rust\n    /// # use rocket::outcome::Outcome;\n    /// # use rocket::outcome::Outcome::*;\n    /// #\n    /// let x: Outcome<i32, &str, usize> = Success(10);\n    /// assert_eq!(x.ok_map_error(|s| Ok(123)), Ok(10));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Error(\"hello\");\n    /// assert_eq!(x.ok_map_error(|s| Ok(123)), Ok(123));\n    ///\n    /// let x: Outcome<i32, &str, usize> = Forward(0);\n    /// assert_eq!(x.ok_map_error(|s| Ok(123)), Err(0));\n    /// ```\n    #[inline]\n    pub fn ok_map_error<M>(self, f: M) -> Result<S, F>\n        where M: FnOnce(E) -> Result<S, F>\n    {\n        match self {\n            Outcome::Success(s) => Ok(s),\n            Outcome::Error(e) => f(e),\n            Outcome::Forward(v) => Err(v),\n        }\n    }\n}\n\nimpl<'a, S: Send + 'a, E: Send + 'a, F: Send + 'a> Outcome<S, E, F> {\n    /// Pins a future that resolves to `self`, returning a\n    /// [`BoxFuture`](crate::futures::future::BoxFuture) that resolves to\n    /// `self`.\n    #[inline]\n    pub fn pin(self) -> futures::future::BoxFuture<'a, Self> {\n        Box::pin(async move { self })\n    }\n}\n\ncrate::export! {\n    /// Unwraps a [`Success`](Outcome::Success) or propagates a `Forward` or\n    /// `Error` by returning early.\n    ///\n    /// # Syntax\n    ///\n    /// The macro has the following \"signature\":\n    ///\n    /// ```rust\n    /// use rocket::outcome::Outcome;\n    ///\n    /// // Returns the inner `S` if `outcome` is `Outcome::Success`. Otherwise\n    /// // returns from the caller with `Outcome<impl From<E>, impl From<F>>`.\n    /// fn try_outcome<S, E, F>(outcome: Outcome<S, E, F>) -> S\n    /// # { unimplemented!() }\n    /// ```\n    ///\n    /// This is just like `?` (or previously, `try!`), but for `Outcome`. In the\n    /// case of a `Forward` or `Error` variant, the inner type is passed to\n    /// [`From`](std::convert::From), allowing for the conversion between\n    /// specific and more general types. The resulting forward/error is\n    /// immediately returned. Because of the early return, `try_outcome!` can\n    /// only be used in methods that return [`Outcome`].\n    ///\n    /// [`Outcome`]: crate::outcome::Outcome\n    ///\n    /// ## Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use std::sync::atomic::{AtomicUsize, Ordering};\n    ///\n    /// use rocket::State;\n    /// use rocket::request::{self, Request, FromRequest};\n    /// use rocket::outcome::{try_outcome, Outcome::*};\n    ///\n    /// #[derive(Default)]\n    /// struct Atomics {\n    ///     uncached: AtomicUsize,\n    ///     cached: AtomicUsize,\n    /// }\n    ///\n    /// struct Guard1;\n    /// struct Guard2;\n    ///\n    /// #[rocket::async_trait]\n    /// impl<'r> FromRequest<'r> for Guard1 {\n    ///     type Error = ();\n    ///\n    ///     async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, ()> {\n    ///         // Attempt to fetch the guard, passing through any error or forward.\n    ///         let atomics = try_outcome!(req.guard::<&State<Atomics>>().await);\n    ///         atomics.uncached.fetch_add(1, Ordering::Relaxed);\n    ///         req.local_cache(|| atomics.cached.fetch_add(1, Ordering::Relaxed));\n    ///\n    ///         Success(Guard1)\n    ///     }\n    /// }\n    ///\n    /// #[rocket::async_trait]\n    /// impl<'r> FromRequest<'r> for Guard2 {\n    ///     type Error = ();\n    ///\n    ///     async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, ()> {\n    ///         // Attempt to fetch the guard, passing through any error or forward.\n    ///         let guard1: Guard1 = try_outcome!(req.guard::<Guard1>().await);\n    ///         Success(Guard2)\n    ///     }\n    /// }\n    /// ```\n    macro_rules! try_outcome {\n        ($expr:expr $(,)?) => (match $expr {\n            $crate::outcome::Outcome::Success(val) => val,\n            $crate::outcome::Outcome::Error(e) => {\n                return $crate::outcome::Outcome::Error(::std::convert::From::from(e))\n            },\n            $crate::outcome::Outcome::Forward(f) => {\n                return $crate::outcome::Outcome::Forward(::std::convert::From::from(f))\n            },\n        });\n    }\n}\n\nimpl<S, E, F> Outcome<S, E, F> {\n    #[inline]\n    fn dbg_str(&self) -> &'static str {\n        match self {\n            Success(..) => \"Success\",\n            Error(..) => \"Error\",\n            Forward(..) => \"Forward\",\n        }\n    }\n\n    #[inline]\n    fn color(&self) -> Color {\n        match self {\n            Success(..) => Color::Green,\n            Error(..) => Color::Red,\n            Forward(..) => Color::Yellow,\n        }\n    }\n}\n\npub(crate) struct Display<'a, 'r>(&'a route::Outcome<'r>);\n\nimpl<'r> route::Outcome<'r> {\n    pub(crate) fn log_display(&self) -> Display<'_, 'r> {\n        impl fmt::Display for Display<'_, '_> {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                write!(f, \"{}\", \"Outcome: \".primary().bold())?;\n\n                let color = self.0.color();\n                match self.0 {\n                    Success(r) => write!(f, \"{}({})\", \"Success\".paint(color), r.status().primary()),\n                    Error(s) => write!(f, \"{}({})\", \"Error\".paint(color), s.primary()),\n                    Forward((_, s)) => write!(f, \"{}({})\", \"Forward\".paint(color), s.primary()),\n                }\n            }\n        }\n\n        Display(self)\n    }\n}\n\nimpl<S, E, F> fmt::Debug for Outcome<S, E, F> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Outcome::{}\", self.dbg_str())\n    }\n}\n\nimpl<S, E, F> fmt::Display for Outcome<S, E, F> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.dbg_str().paint(self.color()))\n    }\n}\n\n/// Conversion trait from some type into an Outcome type.\npub trait IntoOutcome<Outcome> {\n    /// The type to use when returning an `Outcome::Error`.\n    type Error: Sized;\n\n    /// The type to use when returning an `Outcome::Forward`.\n    type Forward: Sized;\n\n    /// Converts `self` into an `Outcome`. If `self` represents a success, an\n    /// `Outcome::Success` is returned. Otherwise, an `Outcome::Error` is\n    /// returned with `error` as the inner value.\n    fn or_error(self, error: Self::Error) -> Outcome;\n\n    /// Converts `self` into an `Outcome`. If `self` represents a success, an\n    /// `Outcome::Success` is returned. Otherwise, an `Outcome::Forward` is\n    /// returned with `forward` as the inner value.\n    fn or_forward(self, forward: Self::Forward) -> Outcome;\n}\n\nimpl<S, E, F> IntoOutcome<Outcome<S, E, F>> for Option<S> {\n    type Error = E;\n    type Forward = F;\n\n    #[inline]\n    fn or_error(self, error: E) -> Outcome<S, E, F> {\n        match self {\n            Some(val) => Success(val),\n            None => Error(error)\n        }\n    }\n\n    #[inline]\n    fn or_forward(self, forward: F) -> Outcome<S, E, F> {\n        match self {\n            Some(val) => Success(val),\n            None => Forward(forward)\n        }\n    }\n}\n\nimpl<'r, T: FromData<'r>> IntoOutcome<data::Outcome<'r, T>> for Result<T, T::Error> {\n    type Error = Status;\n    type Forward = (Data<'r>, Status);\n\n    #[inline]\n    fn or_error(self, error: Status) -> data::Outcome<'r, T> {\n        match self {\n            Ok(val) => Success(val),\n            Err(err) => Error((error, err))\n        }\n    }\n\n    #[inline]\n    fn or_forward(self, (data, forward): (Data<'r>, Status)) -> data::Outcome<'r, T> {\n        match self {\n            Ok(val) => Success(val),\n            Err(_) => Forward((data, forward))\n        }\n    }\n}\n\nimpl<S, E> IntoOutcome<request::Outcome<S, E>> for Result<S, E> {\n    type Error = Status;\n    type Forward = Status;\n\n    #[inline]\n    fn or_error(self, error: Status) -> request::Outcome<S, E> {\n        match self {\n            Ok(val) => Success(val),\n            Err(err) => Error((error, err))\n        }\n    }\n\n    #[inline]\n    fn or_forward(self, status: Status) -> request::Outcome<S, E> {\n        match self {\n            Ok(val) => Success(val),\n            Err(_) => Forward(status)\n        }\n    }\n}\n\nimpl<'r, 'o: 'r> IntoOutcome<route::Outcome<'r>> for response::Result<'o> {\n    type Error = ();\n    type Forward = (Data<'r>, Status);\n\n    #[inline]\n    fn or_error(self, _: ()) -> route::Outcome<'r> {\n        match self {\n            Ok(val) => Success(val),\n            Err(status) => Error(status),\n        }\n    }\n\n    #[inline]\n    fn or_forward(self, (data, forward): (Data<'r>, Status)) -> route::Outcome<'r> {\n        match self {\n            Ok(val) => Success(val),\n            Err(_) => Forward((data, forward))\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use state::TypeMap;\nuse figment::Figment;\n\nuse crate::{Catcher, Config, Rocket, Route, Shutdown};\nuse crate::router::Router;\nuse crate::fairing::Fairings;\n\nmod private {\n    pub trait Sealed {  }\n}\n\n#[doc(hidden)]\npub trait Stateful: private::Sealed {\n    fn into_state(self) -> State;\n    fn as_state_ref(&self) -> StateRef<'_>;\n}\n\n/// A marker trait for Rocket's launch phases.\n///\n/// This treat is implemented by the three phase marker types: [`Build`],\n/// [`Ignite`], and [`Orbit`], representing the three phases to launch an\n/// instance of [`Rocket`]. This trait is _sealed_ and cannot be implemented\n/// outside of Rocket.\n///\n/// For a description of the three phases, see [`Rocket#phases`].\npub trait Phase: private::Sealed {\n    #[doc(hidden)]\n    type State: std::fmt::Debug + Stateful + Sync + Send + Unpin;\n}\n\nmacro_rules! phase {\n    ($(#[$o:meta])* $P:ident ($(#[$i:meta])* $S:ident) { $($fields:tt)* }) => (\n        $(#[$o])*\n        pub enum $P { }\n\n        impl Phase for $P {\n            #[doc(hidden)]\n            type State = $S;\n        }\n\n        $(#[$i])*\n        #[doc(hidden)]\n        pub struct $S {\n            $($fields)*\n        }\n\n        impl Stateful for $S {\n            fn into_state(self) -> State { State::$P(self) }\n            fn as_state_ref(&self) -> StateRef<'_> { StateRef::$P(self) }\n        }\n\n        #[doc(hidden)]\n        impl From<$S> for Rocket<$P> {\n            fn from(s: $S) -> Self { Rocket(s) }\n        }\n\n        impl private::Sealed for $P {}\n\n        impl private::Sealed for $S {}\n    )\n}\n\nmacro_rules! phases {\n    ($($(#[$o:meta])* $P:ident ($(#[$i:meta])* $S:ident) { $($fields:tt)* })*) => (\n        #[doc(hidden)]\n        pub enum State { $($P($S)),* }\n\n        #[doc(hidden)]\n        pub enum StateRef<'a> { $($P(&'a $S)),* }\n\n        $(phase!($(#[$o])* $P ($(#[$i])* $S) { $($fields)* });)*\n    )\n}\n\nphases! {\n    /// The initial launch [`Phase`]. See [Rocket#build](`Rocket#build`) for\n    /// phase details.\n    ///\n    /// An instance of `Rocket` in this phase is typed as [`Rocket<Build>`]: a\n    /// transient, in-progress build.\n    Build (#[derive(Default, Debug)] Building) {\n        pub(crate) routes: Vec<Route>,\n        pub(crate) catchers: Vec<Catcher>,\n        pub(crate) fairings: Fairings,\n        pub(crate) figment: Figment,\n        pub(crate) state: TypeMap![Send + Sync],\n    }\n\n    /// The second launch [`Phase`]: post-build but pre-orbit. See\n    /// [Rocket#ignite](`Rocket#ignite`) for details.\n    ///\n    /// An instance of `Rocket` in this phase is typed as [`Rocket<Ignite>`] and\n    /// represents a fully built and finalized application server ready for\n    /// launch into orbit. See [`Rocket#ignite`] for full details.\n    Ignite (#[derive(Debug)] Igniting) {\n        pub(crate) router: Router,\n        pub(crate) fairings: Fairings,\n        pub(crate) figment: Figment,\n        pub(crate) config: Config,\n        pub(crate) state: TypeMap![Send + Sync],\n        pub(crate) shutdown: Shutdown,\n    }\n\n    /// The final launch [`Phase`]. See [Rocket#orbit](`Rocket#orbit`) for\n    /// details.\n    ///\n    /// An instance of `Rocket` in this phase is typed as [`Rocket<Orbit>`] and\n    /// represents a running application.\n    Orbit (#[derive(Debug)] Orbiting) {\n        pub(crate) router: Router,\n        pub(crate) fairings: Fairings,\n        pub(crate) figment: Figment,\n        pub(crate) config: Config,\n        pub(crate) state: TypeMap![Send + Sync],\n        pub(crate) shutdown: Shutdown,\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::ops::{Deref, DerefMut};\nuse std::net::SocketAddr;\n\nuse yansi::Paint;\nuse either::Either;\nuse figment::{Figment, Provider};\n\nuse crate::{Catcher, Config, Route, Shutdown, sentinel, shield::Shield};\nuse crate::router::Router;\nuse crate::trip_wire::TripWire;\nuse crate::fairing::{Fairing, Fairings};\nuse crate::phase::{Phase, Build, Building, Ignite, Igniting, Orbit, Orbiting};\nuse crate::phase::{Stateful, StateRef, State};\nuse crate::http::uri::{self, Origin};\nuse crate::http::ext::IntoOwned;\nuse crate::error::{Error, ErrorKind};\nuse crate::log::PaintExt;\n\n/// The application server itself.\n///\n/// # Phases\n///\n/// A `Rocket` instance represents a web server and its state. It progresses\n/// through three statically-enforced phases: build, ignite, orbit.\n///\n/// * **Build**: _application and server configuration_\n///\n///   This phase enables:\n///\n///     * setting configuration options\n///     * mounting/registering routes/catchers\n///     * managing state\n///     * attaching fairings\n///\n///   This is the _only_ phase in which an instance can be modified. To finalize\n///   changes, an instance is ignited via [`Rocket::ignite()`], progressing it\n///   into the _ignite_ phase, or directly launched into orbit with\n///   [`Rocket::launch()`] which progress the instance through ignite into\n///   orbit.\n///\n/// * **Ignite**: _verification and finalization of configuration_\n///\n///   An instance in the [`Ignite`] phase is in its final configuration,\n///   available via [`Rocket::config()`]. Barring user-supplied interior\n///   mutation, application state is guaranteed to remain unchanged beyond this\n///   point. An instance in the ignite phase can be launched into orbit to serve\n///   requests via [`Rocket::launch()`].\n///\n/// * **Orbit**: _a running web server_\n///\n///   An instance in the [`Orbit`] phase represents a _running_ application,\n///   actively serving requests.\n///\n/// # Launching\n///\n/// To launch a `Rocket` application, the suggested approach is to return an\n/// instance of `Rocket<Build>` from a function named `rocket` marked with the\n/// [`#[launch]`](crate::launch) attribute:\n///\n///   ```rust,no_run\n///   # use rocket::launch;\n///   #[launch]\n///   fn rocket() -> _ {\n///       rocket::build()\n///   }\n///   ```\n///\n/// This generates a `main` function with an `async` runtime that runs the\n/// returned `Rocket` instance.\n///\n/// * **Manual Launching**\n///\n///   To launch an instance of `Rocket`, it _must_ progress through all three\n///   phases. To progress into the ignite or launch phases, a tokio `async`\n///   runtime is required. The [`#[main]`](crate::main) attribute initializes a\n///   Rocket-specific tokio runtime and runs the attributed `async fn` inside of\n///   it:\n///\n///   ```rust,no_run\n///   #[rocket::main]\n///   async fn main() -> Result<(), rocket::Error> {\n///       let _rocket = rocket::build()\n///           .ignite().await?\n///           .launch().await?;\n///\n///       Ok(())\n///   }\n///   ```\n///\n///   Note that [`Rocket::launch()`] automatically progresses an instance of\n///   `Rocket` from any phase into orbit:\n///\n///   ```rust,no_run\n///   #[rocket::main]\n///   async fn main() -> Result<(), rocket::Error> {\n///       let _rocket = rocket::build().launch().await?;\n///       Ok(())\n///   }\n///   ```\n///\n///   For extreme and rare cases in which [`#[main]`](crate::main) imposes\n///   obstinate restrictions, use [`rocket::execute()`](crate::execute()) to\n///   execute Rocket's `launch()` future.\n///\n/// * **Automatic Launching**\n///\n///   Manually progressing an instance of Rocket though its phases is only\n///   necessary when either an instance's finalized state is to be inspected (in\n///   the _ignite_ phase) or the instance is expected to deorbit due to\n///   [`Rocket::shutdown()`]. In the more common case when neither is required,\n///   the [`#[launch]`](crate::launch) attribute can be used. When applied to a\n///   function that returns a `Rocket<Build>`, it automatically initializes an\n///   `async` runtime and launches the function's returned instance:\n///\n///   ```rust,no_run\n///   # use rocket::launch;\n///   use rocket::{Rocket, Build};\n///\n///   #[launch]\n///   fn rocket() -> Rocket<Build> {\n///       rocket::build()\n///   }\n///   ```\n///\n///   To avoid needing to import _any_ items in the common case, the `launch`\n///   attribute will infer a return type written as `_` as `Rocket<Build>`:\n///\n///   ```rust,no_run\n///   # use rocket::launch;\n///   #[launch]\n///   fn rocket() -> _ {\n///       rocket::build()\n///   }\n///   ```\npub struct Rocket<P: Phase>(pub(crate) P::State);\n\nimpl Rocket<Build> {\n    /// Create a new `Rocket` application using the default configuration\n    /// provider, [`Config::figment()`].\n    ///\n    /// This method is typically called through the\n    /// [`rocket::build()`](crate::build) alias.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use rocket::launch;\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    /// }\n    /// ```\n    #[must_use]\n    #[inline(always)]\n    pub fn build() -> Self {\n        Rocket::custom(Config::figment())\n    }\n\n    /// Creates a new `Rocket` application using the supplied configuration\n    /// provider.\n    ///\n    /// This method is typically called through the\n    /// [`rocket::custom()`](crate::custom()) alias.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::launch;\n    /// use rocket::figment::{Figment, providers::{Toml, Env, Format}};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let figment = Figment::from(rocket::Config::default())\n    ///         .merge(Toml::file(\"MyApp.toml\").nested())\n    ///         .merge(Env::prefixed(\"MY_APP_\").global());\n    ///\n    ///     rocket::custom(figment)\n    /// }\n    /// ```\n    #[must_use]\n    pub fn custom<T: Provider>(provider: T) -> Self {\n        // We initialize the logger here so that logging from fairings and so on\n        // are visible; we use the final config to set a max log-level in ignite\n        crate::log::init_default();\n\n        let rocket: Rocket<Build> = Rocket(Building {\n            figment: Figment::from(provider),\n            ..Default::default()\n        });\n\n        rocket.attach(Shield::default())\n    }\n\n    /// Sets the configuration provider in `self` to `provider`.\n    ///\n    /// A [`Figment`] generated from the current `provider` can _always_ be\n    /// retrieved via [`Rocket::figment()`]. However, because the provider can\n    /// be changed at any point prior to ignition, a [`Config`] can only be\n    /// retrieved in the ignite or orbit phases, or by manually extracting one\n    /// from a particular figment.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    /// # use std::net::Ipv4Addr;\n    /// # use std::path::{Path, PathBuf};\n    /// # type Result = std::result::Result<(), rocket::Error>;\n    ///\n    /// let config = Config {\n    ///     port: 7777,\n    ///     address: Ipv4Addr::new(18, 127, 0, 1).into(),\n    ///     temp_dir: \"/tmp/config-example\".into(),\n    ///     ..Config::debug_default()\n    /// };\n    ///\n    /// # let _: Result = rocket::async_test(async move {\n    /// let rocket = rocket::custom(&config).ignite().await?;\n    /// assert_eq!(rocket.config().port, 7777);\n    /// assert_eq!(rocket.config().address, Ipv4Addr::new(18, 127, 0, 1));\n    /// assert_eq!(rocket.config().temp_dir.relative(), Path::new(\"/tmp/config-example\"));\n    ///\n    /// // Create a new figment which modifies _some_ keys the existing figment:\n    /// let figment = rocket.figment().clone()\n    ///     .merge((Config::PORT, 8888))\n    ///     .merge((Config::ADDRESS, \"171.64.200.10\"));\n    ///\n    /// let rocket = rocket::custom(&config)\n    ///     .configure(figment)\n    ///     .ignite().await?;\n    ///\n    /// assert_eq!(rocket.config().port, 8888);\n    /// assert_eq!(rocket.config().address, Ipv4Addr::new(171, 64, 200, 10));\n    /// assert_eq!(rocket.config().temp_dir.relative(), Path::new(\"/tmp/config-example\"));\n    /// # Ok(())\n    /// # });\n    /// ```\n    #[must_use]\n    pub fn configure<T: Provider>(mut self, provider: T) -> Self {\n        self.figment = Figment::from(provider);\n        self\n    }\n\n    #[track_caller]\n    fn load<'a, B, T, F, M>(mut self, kind: &str, base: B, items: Vec<T>, m: M, f: F) -> Self\n        where B: TryInto<Origin<'a>> + Clone + fmt::Display,\n              B::Error: fmt::Display,\n              M: Fn(&Origin<'a>, T) -> Result<T, uri::Error<'static>>,\n              F: Fn(&mut Self, T),\n              T: Clone + fmt::Display,\n    {\n        let mut base = match base.clone().try_into() {\n            Ok(origin) => origin.into_owned(),\n            Err(e) => {\n                error!(\"invalid {} base: {}\", kind, Paint::white(&base));\n                error_!(\"{}\", e);\n                info_!(\"{} {}\", \"in\".primary(), std::panic::Location::caller());\n                panic!(\"aborting due to {} base error\", kind);\n            }\n        };\n\n        if base.query().is_some() {\n            warn!(\"query in {} base '{}' is ignored\", kind, Paint::white(&base));\n            base.clear_query();\n        }\n\n        for unmounted_item in items {\n            let item = match m(&base, unmounted_item.clone()) {\n                Ok(item) => item,\n                Err(e) => {\n                    error!(\"malformed URI in {} {}\", kind, unmounted_item);\n                    error_!(\"{}\", e);\n                    info_!(\"{} {}\", Paint::white(\"in\"), std::panic::Location::caller());\n                    panic!(\"aborting due to invalid {} URI\", kind);\n                }\n            };\n\n            f(&mut self, item)\n        }\n\n        self\n    }\n\n    /// Mounts all of the routes in the supplied vector at the given `base`\n    /// path. Mounting a route with path `path` at path `base` makes the route\n    /// available at `base/path`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either:\n    ///   * the `base` mount point is not a valid static path: a valid origin\n    ///     URI without dynamic parameters.\n    ///\n    ///   * any route's URI is not a valid origin URI.\n    ///\n    ///     **Note:** _This kind of panic is guaranteed not to occur if the routes\n    ///     were generated using Rocket's code generation._\n    ///\n    /// # Examples\n    ///\n    /// Use the `routes!` macro to mount routes created using the code\n    /// generation facilities. Requests to the `/hello/world` URI will be\n    /// dispatched to the `hi` route.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// #\n    /// #[get(\"/world\")]\n    /// fn hi() -> &'static str {\n    ///     \"Hello!\"\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().mount(\"/hello\", routes![hi])\n    /// }\n    /// ```\n    ///\n    /// Manually create a route named `hi` at path `\"/world\"` mounted at base\n    /// `\"/hello\"`. Requests to the `/hello/world` URI will be dispatched to the\n    /// `hi` route.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::{Request, Route, Data, route};\n    /// use rocket::http::Method;\n    ///\n    /// fn hi<'r>(req: &'r Request, _: Data<'r>) -> route::BoxFuture<'r> {\n    ///     route::Outcome::from(req, \"Hello!\").pin()\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let hi_route = Route::new(Method::Get, \"/world\", hi);\n    ///     rocket::build().mount(\"/hello\", vec![hi_route])\n    /// }\n    /// ```\n    #[must_use]\n    #[track_caller]\n    pub fn mount<'a, B, R>(self, base: B, routes: R) -> Self\n        where B: TryInto<Origin<'a>> + Clone + fmt::Display,\n              B::Error: fmt::Display,\n              R: Into<Vec<Route>>\n    {\n        self.load(\"route\", base, routes.into(),\n            |base, route| route.map_base(|old| format!(\"{}{}\", base, old)),\n            |r, route| r.0.routes.push(route))\n    }\n\n    /// Registers all of the catchers in the supplied vector, scoped to `base`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `base` is not a valid static path: a valid origin URI without\n    /// dynamic parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::Request;\n    ///\n    /// #[catch(500)]\n    /// fn internal_error() -> &'static str {\n    ///     \"Whoops! Looks like we messed up.\"\n    /// }\n    ///\n    /// #[catch(404)]\n    /// fn not_found(req: &Request) -> String {\n    ///     format!(\"I couldn't find '{}'. Try something else?\", req.uri())\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().register(\"/\", catchers![internal_error, not_found])\n    /// }\n    /// ```\n    #[must_use]\n    pub fn register<'a, B, C>(self, base: B, catchers: C) -> Self\n        where B: TryInto<Origin<'a>> + Clone + fmt::Display,\n              B::Error: fmt::Display,\n              C: Into<Vec<Catcher>>\n    {\n        self.load(\"catcher\", base, catchers.into(),\n            |base, catcher| catcher.map_base(|old| format!(\"{}{}\", base, old)),\n            |r, catcher| r.0.catchers.push(catcher))\n    }\n\n    /// Add `state` to the state managed by this instance of Rocket.\n    ///\n    /// This method can be called any number of times as long as each call\n    /// refers to a different `T`.\n    ///\n    /// Managed state can be retrieved by any request handler via the\n    /// [`State`](crate::State) request guard. In particular, if a value of type `T`\n    /// is managed by Rocket, adding `State<T>` to the list of arguments in a\n    /// request handler instructs Rocket to retrieve the managed value.\n    ///\n    /// # Panics\n    ///\n    /// Panics if state of type `T` is already being managed.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::State;\n    ///\n    /// struct MyInt(isize);\n    /// struct MyString(String);\n    ///\n    /// #[get(\"/int\")]\n    /// fn int(state: &State<MyInt>) -> String {\n    ///     format!(\"The stateful int is: {}\", state.0)\n    /// }\n    ///\n    /// #[get(\"/string\")]\n    /// fn string(state: &State<MyString>) -> &str {\n    ///     &state.0\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .manage(MyInt(10))\n    ///         .manage(MyString(\"Hello, managed state!\".to_string()))\n    ///         .mount(\"/\", routes![int, string])\n    /// }\n    /// ```\n    #[must_use]\n    pub fn manage<T>(self, state: T) -> Self\n        where T: Send + Sync + 'static\n    {\n        let type_name = std::any::type_name::<T>();\n        if !self.state.set(state) {\n            error!(\"state for type '{}' is already being managed\", type_name);\n            panic!(\"aborting due to duplicated managed state\");\n        }\n\n        self\n    }\n\n    /// Attaches a fairing to this instance of Rocket. No fairings are eagerly\n    /// executed; fairings are executed at their appropriate time.\n    ///\n    /// If the attached fairing is _fungible_ and a fairing of the same name\n    /// already exists, this fairing replaces it.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::Rocket;\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .attach(AdHoc::on_liftoff(\"Liftoff Message\", |_| Box::pin(async {\n    ///             println!(\"We have liftoff!\");\n    ///         })))\n    /// }\n    /// ```\n    #[must_use]\n    pub fn attach<F: Fairing>(mut self, fairing: F) -> Self {\n        self.fairings.add(Box::new(fairing));\n        self\n    }\n\n    /// Returns a `Future` that transitions this instance of `Rocket` into the\n    /// _ignite_ phase.\n    ///\n    /// When `await`ed, the future runs all _ignite_ fairings in serial,\n    /// [attach](Rocket::attach()) order, and verifies that `self` represents a\n    /// valid instance of `Rocket` ready for launch. This means that:\n    ///\n    ///   * All ignite fairings succeeded.\n    ///   * A valid [`Config`] was extracted from [`Rocket::figment()`].\n    ///   * If `secrets` are enabled, the extracted `Config` contains a safe\n    ///     secret key.\n    ///   * There are no [`Route#collisions`] or [`Catcher#collisions`]\n    ///     collisions.\n    ///   * No [`Sentinel`](crate::Sentinel) triggered an abort.\n    ///\n    /// If any of these conditions fail to be met, a respective [`Error`] is\n    /// returned.\n    ///\n    /// [configured]: Rocket::figment()\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[rocket::main]\n    /// async fn main() -> Result<(), rocket::Error> {\n    ///     let rocket = rocket::build()\n    ///         # .configure(rocket::Config::debug_default())\n    ///         .attach(AdHoc::on_ignite(\"Manage State\", |rocket| async move {\n    ///             rocket.manage(String::from(\"managed string\"))\n    ///         }));\n    ///\n    ///     // No fairings are run until ignition occurs.\n    ///     assert!(rocket.state::<String>().is_none());\n    ///\n    ///     let rocket = rocket.ignite().await?;\n    ///     assert_eq!(rocket.state::<String>().unwrap(), \"managed string\");\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn ignite(mut self) -> Result<Rocket<Ignite>, Error> {\n        self = Fairings::handle_ignite(self).await;\n        self.fairings.audit().map_err(|f| ErrorKind::FailedFairings(f.to_vec()))?;\n\n        // Extract the configuration; initialize the logger.\n        #[allow(unused_mut)]\n        let mut config = Config::try_from(&self.figment).map_err(ErrorKind::Config)?;\n        crate::log::init(&config);\n\n        // Check for safely configured secrets.\n        #[cfg(feature = \"secrets\")]\n        if !config.secret_key.is_provided() {\n            if config.profile != Config::DEBUG_PROFILE {\n                return Err(Error::new(ErrorKind::InsecureSecretKey(config.profile.clone())));\n            }\n\n            if config.secret_key.is_zero() {\n                config.secret_key = crate::config::SecretKey::generate()\n                    .unwrap_or_else(crate::config::SecretKey::zero);\n            }\n        } else if config.known_secret_key_used() {\n            warn!(\"The configured `secret_key` is exposed and insecure.\");\n            warn_!(\"The configured key is publicly published and thus insecure.\");\n            warn_!(\"Try generating a new key with `head -c64 /dev/urandom | base64`.\");\n        }\n\n        // Initialize the router; check for collisions.\n        let mut router = Router::new();\n        self.routes.clone().into_iter().for_each(|r| router.add_route(r));\n        self.catchers.clone().into_iter().for_each(|c| router.add_catcher(c));\n        router.finalize().map_err(ErrorKind::Collisions)?;\n\n        // Finally, freeze managed state.\n        self.state.freeze();\n\n        // Log everything we know: config, routes, catchers, fairings.\n        // TODO: Store/print managed state type names?\n        config.pretty_print(self.figment());\n        log_items(\" \", \"Routes\", self.routes(), |r| &r.uri.base, |r| &r.uri);\n        log_items(\" \", \"Catchers\", self.catchers(), |c| &c.base, |c| &c.base);\n        self.fairings.pretty_print();\n\n        // Ignite the rocket.\n        let rocket: Rocket<Ignite> = Rocket(Igniting {\n            router, config,\n            shutdown: Shutdown(TripWire::new()),\n            figment: self.0.figment,\n            fairings: self.0.fairings,\n            state: self.0.state,\n        });\n\n        // Query the sentinels, abort if requested.\n        let sentinels = rocket.routes().flat_map(|r| r.sentinels.iter());\n        sentinel::query(sentinels, &rocket).map_err(ErrorKind::SentinelAborts)?;\n\n        Ok(rocket)\n    }\n}\n\nfn log_items<T, I, B, O>(e: &str, t: &str, items: I, base: B, origin: O)\n    where T: fmt::Display + Copy, I: Iterator<Item = T>,\n          B: Fn(&T) -> &Origin<'_>, O: Fn(&T) -> &Origin<'_>\n{\n    let mut items: Vec<_> = items.collect();\n    if !items.is_empty() {\n        launch_meta!(\"{}{}:\", e.emoji(), t.magenta());\n    }\n\n    items.sort_by_key(|i| origin(i).path().as_str().chars().count());\n    items.sort_by_key(|i| origin(i).path().segments().len());\n    items.sort_by_key(|i| base(i).path().as_str().chars().count());\n    items.sort_by_key(|i| base(i).path().segments().len());\n    items.iter().for_each(|i| launch_meta_!(\"{}\", i));\n}\n\nimpl Rocket<Ignite> {\n    /// Returns the finalized, active configuration. This is guaranteed to\n    /// remain stable through ignition and into orbit.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// #[rocket::main]\n    /// async fn main() -> Result<(), rocket::Error> {\n    ///     let rocket = rocket::build().ignite().await?;\n    ///     let config = rocket.config();\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn config(&self) -> &Config {\n        &self.config\n    }\n\n    /// Returns a handle which can be used to trigger a shutdown and detect a\n    /// triggered shutdown.\n    ///\n    /// A completed graceful shutdown resolves the future returned by\n    /// [`Rocket::launch()`]. If [`Shutdown::notify()`] is called _before_ an\n    /// instance is launched, it will be immediately shutdown after liftoff. See\n    /// [`Shutdown`] and [`config::Shutdown`](crate::config::Shutdown) for\n    /// details on graceful shutdown.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use std::time::Duration;\n    /// use rocket::tokio::{self, time};\n    ///\n    /// #[rocket::main]\n    /// async fn main() -> Result<(), rocket::Error> {\n    ///     let rocket = rocket::build().ignite().await?;\n    ///\n    ///     let shutdown = rocket.shutdown();\n    ///     tokio::spawn(async move {\n    ///         time::sleep(time::Duration::from_secs(5)).await;\n    ///         shutdown.notify();\n    ///     });\n    ///\n    ///     // The `launch()` future resolves after ~5 seconds.\n    ///     let result = rocket.launch().await;\n    ///     assert!(result.is_ok());\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn shutdown(&self) -> Shutdown {\n        self.shutdown.clone()\n    }\n\n    fn into_orbit(self) -> Rocket<Orbit> {\n        Rocket(Orbiting {\n            router: self.0.router,\n            fairings: self.0.fairings,\n            figment: self.0.figment,\n            config: self.0.config,\n            state: self.0.state,\n            shutdown: self.0.shutdown,\n        })\n    }\n\n    async fn _local_launch(self) -> Rocket<Orbit> {\n        let rocket = self.into_orbit();\n        rocket.fairings.handle_liftoff(&rocket).await;\n        launch_info!(\"{}{}\", \" \".emoji(), \"Rocket has launched locally\".primary().bold());\n        rocket\n    }\n\n    async fn _launch(self) -> Result<Rocket<Ignite>, Error> {\n        self.into_orbit()\n            .default_tcp_http_server(|rkt| Box::pin(async move {\n                rkt.fairings.handle_liftoff(&rkt).await;\n\n                let proto = rkt.config.tls_enabled().then(|| \"https\").unwrap_or(\"http\");\n                let socket_addr = SocketAddr::new(rkt.config.address, rkt.config.port);\n                let addr = format!(\"{}://{}\", proto, socket_addr);\n                launch_info!(\"{}{} {}\",\n                    \" \".emoji(),\n                    \"Rocket has launched from\".bold().primary().linger(),\n                    addr.underline());\n            }))\n            .await\n            .map(|rocket| rocket.into_ignite())\n    }\n}\n\nimpl Rocket<Orbit> {\n    pub(crate) fn into_ignite(self) -> Rocket<Ignite> {\n        Rocket(Igniting {\n            router: self.0.router,\n            fairings: self.0.fairings,\n            figment: self.0.figment,\n            config: self.0.config,\n            state: self.0.state,\n            shutdown: self.0.shutdown,\n        })\n    }\n\n    /// Returns the finalized, active configuration. This is guaranteed to\n    /// remain stable after [`Rocket::ignite()`], through ignition and into\n    /// orbit.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .attach(AdHoc::on_liftoff(\"Config\", |rocket| Box::pin(async move {\n    ///             println!(\"Rocket launch config: {:?}\", rocket.config());\n    ///         })))\n    /// }\n    /// ```\n    pub fn config(&self) -> &Config {\n        &self.config\n    }\n\n    /// Returns a handle which can be used to trigger a shutdown and detect a\n    /// triggered shutdown.\n    ///\n    /// A completed graceful shutdown resolves the future returned by\n    /// [`Rocket::launch()`]. See [`Shutdown`] and\n    /// [`config::Shutdown`](crate::config::Shutdown) for details on graceful\n    /// shutdown.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::tokio::{self, time};\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .attach(AdHoc::on_liftoff(\"Shutdown\", |rocket| Box::pin(async move {\n    ///             let shutdown = rocket.shutdown();\n    ///             tokio::spawn(async move {\n    ///                 time::sleep(time::Duration::from_secs(5)).await;\n    ///                 shutdown.notify();\n    ///             });\n    ///         })))\n    /// }\n    /// ```\n    pub fn shutdown(&self) -> Shutdown {\n        self.shutdown.clone()\n    }\n}\n\nimpl<P: Phase> Rocket<P> {\n    /// Returns an iterator over all of the routes mounted on this instance of\n    /// Rocket. The order is unspecified.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::*;\n    /// use rocket::Rocket;\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[get(\"/hello\")]\n    /// fn hello() -> &'static str {\n    ///     \"Hello, world!\"\n    /// }\n    ///\n    /// let rocket = rocket::build()\n    ///     .mount(\"/\", routes![hello])\n    ///     .mount(\"/hi\", routes![hello]);\n    ///\n    /// assert_eq!(rocket.routes().count(), 2);\n    /// assert!(rocket.routes().any(|r| r.uri == \"/hello\"));\n    /// assert!(rocket.routes().any(|r| r.uri == \"/hi/hello\"));\n    /// ```\n    pub fn routes(&self) -> impl Iterator<Item = &Route> {\n        match self.0.as_state_ref() {\n            StateRef::Build(p) => Either::Left(p.routes.iter()),\n            StateRef::Ignite(p) => Either::Right(p.router.routes()),\n            StateRef::Orbit(p) => Either::Right(p.router.routes()),\n        }\n    }\n\n    /// Returns an iterator over all of the catchers registered on this instance\n    /// of Rocket. The order is unspecified.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::*;\n    /// use rocket::Rocket;\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[catch(404)] fn not_found() -> &'static str { \"Nothing here, sorry!\" }\n    /// #[catch(500)] fn just_500() -> &'static str { \"Whoops!?\" }\n    /// #[catch(default)] fn some_default() -> &'static str { \"Everything else.\" }\n    ///\n    /// let rocket = rocket::build()\n    ///     .register(\"/foo\", catchers![not_found])\n    ///     .register(\"/\", catchers![just_500, some_default]);\n    ///\n    /// assert_eq!(rocket.catchers().count(), 3);\n    /// assert!(rocket.catchers().any(|c| c.code == Some(404) && c.base == \"/foo\"));\n    /// assert!(rocket.catchers().any(|c| c.code == Some(500) && c.base == \"/\"));\n    /// assert!(rocket.catchers().any(|c| c.code == None && c.base == \"/\"));\n    /// ```\n    pub fn catchers(&self) -> impl Iterator<Item = &Catcher> {\n        match self.0.as_state_ref() {\n            StateRef::Build(p) => Either::Left(p.catchers.iter()),\n            StateRef::Ignite(p) => Either::Right(p.router.catchers()),\n            StateRef::Orbit(p) => Either::Right(p.router.catchers()),\n        }\n    }\n\n    /// Returns `Some` of the managed state value for the type `T` if it is\n    /// being managed by `self`. Otherwise, returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// #[derive(PartialEq, Debug)]\n    /// struct MyState(&'static str);\n    ///\n    /// let rocket = rocket::build().manage(MyState(\"hello!\"));\n    /// assert_eq!(rocket.state::<MyState>().unwrap(), &MyState(\"hello!\"));\n    /// ```\n    pub fn state<T: Send + Sync + 'static>(&self) -> Option<&T> {\n        match self.0.as_state_ref() {\n            StateRef::Build(p) => p.state.try_get(),\n            StateRef::Ignite(p) => p.state.try_get(),\n            StateRef::Orbit(p) => p.state.try_get(),\n        }\n    }\n\n    /// Returns the figment derived from the configuration provider set for\n    /// `self`. To extract a typed config, prefer to use\n    /// [`AdHoc::config()`](crate::fairing::AdHoc::config()).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// let rocket = rocket::build();\n    /// let figment = rocket.figment();\n    /// ```\n    pub fn figment(&self) -> &Figment {\n        match self.0.as_state_ref() {\n            StateRef::Build(p) => &p.figment,\n            StateRef::Ignite(p) => &p.figment,\n            StateRef::Orbit(p) => &p.figment,\n        }\n    }\n\n    pub(crate) async fn local_launch(self) -> Result<Rocket<Orbit>, Error> {\n        let rocket = match self.0.into_state() {\n            State::Build(s) => Rocket::from(s).ignite().await?._local_launch().await,\n            State::Ignite(s) => Rocket::from(s)._local_launch().await,\n            State::Orbit(s) => Rocket::from(s)\n        };\n\n        Ok(rocket)\n    }\n\n    /// Returns a `Future` that transitions this instance of `Rocket` from any\n    /// phase into the _orbit_ phase. When `await`ed, the future drives the\n    /// server forward, listening for and dispatching requests to mounted routes\n    /// and catchers.\n    ///\n    /// In addition to all of the processes that occur during\n    /// [ignition](Rocket::ignite()), a successful launch results in _liftoff_\n    /// fairings being executed _after_ binding to any respective network\n    /// interfaces but before serving the first request. Liftoff fairings are\n    /// run concurrently; resolution of all fairings is `await`ed before\n    /// resuming request serving.\n    ///\n    /// The `Future` resolves as an `Err` if any of the following occur:\n    ///\n    ///   * there is an error igniting; see [`Rocket::ignite()`].\n    ///   * there is an I/O error starting the server.\n    ///   * an unrecoverable, system-level error occurs while running.\n    ///\n    /// The `Future` resolves as an `Ok` if any of the following occur:\n    ///\n    ///   * graceful shutdown via [`Shutdown::notify()`] completes.\n    ///\n    /// The returned value on `Ok(())` is previously running instance.\n    ///\n    /// The `Future` does not resolve otherwise.\n    ///\n    /// # Error\n    ///\n    /// If there is a problem starting the application or the application fails\n    /// unexpectedly while running, an [`Error`] is returned. Note that a value\n    /// of type `Error` panics if dropped without first being inspected. See the\n    /// [`Error`] documentation for more information.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// #[rocket::main]\n    /// async fn main() {\n    ///     let result = rocket::build().launch().await;\n    ///\n    ///     // this is reachable only after `Shutdown::notify()` or `Ctrl+C`.\n    ///     println!(\"Rocket: deorbit.\");\n    /// }\n    /// ```\n    pub async fn launch(self) -> Result<Rocket<Ignite>, Error> {\n        match self.0.into_state() {\n            State::Build(s) => Rocket::from(s).ignite().await?._launch().await,\n            State::Ignite(s) => Rocket::from(s)._launch().await,\n            State::Orbit(s) => Ok(Rocket::from(s).into_ignite())\n        }\n    }\n}\n\n#[doc(hidden)]\nimpl<P: Phase> Deref for Rocket<P> {\n    type Target = P::State;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\n#[doc(hidden)]\nimpl<P: Phase> DerefMut for Rocket<P> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<P: Phase> fmt::Debug for Rocket<P> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::any::TypeId;\n\nuse crate::{Rocket, Ignite};\n\n/// An automatic last line of defense against launching an invalid [`Rocket`].\n///\n/// A sentinel, automatically run on [`ignition`](Rocket::ignite()), can trigger\n/// a launch abort should an instance fail to meet arbitrary conditions. Every\n/// type that appears in a **mounted** route's type signature is eligible to be\n/// a sentinel. Of these, those that implement `Sentinel` have their\n/// [`abort()`](Sentinel::abort()) method invoked automatically, immediately\n/// after ignition, once for each unique type. Sentinels inspect the finalized\n/// instance of `Rocket` and can trigger a launch abort by returning `true`.\n///\n/// # Built-In Sentinels\n///\n/// The [`State<T>`] type is a sentinel that triggers an abort if the finalized\n/// `Rocket` instance is not managing state for type `T`. Doing so prevents\n/// run-time failures of the `State` request guard.\n///\n/// [`State<T>`]: crate::State\n/// [`State`]: crate::State\n///\n/// ## Example\n///\n/// As an example, consider the following simple application:\n///\n/// ```rust\n/// # use rocket::*;\n/// # type Response = ();\n/// #[get(\"/<id>\")]\n/// fn index(id: usize, state: &State<String>) -> Response {\n///     /* ... */\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", routes![index])\n/// }\n///\n/// # use rocket::{Config, error::ErrorKind};\n/// # rocket::async_test(async {\n/// #    let result = rocket().configure(Config::debug_default()).ignite().await;\n/// #    assert!(matches!(result.unwrap_err().kind(), ErrorKind::SentinelAborts(..)));\n/// # })\n/// ```\n///\n/// At ignition time, effected by the `#[launch]` attribute here, Rocket probes\n/// all types in all mounted routes for `Sentinel` implementations. In this\n/// example, the types are: `usize`, `State<String>`, and `Response`. Those that\n/// implement `Sentinel` are queried for an abort trigger via their\n/// [`Sentinel::abort()`] method. In this example, the sentinel types are\n/// [`State`] and _potentially_ `Response`, if it implements\n/// `Sentinel`. If `abort()` returns true, launch is aborted with a\n/// corresponding error.\n///\n/// In this example, launch will be aborted because state of type `String` is\n/// not being managed. To correct the error and allow launching to proceed\n/// nominally, a value of type `String` must be managed:\n///\n/// ```rust\n/// # use rocket::*;\n/// # type Response = ();\n/// # #[get(\"/<id>\")]\n/// # fn index(id: usize, state: &State<String>) -> Response {\n/// #     /* ... */\n/// # }\n/// #\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build()\n///         .mount(\"/\", routes![index])\n///         .manage(String::from(\"my managed string\"))\n/// }\n///\n/// # use rocket::{Config, error::ErrorKind};\n/// # rocket::async_test(async {\n/// #    rocket().configure(Config::debug_default()).ignite().await.unwrap();\n/// # })\n/// ```\n///\n/// # Embedded Sentinels\n///\n/// Embedded types -- type parameters of already eligible types -- are also\n/// eligible to be sentinels. Consider the following route:\n///\n/// ```rust\n/// # use rocket::*;\n/// # use either::Either;\n/// # type Inner<T> = Option<T>;\n/// # type Foo = ();\n/// # type Bar = ();\n/// #[get(\"/\")]\n/// fn f(guard: Option<&State<String>>) -> Either<Foo, Inner<Bar>> {\n///     unimplemented!()\n/// }\n/// ```\n///\n/// The directly eligible sentinel types, guard and responders, are:\n///\n///   * `Option<&State<String>>`\n///   * `Either<Foo, Inner<Bar>>`\n///\n/// In addition, all embedded types are _also_ eligible. These are:\n///\n///   * `&State<String>`\n///   * `State<String>`\n///   * `String`\n///   * `Foo`\n///   * `Inner<Bar>`\n///   * `Bar`\n///\n/// A type, whether embedded or not, is queried if it is a `Sentinel` _and_ none\n/// of its parent types are sentinels. Said a different way, if every _directly_\n/// eligible type is viewed as the root of an acyclic graph with edges between a\n/// type and its type parameters, the _first_ `Sentinel` in breadth-first order\n/// is queried:\n///\n/// ```text\n/// 1.     Option<&State<String>>        Either<Foo, Inner<Bar>>\n///                 |                           /         \\\n/// 2.        &State<String>                   Foo     Inner<Bar>\n///                 |                                     |\n/// 3.         State<String>                              Bar\n///                 |\n/// 4.            String\n/// ```\n///\n/// In each graph above, types are queried from top to bottom, level 1 to 4.\n/// Querying continues down paths where the parents were _not_ sentinels. For\n/// example, if `Option` is a sentinel but `Either` is not, then querying stops\n/// for the left subgraph (`Option`) but continues for the right subgraph\n/// `Either`.\n///\n/// # Limitations\n///\n/// Because Rocket must know which `Sentinel` implementation to query based on\n/// its _written_ type, generally only explicitly written, resolved, concrete\n/// types are eligible to be sentinels. A typical application will only work\n/// with such types, but there are several common cases to be aware of.\n///\n/// ## `impl Trait`\n///\n/// Occasionally an existential `impl Trait` may find its way into return types:\n///\n/// ```rust\n/// # use rocket::*;\n/// # use either::Either;\n/// use rocket::response::Responder;\n/// # type AnotherSentinel = ();\n///\n/// #[get(\"/\")]\n/// fn f<'r>() -> Either<impl Responder<'r, 'static>, AnotherSentinel> {\n///     /* ... */\n///     # Either::Left(())\n/// }\n/// ```\n///\n/// **Note:** _Rocket actively discourages using `impl Trait` in route\n/// signatures. In addition to impeding sentinel discovery, doing so decreases\n/// the ability to gleam a handler's functionality based on its type signature._\n///\n/// The return type of the route `f` depends on its implementation. At present,\n/// it is not possible to name the underlying concrete type of an `impl Trait`\n/// at compile-time and thus not possible to determine if it implements\n/// `Sentinel`. As such, existentials _are not_ eligible to be sentinels.\n///\n/// That being said, this limitation only applies _per embedding_: types\n/// embedded inside of an `impl Trait` _are_ eligible. As such, in the example\n/// above, the named `AnotherSentinel` type continues to be eligible.\n///\n/// When possible, prefer to name all types:\n///\n/// ```rust\n/// # use rocket::*;\n/// # use either::Either;\n/// # type AbortingSentinel = ();\n/// # type AnotherSentinel = ();\n/// #[get(\"/\")]\n/// fn f() -> Either<AbortingSentinel, AnotherSentinel> {\n///     /* ... */\n///     # unimplemented!()\n/// }\n/// ```\n///\n/// ## Aliases\n///\n/// _Embedded_ sentinels made opaque by a type alias will fail to be considered;\n/// the aliased type itself _is_ considered. In the example below, only\n/// `Result<Foo, Bar>` will be considered, while the embedded `Foo` and `Bar`\n/// will not.\n///\n/// ```rust\n/// # use rocket::get;\n/// # type Foo = ();\n/// # type Bar = ();\n/// type SomeAlias = Result<Foo, Bar>;\n///\n/// #[get(\"/\")]\n/// fn f() -> SomeAlias {\n///     /* ... */\n///     # unimplemented!()\n/// }\n/// ```\n///\n/// Note, however, that `Option<T>` and [`Debug<T>`](crate::response::Debug) are\n/// a sentinels if `T: Sentinel`, and `Result<T, E>` and `Either<T, E>` are\n/// sentinels if _both_ `T: Sentinel, E: Sentinel`. Thus, for these specific\n/// cases, a type alias _will_ \"consider\" embeddings. Nevertheless, prefer to\n/// write concrete types when possible.\n///\n/// ## Type Macros\n///\n/// It is impossible to determine, a priori, what a type macro will expand to.\n/// As such, Rocket is unable to determine which sentinels, if any, a type macro\n/// references, and thus no sentinels are discovered from type macros.\n///\n/// Even approximations are impossible. For example, consider the following:\n///\n/// ```rust\n/// # use rocket::*;\n/// macro_rules! MyType {\n///     (State<'_, u32>) => (&'_ rocket::Config)\n/// }\n///\n/// #[get(\"/\")]\n/// fn f(guard: MyType![State<'_, u32>]) {\n///     /* ... */\n/// }\n/// ```\n///\n/// While the `MyType![State<'_, u32>]` type _appears_ to contain a `State`\n/// sentinel, the macro actually expands to `&'_ rocket::Config`, which is _not_\n/// the `State` sentinel.\n///\n/// Because Rocket knows the exact syntax expected by type macros that it\n/// exports, such as the [typed stream] macros, discovery in these macros works\n/// as expected. You should prefer not to use type macros aside from those\n/// exported by Rocket, or if necessary, restrict your use to those that always\n/// expand to types without sentinels.\n///\n/// [typed stream]: crate::response::stream\n///\n/// # Custom Sentinels\n///\n/// Any type can implement `Sentinel`, and the implementation can arbitrarily\n/// inspect an ignited instance of `Rocket`. For illustration, consider the\n/// following implementation of `Sentinel` for a custom `Responder` which\n/// requires:\n///\n///   * state for a type `T` to be managed\n///   * a catcher for status code `400` at base `/`\n///\n/// ```rust\n/// use rocket::{Rocket, Ignite, Sentinel};\n/// # struct MyResponder;\n/// # struct T;\n///\n/// impl Sentinel for MyResponder {\n///     fn abort(rocket: &Rocket<Ignite>) -> bool {\n///         if rocket.state::<T>().is_none() {\n///             return true;\n///         }\n///\n///         if !rocket.catchers().any(|c| c.code == Some(400) && c.base == \"/\") {\n///             return true;\n///         }\n///\n///         false\n///     }\n/// }\n/// ```\n///\n/// If a `MyResponder` is returned by any mounted route, its `abort()` method\n/// will be invoked. If the required conditions aren't met, signaled by\n/// returning `true` from `abort()`, Rocket aborts launch.\npub trait Sentinel {\n    /// Returns `true` if launch should be aborted and `false` otherwise.\n    fn abort(rocket: &Rocket<Ignite>) -> bool;\n}\n\nimpl<T: Sentinel> Sentinel for Option<T> {\n    fn abort(rocket: &Rocket<Ignite>) -> bool {\n        T::abort(rocket)\n    }\n}\n\n// In the next impls, we want to run _both_ sentinels _without_ short\n// circuiting, for the logs. Ideally we could check if these are the same type\n// or not, but `TypeId` only works with `'static`, and adding those bounds to\n// `T` and `E` would reduce the types for which the implementations work, which\n// would mean more types that we miss in type applies. When the type _isn't_ an\n// alias, however, the existence of these implementations is strictly worse.\n\nimpl<T: Sentinel, E: Sentinel> Sentinel for Result<T, E> {\n    fn abort(rocket: &Rocket<Ignite>) -> bool {\n        let left = T::abort(rocket);\n        let right = E::abort(rocket);\n        left || right\n    }\n}\n\nimpl<T: Sentinel, E: Sentinel> Sentinel for either::Either<T, E> {\n    fn abort(rocket: &Rocket<Ignite>) -> bool {\n        let left = T::abort(rocket);\n        let right = E::abort(rocket);\n        left || right\n    }\n}\n\n/// A sentinel that never aborts. The `Responder` impl for `Debug` will never be\n/// called, so it's okay to not abort for failing `T: Sentinel`.\nimpl<T> Sentinel for crate::response::Debug<T> {\n    fn abort(_: &Rocket<Ignite>) -> bool {\n        false\n    }\n}\n\n/// The information resolved from a `T: ?Sentinel` by the `resolve!()` macro.\n#[derive(Clone, Copy)]\npub struct Sentry {\n    /// The type ID of `T`.\n    pub type_id: TypeId,\n    /// The type name `T` as a string.\n    pub type_name: &'static str,\n    /// The type ID of type in which `T` is nested if not a top-level type.\n    pub parent: Option<TypeId>,\n    /// The source (file, column, line) location of the resolved `T`.\n    pub location: (&'static str, u32, u32),\n    /// The value of `<T as Sentinel>::SPECIALIZED` or the fallback.\n    ///\n    /// This is `true` when `T: Sentinel` and `false` when `T: !Sentinel`.\n    pub specialized: bool,\n    /// The value of `<T as Sentinel>::abort` or the fallback.\n    pub abort: fn(&Rocket<Ignite>) -> bool,\n}\n\n/// Query `sentinels`, once for each unique `type_id`, returning an `Err` of all\n/// of the sentinels that triggered an abort or `Ok(())` if none did.\npub(crate) fn query<'s>(\n    sentinels: impl Iterator<Item = &'s Sentry>,\n    rocket: &Rocket<Ignite>,\n) -> Result<(), Vec<Sentry>> {\n    use std::collections::{HashMap, VecDeque};\n\n    // Build a graph of the sentinels.\n    let mut roots: VecDeque<&'s Sentry> = VecDeque::new();\n    let mut map: HashMap<TypeId, VecDeque<&'s Sentry>> = HashMap::new();\n    for sentinel in sentinels {\n        match sentinel.parent {\n            Some(parent) => map.entry(parent).or_default().push_back(sentinel),\n            None => roots.push_back(sentinel),\n        }\n    }\n\n    // Traverse the graph in breadth-first order. If we find a specialized\n    // sentinel, query it (once for a unique type) and don't traverse its\n    // children. Otherwise, traverse its children. Record queried aborts.\n    let mut remaining = roots;\n    let mut visited: HashMap<TypeId, bool> = HashMap::new();\n    let mut aborted = vec![];\n    while let Some(sentinel) = remaining.pop_front() {\n        if sentinel.specialized {\n            if *visited.entry(sentinel.type_id).or_insert_with(|| (sentinel.abort)(rocket)) {\n                aborted.push(sentinel);\n            }\n        } else if let Some(mut children) = map.remove(&sentinel.type_id) {\n            remaining.append(&mut children);\n        }\n    }\n\n    match aborted.is_empty() {\n        true => Ok(()),\n        false => Err(aborted.into_iter().cloned().collect())\n    }\n}\n\nimpl fmt::Debug for Sentry {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Sentry\")\n            .field(\"type_id\", &self.type_id)\n            .field(\"type_name\", &self.type_name)\n            .field(\"parent\", &self.parent)\n            .field(\"location\", &self.location)\n            .field(\"default\", &self.specialized)\n            .finish()\n    }\n}\n\n/// Resolves a `T` to the specialized or fallback implementation of\n/// `Sentinel`, returning a `Sentry` struct with the resolved items.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! resolve {\n    ($T:ty $(, $P:ty)?) => ({\n        #[allow(unused_imports)]\n        use $crate::sentinel::resolution::{Resolve, DefaultSentinel as _};\n\n        $crate::sentinel::Sentry {\n            type_id: std::any::TypeId::of::<$T>(),\n            type_name: std::any::type_name::<$T>(),\n            parent: None $(.or(Some(std::any::TypeId::of::<$P>())))?,\n            location: (std::file!(), std::line!(), std::column!()),\n            specialized: Resolve::<$T>::SPECIALIZED,\n            abort: Resolve::<$T>::abort,\n        }\n    })\n}\n\npub use resolve;\n\npub mod resolution {\n    use super::*;\n\n    /// The *magic*.\n    ///\n    /// `Resolve<T>::item` for `T: Sentinel` is `<T as Sentinel>::item`.\n    /// `Resolve<T>::item` for `T: !Sentinel` is `DefaultSentinel::item`.\n    ///\n    /// This _must_ be used as `Resolve::<T>:item` for resolution to work. This\n    /// is a fun, static dispatch hack for \"specialization\" that works because\n    /// Rust prefers inherent methods over blanket trait impl methods.\n    pub struct Resolve<T: ?Sized>(std::marker::PhantomData<T>);\n\n    /// Fallback trait \"implementing\" `Sentinel` for all types. This is what\n    /// Rust will resolve `Resolve<T>::item` to when `T: !Sentinel`.\n    pub trait DefaultSentinel {\n        const SPECIALIZED: bool = false;\n\n        fn abort(_: &Rocket<Ignite>) -> bool { false }\n    }\n\n    impl<T: ?Sized> DefaultSentinel for T {}\n\n    /// \"Specialized\" \"implementation\" of `Sentinel` for `T: Sentinel`. This is\n    /// what Rust will resolve `Resolve<T>::item` to when `T: Sentinel`.\n    impl<T: Sentinel + ?Sized> Resolve<T> {\n        pub const SPECIALIZED: bool = true;\n\n        pub fn abort(rocket: &Rocket<Ignite>) -> bool {\n            T::abort(rocket)\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use std::any::TypeId;\n    use crate::sentinel::resolve;\n\n    struct NotASentinel;\n    struct YesASentinel;\n\n    impl super::Sentinel for YesASentinel {\n        fn abort(_: &crate::Rocket<crate::Ignite>) -> bool {\n            unimplemented!()\n        }\n    }\n\n    #[test]\n    fn check_can_determine() {\n        let not_a_sentinel = resolve!(NotASentinel);\n        assert!(not_a_sentinel.type_name.ends_with(\"NotASentinel\"));\n        assert!(!not_a_sentinel.specialized);\n\n        let yes_a_sentinel = resolve!(YesASentinel);\n        assert!(yes_a_sentinel.type_name.ends_with(\"YesASentinel\"));\n        assert!(yes_a_sentinel.specialized);\n    }\n\n    struct HasSentinel<T>(T);\n\n    #[test]\n    fn parent_works() {\n        let child = resolve!(YesASentinel, HasSentinel<YesASentinel>);\n        assert!(child.type_name.ends_with(\"YesASentinel\"));\n        assert_eq!(child.parent.unwrap(), TypeId::of::<HasSentinel<YesASentinel>>());\n        assert!(child.specialized);\n\n        let not_a_direct_sentinel = resolve!(HasSentinel<YesASentinel>);\n        assert!(not_a_direct_sentinel.type_name.contains(\"HasSentinel\"));\n        assert!(not_a_direct_sentinel.type_name.contains(\"YesASentinel\"));\n        assert!(not_a_direct_sentinel.parent.is_none());\n        assert!(!not_a_direct_sentinel.specialized);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::io;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse std::pin::Pin;\n\nuse yansi::Paint;\nuse tokio::sync::oneshot;\nuse tokio::time::sleep;\nuse futures::stream::StreamExt;\nuse futures::future::{FutureExt, Future, BoxFuture};\n\nuse crate::{route, Rocket, Orbit, Request, Response, Data, Config};\nuse crate::form::Form;\nuse crate::outcome::Outcome;\nuse crate::error::{Error, ErrorKind};\nuse crate::ext::{AsyncReadExt, CancellableListener, CancellableIo};\nuse crate::request::ConnectionMeta;\nuse crate::data::IoHandler;\n\nuse crate::http::{hyper, uncased, Method, Status, Header};\nuse crate::http::private::{TcpListener, Listener, Connection, Incoming};\n\n// A token returned to force the execution of one method before another.\npub(crate) struct RequestToken;\n\nasync fn handle<Fut, T, F>(name: Option<&str>, run: F) -> Option<T>\n    where F: FnOnce() -> Fut, Fut: Future<Output = T>,\n{\n    use std::panic::AssertUnwindSafe;\n\n    macro_rules! panic_info {\n        ($name:expr, $e:expr) => {{\n            match $name {\n                Some(name) => error_!(\"Handler {} panicked.\", name.primary()),\n                None => error_!(\"A handler panicked.\")\n            };\n\n            info_!(\"This is an application bug.\");\n            info_!(\"A panic in Rust must be treated as an exceptional event.\");\n            info_!(\"Panicking is not a suitable error handling mechanism.\");\n            info_!(\"Unwinding, the result of a panic, is an expensive operation.\");\n            info_!(\"Panics will degrade application performance.\");\n            info_!(\"Instead of panicking, return `Option` and/or `Result`.\");\n            info_!(\"Values of either type can be returned directly from handlers.\");\n            warn_!(\"A panic is treated as an internal server error.\");\n            $e\n        }}\n    }\n\n    let run = AssertUnwindSafe(run);\n    let fut = std::panic::catch_unwind(move || run())\n        .map_err(|e| panic_info!(name, e))\n        .ok()?;\n\n    AssertUnwindSafe(fut)\n        .catch_unwind()\n        .await\n        .map_err(|e| panic_info!(name, e))\n        .ok()\n}\n\n// This function tries to hide all of the Hyper-ness from Rocket. It essentially\n// converts Hyper types into Rocket types, then calls the `dispatch` function,\n// which knows nothing about Hyper. Because responding depends on the\n// `HyperResponse` type, this function does the actual response processing.\nasync fn hyper_service_fn(\n    rocket: Arc<Rocket<Orbit>>,\n    conn: ConnectionMeta,\n    mut hyp_req: hyper::Request<hyper::Body>,\n) -> Result<hyper::Response<hyper::Body>, io::Error> {\n    // This future must return a hyper::Response, but the response body might\n    // borrow from the request. Instead, write the body in another future that\n    // sends the response metadata (and a body channel) prior.\n    let (tx, rx) = oneshot::channel();\n\n    #[cfg(not(broken_fmt))]\n    debug!(\"received request: {:#?}\", hyp_req);\n\n    tokio::spawn(async move {\n        // We move the request next, so get the upgrade future now.\n        let pending_upgrade = hyper::upgrade::on(&mut hyp_req);\n\n        // Convert a Hyper request into a Rocket request.\n        let (h_parts, mut h_body) = hyp_req.into_parts();\n        match Request::from_hyp(&rocket, &h_parts, Some(conn)) {\n            Ok(mut req) => {\n                // Convert into Rocket `Data`, dispatch request, write response.\n                let mut data = Data::from(&mut h_body);\n                let token = rocket.preprocess_request(&mut req, &mut data).await;\n                let mut response = rocket.dispatch(token, &req, data).await;\n                let upgrade = response.take_upgrade(req.headers().get(\"upgrade\"));\n                if let Ok(Some((proto, handler))) = upgrade {\n                    rocket.handle_upgrade(response, proto, handler, pending_upgrade, tx).await;\n                } else {\n                    if upgrade.is_err() {\n                        warn_!(\"Request wants upgrade but no I/O handler matched.\");\n                        info_!(\"Request is not being upgraded.\");\n                    }\n\n                    rocket.send_response(response, tx).await;\n                }\n            },\n            Err(e) => {\n                warn!(\"Bad incoming HTTP request.\");\n                e.errors.iter().for_each(|e| warn_!(\"Error: {}.\", e));\n                warn_!(\"Dispatching salvaged request to catcher: {}.\", e.request);\n\n                let response = rocket.handle_error(Status::BadRequest, &e.request).await;\n                rocket.send_response(response, tx).await;\n            }\n        }\n    });\n\n    // Receive the response written to `tx` by the task above.\n    rx.await.map_err(|e| io::Error::new(io::ErrorKind::BrokenPipe, e))\n}\n\nimpl Rocket<Orbit> {\n    /// Wrapper around `_send_response` to log a success or error.\n    #[inline]\n    async fn send_response(\n        &self,\n        response: Response<'_>,\n        tx: oneshot::Sender<hyper::Response<hyper::Body>>,\n    ) {\n        let remote_hungup = |e: &io::Error| match e.kind() {\n            | io::ErrorKind::BrokenPipe\n            | io::ErrorKind::ConnectionReset\n            | io::ErrorKind::ConnectionAborted => true,\n            _ => false,\n        };\n\n        match self._send_response(response, tx).await {\n            Ok(()) => info_!(\"{}\", \"Response succeeded.\".green()),\n            Err(e) if remote_hungup(&e) => warn_!(\"Remote left: {}.\", e),\n            Err(e) => warn_!(\"Failed to write response: {}.\", e),\n        }\n    }\n\n    /// Attempts to create a hyper response from `response` and send it to `tx`.\n    #[inline]\n    async fn _send_response(\n        &self,\n        mut response: Response<'_>,\n        tx: oneshot::Sender<hyper::Response<hyper::Body>>,\n    ) -> io::Result<()> {\n        let mut hyp_res = hyper::Response::builder();\n\n        hyp_res = hyp_res.status(response.status().code);\n        for header in response.headers().iter() {\n            let name = header.name.as_str();\n            let value = header.value.as_bytes();\n            hyp_res = hyp_res.header(name, value);\n        }\n\n        let body = response.body_mut();\n        if let Some(n) = body.size().await {\n            hyp_res = hyp_res.header(hyper::header::CONTENT_LENGTH, n);\n        }\n\n        let (mut sender, hyp_body) = hyper::Body::channel();\n        let hyp_response = hyp_res.body(hyp_body)\n            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;\n\n        #[cfg(not(broken_fmt))]\n        debug!(\"sending response: {:#?}\", hyp_response);\n\n        tx.send(hyp_response).map_err(|_| {\n            let msg = \"client disconnect before response started\";\n            io::Error::new(io::ErrorKind::BrokenPipe, msg)\n        })?;\n\n        let max_chunk_size = body.max_chunk_size();\n        let mut stream = body.into_bytes_stream(max_chunk_size);\n        while let Some(next) = stream.next().await {\n            sender.send_data(next?).await\n                .map_err(|e| io::Error::new(io::ErrorKind::BrokenPipe, e))?;\n        }\n\n        Ok(())\n    }\n\n    async fn handle_upgrade<'r>(\n        &self,\n        mut response: Response<'r>,\n        proto: uncased::Uncased<'r>,\n        io_handler: Pin<Box<dyn IoHandler + 'r>>,\n        pending_upgrade: hyper::upgrade::OnUpgrade,\n        tx: oneshot::Sender<hyper::Response<hyper::Body>>,\n    ) {\n        info_!(\"Upgrading connection to {}.\", Paint::white(&proto).bold());\n        response.set_status(Status::SwitchingProtocols);\n        response.set_raw_header(\"Connection\", \"Upgrade\");\n        response.set_raw_header(\"Upgrade\", proto.clone().into_cow());\n        self.send_response(response, tx).await;\n\n        match pending_upgrade.await {\n            Ok(io_stream) => {\n                info_!(\"Upgrade successful.\");\n                if let Err(e) = io_handler.io(io_stream.into()).await {\n                    if e.kind() == io::ErrorKind::BrokenPipe {\n                        warn!(\"Upgraded {} I/O handler was closed.\", proto);\n                    } else {\n                        error!(\"Upgraded {} I/O handler failed: {}\", proto, e);\n                    }\n                }\n            },\n            Err(e) => {\n                warn!(\"Response indicated upgrade, but upgrade failed.\");\n                warn_!(\"Upgrade error: {}\", e);\n            }\n        }\n    }\n\n    /// Preprocess the request for Rocket things. Currently, this means:\n    ///\n    ///   * Rewriting the method in the request if _method form field exists.\n    ///   * Run the request fairings.\n    ///\n    /// Keep this in-sync with derive_form when preprocessing form fields.\n    pub(crate) async fn preprocess_request(\n        &self,\n        req: &mut Request<'_>,\n        data: &mut Data<'_>\n    ) -> RequestToken {\n        // Check if this is a form and if the form contains the special _method\n        // field which we use to reinterpret the request's method.\n        let (min_len, max_len) = (\"_method=get\".len(), \"_method=delete\".len());\n        let peek_buffer = data.peek(max_len).await;\n        let is_form = req.content_type().map_or(false, |ct| ct.is_form());\n\n        if is_form && req.method() == Method::Post && peek_buffer.len() >= min_len {\n            let method = std::str::from_utf8(peek_buffer).ok()\n                .and_then(|raw_form| Form::values(raw_form).next())\n                .filter(|field| field.name == \"_method\")\n                .and_then(|field| field.value.parse().ok());\n\n            if let Some(method) = method {\n                req._set_method(method);\n            }\n        }\n\n        // Run request fairings.\n        self.fairings.handle_request(req, data).await;\n\n        RequestToken\n    }\n\n    #[inline]\n    pub(crate) async fn dispatch<'s, 'r: 's>(\n        &'s self,\n        _token: RequestToken,\n        request: &'r Request<'s>,\n        data: Data<'r>\n    ) -> Response<'r> {\n        info!(\"{}:\", request);\n\n        // Remember if the request is `HEAD` for later body stripping.\n        let was_head_request = request.method() == Method::Head;\n\n        // Route the request and run the user's handlers.\n        let mut response = self.route_and_process(request, data).await;\n\n        // Add a default 'Server' header if it isn't already there.\n        // TODO: If removing Hyper, write out `Date` header too.\n        if let Some(ident) = request.rocket().config.ident.as_str() {\n            if !response.headers().contains(\"Server\") {\n                response.set_header(Header::new(\"Server\", ident));\n            }\n        }\n\n        // Run the response fairings.\n        self.fairings.handle_response(request, &mut response).await;\n\n        // Strip the body if this is a `HEAD` request.\n        if was_head_request {\n            response.strip_body();\n        }\n\n        response\n    }\n\n    async fn route_and_process<'s, 'r: 's>(\n        &'s self,\n        request: &'r Request<'s>,\n        data: Data<'r>\n    ) -> Response<'r> {\n        let mut response = match self.route(request, data).await {\n            Outcome::Success(response) => response,\n            Outcome::Forward((data, _)) if request.method() == Method::Head => {\n                info_!(\"Autohandling {} request.\", \"HEAD\".primary().bold());\n\n                // Dispatch the request again with Method `GET`.\n                request._set_method(Method::Get);\n                match self.route(request, data).await {\n                    Outcome::Success(response) => response,\n                    Outcome::Error(status) => self.handle_error(status, request).await,\n                    Outcome::Forward((_, status)) => self.handle_error(status, request).await,\n                }\n            }\n            Outcome::Forward((_, status)) => self.handle_error(status, request).await,\n            Outcome::Error(status) => self.handle_error(status, request).await,\n        };\n\n        // Set the cookies. Note that error responses will only include cookies\n        // set by the error handler. See `handle_error` for more.\n        let delta_jar = request.cookies().take_delta_jar();\n        for cookie in delta_jar.delta() {\n            response.adjoin_header(cookie);\n        }\n\n        response\n    }\n\n    /// Tries to find a `Responder` for a given `request`. It does this by\n    /// routing the request and calling the handler for each matching route\n    /// until one of the handlers returns success or error, or there are no\n    /// additional routes to try (forward). The corresponding outcome for each\n    /// condition is returned.\n    #[inline]\n    async fn route<'s, 'r: 's>(\n        &'s self,\n        request: &'r Request<'s>,\n        mut data: Data<'r>,\n    ) -> route::Outcome<'r> {\n        // Go through all matching routes until we fail or succeed or run out of\n        // routes to try, in which case we forward with the last status.\n        let mut status = Status::NotFound;\n        for route in self.router.route(request) {\n            // Retrieve and set the requests parameters.\n            info_!(\"Matched: {}\", route);\n            request.set_route(route);\n\n            let name = route.name.as_deref();\n            let outcome = handle(name, || route.handler.handle(request, data)).await\n                .unwrap_or(Outcome::Error(Status::InternalServerError));\n\n            // Check if the request processing completed (Some) or if the\n            // request needs to be forwarded. If it does, continue the loop\n            // (None) to try again.\n            info_!(\"{}\", outcome.log_display());\n            match outcome {\n                o@Outcome::Success(_) | o@Outcome::Error(_) => return o,\n                Outcome::Forward(forwarded) => (data, status) = forwarded,\n            }\n        }\n\n        error_!(\"No matching routes for {}.\", request);\n        Outcome::Forward((data, status))\n    }\n\n    /// Invokes the handler with `req` for catcher with status `status`.\n    ///\n    /// In order of preference, invoked handler is:\n    ///   * the user's registered handler for `status`\n    ///   * the user's registered `default` handler\n    ///   * Rocket's default handler for `status`\n    ///\n    /// Return `Ok(result)` if the handler succeeded. Returns `Ok(Some(Status))`\n    /// if the handler ran to completion but failed. Returns `Ok(None)` if the\n    /// handler panicked while executing.\n    async fn invoke_catcher<'s, 'r: 's>(\n        &'s self,\n        status: Status,\n        req: &'r Request<'s>\n    ) -> Result<Response<'r>, Option<Status>> {\n        // For now, we reset the delta state to prevent any modifications\n        // from earlier, unsuccessful paths from being reflected in error\n        // response. We may wish to relax this in the future.\n        req.cookies().reset_delta();\n\n        if let Some(catcher) = self.router.catch(status, req) {\n            warn_!(\"Responding with registered {} catcher.\", catcher);\n            let name = catcher.name.as_deref();\n            handle(name, || catcher.handler.handle(status, req)).await\n                .map(|result| result.map_err(Some))\n                .unwrap_or_else(|| Err(None))\n        } else {\n            let code = status.code.blue().bold();\n            warn_!(\"No {} catcher registered. Using Rocket default.\", code);\n            Ok(crate::catcher::default_handler(status, req))\n        }\n    }\n\n    // Invokes the catcher for `status`. Returns the response on success.\n    //\n    // On catcher error, the 500 error catcher is attempted. If _that_ errors,\n    // the (infallible) default 500 error cather is used.\n    pub(crate) async fn handle_error<'s, 'r: 's>(\n        &'s self,\n        mut status: Status,\n        req: &'r Request<'s>\n    ) -> Response<'r> {\n        // Dispatch to the `status` catcher.\n        if let Ok(r) = self.invoke_catcher(status, req).await {\n            return r;\n        }\n\n        // If it fails and it's not a 500, try the 500 catcher.\n        if status != Status::InternalServerError {\n            error_!(\"Catcher failed. Attempting 500 error catcher.\");\n            status = Status::InternalServerError;\n            if let Ok(r) = self.invoke_catcher(status, req).await {\n                return r;\n            }\n        }\n\n        // If it failed again or if it was already a 500, use Rocket's default.\n        error_!(\"{} catcher failed. Using Rocket default 500.\", status.code);\n        crate::catcher::default_handler(Status::InternalServerError, req)\n    }\n\n    pub(crate) async fn default_tcp_http_server<C>(mut self, ready: C) -> Result<Self, Error>\n        where C: for<'a> Fn(&'a Self) -> BoxFuture<'a, ()>\n    {\n        use std::net::ToSocketAddrs;\n\n        // Determine the address we're going to serve on.\n        let addr = format!(\"{}:{}\", self.config.address, self.config.port);\n        let mut addr = addr.to_socket_addrs()\n            .map(|mut addrs| addrs.next().expect(\">= 1 socket addr\"))\n            .map_err(|e| Error::new(ErrorKind::Io(e)))?;\n\n        #[cfg(feature = \"tls\")]\n        if self.config.tls_enabled() {\n            if let Some(ref config) = self.config.tls {\n                use crate::http::tls::TlsListener;\n\n                let conf = config.to_native_config().map_err(ErrorKind::Io)?;\n                let l = TlsListener::bind(addr, conf).await.map_err(ErrorKind::Bind)?;\n                addr = l.local_addr().unwrap_or(addr);\n                self.config.address = addr.ip();\n                self.config.port = addr.port();\n                ready(&mut self).await;\n                return self.http_server(l).await;\n            }\n        }\n\n        let l = TcpListener::bind(addr).await.map_err(ErrorKind::Bind)?;\n        addr = l.local_addr().unwrap_or(addr);\n        self.config.address = addr.ip();\n        self.config.port = addr.port();\n        ready(&mut self).await;\n        self.http_server(l).await\n    }\n\n    // TODO.async: Solidify the Listener APIs and make this function public\n    pub(crate) async fn http_server<L>(self, listener: L) -> Result<Self, Error>\n        where L: Listener + Send, <L as Listener>::Connection: Send + Unpin + 'static\n    {\n        // Emit a warning if we're not running inside of Rocket's async runtime.\n        if self.config.profile == Config::DEBUG_PROFILE {\n            tokio::task::spawn_blocking(|| {\n                let this  = std::thread::current();\n                if !this.name().map_or(false, |s| s.starts_with(\"rocket-worker\")) {\n                    warn!(\"Rocket is executing inside of a custom runtime.\");\n                    info_!(\"Rocket's runtime is enabled via `#[rocket::main]` or `#[launch]`.\");\n                    info_!(\"Forced shutdown is disabled. Runtime settings may be suboptimal.\");\n                }\n            });\n        }\n\n        // Set up cancellable I/O from the given listener. Shutdown occurs when\n        // `Shutdown` (`TripWire`) resolves. This can occur directly through a\n        // notification or indirectly through an external signal which, when\n        // received, results in triggering the notify.\n        let shutdown = self.shutdown();\n        let sig_stream = self.config.shutdown.signal_stream();\n        let grace = self.config.shutdown.grace as u64;\n        let mercy = self.config.shutdown.mercy as u64;\n\n        // Start a task that listens for external signals and notifies shutdown.\n        if let Some(mut stream) = sig_stream {\n            let shutdown = shutdown.clone();\n            tokio::spawn(async move {\n                while let Some(sig) = stream.next().await {\n                    if shutdown.0.tripped() {\n                        warn!(\"Received {}. Shutdown already in progress.\", sig);\n                    } else {\n                        warn!(\"Received {}. Requesting shutdown.\", sig);\n                    }\n\n                    shutdown.0.trip();\n                }\n            });\n        }\n\n        // Save the keep-alive value for later use; we're about to move `self`.\n        let keep_alive = self.config.keep_alive;\n\n        // Create the Hyper `Service`.\n        let rocket = Arc::new(self);\n        let service_fn = |conn: &CancellableIo<_, L::Connection>| {\n            let rocket = rocket.clone();\n            let connection = ConnectionMeta {\n                remote: conn.peer_address(),\n                client_certificates: conn.peer_certificates(),\n            };\n\n            async move {\n                Ok::<_, std::convert::Infallible>(hyper::service::service_fn(move |req| {\n                    hyper_service_fn(rocket.clone(), connection.clone(), req)\n                }))\n            }\n        };\n\n        // NOTE: `hyper` uses `tokio::spawn()` as the default executor.\n        let listener = CancellableListener::new(shutdown.clone(), listener, grace, mercy);\n        let builder = hyper::server::Server::builder(Incoming::new(listener).nodelay(true));\n\n        #[cfg(feature = \"http2\")]\n        let builder = builder.http2_keep_alive_interval(match keep_alive {\n            0 => None,\n            n => Some(Duration::from_secs(n as u64))\n        });\n\n        let server = builder\n            .http1_keepalive(keep_alive != 0)\n            .http1_preserve_header_case(true)\n            .serve(hyper::service::make_service_fn(service_fn))\n            .with_graceful_shutdown(shutdown.clone());\n\n        // This deserves some explanation.\n        //\n        // This is largely to deal with Hyper's dreadful and largely nonexistent\n        // handling of shutdown, in general, nevermind graceful.\n        //\n        // When Hyper receives a \"graceful shutdown\" request, it stops accepting\n        // new requests. That's it. It continues to process existing requests\n        // and outgoing responses forever and never cancels them. As a result,\n        // Rocket must take it upon itself to cancel any existing I/O.\n        //\n        // To do so, Rocket wraps all connections in a `CancellableIo` struct,\n        // an internal structure that gracefully closes I/O when it receives a\n        // signal. That signal is the `shutdown` future. When the future\n        // resolves, `CancellableIo` begins to terminate in grace, mercy, and\n        // finally force close phases. Since all connections are wrapped in\n        // `CancellableIo`, this eventually ends all I/O.\n        //\n        // At that point, unless a user spawned an infinite, stand-alone task\n        // that isn't monitoring `Shutdown`, all tasks should resolve. This\n        // means that all instances of the shared `Arc<Rocket>` are dropped and\n        // we can return the owned instance of `Rocket`.\n        //\n        // Unfortunately, the Hyper `server` future resolves as soon as it has\n        // finishes processing requests without respect for ongoing responses.\n        // That is, `server` resolves even when there are running tasks that are\n        // generating a response. So, `server` resolving implies little to\n        // nothing about the state of connections. As a result, we depend on the\n        // timing of grace + mercy + some buffer to determine when all\n        // connections should be closed, thus all tasks should be complete, thus\n        // all references to `Arc<Rocket>` should be dropped and we can get a\n        // unique reference.\n        tokio::pin!(server);\n        tokio::select! {\n            biased;\n\n            _ = shutdown => {\n                // Run shutdown fairings. We compute `sleep()` for grace periods\n                // beforehand to ensure we don't add shutdown fairing completion\n                // time, which is arbitrary, to these periods.\n                info!(\"Shutdown requested. Waiting for pending I/O...\");\n                let grace_timer = sleep(Duration::from_secs(grace));\n                let mercy_timer = sleep(Duration::from_secs(grace + mercy));\n                let shutdown_timer = sleep(Duration::from_secs(grace + mercy + 1));\n                rocket.fairings.handle_shutdown(&*rocket).await;\n\n                tokio::pin!(grace_timer, mercy_timer, shutdown_timer);\n                tokio::select! {\n                    biased;\n\n                    result = &mut server => {\n                        if let Err(e) = result {\n                            warn!(\"Server failed while shutting down: {}\", e);\n                            return Err(Error::shutdown(rocket.clone(), e));\n                        }\n\n                        if Arc::strong_count(&rocket) != 1 { grace_timer.await; }\n                        if Arc::strong_count(&rocket) != 1 { mercy_timer.await; }\n                        if Arc::strong_count(&rocket) != 1 { shutdown_timer.await; }\n                        match Arc::try_unwrap(rocket) {\n                            Ok(rocket) => {\n                                info!(\"Graceful shutdown completed successfully.\");\n                                Ok(rocket)\n                            }\n                            Err(rocket) => {\n                                warn!(\"Shutdown failed: outstanding background I/O.\");\n                                Err(Error::shutdown(rocket, None))\n                            }\n                        }\n                    }\n                    _ = &mut shutdown_timer => {\n                        warn!(\"Shutdown failed: server executing after timeouts.\");\n                        return Err(Error::shutdown(rocket.clone(), None));\n                    },\n                }\n            }\n            result = &mut server => {\n                match result {\n                    Ok(()) => {\n                        info!(\"Server shutdown nominally.\");\n                        Ok(Arc::try_unwrap(rocket).map_err(|r| Error::shutdown(r, None))?)\n                    }\n                    Err(e) => {\n                        info!(\"Server failed prior to shutdown: {}:\", e);\n                        Err(Error::shutdown(rocket.clone(), e))\n                    }\n                }\n            }\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::future::Future;\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\n\nuse futures::FutureExt;\n\nuse crate::request::{FromRequest, Outcome, Request};\nuse crate::trip_wire::TripWire;\n\n/// A request guard and future for graceful shutdown.\n///\n/// A server shutdown is manually requested by calling [`Shutdown::notify()`]\n/// or, if enabled, through [automatic triggers] like `Ctrl-C`. Rocket will stop accepting new\n/// requests, finish handling any pending requests, wait a grace period before\n/// cancelling any outstanding I/O, and return `Ok()` to the caller of\n/// [`Rocket::launch()`]. Graceful shutdown is configured via\n/// [`config::Shutdown`](crate::config::Shutdown).\n///\n/// [`Rocket::launch()`]: crate::Rocket::launch()\n/// [automatic triggers]: crate::config::Shutdown#triggers\n///\n/// # Detecting Shutdown\n///\n/// `Shutdown` is also a future that resolves when [`Shutdown::notify()`] is\n/// called. This can be used to detect shutdown in any part of the application:\n///\n/// ```rust\n/// # use rocket::*;\n/// use rocket::Shutdown;\n///\n/// #[get(\"/wait/for/shutdown\")]\n/// async fn wait_for_shutdown(shutdown: Shutdown) -> &'static str {\n///     shutdown.await;\n///     \"Somewhere, shutdown was requested.\"\n/// }\n/// ```\n///\n/// See the [`stream`](crate::response::stream#graceful-shutdown) docs for an\n/// example of detecting shutdown in an infinite responder.\n///\n/// Additionally, a completed shutdown request resolves the future returned from\n/// [`Rocket::launch()`](crate::Rocket::launch()):\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// #\n/// use rocket::Shutdown;\n///\n/// #[get(\"/shutdown\")]\n/// fn shutdown(shutdown: Shutdown) -> &'static str {\n///     shutdown.notify();\n///     \"Shutting down...\"\n/// }\n///\n/// #[rocket::main]\n/// async fn main() {\n///     let result = rocket::build()\n///         .mount(\"/\", routes![shutdown])\n///         .launch()\n///         .await;\n///\n///     // If the server shut down (by visiting `/shutdown`), `result` is `Ok`.\n///     result.expect(\"server failed unexpectedly\");\n/// }\n/// ```\n#[derive(Debug, Clone)]\n#[must_use = \"`Shutdown` does nothing unless polled or `notify`ed\"]\npub struct Shutdown(pub(crate) TripWire);\n\nimpl Shutdown {\n    /// Notify the application to shut down gracefully.\n    ///\n    /// This function returns immediately; pending requests will continue to run\n    /// until completion or expiration of the grace period, which ever comes\n    /// first, before the actual shutdown occurs. The grace period can be\n    /// configured via [`Shutdown::grace`](crate::config::Shutdown::grace).\n    ///\n    /// ```rust\n    /// # use rocket::*;\n    /// use rocket::Shutdown;\n    ///\n    /// #[get(\"/shutdown\")]\n    /// fn shutdown(shutdown: Shutdown) -> &'static str {\n    ///     shutdown.notify();\n    ///     \"Shutting down...\"\n    /// }\n    /// ```\n    #[inline]\n    pub fn notify(self) {\n        self.0.trip();\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for Shutdown {\n    type Error = std::convert::Infallible;\n\n    #[inline]\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n        Outcome::Success(request.rocket().shutdown())\n    }\n}\n\nimpl Future for Shutdown {\n    type Output = ();\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        self.0.poll_unpin(cx)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Shutdown;\n\n    #[test]\n    fn ensure_is_send_sync_clone_unpin() {\n        fn is_send_sync_clone_unpin<T: Send + Sync + Clone + Unpin>() {}\n        is_send_sync_clone_unpin::<Shutdown>();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::ops::Deref;\nuse std::any::type_name;\n\nuse ref_cast::RefCast;\nuse yansi::Paint;\n\nuse crate::{Phase, Rocket, Ignite, Sentinel};\nuse crate::request::{self, FromRequest, Request};\nuse crate::outcome::Outcome;\nuse crate::http::Status;\n\n/// Request guard to retrieve managed state.\n///\n/// A reference `&State<T>` type is a request guard which retrieves the managed\n/// state managing for some type `T`. A value for the given type must previously\n/// have been registered to be managed by Rocket via [`Rocket::manage()`]. The\n/// type being managed must be thread safe and sendable across thread\n/// boundaries as multiple handlers in multiple threads may be accessing the\n/// value at once. In other words, it must implement [`Send`] + [`Sync`] +\n/// `'static`.\n///\n/// # Example\n///\n/// Imagine you have some configuration struct of the type `MyConfig` that you'd\n/// like to initialize at start-up and later access it in several handlers. The\n/// following example does just this:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::State;\n///\n/// // In a real application, this would likely be more complex.\n/// struct MyConfig {\n///     user_val: String\n/// }\n///\n/// #[get(\"/\")]\n/// fn index(state: &State<MyConfig>) -> String {\n///     format!(\"The config value is: {}\", state.user_val)\n/// }\n///\n/// #[get(\"/raw\")]\n/// fn raw_config_value(state: &State<MyConfig>) -> &str {\n///     &state.user_val\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build()\n///         .mount(\"/\", routes![index, raw_config_value])\n///         .manage(MyConfig { user_val: \"user input\".to_string() })\n/// }\n/// ```\n///\n/// # Within Request Guards\n///\n/// Because `State` is itself a request guard, managed state can be retrieved\n/// from another request guard's implementation using either\n/// [`Request::guard()`] or [`Rocket::state()`]. In the following code example,\n/// the `Item` request guard retrieves `MyConfig` from managed state:\n///\n/// ```rust\n/// use rocket::State;\n/// use rocket::request::{self, Request, FromRequest};\n/// use rocket::outcome::IntoOutcome;\n/// use rocket::http::Status;\n///\n/// # struct MyConfig { user_val: String };\n/// struct Item<'r>(&'r str);\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for Item<'r> {\n///     type Error = ();\n///\n///     async fn from_request(request: &'r Request<'_>) -> request::Outcome<Self, ()> {\n///         // Using `State` as a request guard. Use `inner()` to get an `'r`.\n///         let outcome = request.guard::<&State<MyConfig>>().await\n///             .map(|my_config| Item(&my_config.user_val));\n///\n///         // Or alternatively, using `Rocket::state()`:\n///         let outcome = request.rocket().state::<MyConfig>()\n///             .map(|my_config| Item(&my_config.user_val))\n///             .or_forward(Status::InternalServerError);\n///\n///         outcome\n///     }\n/// }\n/// ```\n///\n/// # Testing with `State`\n///\n/// When unit testing your application, you may find it necessary to manually\n/// construct a type of `State` to pass to your functions. To do so, use the\n/// [`State::get()`] static method or the `From<&T>` implementation:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::State;\n///\n/// struct MyManagedState(usize);\n///\n/// #[get(\"/\")]\n/// fn handler(state: &State<MyManagedState>) -> String {\n///     state.0.to_string()\n/// }\n///\n/// let mut rocket = rocket::build().manage(MyManagedState(127));\n/// let state = State::get(&rocket).expect(\"managed `MyManagedState`\");\n/// assert_eq!(handler(state), \"127\");\n///\n/// let managed = MyManagedState(77);\n/// assert_eq!(handler(State::from(&managed)), \"77\");\n/// ```\n#[repr(transparent)]\n#[derive(RefCast, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct State<T: Send + Sync + 'static>(T);\n\nimpl<T: Send + Sync + 'static> State<T> {\n    /// Returns the managed state value in `rocket` for the type `T` if it is\n    /// being managed by `rocket`. Otherwise, returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::State;\n    ///\n    /// #[derive(Debug, PartialEq)]\n    /// struct Managed(usize);\n    ///\n    /// #[derive(Debug, PartialEq)]\n    /// struct Unmanaged(usize);\n    ///\n    /// let rocket = rocket::build().manage(Managed(7));\n    ///\n    /// let state: Option<&State<Managed>> = State::get(&rocket);\n    /// assert_eq!(state.map(|s| s.inner()), Some(&Managed(7)));\n    ///\n    /// let state: Option<&State<Unmanaged>> = State::get(&rocket);\n    /// assert_eq!(state, None);\n    /// ```\n    #[inline(always)]\n    pub fn get<P: Phase>(rocket: &Rocket<P>) -> Option<&State<T>> {\n        rocket.state::<T>().map(State::ref_cast)\n    }\n\n    /// This exists because `State::from()` would otherwise be nothing. But we\n    /// want `State::from(&foo)` to give us `<&State>::from(&foo)`. Here it is.\n    #[doc(hidden)]\n    #[inline(always)]\n    pub fn from(value: &T) -> &State<T> {\n        State::ref_cast(value)\n    }\n\n    /// Borrow the inner value.\n    ///\n    /// Using this method is typically unnecessary as `State` implements\n    /// [`Deref`] with a [`Deref::Target`] of `T`. This means Rocket will\n    /// automatically coerce a `State<T>` to an `&T` as required. This method\n    /// should only be used when a longer lifetime is required.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::State;\n    ///\n    /// #[derive(Clone)]\n    /// struct MyConfig {\n    ///     user_val: String\n    /// }\n    ///\n    /// fn handler1<'r>(config: &State<MyConfig>) -> String {\n    ///     let config = config.inner().clone();\n    ///     config.user_val\n    /// }\n    ///\n    /// // Use the `Deref` implementation which coerces implicitly\n    /// fn handler2(config: &State<MyConfig>) -> String {\n    ///     config.user_val.clone()\n    /// }\n    /// ```\n    #[inline(always)]\n    pub fn inner(&self) -> &T {\n        &self.0\n    }\n}\n\nimpl<'r, T: Send + Sync + 'static> From<&'r T> for &'r State<T> {\n    #[inline(always)]\n    fn from(reference: &'r T) -> Self {\n        State::ref_cast(reference)\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: Send + Sync + 'static> FromRequest<'r> for &'r State<T> {\n    type Error = ();\n\n    #[inline(always)]\n    async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, ()> {\n        match State::get(req.rocket()) {\n            Some(state) => Outcome::Success(state),\n            None => {\n                error_!(\"Attempted to retrieve unmanaged state `{}`!\", type_name::<T>());\n                Outcome::Error((Status::InternalServerError, ()))\n            }\n        }\n    }\n}\n\nimpl<T: Send + Sync + 'static> Sentinel for &State<T> {\n    fn abort(rocket: &Rocket<Ignite>) -> bool {\n        if rocket.state::<T>().is_none() {\n            let type_name = type_name::<T>();\n            error!(\"launching with unmanaged `{}` state.\", type_name.primary().bold());\n            info_!(\"Using `State` requires managing it with `.manage()`.\");\n            return true;\n        }\n\n        false\n    }\n}\n\nimpl<T: Send + Sync + fmt::Display + 'static> fmt::Display for State<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl<T: Send + Sync + 'static> Deref for State<T> {\n    type Target = T;\n\n    #[inline(always)]\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::{ops::Deref, pin::Pin, future::Future};\nuse std::task::{Context, Poll};\nuse std::sync::{Arc, atomic::{AtomicBool, Ordering}};\n\nuse tokio::sync::Notify;\n\n#[doc(hidden)]\npub struct State {\n    tripped: AtomicBool,\n    notify: Notify,\n}\n\n#[must_use = \"`TripWire` does nothing unless polled or `trip()`ed\"]\npub struct TripWire {\n    state: Arc<State>,\n    // `Notified` is `!Unpin`. Even if we could name it, we'd need to pin it.\n    event: Option<Pin<Box<dyn Future<Output = ()> + Send + Sync>>>,\n}\n\nimpl Deref for TripWire {\n    type Target = State;\n\n    fn deref(&self) -> &Self::Target {\n        &self.state\n    }\n}\n\nimpl Clone for TripWire {\n    fn clone(&self) -> Self {\n        TripWire {\n            state: self.state.clone(),\n            event: None\n        }\n    }\n}\n\nimpl fmt::Debug for TripWire {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"TripWire\")\n            .field(\"tripped\", &self.tripped)\n            .finish()\n    }\n}\n\nimpl Future for TripWire {\n    type Output = ();\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        if self.tripped.load(Ordering::Acquire) {\n            self.event = None;\n            return Poll::Ready(());\n        }\n\n        if self.event.is_none() {\n            let state = self.state.clone();\n            self.event = Some(Box::pin(async move {\n                let notified = state.notify.notified();\n                notified.await\n            }));\n        }\n\n        if let Some(ref mut event) = self.event {\n            if event.as_mut().poll(cx).is_ready() {\n                // We need to call `trip()` to avoid a race condition where:\n                //   1) many trip wires have seen !self.tripped but have not\n                //      polled for `self.event` yet, so are not subscribed\n                //   2) trip() is called, adding a permit to `event`\n                //   3) some trip wires poll `event` for the first time\n                //   4) one of those wins, returns `Ready()`\n                //   5) the rest return pending\n                //\n                // Without this `self.trip()` those will never be awoken. With\n                // the call to self.trip(), those that made it to poll() in 3)\n                // will be awoken by `notify_waiters()`. For those the didn't,\n                // one will be awoken by `notify_one()`, which will in-turn call\n                // self.trip(), awaking more until there are no more to awake.\n                self.trip();\n                self.event = None;\n                return Poll::Ready(());\n            }\n        }\n\n        Poll::Pending\n    }\n}\n\nimpl TripWire {\n    pub fn new() -> Self {\n        TripWire {\n            state: Arc::new(State {\n                tripped: AtomicBool::new(false),\n                notify: Notify::new()\n            }),\n            event: None,\n        }\n    }\n\n    pub fn trip(&self) {\n        self.tripped.store(true, Ordering::Release);\n        self.notify.notify_waiters();\n        self.notify.notify_one();\n    }\n\n    #[inline(always)]\n    pub fn tripped(&self) -> bool {\n        self.tripped.load(Ordering::Acquire)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::TripWire;\n\n    #[test]\n    fn ensure_is_send_sync_clone_unpin() {\n        fn is_send_sync_clone_unpin<T: Send + Sync + Clone + Unpin>() {}\n        is_send_sync_clone_unpin::<TripWire>();\n    }\n\n    #[tokio::test]\n    async fn simple_trip() {\n        let wire = TripWire::new();\n        wire.trip();\n        wire.await;\n    }\n\n    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n    async fn no_trip() {\n        use tokio::time::{sleep, Duration};\n        use futures::stream::{FuturesUnordered as Set, StreamExt};\n        use futures::future::{BoxFuture, FutureExt};\n\n        let wire = TripWire::new();\n        let mut futs: Set<BoxFuture<'static, bool>> = Set::new();\n        for _ in 0..10 {\n            futs.push(Box::pin(wire.clone().map(|_| false)));\n        }\n\n        let sleep = sleep(Duration::from_secs(1));\n        futs.push(Box::pin(sleep.map(|_| true)));\n        assert!(futs.next().await.unwrap());\n    }\n\n    #[tokio::test(flavor = \"multi_thread\", worker_threads = 10)]\n    async fn general_trip() {\n        let wire = TripWire::new();\n        let mut tasks = vec![];\n        for _ in 0..1000 {\n            tasks.push(tokio::spawn(wire.clone()));\n            tokio::task::yield_now().await;\n        }\n\n        wire.trip();\n        for task in tasks {\n            task.await.unwrap();\n        }\n    }\n\n    #[tokio::test(flavor = \"multi_thread\", worker_threads = 10)]\n    async fn single_stage_trip() {\n        let mut tasks = vec![];\n        for i in 0..1000 {\n            // Trip once every 100. 50 will be left \"untripped\", but should be.\n            if i % 2 == 0 {\n                let wire = TripWire::new();\n                tasks.push(tokio::spawn(wire.clone()));\n                tasks.push(tokio::spawn(async move { wire.trip() }));\n            } else {\n                let wire = TripWire::new();\n                let wire2 = wire.clone();\n                tasks.push(tokio::spawn(async move { wire.trip() }));\n                tasks.push(tokio::spawn(wire2));\n            }\n        }\n\n        for task in tasks {\n            task.await.unwrap();\n        }\n    }\n\n    #[tokio::test(flavor = \"multi_thread\", worker_threads = 10)]\n    async fn staged_trip() {\n        let wire = TripWire::new();\n        let mut tasks = vec![];\n        for i in 0..1050 {\n            let wire = wire.clone();\n            // Trip once every 100. 50 will be left \"untripped\", but should be.\n            let task = if i % 100 == 0 {\n                tokio::spawn(async move { wire.trip() })\n            } else {\n                tokio::spawn(wire)\n            };\n\n            if i % 20 == 0 {\n                tokio::task::yield_now().await;\n            }\n\n            tasks.push(task);\n        }\n\n        for task in tasks {\n            task.await.unwrap();\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::io::Cursor;\n\nuse crate::response::Response;\nuse crate::request::Request;\nuse crate::http::{Status, ContentType, uri};\nuse crate::catcher::{Handler, BoxFuture};\n\nuse yansi::Paint;\n\n/// An error catching route.\n///\n/// Catchers are routes that run when errors are produced by the application.\n/// They consist of a [`Handler`] and an optional status code to match against\n/// arising errors. Errors arise from the the following sources:\n///\n///   * A failing guard.\n///   * A failing responder.\n///   * A forwarding guard.\n///   * Routing failure.\n///\n/// Each error or forward is paired with a status code. Guards and responders\n/// indicate the status code themselves via their `Err` and `Outcome` return\n/// value. A complete routing failure is always a `404`. Rocket invokes the\n/// error handler for the catcher with an error's status code, or in the case of\n/// every route resulting in a forward, the last forwarded status code.\n///\n/// ### Error Handler Restrictions\n///\n/// Because error handlers are a last resort, they should not fail to produce a\n/// response. If an error handler _does_ fail, Rocket invokes its default `500`\n/// error catcher. Error handlers cannot forward.\n///\n/// # Routing\n///\n/// If a route fails by returning an error [`Outcome`], Rocket routes the\n/// erroring request to the highest precedence catcher among all the catchers\n/// that match. Precedence is determined by the catcher's _base_, which is\n/// provided as the first argument to [`Rocket::register()`]. Catchers with more\n/// non-empty segments have a higher precedence.\n///\n/// Rocket provides [built-in defaults](#built-in-default), but _default_\n/// catchers can also be registered. A _default_ catcher is a catcher with no\n/// explicit status code: `None`.\n///\n/// [`Outcome`]: crate::request::Outcome\n/// [`Rocket::register()`]: crate::Rocket::register()\n///\n/// # Collisions\n///\n/// Two catchers are said to _collide_ if there exists an error that matches\n/// both catchers. Colliding catchers present a routing ambiguity and are thus\n/// disallowed by Rocket. Because catchers can be constructed dynamically,\n/// collision checking is done at [`ignite`](crate::Rocket::ignite()) time,\n/// after it becomes statically impossible to register any more catchers on an\n/// instance of `Rocket`.\n///\n/// ### Built-In Default\n///\n/// Rocket's provides a built-in default catcher that can handle all errors. It\n/// produces HTML or JSON, depending on the value of the `Accept` header. As\n/// such, catchers only need to be registered if an error needs to be handled in\n/// a custom fashion. The built-in default never conflicts with any\n/// user-registered catchers.\n///\n/// # Code Generation\n///\n/// Catchers should rarely be constructed or used directly. Instead, they are\n/// typically generated via the [`catch`] attribute, as follows:\n///\n/// ```rust,no_run\n/// #[macro_use] extern crate rocket;\n///\n/// use rocket::Request;\n/// use rocket::http::Status;\n///\n/// #[catch(500)]\n/// fn internal_error() -> &'static str {\n///     \"Whoops! Looks like we messed up.\"\n/// }\n///\n/// #[catch(404)]\n/// fn not_found(req: &Request) -> String {\n///     format!(\"I couldn't find '{}'. Try something else?\", req.uri())\n/// }\n///\n/// #[catch(default)]\n/// fn default(status: Status, req: &Request) -> String {\n///     format!(\"{} ({})\", status, req.uri())\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().register(\"/\", catchers![internal_error, not_found, default])\n/// }\n/// ```\n///\n/// A function decorated with `#[catch]` may take zero, one, or two arguments.\n/// It's type signature must be one of the following, where `R:`[`Responder`]:\n///\n///   * `fn() -> R`\n///   * `fn(`[`&Request`]`) -> R`\n///   * `fn(`[`Status`]`, `[`&Request`]`) -> R`\n///\n/// See the [`catch`] documentation for full details.\n///\n/// [`catch`]: crate::catch\n/// [`Responder`]: crate::response::Responder\n/// [`&Request`]: crate::request::Request\n/// [`Status`]: crate::http::Status\n#[derive(Clone)]\npub struct Catcher {\n    /// The name of this catcher, if one was given.\n    pub name: Option<Cow<'static, str>>,\n\n    /// The mount point.\n    pub base: uri::Origin<'static>,\n\n    /// The HTTP status to match against if this route is not `default`.\n    pub code: Option<u16>,\n\n    /// The catcher's associated error handler.\n    pub handler: Box<dyn Handler>,\n}\n\nimpl Catcher {\n    /// Creates a catcher for the given `status`, or a default catcher if\n    /// `status` is `None`, using the given error handler. This should only be\n    /// used when routing manually.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// fn handle_500<'r>(_: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///     Box::pin(async move{ \"Whoops, we messed up!\".respond_to(req) })\n    /// }\n    ///\n    /// fn handle_default<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"{}: {}\", status, req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let not_found_catcher = Catcher::new(404, handle_404);\n    /// let internal_server_error_catcher = Catcher::new(500, handle_500);\n    /// let default_error_catcher = Catcher::new(None, handle_default);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if `code` is not in the HTTP status code error range `[400,\n    /// 600)`.\n    #[inline(always)]\n    pub fn new<S, H>(code: S, handler: H) -> Catcher\n        where S: Into<Option<u16>>, H: Handler\n    {\n        let code = code.into();\n        if let Some(code) = code {\n            assert!(code >= 400 && code < 600);\n        }\n\n        Catcher {\n            name: None,\n            base: uri::Origin::ROOT,\n            handler: Box::new(handler),\n            code,\n        }\n    }\n\n    /// Maps the `base` of this catcher using `mapper`, returning a new\n    /// `Catcher` with the returned base.\n    ///\n    /// `mapper` is called with the current base. The returned `String` is used\n    /// as the new base if it is a valid URI. If the returned base URI contains\n    /// a query, it is ignored. Returns an error if the base produced by\n    /// `mapper` is not a valid origin URI.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let catcher = Catcher::new(404, handle_404);\n    /// assert_eq!(catcher.base.path(), \"/\");\n    ///\n    /// let catcher = catcher.map_base(|_| format!(\"/bar\")).unwrap();\n    /// assert_eq!(catcher.base.path(), \"/bar\");\n    ///\n    /// let catcher = catcher.map_base(|base| format!(\"/foo{}\", base)).unwrap();\n    /// assert_eq!(catcher.base.path(), \"/foo/bar\");\n    ///\n    /// let catcher = catcher.map_base(|base| format!(\"/foo ? {}\", base));\n    /// assert!(catcher.is_err());\n    /// ```\n    pub fn map_base<'a, F>(\n        mut self,\n        mapper: F\n    ) -> std::result::Result<Self, uri::Error<'static>>\n        where F: FnOnce(uri::Origin<'a>) -> String\n    {\n        self.base = uri::Origin::parse_owned(mapper(self.base))?.into_normalized();\n        self.base.clear_query();\n        Ok(self)\n    }\n}\n\nimpl Default for Catcher {\n    fn default() -> Self {\n        fn handler<'r>(s: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n            Box::pin(async move { Ok(default_handler(s, req)) })\n        }\n\n        let mut catcher = Catcher::new(None, handler);\n        catcher.name = Some(\"<Rocket Catcher>\".into());\n        catcher\n    }\n}\n\n/// Information generated by the `catch` attribute during codegen.\n#[doc(hidden)]\npub struct StaticInfo {\n    /// The catcher's name, i.e, the name of the function.\n    pub name: &'static str,\n    /// The catcher's status code.\n    pub code: Option<u16>,\n    /// The catcher's handler, i.e, the annotated function.\n    pub handler: for<'r> fn(Status, &'r Request<'_>) -> BoxFuture<'r>,\n}\n\n#[doc(hidden)]\nimpl From<StaticInfo> for Catcher {\n    #[inline]\n    fn from(info: StaticInfo) -> Catcher {\n        let mut catcher = Catcher::new(info.code, info.handler);\n        catcher.name = Some(info.name.into());\n        catcher\n    }\n}\n\nimpl fmt::Display for Catcher {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(ref n) = self.name {\n            write!(f, \"{}{}{} \", \"(\".cyan(), n.primary(), \")\".cyan())?;\n        }\n\n        if self.base.path() != \"/\" {\n            write!(f, \"{} \", self.base.path().green())?;\n        }\n\n        match self.code {\n            Some(code) => write!(f, \"{}\", code.blue()),\n            None => write!(f, \"{}\", \"default\".blue()),\n        }\n    }\n}\n\nimpl fmt::Debug for Catcher {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Catcher\")\n            .field(\"name\", &self.name)\n            .field(\"base\", &self.base)\n            .field(\"code\", &self.code)\n            .finish()\n    }\n}\n\nmacro_rules! html_error_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"color-scheme\" content=\"light dark\">\n    <title>\"#, $code, \" \", $reason, r#\"</title>\n</head>\n<body align=\"center\">\n    <div role=\"main\" align=\"center\">\n        <h1>\"#, $code, \": \", $reason, r#\"</h1>\n        <p>\"#, $description, r#\"</p>\n        <hr />\n    </div>\n    <div role=\"contentinfo\" align=\"center\">\n        <small>Rocket</small>\n    </div>\n</body>\n</html>\"#\n        )\n    )\n}\n\nmacro_rules! json_error_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"{\n  \"error\": {\n    \"code\": \"#, $code, r#\",\n    \"reason\": \"\"#, $reason, r#\"\",\n    \"description\": \"\"#, $description, r#\"\"\n  }\n}\"#\n        )\n    )\n}\n\n// This is unfortunate, but the `{`, `}` above make it unusable for `format!`.\nmacro_rules! json_error_fmt_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"{{\n  \"error\": {{\n    \"code\": \"#, $code, r#\",\n    \"reason\": \"\"#, $reason, r#\"\",\n    \"description\": \"\"#, $description, r#\"\"\n  }}\n}}\"#\n        )\n    )\n}\n\nmacro_rules! default_handler_fn {\n    ($($code:expr, $reason:expr, $description:expr),+) => (\n        use std::borrow::Cow;\n\n        pub(crate) fn default_handler<'r>(\n            status: Status,\n            req: &'r Request<'_>\n        ) -> Response<'r> {\n            let preferred = req.accept().map(|a| a.preferred());\n            let (mime, text) = if preferred.map_or(false, |a| a.is_json()) {\n                let json: Cow<'_, str> = match status.code {\n                    $($code => json_error_template!($code, $reason, $description).into(),)*\n                    code => format!(json_error_fmt_template!(\"{}\", \"Unknown Error\",\n                            \"An unknown error has occurred.\"), code).into()\n                };\n\n                (ContentType::JSON, json)\n            } else {\n                let html: Cow<'_, str> = match status.code {\n                    $($code => html_error_template!($code, $reason, $description).into(),)*\n                    code => format!(html_error_template!(\"{}\", \"Unknown Error\",\n                            \"An unknown error has occurred.\"), code, code).into(),\n                };\n\n                (ContentType::HTML, html)\n            };\n\n            let mut r = Response::build().status(status).header(mime).finalize();\n            match text {\n                Cow::Owned(v) => r.set_sized_body(v.len(), Cursor::new(v)),\n                Cow::Borrowed(v) => r.set_sized_body(v.len(), Cursor::new(v)),\n            };\n\n            r\n        }\n    )\n}\n\ndefault_handler_fn! {\n    400, \"Bad Request\", \"The request could not be understood by the server due \\\n        to malformed syntax.\",\n    401, \"Unauthorized\", \"The request requires user authentication.\",\n    402, \"Payment Required\", \"The request could not be processed due to lack of payment.\",\n    403, \"Forbidden\", \"The server refused to authorize the request.\",\n    404, \"Not Found\", \"The requested resource could not be found.\",\n    405, \"Method Not Allowed\", \"The request method is not supported for the requested resource.\",\n    406, \"Not Acceptable\", \"The requested resource is capable of generating only content not \\\n        acceptable according to the Accept headers sent in the request.\",\n    407, \"Proxy Authentication Required\", \"Authentication with the proxy is required.\",\n    408, \"Request Timeout\", \"The server timed out waiting for the request.\",\n    409, \"Conflict\", \"The request could not be processed because of a conflict in the request.\",\n    410, \"Gone\", \"The resource requested is no longer available and will not be available again.\",\n    411, \"Length Required\", \"The request did not specify the length of its content, which is \\\n        required by the requested resource.\",\n    412, \"Precondition Failed\", \"The server does not meet one of the \\\n        preconditions specified in the request.\",\n    413, \"Payload Too Large\", \"The request is larger than the server is \\\n        willing or able to process.\",\n    414, \"URI Too Long\", \"The URI provided was too long for the server to process.\",\n    415, \"Unsupported Media Type\", \"The request entity has a media type which \\\n        the server or resource does not support.\",\n    416, \"Range Not Satisfiable\", \"The portion of the requested file cannot be \\\n        supplied by the server.\",\n    417, \"Expectation Failed\", \"The server cannot meet the requirements of the \\\n        Expect request-header field.\",\n    418, \"I'm a teapot\", \"I was requested to brew coffee, and I am a teapot.\",\n    421, \"Misdirected Request\", \"The server cannot produce a response for this request.\",\n    422, \"Unprocessable Entity\", \"The request was well-formed but was unable to \\\n        be followed due to semantic errors.\",\n    426, \"Upgrade Required\", \"Switching to the protocol in the Upgrade header field is required.\",\n    428, \"Precondition Required\", \"The server requires the request to be conditional.\",\n    429, \"Too Many Requests\", \"Too many requests have been received recently.\",\n    431, \"Request Header Fields Too Large\", \"The server is unwilling to process \\\n        the request because either an individual header field, or all the header \\\n        fields collectively, are too large.\",\n    451, \"Unavailable For Legal Reasons\", \"The requested resource is unavailable \\\n        due to a legal demand to deny access to this resource.\",\n    500, \"Internal Server Error\", \"The server encountered an internal error while \\\n        processing this request.\",\n    501, \"Not Implemented\", \"The server either does not recognize the request \\\n        method, or it lacks the ability to fulfill the request.\",\n    503, \"Service Unavailable\", \"The server is currently unavailable.\",\n    504, \"Gateway Timeout\", \"The server did not receive a timely response from an upstream server.\",\n    510, \"Not Extended\", \"Further extensions to the request are required for \\\n        the server to fulfill it.\"\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::{Request, Response};\nuse crate::http::Status;\n\n/// Type alias for the return type of a [`Catcher`](crate::Catcher)'s\n/// [`Handler::handle()`].\npub type Result<'r> = std::result::Result<Response<'r>, crate::http::Status>;\n\n/// Type alias for the return type of a _raw_ [`Catcher`](crate::Catcher)'s\n/// [`Handler`].\npub type BoxFuture<'r, T = Result<'r>> = futures::future::BoxFuture<'r, T>;\n\n/// Trait implemented by [`Catcher`](crate::Catcher) error handlers.\n///\n/// This trait is exactly like a [`Route`](crate::Route)'s\n/// [`Handler`](crate::route::Handler) except it handles errors instead of\n/// requests. Thus, the documentation for\n/// [`route::Handler`](crate::route::Handler) applies to this trait as well. We\n/// defer to it for full details.\n///\n/// ## Async Trait\n///\n/// This is an _async_ trait. Implementations must be decorated\n/// [`#[rocket::async_trait]`](crate::async_trait).\n///\n/// # Example\n///\n/// Say you'd like to write a handler that changes its functionality based on a\n/// `Kind` enum value that the user provides. Such a handler might be written\n/// and used as follows:\n///\n/// ```rust,no_run\n/// use rocket::{Request, Catcher, catcher};\n/// use rocket::response::{Response, Responder};\n/// use rocket::http::Status;\n///\n/// #[derive(Copy, Clone)]\n/// enum Kind {\n///     Simple,\n///     Intermediate,\n///     Complex,\n/// }\n///\n/// #[derive(Clone)]\n/// struct CustomHandler(Kind);\n///\n/// #[rocket::async_trait]\n/// impl catcher::Handler for CustomHandler {\n///     async fn handle<'r>(&self, status: Status, req: &'r Request<'_>) -> catcher::Result<'r> {\n///         let inner = match self.0 {\n///             Kind::Simple => \"simple\".respond_to(req)?,\n///             Kind::Intermediate => \"intermediate\".respond_to(req)?,\n///             Kind::Complex => \"complex\".respond_to(req)?,\n///         };\n///\n///         Response::build_from(inner).status(status).ok()\n///     }\n/// }\n///\n/// impl CustomHandler {\n///     /// Returns a `default` catcher that uses `CustomHandler`.\n///     fn default(kind: Kind) -> Vec<Catcher> {\n///         vec![Catcher::new(None, CustomHandler(kind))]\n///     }\n///\n///     /// Returns a catcher for code `status` that uses `CustomHandler`.\n///     fn catch(status: Status, kind: Kind) -> Vec<Catcher> {\n///         vec![Catcher::new(status.code, CustomHandler(kind))]\n///     }\n/// }\n///\n/// #[rocket::launch]\n/// fn rocket() -> _ {\n///     rocket::build()\n///         // to handle only `404`\n///         .register(\"/\", CustomHandler::catch(Status::NotFound, Kind::Simple))\n///         // or to register as the default\n///         .register(\"/\", CustomHandler::default(Kind::Simple))\n/// }\n/// ```\n///\n/// Note the following:\n///\n///   1. `CustomHandler` implements `Clone`. This is required so that\n///      `CustomHandler` implements `Cloneable` automatically. The `Cloneable`\n///      trait serves no other purpose but to ensure that every `Handler`\n///      can be cloned, allowing `Catcher`s to be cloned.\n///   2. `CustomHandler`'s methods return `Vec<Route>`, allowing for use\n///      directly as the parameter to `rocket.register(\"/\", )`.\n///   3. Unlike static-function-based handlers, this custom handler can make use\n///      of internal state.\n#[crate::async_trait]\npub trait Handler: Cloneable + Send + Sync + 'static {\n    /// Called by Rocket when an error with `status` for a given `Request`\n    /// should be handled by this handler.\n    ///\n    /// Error handlers _should not_ fail and thus _should_ always return `Ok`.\n    /// Nevertheless, failure is allowed, both for convenience and necessity. If\n    /// an error handler fails, Rocket's default `500` catcher is invoked. If it\n    /// succeeds, the returned `Response` is used to respond to the client.\n    async fn handle<'r>(&self, status: Status, req: &'r Request<'_>) -> Result<'r>;\n}\n\n// We write this manually to avoid double-boxing.\nimpl<F: Clone + Sync + Send + 'static> Handler for F\n    where for<'x> F: Fn(Status, &'x Request<'_>) -> BoxFuture<'x>,\n{\n    fn handle<'r, 'life0, 'life1, 'async_trait>(\n        &'life0 self,\n        status: Status,\n        req: &'r Request<'life1>,\n    ) -> BoxFuture<'r>\n        where 'r: 'async_trait,\n              'life0: 'async_trait,\n              'life1: 'async_trait,\n              Self: 'async_trait,\n    {\n        self(status, req)\n    }\n}\n\n#[cfg(test)]\npub fn dummy_handler<'r>(_: Status, _: &'r Request<'_>) -> BoxFuture<'r> {\n   Box::pin(async move { Ok(Response::new()) })\n}\n\nmod private {\n    pub trait Sealed {}\n    impl<T: super::Handler + Clone> Sealed for T {}\n}\n\n/// Helper trait to make a [`Catcher`](crate::Catcher)'s `Box<dyn Handler>`\n/// `Clone`.\n///\n/// This trait cannot be implemented directly. Instead, implement `Clone` and\n/// [`Handler`]; all types that implement `Clone` and `Handler` automatically\n/// implement `Cloneable`.\npub trait Cloneable: private::Sealed {\n    #[doc(hidden)]\n    fn clone_handler(&self) -> Box<dyn Handler>;\n}\n\nimpl<T: Handler + Clone> Cloneable for T {\n    fn clone_handler(&self) -> Box<dyn Handler> {\n        Box::new(self.clone())\n    }\n}\n\nimpl Clone for Box<dyn Handler> {\n    fn clone(&self) -> Box<dyn Handler> {\n        self.clone_handler()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types and traits for error catchers and their handlers and return types.\n\nmod catcher;\nmod handler;\n\npub use catcher::*;\npub use handler::*;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::net::{IpAddr, Ipv4Addr};\n\nuse figment::{Figment, Profile, Provider, Metadata, error::Result};\nuse figment::providers::{Serialized, Env, Toml, Format};\nuse figment::value::{Map, Dict, magic::RelativePathBuf};\nuse serde::{Deserialize, Serialize};\nuse yansi::{Paint, Style, Color::Primary};\n\nuse crate::log::PaintExt;\nuse crate::config::{LogLevel, Shutdown, Ident};\nuse crate::request::{self, Request, FromRequest};\nuse crate::http::uncased::Uncased;\nuse crate::data::Limits;\n\n#[cfg(feature = \"tls\")]\nuse crate::config::TlsConfig;\n\n#[cfg(feature = \"secrets\")]\nuse crate::config::SecretKey;\n\n/// Rocket server configuration.\n///\n/// See the [module level docs](crate::config) as well as the [configuration\n/// guide] for further details.\n///\n/// [configuration guide]: https://rocket.rs/v0.5/guide/configuration/\n///\n/// # Defaults\n///\n/// All configuration values have a default, documented in the [fields](#fields)\n/// section below. [`Config::debug_default()`] returns the default values for\n/// the debug profile while [`Config::release_default()`] the default values for\n/// the release profile. The [`Config::default()`] method automatically selects\n/// the appropriate of the two based on the selected profile. With the exception\n/// of `log_level`, which is `normal` in `debug` and `critical` in `release`,\n/// and `secret_key`, which is regenerated from a random value if not set in\n/// \"debug\" mode only, all default values are identical in all profiles.\n///\n/// # Provider Details\n///\n/// `Config` is a Figment [`Provider`] with the following characteristics:\n///\n///   * **Profile**\n///\n///     The profile is set to the value of the `profile` field.\n///\n///   * **Metadata**\n///\n///     This provider is named `Rocket Config`. It does not specify a\n///     [`Source`](figment::Source) and uses default interpolation.\n///\n///   * **Data**\n///\n///     The data emitted by this provider are the keys and values corresponding\n///     to the fields and values of the structure. The dictionary is emitted to\n///     the \"default\" meta-profile.\n///\n/// Note that these behaviors differ from those of [`Config::figment()`].\n#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]\npub struct Config {\n    /// The selected profile. **(default: _debug_ `debug` / _release_ `release`)**\n    ///\n    /// _**Note:** This field is never serialized nor deserialized. When a\n    /// `Config` is merged into a `Figment` as a `Provider`, this profile is\n    /// selected on the `Figment`. When a `Config` is extracted, this field is\n    /// set to the extracting Figment's selected `Profile`._\n    #[serde(skip)]\n    pub profile: Profile,\n    /// IP address to serve on. **(default: `127.0.0.1`)**\n    pub address: IpAddr,\n    /// Port to serve on. **(default: `8000`)**\n    pub port: u16,\n    /// Number of threads to use for executing futures. **(default: `num_cores`)**\n    ///\n    /// _**Note:** Rocket only reads this value from sources in the [default\n    /// provider](Config::figment())._\n    pub workers: usize,\n    /// Limit on threads to start for blocking tasks. **(default: `512`)**\n    pub max_blocking: usize,\n    /// How, if at all, to identify the server via the `Server` header.\n    /// **(default: `\"Rocket\"`)**\n    pub ident: Ident,\n    /// The name of a header, whose value is typically set by an intermediary\n    /// server or proxy, which contains the real IP address of the connecting\n    /// client. Used internally and by [`Request::client_ip()`] and\n    /// [`Request::real_ip()`].\n    ///\n    /// To disable using any header for this purpose, set this value to `false`.\n    /// Deserialization semantics are identical to those of [`Ident`] except\n    /// that the value must syntactically be a valid HTTP header name.\n    ///\n    /// **(default: `\"X-Real-IP\"`)**\n    #[serde(deserialize_with = \"crate::config::ip_header::deserialize\")]\n    pub ip_header: Option<Uncased<'static>>,\n    /// Streaming read size limits. **(default: [`Limits::default()`])**\n    pub limits: Limits,\n    /// Directory to store temporary files in. **(default:\n    /// [`std::env::temp_dir()`])**\n    #[serde(serialize_with = \"RelativePathBuf::serialize_relative\")]\n    pub temp_dir: RelativePathBuf,\n    /// Keep-alive timeout in seconds; disabled when `0`. **(default: `5`)**\n    pub keep_alive: u32,\n    /// The TLS configuration, if any. **(default: `None`)**\n    #[cfg(feature = \"tls\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"tls\")))]\n    pub tls: Option<TlsConfig>,\n    /// The secret key for signing and encrypting. **(default: `0`)**\n    ///\n    /// _**Note:** This field _always_ serializes as a 256-bit array of `0`s to\n    /// aid in preventing leakage of the secret key._\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    #[serde(serialize_with = \"SecretKey::serialize_zero\")]\n    pub secret_key: SecretKey,\n    /// Graceful shutdown configuration. **(default: [`Shutdown::default()`])**\n    pub shutdown: Shutdown,\n    /// Max level to log. **(default: _debug_ `normal` / _release_ `critical`)**\n    pub log_level: LogLevel,\n    /// Whether to use colors and emoji when logging. **(default: `true`)**\n    #[serde(deserialize_with = \"figment::util::bool_from_str_or_int\")]\n    pub cli_colors: bool,\n    /// PRIVATE: This structure may grow (but never change otherwise) in a\n    /// non-breaking release. As such, constructing this structure should\n    /// _always_ be done using a public constructor or update syntax:\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    ///\n    /// let config = Config {\n    ///     port: 1024,\n    ///     keep_alive: 10,\n    ///     ..Default::default()\n    /// };\n    /// ```\n    #[doc(hidden)]\n    #[serde(skip)]\n    pub __non_exhaustive: (),\n}\n\nimpl Default for Config {\n    /// Returns the default configuration based on the Rust compilation profile.\n    /// This is [`Config::debug_default()`] in `debug` and\n    /// [`Config::release_default()`] in `release`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    ///\n    /// let config = Config::default();\n    /// ```\n    fn default() -> Config {\n        #[cfg(debug_assertions)] { Config::debug_default() }\n        #[cfg(not(debug_assertions))] { Config::release_default() }\n    }\n}\n\nimpl Config {\n    const DEPRECATED_KEYS: &'static [(&'static str, Option<&'static str>)] = &[\n        (\"env\", Some(Self::PROFILE)), (\"log\", Some(Self::LOG_LEVEL)),\n        (\"read_timeout\", None), (\"write_timeout\", None),\n    ];\n\n    const DEPRECATED_PROFILES: &'static [(&'static str, Option<&'static str>)] = &[\n        (\"dev\", Some(\"debug\")), (\"prod\", Some(\"release\")), (\"stag\", None)\n    ];\n\n    /// Returns the default configuration for the `debug` profile, _irrespective\n    /// of the Rust compilation profile_ and `ROCKET_PROFILE`.\n    ///\n    /// This may differ from the configuration used by default,\n    /// [`Config::default()`], which is selected based on the Rust compilation\n    /// profile. See [defaults](#defaults) and [provider\n    /// details](#provider-details) for specifics.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    ///\n    /// let config = Config::debug_default();\n    /// ```\n    pub fn debug_default() -> Config {\n        Config {\n            profile: Self::DEBUG_PROFILE,\n            address: Ipv4Addr::new(127, 0, 0, 1).into(),\n            port: 8000,\n            workers: num_cpus::get(),\n            max_blocking: 512,\n            ident: Ident::default(),\n            ip_header: Some(Uncased::from_borrowed(\"X-Real-IP\")),\n            limits: Limits::default(),\n            temp_dir: std::env::temp_dir().into(),\n            keep_alive: 5,\n            #[cfg(feature = \"tls\")]\n            tls: None,\n            #[cfg(feature = \"secrets\")]\n            secret_key: SecretKey::zero(),\n            shutdown: Shutdown::default(),\n            log_level: LogLevel::Normal,\n            cli_colors: true,\n            __non_exhaustive: (),\n        }\n    }\n\n    /// Returns the default configuration for the `release` profile,\n    /// _irrespective of the Rust compilation profile_ and `ROCKET_PROFILE`.\n    ///\n    /// This may differ from the configuration used by default,\n    /// [`Config::default()`], which is selected based on the Rust compilation\n    /// profile. See [defaults](#defaults) and [provider\n    /// details](#provider-details) for specifics.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    ///\n    /// let config = Config::release_default();\n    /// ```\n    pub fn release_default() -> Config {\n        Config {\n            profile: Self::RELEASE_PROFILE,\n            log_level: LogLevel::Critical,\n            ..Config::debug_default()\n        }\n    }\n\n    /// Returns the default provider figment used by [`rocket::build()`].\n    ///\n    /// The default figment reads from the following sources, in ascending\n    /// priority order:\n    ///\n    ///   1. [`Config::default()`] (see [defaults](#defaults))\n    ///   2. `Rocket.toml` _or_ filename in `ROCKET_CONFIG` environment variable\n    ///   3. `ROCKET_` prefixed environment variables\n    ///\n    /// The profile selected is the value set in the `ROCKET_PROFILE`\n    /// environment variable. If it is not set, it defaults to `debug` when\n    /// compiled in debug mode and `release` when compiled in release mode.\n    ///\n    /// [`rocket::build()`]: crate::build()\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    /// use serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct MyConfig {\n    ///     app_key: String,\n    /// }\n    ///\n    /// let my_config = Config::figment().extract::<MyConfig>();\n    /// ```\n    pub fn figment() -> Figment {\n        Figment::from(Config::default())\n            .merge(Toml::file(Env::var_or(\"ROCKET_CONFIG\", \"Rocket.toml\")).nested())\n            .merge(Env::prefixed(\"ROCKET_\").ignore(&[\"PROFILE\"]).global())\n            .select(Profile::from_env_or(\"ROCKET_PROFILE\", Self::DEFAULT_PROFILE))\n    }\n\n    /// Attempts to extract a `Config` from `provider`, returning the result.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    /// use rocket::figment::providers::{Toml, Format, Env};\n    ///\n    /// // Use Rocket's default `Figment`, but allow values from `MyApp.toml`\n    /// // and `MY_APP_` prefixed environment variables to supersede its values.\n    /// let figment = Config::figment()\n    ///     .merge((\"some-thing\", 123))\n    ///     .merge(Env::prefixed(\"CONFIG_\"));\n    ///\n    /// let config = Config::try_from(figment);\n    /// ```\n    pub fn try_from<T: Provider>(provider: T) -> Result<Self> {\n        let figment = Figment::from(provider);\n        let mut config = figment.extract::<Self>()?;\n        config.profile = figment.profile().clone();\n        Ok(config)\n    }\n\n    /// Extract a `Config` from `provider`, panicking if extraction fails.\n    ///\n    /// # Panics\n    ///\n    /// If extraction fails, prints an error message indicating the error and\n    /// panics. For a version that doesn't panic, use [`Config::try_from()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    /// use rocket::figment::providers::{Toml, Format, Env};\n    ///\n    /// // Use Rocket's default `Figment`, but allow values from `MyApp.toml`\n    /// // and `MY_APP_` prefixed environment variables to supersede its values.\n    /// let figment = Config::figment()\n    ///     .merge(Toml::file(\"MyApp.toml\").nested())\n    ///     .merge(Env::prefixed(\"MY_APP_\"));\n    ///\n    /// let config = Config::from(figment);\n    /// ```\n    pub fn from<T: Provider>(provider: T) -> Self {\n        Self::try_from(provider).unwrap_or_else(bail_with_config_error)\n    }\n\n    /// Returns `true` if TLS is enabled.\n    ///\n    /// TLS is enabled when the `tls` feature is enabled and TLS has been\n    /// configured with at least one ciphersuite. Note that without changing\n    /// defaults, all supported ciphersuites are enabled in the recommended\n    /// configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// let config = rocket::Config::default();\n    /// if config.tls_enabled() {\n    ///     println!(\"TLS is enabled!\");\n    /// } else {\n    ///     println!(\"TLS is disabled.\");\n    /// }\n    /// ```\n    pub fn tls_enabled(&self) -> bool {\n        #[cfg(feature = \"tls\")] {\n            self.tls.as_ref().map_or(false, |tls| !tls.ciphers.is_empty())\n        }\n\n        #[cfg(not(feature = \"tls\"))] { false }\n    }\n\n    /// Returns `true` if mTLS is enabled.\n    ///\n    /// mTLS is enabled when TLS is enabled ([`Config::tls_enabled()`]) _and_\n    /// the `mtls` feature is enabled _and_ mTLS has been configured with a CA\n    /// certificate chain.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// let config = rocket::Config::default();\n    /// if config.mtls_enabled() {\n    ///     println!(\"mTLS is enabled!\");\n    /// } else {\n    ///     println!(\"mTLS is disabled.\");\n    /// }\n    /// ```\n    pub fn mtls_enabled(&self) -> bool {\n        if !self.tls_enabled() {\n            return false;\n        }\n\n        #[cfg(feature = \"mtls\")] {\n            self.tls.as_ref().map_or(false, |tls| tls.mutual.is_some())\n        }\n\n        #[cfg(not(feature = \"mtls\"))] { false }\n    }\n\n    #[cfg(feature = \"secrets\")]\n    pub(crate) fn known_secret_key_used(&self) -> bool {\n        const KNOWN_SECRET_KEYS: &'static [&'static str] = &[\n            \"hPRYyVRiMyxpw5sBB1XeCMN1kFsDCqKvBi2QJxBVHQk=\"\n        ];\n\n        KNOWN_SECRET_KEYS.iter().any(|&key_str| {\n            let value = figment::value::Value::from(key_str);\n            self.secret_key == value.deserialize().expect(\"known key is valid\")\n        })\n    }\n\n    #[inline]\n    pub(crate) fn trace_print(&self, figment: &Figment) {\n        if self.log_level != LogLevel::Debug {\n            return;\n        }\n\n        trace!(\"-- configuration trace information --\");\n        for param in Self::PARAMETERS {\n            if let Some(meta) = figment.find_metadata(param) {\n                let (param, name) = (param.blue(), meta.name.primary());\n                if let Some(ref source) = meta.source {\n                    trace_!(\"{:?} parameter source: {} ({})\", param, name, source);\n                } else {\n                    trace_!(\"{:?} parameter source: {}\", param, name);\n                }\n            }\n        }\n    }\n\n    pub(crate) fn pretty_print(&self, figment: &Figment) {\n        static VAL: Style = Primary.bold();\n\n        self.trace_print(figment);\n        launch_meta!(\"{}Configured for {}.\", \" \".emoji(), self.profile.underline());\n        launch_meta_!(\"address: {}\", self.address.paint(VAL));\n        launch_meta_!(\"port: {}\", self.port.paint(VAL));\n        launch_meta_!(\"workers: {}\", self.workers.paint(VAL));\n        launch_meta_!(\"max blocking threads: {}\", self.max_blocking.paint(VAL));\n        launch_meta_!(\"ident: {}\", self.ident.paint(VAL));\n\n        match self.ip_header {\n            Some(ref name) => launch_meta_!(\"IP header: {}\", name.paint(VAL)),\n            None => launch_meta_!(\"IP header: {}\", \"disabled\".paint(VAL))\n        }\n\n        launch_meta_!(\"limits: {}\", (&self.limits).paint(VAL));\n        launch_meta_!(\"temp dir: {}\", self.temp_dir.relative().display().paint(VAL));\n        launch_meta_!(\"http/2: {}\", (cfg!(feature = \"http2\").paint(VAL)));\n\n        match self.keep_alive {\n            0 => launch_meta_!(\"keep-alive: {}\", \"disabled\".paint(VAL)),\n            ka => launch_meta_!(\"keep-alive: {}{}\", ka.paint(VAL), \"s\".paint(VAL)),\n        }\n\n        match (self.tls_enabled(), self.mtls_enabled()) {\n            (true, true) => launch_meta_!(\"tls: {}\", \"enabled w/mtls\".paint(VAL)),\n            (true, false) => launch_meta_!(\"tls: {} w/o mtls\", \"enabled\".paint(VAL)),\n            (false, _) => launch_meta_!(\"tls: {}\", \"disabled\".paint(VAL)),\n        }\n\n        launch_meta_!(\"shutdown: {}\", self.shutdown.paint(VAL));\n        launch_meta_!(\"log level: {}\", self.log_level.paint(VAL));\n        launch_meta_!(\"cli colors: {}\", self.cli_colors.paint(VAL));\n\n        // Check for now deprecated config values.\n        for (key, replacement) in Self::DEPRECATED_KEYS {\n            if let Some(md) = figment.find_metadata(key) {\n                warn!(\"found value for deprecated config key `{}`\", key.paint(VAL));\n                if let Some(ref source) = md.source {\n                    launch_meta_!(\"in {} {}\", source.paint(VAL), md.name);\n                }\n\n                if let Some(new_key) = replacement {\n                    launch_meta_!(\"key has been by replaced by `{}`\", new_key.paint(VAL));\n                } else {\n                    launch_meta_!(\"key has no special meaning\");\n                }\n            }\n        }\n\n        // Check for now removed config values.\n        for (prefix, replacement) in Self::DEPRECATED_PROFILES {\n            if let Some(profile) = figment.profiles().find(|p| p.starts_with(prefix)) {\n                warn!(\"found set deprecated profile `{}`\", profile.paint(VAL));\n\n                if let Some(new_profile) = replacement {\n                    launch_meta_!(\"profile was replaced by `{}`\", new_profile.paint(VAL));\n                } else {\n                    launch_meta_!(\"profile `{}` has no special meaning\", profile);\n                }\n            }\n        }\n\n        #[cfg(feature = \"secrets\")] {\n            launch_meta_!(\"secret key: {}\", self.secret_key.paint(VAL));\n            if !self.secret_key.is_provided() {\n                warn!(\"secrets enabled without a stable `secret_key`\");\n                launch_meta_!(\"disable `secrets` feature or configure a `secret_key`\");\n                launch_meta_!(\"this becomes an {} in non-debug profiles\", \"error\".red());\n            }\n        }\n    }\n}\n\n/// Associated constants for default profiles.\nimpl Config {\n    /// The default debug profile: `debug`.\n    pub const DEBUG_PROFILE: Profile = Profile::const_new(\"debug\");\n\n    /// The default release profile: `release`.\n    pub const RELEASE_PROFILE: Profile = Profile::const_new(\"release\");\n\n    /// The default profile: \"debug\" on `debug`, \"release\" on `release`.\n    #[cfg(debug_assertions)]\n    pub const DEFAULT_PROFILE: Profile = Self::DEBUG_PROFILE;\n\n    /// The default profile: \"debug\" on `debug`, \"release\" on `release`.\n    #[cfg(not(debug_assertions))]\n    pub const DEFAULT_PROFILE: Profile = Self::RELEASE_PROFILE;\n}\n\n/// Associated constants for stringy versions of configuration parameters.\nimpl Config {\n    /// The stringy parameter name for setting/extracting [`Config::profile`].\n    ///\n    /// This isn't `pub` because setting it directly does nothing.\n    const PROFILE: &'static str = \"profile\";\n\n    /// The stringy parameter name for setting/extracting [`Config::address`].\n    pub const ADDRESS: &'static str = \"address\";\n\n    /// The stringy parameter name for setting/extracting [`Config::port`].\n    pub const PORT: &'static str = \"port\";\n\n    /// The stringy parameter name for setting/extracting [`Config::workers`].\n    pub const WORKERS: &'static str = \"workers\";\n\n    /// The stringy parameter name for setting/extracting [`Config::max_blocking`].\n    pub const MAX_BLOCKING: &'static str = \"max_blocking\";\n\n    /// The stringy parameter name for setting/extracting [`Config::keep_alive`].\n    pub const KEEP_ALIVE: &'static str = \"keep_alive\";\n\n    /// The stringy parameter name for setting/extracting [`Config::ident`].\n    pub const IDENT: &'static str = \"ident\";\n\n    /// The stringy parameter name for setting/extracting [`Config::ip_header`].\n    pub const IP_HEADER: &'static str = \"ip_header\";\n\n    /// The stringy parameter name for setting/extracting [`Config::limits`].\n    pub const LIMITS: &'static str = \"limits\";\n\n    /// The stringy parameter name for setting/extracting [`Config::tls`].\n    pub const TLS: &'static str = \"tls\";\n\n    /// The stringy parameter name for setting/extracting [`Config::secret_key`].\n    pub const SECRET_KEY: &'static str = \"secret_key\";\n\n    /// The stringy parameter name for setting/extracting [`Config::temp_dir`].\n    pub const TEMP_DIR: &'static str = \"temp_dir\";\n\n    /// The stringy parameter name for setting/extracting [`Config::log_level`].\n    pub const LOG_LEVEL: &'static str = \"log_level\";\n\n    /// The stringy parameter name for setting/extracting [`Config::shutdown`].\n    pub const SHUTDOWN: &'static str = \"shutdown\";\n\n    /// The stringy parameter name for setting/extracting [`Config::cli_colors`].\n    pub const CLI_COLORS: &'static str = \"cli_colors\";\n\n    /// An array of all of the stringy parameter names.\n    pub const PARAMETERS: &'static [&'static str] = &[\n        Self::ADDRESS, Self::PORT, Self::WORKERS, Self::MAX_BLOCKING,\n        Self::KEEP_ALIVE, Self::IDENT, Self::IP_HEADER, Self::LIMITS, Self::TLS,\n        Self::SECRET_KEY, Self::TEMP_DIR, Self::LOG_LEVEL, Self::SHUTDOWN,\n        Self::CLI_COLORS,\n    ];\n}\n\nimpl Provider for Config {\n    #[track_caller]\n    fn metadata(&self) -> Metadata {\n        if self == &Config::default() {\n            Metadata::named(\"rocket::Config::default()\")\n        } else {\n            Metadata::named(\"rocket::Config\")\n        }\n    }\n\n    #[track_caller]\n    fn data(&self) -> Result<Map<Profile, Dict>> {\n        #[allow(unused_mut)]\n        let mut map: Map<Profile, Dict> = Serialized::defaults(self).data()?;\n\n        // We need to special-case `secret_key` since its serializer zeroes.\n        #[cfg(feature = \"secrets\")]\n        if !self.secret_key.is_zero() {\n            if let Some(map) = map.get_mut(&Profile::Default) {\n                map.insert(\"secret_key\".into(), self.secret_key.key.master().into());\n            }\n        }\n\n        Ok(map)\n    }\n\n    fn profile(&self) -> Option<Profile> {\n        Some(self.profile.clone())\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Config {\n    type Error = std::convert::Infallible;\n\n    async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n        request::Outcome::Success(req.rocket().config())\n    }\n}\n\n#[doc(hidden)]\npub fn bail_with_config_error<T>(error: figment::Error) -> T {\n    pretty_print_error(error);\n    panic!(\"aborting due to configuration error(s)\")\n}\n\n#[doc(hidden)]\npub fn pretty_print_error(error: figment::Error) {\n    use figment::error::{Kind, OneOf};\n\n    crate::log::init_default();\n    error!(\"Failed to extract valid configuration.\");\n    for e in error {\n        fn w<T>(v: T) -> yansi::Painted<T> { Paint::new(v).primary() }\n\n        match e.kind {\n            Kind::Message(msg) => error_!(\"{}\", msg),\n            Kind::InvalidType(v, exp) => {\n                error_!(\"invalid type: found {}, expected {}\", w(v), w(exp));\n            }\n            Kind::InvalidValue(v, exp) => {\n                error_!(\"invalid value {}, expected {}\", w(v), w(exp));\n            },\n            Kind::InvalidLength(v, exp) => {\n                error_!(\"invalid length {}, expected {}\", w(v), w(exp))\n            },\n            Kind::UnknownVariant(v, exp) => {\n                error_!(\"unknown variant: found `{}`, expected `{}`\", w(v), w(OneOf(exp)))\n            }\n            Kind::UnknownField(v, exp) => {\n                error_!(\"unknown field: found `{}`, expected `{}`\", w(v), w(OneOf(exp)))\n            }\n            Kind::MissingField(v) => {\n                error_!(\"missing field `{}`\", w(v))\n            }\n            Kind::DuplicateField(v) => {\n                error_!(\"duplicate field `{}`\", w(v))\n            }\n            Kind::ISizeOutOfRange(v) => {\n                error_!(\"signed integer `{}` is out of range\", w(v))\n            }\n            Kind::USizeOutOfRange(v) => {\n                error_!(\"unsigned integer `{}` is out of range\", w(v))\n            }\n            Kind::Unsupported(v) => {\n                error_!(\"unsupported type `{}`\", w(v))\n            }\n            Kind::UnsupportedKey(a, e) => {\n                error_!(\"unsupported type `{}` for key: must be `{}`\", w(a), w(e))\n            }\n        }\n\n        if let (Some(ref profile), Some(ref md)) = (&e.profile, &e.metadata) {\n            if !e.path.is_empty() {\n                let key = md.interpolate(profile, &e.path);\n                info_!(\"for key {}\", w(key));\n            }\n        }\n\n        if let Some(md) = e.metadata {\n            if let Some(source) = md.source {\n                info_!(\"in {} {}\", w(source), md.name);\n            } else {\n                info_!(\"in {}\", w(md.name));\n            }\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse serde::{Deserialize, Serialize};\nuse serde::de::{self, Deserializer};\n\nuse crate::http::Header;\n\n/// An identifier (or `None`) to send as the `Server` header.\n///\n/// # Deserialization\n///\n/// An `Ident` deserializes from any of the following:\n///\n/// * `string`\n///\n///   The string must be a valid `Ident`. See [`Ident::try_new()`] for details.\n///\n/// * `boolean`\n///\n///   The boolean must be `false`. The value will be [`Ident::none()`].\n///\n/// * `Option<string>`\n///\n///   If `Some`, this is the same as deserializing from the inner string. If\n///   `None`, the value is [`Ident::none()`].\n///\n/// * `unit`\n///\n///   Always deserializes as [`Ident::none()`].\n///\n/// # Examples\n///\n/// As with all Rocket configuration options, when using the default\n/// [`Config::figment()`](crate::Config::figment()), `Ident` can be configured\n/// via a `Rocket.toml` file. When no value for `ident` is provided, the value\n/// defaults to `\"Rocket\"`. Because a default is provided, configuration only\n/// needs to provided to customize or remove the value.\n///\n/// ```rust\n/// # use rocket::figment::{Figment, providers::{Format, Toml}};\n/// use rocket::config::{Config, Ident};\n///\n/// // If these are the contents of `Rocket.toml`...\n/// # let toml = Toml::string(r#\"\n/// [default]\n/// ident = false\n/// # \"#).nested();\n///\n/// // The config parses as follows:\n/// # let config = Config::from(Figment::from(Config::debug_default()).merge(toml));\n/// assert_eq!(config.ident, Ident::none());\n///\n/// // If these are the contents of `Rocket.toml`...\n/// # let toml = Toml::string(r#\"\n/// [default]\n/// ident = \"My Server\"\n/// # \"#).nested();\n///\n/// // The config parses as follows:\n/// # let config = Config::from(Figment::from(Config::debug_default()).merge(toml));\n/// assert_eq!(config.ident, Ident::try_new(\"My Server\").unwrap());\n/// ```\n///\n/// The following example illustrates manual configuration:\n///\n/// ```rust\n/// use rocket::config::{Config, Ident};\n///\n/// let figment = rocket::Config::figment().merge((\"ident\", false));\n/// let config = rocket::Config::from(figment);\n/// assert_eq!(config.ident, Ident::none());\n///\n/// let figment = rocket::Config::figment().merge((\"ident\", \"Fancy/1.0\"));\n/// let config = rocket::Config::from(figment);\n/// assert_eq!(config.ident, Ident::try_new(\"Fancy/1.0\").unwrap());\n/// ```\n#[derive(Debug, Clone, PartialEq, Serialize)]\npub struct Ident(Option<String>);\n\nmacro_rules! ident {\n    ($value:expr) => {\n        {\n            #[allow(unknown_lints, eq_op)]\n            const _: [(); 0 - !{\n                const ASSERT: bool = $crate::http::Header::is_valid_value($value, false);\n                ASSERT\n            } as usize] = [];\n\n            $crate::config::Ident::try_new($value).unwrap()\n        }\n    }\n}\n\nimpl Ident {\n    /// Returns a new `Ident` with the string `ident`.\n    ///\n    /// When configured as the [`Config::ident`](crate::Config::ident), Rocket\n    /// will set a `Server` header with the `ident` value on all responses.\n    ///\n    /// # Errors\n    ///\n    /// The string `ident` must be non-empty and may only contain visible ASCII\n    /// characters. The first character cannot be whitespace. The only\n    /// whitespace characters allowed are ` ` (space) and `\\t` (horizontal tab).\n    /// The string is returned wrapped in `Err` if it contains any invalid\n    /// characters.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::Ident;\n    ///\n    /// let ident = Ident::try_new(\"Rocket\").unwrap();\n    /// assert_eq!(ident.as_str(), Some(\"Rocket\"));\n    ///\n    /// let ident = Ident::try_new(\"Rocket Run\").unwrap();\n    /// assert_eq!(ident.as_str(), Some(\"Rocket Run\"));\n    ///\n    /// let ident = Ident::try_new(\" Rocket\");\n    /// assert!(ident.is_err());\n    ///\n    /// let ident = Ident::try_new(\"Rocket\\nRun\");\n    /// assert!(ident.is_err());\n    ///\n    /// let ident = Ident::try_new(\"\\tShip\");\n    /// assert!(ident.is_err());\n    /// ```\n    pub fn try_new<S: Into<String>>(ident: S) -> Result<Ident, String> {\n        // This is a little more lenient than reality.\n        let ident = ident.into();\n        if !Header::is_valid_value(&ident, false) {\n            return Err(ident);\n        }\n\n        Ok(Ident(Some(ident)))\n    }\n\n    /// Returns a new `Ident` which is `None`.\n    ///\n    /// When configured as the [`Config::ident`](crate::Config::ident), Rocket\n    /// will not set a `Server` header on any response. Any `Server` header\n    /// emitted by the application will still be written out.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::Ident;\n    ///\n    /// let ident = Ident::none();\n    /// assert_eq!(ident.as_str(), None);\n    /// ```\n    pub const fn none() -> Ident {\n        Ident(None)\n    }\n\n    /// Returns `self` as an `Option<&str>`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::Ident;\n    ///\n    /// let ident = Ident::try_new(\"Rocket\").unwrap();\n    /// assert_eq!(ident.as_str(), Some(\"Rocket\"));\n    ///\n    /// let ident = Ident::try_new(\"Rocket/1 (Unix)\").unwrap();\n    /// assert_eq!(ident.as_str(), Some(\"Rocket/1 (Unix)\"));\n    ///\n    /// let ident = Ident::none();\n    /// assert_eq!(ident.as_str(), None);\n    /// ```\n    pub fn as_str(&self) -> Option<&str> {\n        self.0.as_deref()\n    }\n}\n\nimpl<'de> Deserialize<'de> for Ident {\n    fn deserialize<D: Deserializer<'de>>(de: D) -> Result<Self, D::Error> {\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = Ident;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                formatter.write_str(\"a server ident string or `false`\")\n            }\n\n            fn visit_bool<E: de::Error>(self, v: bool) -> Result<Self::Value, E> {\n                if !v {\n                    return Ok(Ident::none());\n                }\n\n                Err(E::invalid_value(de::Unexpected::Bool(v), &self))\n            }\n\n            fn visit_some<D>(self, de: D) -> Result<Self::Value, D::Error>\n                where D: Deserializer<'de>\n            {\n                de.deserialize_string(self)\n            }\n\n            fn visit_none<E: de::Error>(self) -> Result<Self::Value, E> {\n                Ok(Ident::none())\n            }\n\n            fn visit_unit<E: de::Error>(self) -> Result<Self::Value, E> {\n                Ok(Ident::none())\n            }\n\n            fn visit_string<E: de::Error>(self, v: String) -> Result<Self::Value, E> {\n                Ident::try_new(v)\n                    .map_err(|s| E::invalid_value(de::Unexpected::Str(&s), &self))\n            }\n\n            fn visit_str<E: de::Error>(self, v: &str) -> Result<Self::Value, E> {\n                self.visit_string(v.into())\n            }\n        }\n\n        de.deserialize_string(Visitor)\n    }\n}\n\nimpl fmt::Display for Ident {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.as_str() {\n            Some(name) => name.fmt(f),\n            None => \"disabled\".fmt(f),\n        }\n    }\n}\n\n/// The default `Ident` is `\"Rocket\"`.\nimpl Default for Ident {\n    fn default() -> Self {\n        ident!(\"Rocket\")\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse serde::de;\n\nuse crate::http::Header;\nuse crate::http::uncased::Uncased;\n\npub(crate) fn deserialize<'de, D>(de: D) -> Result<Option<Uncased<'static>>, D::Error>\n    where D: de::Deserializer<'de>\n{\n    struct Visitor;\n\n    impl<'de> de::Visitor<'de> for Visitor {\n        type Value = Option<Uncased<'static>>;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n            formatter.write_str(\"a valid header name or `false`\")\n        }\n\n        fn visit_bool<E: de::Error>(self, v: bool) -> Result<Self::Value, E> {\n            if !v {\n                return Ok(None);\n            }\n\n            Err(E::invalid_value(de::Unexpected::Bool(v), &self))\n        }\n\n        fn visit_some<D>(self, de: D) -> Result<Self::Value, D::Error>\n            where D: de::Deserializer<'de>\n        {\n            de.deserialize_string(self)\n        }\n\n        fn visit_none<E: de::Error>(self) -> Result<Self::Value, E> {\n            Ok(None)\n        }\n\n        fn visit_unit<E: de::Error>(self) -> Result<Self::Value, E> {\n            Ok(None)\n        }\n\n        fn visit_str<E: de::Error>(self, v: &str) -> Result<Self::Value, E> {\n            self.visit_string(v.into())\n        }\n\n        fn visit_string<E: de::Error>(self, v: String) -> Result<Self::Value, E> {\n            if Header::is_valid_name(&v) {\n                Ok(Some(Uncased::from_owned(v)))\n            } else {\n                Err(E::invalid_value(de::Unexpected::Str(&v), &self))\n            }\n        }\n    }\n\n    de.deserialize_string(Visitor)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse serde::{de, ser, Deserialize, Serialize};\n\nuse crate::http::private::cookie::Key;\nuse crate::request::{Outcome, Request, FromRequest};\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\nenum Kind {\n    Zero,\n    Generated,\n    Provided\n}\n\n/// A cryptographically secure secret key.\n///\n/// A `SecretKey` is primarily used by [private cookies]. See the [configuration\n/// guide] for further details. It can be configured from 256-bit random\n/// material or a 512-bit master key, each as either a base64-encoded string or\n/// raw bytes.\n///\n/// ```rust\n/// use rocket::config::Config;\n///\n/// // NOTE: Don't (!) use this key! Generate your own and keep it private!\n/// //       e.g. via `head -c64 /dev/urandom | base64`\n/// let figment = Config::figment()\n///     # .merge((\"secret_key\", \"hPRYyVRiMyxpw5sBB1XeCMN1kFsDCqKvBi2QJxBVHQk=\"));\n///     # /*\n///     .merge((\"secret_key\", \"hPrYyRiMy5sBB1+CM1kFsqKvBiQJxBVHQk=\"));\n///     # */\n///\n/// let config = Config::from(figment);\n/// assert!(!config.secret_key.is_zero());\n/// ```\n///\n/// When configured in the debug profile with the `secrets` feature enabled, a\n/// key set as `0` is automatically regenerated at launch time from the OS's\n/// random source if available.\n///\n/// ```rust\n/// use rocket::config::Config;\n/// use rocket::local::blocking::Client;\n///\n/// let figment = Config::figment()\n///     .merge((\"secret_key\", vec![0u8; 64]))\n///     .select(\"debug\");\n///\n/// let rocket = rocket::custom(figment);\n/// let client = Client::tracked(rocket).expect(\"okay in debug\");\n/// assert!(!client.rocket().config().secret_key.is_zero());\n/// ```\n///\n/// When running in any other profile with the `secrets` feature enabled,\n/// providing a key of `0` or not provided a key at all results in an error at\n/// launch-time:\n///\n/// ```rust\n/// use rocket::config::Config;\n/// use rocket::figment::Profile;\n/// use rocket::local::blocking::Client;\n/// use rocket::error::ErrorKind;\n///\n/// let profile = Profile::const_new(\"staging\");\n/// let figment = Config::figment()\n///     .merge((\"secret_key\", vec![0u8; 64]))\n///     .select(profile.clone());\n///\n/// let rocket = rocket::custom(figment);\n/// let error = Client::tracked(rocket).expect_err(\"error in non-debug\");\n/// assert!(matches!(error.kind(), ErrorKind::InsecureSecretKey(profile)));\n/// ```\n///\n/// [private cookies]: https://rocket.rs/v0.5/guide/requests/#private-cookies\n/// [configuration guide]: https://rocket.rs/v0.5/guide/configuration/#secret-key\n#[derive(Clone)]\n#[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\npub struct SecretKey {\n    pub(crate) key: Key,\n    provided: bool,\n}\n\nimpl SecretKey {\n    /// Returns a secret key that is all zeroes.\n    pub(crate) fn zero() -> SecretKey {\n        SecretKey { key: Key::from(&[0; 64]), provided: false }\n    }\n\n    /// Creates a `SecretKey` from a 512-bit `master` key. For security,\n    /// `master` _must_ be cryptographically random.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `master` < 64 bytes.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::SecretKey;\n    ///\n    /// # let master = vec![0u8; 64];\n    /// let key = SecretKey::from(&master);\n    /// ```\n    pub fn from(master: &[u8]) -> SecretKey {\n        SecretKey { key: Key::from(master), provided: true }\n    }\n\n    /// Derives a `SecretKey` from 256 bits of cryptographically random\n    /// `material`. For security, `material` _must_ be cryptographically random.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `material` < 32 bytes.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::SecretKey;\n    ///\n    /// # let material = vec![0u8; 32];\n    /// let key = SecretKey::derive_from(&material);\n    /// ```\n    pub fn derive_from(material: &[u8]) -> SecretKey {\n        SecretKey { key: Key::derive_from(material), provided: true }\n    }\n\n    /// Attempts to generate a `SecretKey` from randomness retrieved from the\n    /// OS. If randomness from the OS isn't available, returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::SecretKey;\n    ///\n    /// let key = SecretKey::generate();\n    /// ```\n    pub fn generate() -> Option<SecretKey> {\n        Some(SecretKey { key: Key::try_generate()?, provided: false })\n    }\n\n    /// Returns `true` if `self` is the `0`-key.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::SecretKey;\n    ///\n    /// let master = vec![0u8; 64];\n    /// let key = SecretKey::from(&master);\n    /// assert!(key.is_zero());\n    /// ```\n    pub fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n\n    /// Returns `true` if `self` was not automatically generated and is not zero.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::SecretKey;\n    ///\n    /// let master = vec![0u8; 64];\n    /// let key = SecretKey::generate().unwrap();\n    /// assert!(!key.is_provided());\n    ///\n    /// let master = vec![0u8; 64];\n    /// let key = SecretKey::from(&master);\n    /// assert!(!key.is_provided());\n    /// ```\n    pub fn is_provided(&self) -> bool {\n        self.provided && !self.is_zero()\n    }\n\n    /// Serialize as `zero` to avoid key leakage.\n    pub(crate) fn serialize_zero<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n        where S: ser::Serializer\n    {\n        ser.serialize_bytes(&[0; 32][..])\n    }\n}\n\nimpl PartialEq for SecretKey {\n    fn eq(&self, other: &Self) -> bool {\n        // `Key::partial_eq()` is a constant-time op.\n        self.key == other.key\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r SecretKey {\n    type Error = std::convert::Infallible;\n\n    async fn from_request(req: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n        Outcome::Success(&req.rocket().config().secret_key)\n    }\n}\n\nimpl<'de> Deserialize<'de> for SecretKey {\n    fn deserialize<D: de::Deserializer<'de>>(de: D) -> Result<Self, D::Error> {\n        use {binascii::{b64decode, hex2bin}, de::Unexpected::Str};\n\n        struct Visitor;\n\n        impl<'de> de::Visitor<'de> for Visitor {\n            type Value = SecretKey;\n\n            fn expecting(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                f.write_str(\"256-bit base64 or hex string, or 32-byte slice\")\n            }\n\n            fn visit_str<E: de::Error>(self, val: &str) -> Result<SecretKey, E> {\n                let e = |s| E::invalid_value(Str(s), &\"256-bit base64 or hex\");\n\n                // `binascii` requires a more space than actual output for padding\n                let mut buf = [0u8; 96];\n                let bytes = match val.len() {\n                    44 | 88 => b64decode(val.as_bytes(), &mut buf).map_err(|_| e(val))?,\n                    64 => hex2bin(val.as_bytes(), &mut buf).map_err(|_| e(val))?,\n                    n => Err(E::invalid_length(n, &\"44 or 88 for base64, 64 for hex\"))?\n                };\n\n                self.visit_bytes(bytes)\n            }\n\n            fn visit_bytes<E: de::Error>(self, bytes: &[u8]) -> Result<SecretKey, E> {\n                if bytes.len() < 32 {\n                    Err(E::invalid_length(bytes.len(), &\"at least 32\"))\n                } else if bytes.iter().all(|b| *b == 0) {\n                    Ok(SecretKey::zero())\n                } else if bytes.len() >= 64 {\n                    Ok(SecretKey::from(bytes))\n                } else {\n                    Ok(SecretKey::derive_from(bytes))\n                }\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where A: de::SeqAccess<'de>\n            {\n                let mut bytes = Vec::with_capacity(seq.size_hint().unwrap_or(0));\n                while let Some(byte) = seq.next_element()? {\n                    bytes.push(byte);\n                }\n\n                self.visit_bytes(&bytes)\n            }\n        }\n\n        de.deserialize_any(Visitor)\n    }\n}\n\nimpl fmt::Display for SecretKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if self.is_zero() {\n            f.write_str(\"[zero]\")\n        } else {\n            match self.provided {\n                true => f.write_str(\"[provided]\"),\n                false => f.write_str(\"[generated]\"),\n            }\n        }\n    }\n}\n\nimpl fmt::Debug for SecretKey {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        <Self as fmt::Display>::fmt(self, f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\n#[cfg(unix)]\nuse std::collections::HashSet;\n\nuse futures::stream::Stream;\nuse serde::{Deserialize, Serialize};\n\n/// A Unix signal for triggering graceful shutdown.\n///\n/// Each variant corresponds to a Unix process signal which can be used to\n/// trigger a graceful shutdown. See [`Shutdown`] for details.\n///\n/// ## (De)serialization\n///\n/// A `Sig` variant serializes and deserializes as a lowercase string equal to\n/// the name of the variant: `\"alrm\"` for [`Sig::Alrm`], `\"chld\"` for\n/// [`Sig::Chld`], and so on.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\n#[cfg_attr(nightly, doc(cfg(unix)))]\npub enum Sig {\n    /// The `SIGALRM` Unix signal.\n    Alrm,\n    /// The `SIGCHLD` Unix signal.\n    Chld,\n    /// The `SIGHUP` Unix signal.\n    Hup,\n    /// The `SIGINT` Unix signal.\n    Int,\n    /// The `SIGIO` Unix signal.\n    Io,\n    /// The `SIGPIPE` Unix signal.\n    Pipe,\n    /// The `SIGQUIT` Unix signal.\n    Quit,\n    /// The `SIGTERM` Unix signal.\n    Term,\n    /// The `SIGUSR1` Unix signal.\n    Usr1,\n    /// The `SIGUSR2` Unix signal.\n    Usr2\n}\n\nimpl fmt::Display for Sig {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let s = match self {\n            Sig::Alrm => \"SIGALRM\",\n            Sig::Chld => \"SIGCHLD\",\n            Sig::Hup => \"SIGHUP\",\n            Sig::Int => \"SIGINT\",\n            Sig::Io => \"SIGIO\",\n            Sig::Pipe => \"SIGPIPE\",\n            Sig::Quit => \"SIGQUIT\",\n            Sig::Term => \"SIGTERM\",\n            Sig::Usr1 => \"SIGUSR1\",\n            Sig::Usr2 => \"SIGUSR2\",\n        };\n\n        s.fmt(f)\n    }\n}\n\n/// Graceful shutdown configuration.\n///\n/// # Summary\n///\n/// This structure configures when and how graceful shutdown occurs. The `ctrlc`\n/// and `signals` properties control _when_ and the `grace` and `mercy`\n/// properties control _how_.\n///\n/// When a shutdown is triggered by an externally or internally initiated\n/// [`Shutdown::notify()`], Rocket allows application I/O to make progress for\n/// at most `grace` seconds before initiating connection-level shutdown.\n/// Connection shutdown forcibly terminates _application_ I/O, but connections\n/// are allowed an additional `mercy` seconds to shutdown before being\n/// forcefully terminated. This implies that a _cooperating_ and active remote\n/// client maintaining an open connection can stall shutdown for at most `grace`\n/// seconds, while an _uncooperative_ remote client can stall shutdown for at\n/// most `grace + mercy` seconds.\n///\n/// # Triggers\n///\n/// _All_ graceful shutdowns are initiated via [`Shutdown::notify()`]. Rocket\n/// can be configured to call [`Shutdown::notify()`] automatically on certain\n/// conditions, specified via the `ctrlc` and `signals` properties of this\n/// structure. More specifically, if `ctrlc` is `true` (the default), `ctrl-c`\n/// (`SIGINT`) initiates a server shutdown, and on Unix, `signals` specifies a\n/// list of IPC signals that trigger a shutdown (`[\"term\"]` by default).\n///\n/// [`Shutdown::notify()`]: crate::Shutdown::notify()\n///\n/// # Grace Period\n///\n/// Once a shutdown is triggered, Rocket stops accepting new connections and\n/// waits at most `grace` seconds before initiating connection shutdown.\n/// Applications can `await` the [`Shutdown`](crate::Shutdown) future to detect\n/// a shutdown and cancel any server-initiated I/O, such as from [infinite\n/// responders](crate::response::stream#graceful-shutdown), to avoid abrupt I/O\n/// cancellation.\n///\n/// # Mercy Period\n///\n/// After the grace period has elapsed, Rocket initiates connection shutdown,\n/// allowing connection-level I/O termination such as TLS's `close_notify` to\n/// proceed nominally. Rocket waits at most `mercy` seconds for connections to\n/// shutdown before forcefully terminating all connections.\n///\n/// # Runaway I/O\n///\n/// If tasks are _still_ executing after both periods _and_ a Rocket configured\n/// async runtime is in use, Rocket waits an unspecified amount of time (not to\n/// exceed 1s) and forcefully terminates the asynchronous runtime. This\n/// guarantees that the server process terminates, prohibiting uncooperative,\n/// runaway I/O from preventing shutdown altogether.\n///\n/// A \"Rocket configured runtime\" is one started by the `#[rocket::main]` and\n/// `#[launch]` attributes. Rocket _never_ forcefully terminates a custom\n/// runtime. A server that creates its own async runtime must take care to\n/// terminate itself if tasks it spawns fail to cooperate.\n///\n/// Under normal circumstances, forced termination should never occur. No use of\n/// \"normal\" cooperative I/O (that is, via `.await` or `task::spawn()`) should\n/// trigger abrupt termination. Instead, forced cancellation is intended to\n/// prevent _buggy_ code, such as an unintended infinite loop or unknown use of\n/// blocking I/O, from preventing shutdown.\n///\n/// This behavior can be disabled by setting [`Shutdown::force`] to `false`.\n///\n/// # Example\n///\n/// As with all Rocket configuration options, when using the default\n/// [`Config::figment()`](crate::Config::figment()), `Shutdown` can be\n/// configured via a `Rocket.toml` file. As always, defaults are provided\n/// (documented below), and thus configuration only needs to provided to change\n/// defaults.\n///\n/// ```rust\n/// # use rocket::figment::{Figment, providers::{Format, Toml}};\n/// use rocket::Config;\n///\n/// // If these are the contents of `Rocket.toml`...\n/// # let toml = Toml::string(r#\"\n/// [default.shutdown]\n/// ctrlc = false\n/// signals = [\"term\", \"hup\"]\n/// grace = 10\n/// mercy = 5\n/// # force = false\n/// # \"#).nested();\n///\n/// // The config parses as follows:\n/// # let config = Config::from(Figment::from(Config::debug_default()).merge(toml));\n/// assert_eq!(config.shutdown.ctrlc, false);\n/// assert_eq!(config.shutdown.grace, 10);\n/// assert_eq!(config.shutdown.mercy, 5);\n/// # assert_eq!(config.shutdown.force, false);\n///\n/// # #[cfg(unix)] {\n/// use rocket::config::Sig;\n///\n/// assert_eq!(config.shutdown.signals.len(), 2);\n/// assert!(config.shutdown.signals.contains(&Sig::Term));\n/// assert!(config.shutdown.signals.contains(&Sig::Hup));\n/// # }\n/// ```\n///\n/// Or, as with all configuration options, programmatically:\n///\n/// ```rust\n/// # use rocket::figment::{Figment, providers::{Format, Toml}};\n/// use rocket::config::{Config, Shutdown};\n///\n/// #[cfg(unix)]\n/// use rocket::config::Sig;\n///\n/// let config = Config {\n///     shutdown: Shutdown {\n///         ctrlc: false,\n///         #[cfg(unix)]\n///         signals: {\n///             let mut set = std::collections::HashSet::new();\n///             set.insert(Sig::Term);\n///             set.insert(Sig::Hup);\n///             set\n///         },\n///         grace: 10,\n///         mercy: 5,\n///         force: true,\n///         ..Default::default()\n///     },\n///     ..Config::default()\n/// };\n///\n/// assert_eq!(config.shutdown.ctrlc, false);\n/// assert_eq!(config.shutdown.grace, 10);\n/// assert_eq!(config.shutdown.mercy, 5);\n/// assert_eq!(config.shutdown.force, true);\n///\n/// #[cfg(unix)] {\n///     assert_eq!(config.shutdown.signals.len(), 2);\n///     assert!(config.shutdown.signals.contains(&Sig::Term));\n///     assert!(config.shutdown.signals.contains(&Sig::Hup));\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Shutdown {\n    /// Whether `ctrl-c` (`SIGINT`) initiates a server shutdown.\n    ///\n    /// **default: `true`**\n    #[serde(deserialize_with = \"figment::util::bool_from_str_or_int\")]\n    pub ctrlc: bool,\n    /// On Unix, a set of signal which trigger a shutdown. On non-Unix, this\n    /// option is unavailable and silently ignored.\n    ///\n    /// **default: { [`Sig::Term`] }**\n    #[cfg(unix)]\n    #[cfg_attr(nightly, doc(cfg(unix)))]\n    pub signals: HashSet<Sig>,\n    /// The grace period: number of seconds to continue to try to finish\n    /// outstanding _server_ I/O for before forcibly terminating it.\n    ///\n    /// **default: `2`**\n    pub grace: u32,\n    /// The mercy period: number of seconds to continue to try to finish\n    /// outstanding _connection_ I/O for before forcibly terminating it.\n    ///\n    /// **default: `3`**\n    pub mercy: u32,\n    /// Whether to force termination of an async runtime that refuses to\n    /// cooperatively shutdown.\n    ///\n    /// Rocket _never_ forcefully terminates a custom runtime, irrespective of\n    /// this value. A server that creates its own async runtime must take care\n    /// to terminate itself if it fails to cooperate.\n    ///\n    /// _**Note:** Rocket only reads this value from sources in the [default\n    /// provider](crate::Config::figment())._\n    ///\n    /// **default: `true`**\n    #[serde(deserialize_with = \"figment::util::bool_from_str_or_int\")]\n    pub force: bool,\n    /// PRIVATE: This structure may grow (but never change otherwise) in a\n    /// non-breaking release. As such, constructing this structure should\n    /// _always_ be done using a public constructor or update syntax:\n    ///\n    /// ```rust\n    /// use rocket::config::Shutdown;\n    ///\n    /// let config = Shutdown {\n    ///     grace: 5,\n    ///     mercy: 10,\n    ///     ..Default::default()\n    /// };\n    /// ```\n    #[doc(hidden)]\n    #[serde(skip)]\n    pub __non_exhaustive: (),\n}\n\nimpl fmt::Display for Shutdown {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"ctrlc = {}, force = {}, \", self.ctrlc, self.force)?;\n\n        #[cfg(unix)] {\n            write!(f, \"signals = [\")?;\n            for (i, sig) in self.signals.iter().enumerate() {\n                if i != 0 { write!(f, \", \")?; }\n                write!(f, \"{}\", sig)?;\n            }\n            write!(f, \"], \")?;\n        }\n\n        write!(f, \"grace = {}s, mercy = {}s\", self.grace, self.mercy)?;\n        Ok(())\n    }\n}\n\nimpl Default for Shutdown {\n    fn default() -> Self {\n        Shutdown {\n            ctrlc: true,\n            #[cfg(unix)]\n            signals: { let mut set = HashSet::new(); set.insert(Sig::Term); set },\n            grace: 2,\n            mercy: 3,\n            force: true,\n            __non_exhaustive: (),\n        }\n    }\n}\n\nimpl Shutdown {\n    #[cfg(unix)]\n    pub(crate) fn signal_stream(&self) -> Option<impl Stream<Item = Sig>> {\n        use tokio_stream::{StreamExt, StreamMap, wrappers::SignalStream};\n        use tokio::signal::unix::{signal, SignalKind};\n\n        if !self.ctrlc && self.signals.is_empty() {\n            return None;\n        }\n\n        let mut signals = self.signals.clone();\n        if self.ctrlc {\n            signals.insert(Sig::Int);\n        }\n\n        let mut map = StreamMap::new();\n        for sig in signals {\n            let sigkind = match sig {\n                Sig::Alrm => SignalKind::alarm(),\n                Sig::Chld => SignalKind::child(),\n                Sig::Hup => SignalKind::hangup(),\n                Sig::Int => SignalKind::interrupt(),\n                Sig::Io => SignalKind::io(),\n                Sig::Pipe => SignalKind::pipe(),\n                Sig::Quit => SignalKind::quit(),\n                Sig::Term => SignalKind::terminate(),\n                Sig::Usr1 => SignalKind::user_defined1(),\n                Sig::Usr2 => SignalKind::user_defined2()\n            };\n\n            match signal(sigkind) {\n                Ok(signal) => { map.insert(sig, SignalStream::new(signal)); },\n                Err(e) => warn!(\"Failed to enable `{}` shutdown signal: {}\", sig, e),\n            }\n        }\n\n        Some(map.map(|(k, _)| k))\n    }\n\n    #[cfg(not(unix))]\n    pub(crate) fn signal_stream(&self) -> Option<impl Stream<Item = Sig>> {\n        use tokio_stream::StreamExt;\n        use futures::stream::once;\n\n        self.ctrlc.then(|| tokio::signal::ctrl_c())\n            .map(|signal| once(Box::pin(signal)))\n            .map(|stream| stream.filter_map(|result| {\n                result.map(|_| Sig::Int)\n                    .map_err(|e| warn!(\"Failed to enable `ctrl-c` shutdown signal: {}\", e))\n                    .ok()\n            }))\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use figment::value::magic::{Either, RelativePathBuf};\nuse serde::{Deserialize, Serialize};\nuse indexmap::IndexSet;\n\n/// TLS configuration: certificate chain, key, and ciphersuites.\n///\n/// Four parameters control `tls` configuration:\n///\n///   * `certs`, `key`\n///\n///     Both `certs` and `key` can be configured as a path or as raw bytes.\n///     `certs` must be a DER-encoded X.509 TLS certificate chain, while `key`\n///     must be a DER-encoded ASN.1 key in either PKCS#8, PKCS#1, or SEC1\n///     format. When a path is configured in a file, such as `Rocket.toml`,\n///     relative paths are interpreted as relative to the source file's\n///     directory.\n///\n///   * `ciphers`\n///\n///     A list of supported [`CipherSuite`]s in server-preferred order, from\n///     most to least. It is not required and defaults to\n///     [`CipherSuite::DEFAULT_SET`], the recommended setting.\n///\n///   * `prefer_server_cipher_order`\n///\n///     A boolean that indicates whether the server should regard its own\n///     ciphersuite preferences over the client's. The default and recommended\n///     value is `false`.\n///\n/// Additionally, the `mutual` parameter controls if and how the server\n/// authenticates clients via mutual TLS. It works in concert with the\n/// [`mtls`](crate::mtls) module. See [`MutualTls`] for configuration details.\n///\n/// In `Rocket.toml`, configuration might look like:\n///\n/// ```toml\n/// [default.tls]\n/// certs = \"private/rsa_sha256_cert.pem\"\n/// key = \"private/rsa_sha256_key.pem\"\n/// ```\n///\n/// With a custom programmatic configuration, this might look like:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::config::{Config, TlsConfig, CipherSuite};\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     let tls_config = TlsConfig::from_paths(\"/ssl/certs.pem\", \"/ssl/key.pem\")\n///         .with_ciphers(CipherSuite::TLS_V13_SET)\n///         .with_preferred_server_cipher_order(true);\n///\n///     let config = Config {\n///         tls: Some(tls_config),\n///         ..Default::default()\n///     };\n///\n///     rocket::custom(config)\n/// }\n/// ```\n///\n/// Or by creating a custom figment:\n///\n/// ```rust\n/// use rocket::config::Config;\n///\n/// let figment = Config::figment()\n///     .merge((\"tls.certs\", \"path/to/certs.pem\"))\n///     .merge((\"tls.key\", vec![0; 32]));\n/// #\n/// # let config = rocket::Config::from(figment);\n/// # let tls_config = config.tls.as_ref().unwrap();\n/// # assert!(tls_config.certs().is_left());\n/// # assert!(tls_config.key().is_right());\n/// # assert_eq!(tls_config.ciphers().count(), 9);\n/// # assert!(!tls_config.prefer_server_cipher_order());\n/// ```\n#[derive(PartialEq, Debug, Clone, Deserialize, Serialize)]\n#[cfg_attr(nightly, doc(cfg(feature = \"tls\")))]\npub struct TlsConfig {\n    /// Path to a PEM file with, or raw bytes for, a DER-encoded X.509 TLS\n    /// certificate chain.\n    pub(crate) certs: Either<RelativePathBuf, Vec<u8>>,\n    /// Path to a PEM file with, or raw bytes for, DER-encoded private key in\n    /// either PKCS#8 or PKCS#1 format.\n    pub(crate) key: Either<RelativePathBuf, Vec<u8>>,\n    /// List of TLS cipher suites in server-preferred order.\n    #[serde(default = \"CipherSuite::default_set\")]\n    pub(crate) ciphers: IndexSet<CipherSuite>,\n    /// Whether to prefer the server's cipher suite order over the client's.\n    #[serde(default)]\n    pub(crate) prefer_server_cipher_order: bool,\n    /// Configuration for mutual TLS, if any.\n    #[serde(default)]\n    #[cfg(feature = \"mtls\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\n    pub(crate) mutual: Option<MutualTls>,\n}\n\n/// Mutual TLS configuration.\n///\n/// Configuration works in concert with the [`mtls`](crate::mtls) module, which\n/// provides a request guard to validate, verify, and retrieve client\n/// certificates in routes.\n///\n/// By default, mutual TLS is disabled and client certificates are not required,\n/// validated or verified. To enable mutual TLS, the `mtls` feature must be\n/// enabled and support configured via two `tls.mutual` parameters:\n///\n///   * `ca_certs`\n///\n///     A required path to a PEM file or raw bytes to a DER-encoded X.509 TLS\n///     certificate chain for the certificate authority to verify client\n///     certificates against. When a path is configured in a file, such as\n///     `Rocket.toml`, relative paths are interpreted as relative to the source\n///     file's directory.\n///\n///   * `mandatory`\n///\n///     An optional boolean that control whether client authentication is\n///     required.\n///\n///     When `true`, client authentication is required. TLS connections where\n///     the client does not present a certificate are immediately terminated.\n///     When `false`, the client is not required to present a certificate. In\n///     either case, if a certificate _is_ presented, it must be valid or the\n///     connection is terminated.\n///\n/// In a `Rocket.toml`, configuration might look like:\n///\n/// ```toml\n/// [default.tls.mutual]\n/// ca_certs = \"/ssl/ca_cert.pem\"\n/// mandatory = true                # when absent, defaults to false\n/// ```\n///\n/// Programmatically, configuration might look like:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::config::{Config, TlsConfig, MutualTls};\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     let tls_config = TlsConfig::from_paths(\"/ssl/certs.pem\", \"/ssl/key.pem\")\n///         .with_mutual(MutualTls::from_path(\"/ssl/ca_cert.pem\"));\n///\n///     let config = Config {\n///         tls: Some(tls_config),\n///         ..Default::default()\n///     };\n///\n///     rocket::custom(config)\n/// }\n/// ```\n///\n/// Once mTLS is configured, the [`mtls::Certificate`](crate::mtls::Certificate)\n/// request guard can be used to retrieve client certificates in routes.\n#[derive(PartialEq, Debug, Clone, Deserialize, Serialize)]\n#[cfg(feature = \"mtls\")]\n#[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\npub struct MutualTls {\n    /// Path to a PEM file with, or raw bytes for, DER-encoded Certificate\n    /// Authority certificates which will be used to verify client-presented\n    /// certificates.\n    // TODO: We should support more than one root.\n    pub(crate) ca_certs: Either<RelativePathBuf, Vec<u8>>,\n    /// Whether the client is required to present a certificate.\n    ///\n    /// When `true`, the client is required to present a valid certificate to\n    /// proceed with TLS. When `false`, the client is not required to present a\n    /// certificate. In either case, if a certificate _is_ presented, it must be\n    /// valid or the connection is terminated.\n    #[serde(default)]\n    #[serde(deserialize_with = \"figment::util::bool_from_str_or_int\")]\n    pub mandatory: bool,\n}\n\n/// A supported TLS cipher suite.\n#[allow(non_camel_case_types)]\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Hash, Deserialize, Serialize)]\n#[cfg_attr(nightly, doc(cfg(feature = \"tls\")))]\n#[non_exhaustive]\npub enum CipherSuite {\n    /// The TLS 1.3 `TLS_CHACHA20_POLY1305_SHA256` cipher suite.\n    TLS_CHACHA20_POLY1305_SHA256,\n    /// The TLS 1.3 `TLS_AES_256_GCM_SHA384` cipher suite.\n    TLS_AES_256_GCM_SHA384,\n    /// The TLS 1.3 `TLS_AES_128_GCM_SHA256` cipher suite.\n    TLS_AES_128_GCM_SHA256,\n\n    /// The TLS 1.2 `TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256` cipher suite.\n    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n    /// The TLS 1.2 `TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256` cipher suite.\n    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n    /// The TLS 1.2 `TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384` cipher suite.\n    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n    /// The TLS 1.2 `TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256` cipher suite.\n    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n    /// The TLS 1.2 `TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384` cipher suite.\n    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n    /// The TLS 1.2 `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256` cipher suite.\n    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n}\n\nimpl CipherSuite {\n    /// The default set and order of cipher suites. These are all of the\n    /// variants in [`CipherSuite`] in their declaration order.\n    pub const DEFAULT_SET: [CipherSuite; 9] = [\n        // TLS v1.3 suites...\n        CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_AES_256_GCM_SHA384,\n        CipherSuite::TLS_AES_128_GCM_SHA256,\n\n        // TLS v1.2 suites...\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n        CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n        CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n    ];\n\n    /// The default set and order of cipher suites. These are the TLS 1.3\n    /// variants in [`CipherSuite`] in their declaration order.\n    pub const TLS_V13_SET: [CipherSuite; 3] = [\n        CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_AES_256_GCM_SHA384,\n        CipherSuite::TLS_AES_128_GCM_SHA256,\n    ];\n\n    /// The default set and order of cipher suites. These are the TLS 1.2\n    /// variants in [`CipherSuite`] in their declaration order.\n    pub const TLS_V12_SET: [CipherSuite; 6] = [\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n        CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n        CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n        CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n    ];\n\n    /// Used as the `serde` default for `ciphers`.\n    fn default_set() -> IndexSet<Self> {\n        Self::DEFAULT_SET.iter().copied().collect()\n    }\n}\n\nimpl TlsConfig {\n    fn default() -> Self {\n        TlsConfig {\n            certs: Either::Right(vec![]),\n            key: Either::Right(vec![]),\n            ciphers: CipherSuite::default_set(),\n            prefer_server_cipher_order: false,\n            #[cfg(feature = \"mtls\")]\n            mutual: None,\n        }\n    }\n\n    /// Constructs a `TlsConfig` from paths to a `certs` certificate chain\n    /// a `key` private-key. This method does no validation; it simply creates a\n    /// structure suitable for passing into a [`Config`](crate::Config).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::TlsConfig;\n    ///\n    /// let tls_config = TlsConfig::from_paths(\"/ssl/certs.pem\", \"/ssl/key.pem\");\n    /// ```\n    pub fn from_paths<C, K>(certs: C, key: K) -> Self\n        where C: AsRef<std::path::Path>, K: AsRef<std::path::Path>\n    {\n        TlsConfig {\n            certs: Either::Left(certs.as_ref().to_path_buf().into()),\n            key: Either::Left(key.as_ref().to_path_buf().into()),\n            ..TlsConfig::default()\n        }\n    }\n\n    /// Constructs a `TlsConfig` from byte buffers to a `certs`\n    /// certificate chain a `key` private-key. This method does no validation;\n    /// it simply creates a structure suitable for passing into a\n    /// [`Config`](crate::Config).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::TlsConfig;\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf);\n    /// ```\n    pub fn from_bytes(certs: &[u8], key: &[u8]) -> Self {\n        TlsConfig {\n            certs: Either::Right(certs.to_vec()),\n            key: Either::Right(key.to_vec()),\n            ..TlsConfig::default()\n        }\n    }\n\n    /// Sets the cipher suites supported by the server and their order of\n    /// preference from most to least preferred.\n    ///\n    /// If a suite appears more than once in `ciphers`, only the first suite\n    /// (and its relative order) is considered. If all cipher suites for a\n    /// version oF TLS are disabled, the respective protocol itself is disabled\n    /// entirely.\n    ///\n    /// # Example\n    ///\n    /// Disable TLS v1.2 by selecting only TLS v1.3 cipher suites:\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, CipherSuite};\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_ciphers(CipherSuite::TLS_V13_SET);\n    /// ```\n    ///\n    /// Enable only ChaCha20-Poly1305 based TLS v1.2 and TLS v1.3 cipher suites:\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, CipherSuite};\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_ciphers([\n    ///         CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///     ]);\n    /// ```\n    ///\n    /// Later duplicates are ignored.\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, CipherSuite};\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_ciphers([\n    ///         CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///         CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n    ///     ]);\n    ///\n    /// let ciphers: Vec<_> = tls_config.ciphers().collect();\n    /// assert_eq!(ciphers, &[\n    ///     CipherSuite::TLS_CHACHA20_POLY1305_SHA256,\n    ///     CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n    ///     CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n    /// ]);\n    /// ```\n    pub fn with_ciphers<I>(mut self, ciphers: I) -> Self\n        where I: IntoIterator<Item = CipherSuite>\n    {\n        self.ciphers = ciphers.into_iter().collect();\n        self\n    }\n\n    /// Whether to prefer the server's cipher suite order and ignore the\n    /// client's preferences (`true`) or choose the first supported ciphersuite\n    /// in the client's preference list (`false`). The default prefer's the\n    /// client's order (`false`).\n    ///\n    /// During TLS cipher suite negotiation, the client presents a set of\n    /// supported ciphers in its preferred order. From this list, the server\n    /// chooses one cipher suite. By default, the server chooses the first\n    /// cipher it supports from the list.\n    ///\n    /// By setting `prefer_server_order` to `true`, the server instead chooses\n    /// the first ciphersuite in it prefers that the client also supports,\n    /// ignoring the client's preferences.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, CipherSuite};\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_ciphers(CipherSuite::TLS_V13_SET)\n    ///     .with_preferred_server_cipher_order(true);\n    /// ```\n    pub fn with_preferred_server_cipher_order(mut self, prefer_server_order: bool) -> Self {\n        self.prefer_server_cipher_order = prefer_server_order;\n        self\n    }\n\n    /// Configures mutual TLS. See [`MutualTls`] for details.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, MutualTls};\n    ///\n    /// # let certs = &[];\n    /// # let key = &[];\n    /// let mtls_config = MutualTls::from_path(\"path/to/cert.pem\").mandatory(true);\n    /// let tls_config = TlsConfig::from_bytes(certs, key).with_mutual(mtls_config);\n    /// assert!(tls_config.mutual().is_some());\n    /// ```\n    #[cfg(feature = \"mtls\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\n    pub fn with_mutual(mut self, config: MutualTls) -> Self {\n        self.mutual = Some(config);\n        self\n    }\n\n    /// Returns the value of the `certs` parameter.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Config;\n    ///\n    /// let figment = Config::figment()\n    ///     .merge((\"tls.certs\", vec![0; 32]))\n    ///     .merge((\"tls.key\", \"/etc/ssl/key.pem\"));\n    ///\n    /// let config = rocket::Config::from(figment);\n    /// let tls_config = config.tls.as_ref().unwrap();\n    /// let cert_bytes = tls_config.certs().right().unwrap();\n    /// assert!(cert_bytes.iter().all(|&b| b == 0));\n    /// ```\n    pub fn certs(&self) -> either::Either<std::path::PathBuf, &[u8]> {\n        match &self.certs {\n            Either::Left(path) => either::Either::Left(path.relative()),\n            Either::Right(bytes) => either::Either::Right(&bytes),\n        }\n    }\n\n    /// Returns the value of the `key` parameter.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::path::Path;\n    /// use rocket::Config;\n    ///\n    /// let figment = Config::figment()\n    ///     .merge((\"tls.certs\", vec![0; 32]))\n    ///     .merge((\"tls.key\", \"/etc/ssl/key.pem\"));\n    ///\n    /// let config = rocket::Config::from(figment);\n    /// let tls_config = config.tls.as_ref().unwrap();\n    /// let key_path = tls_config.key().left().unwrap();\n    /// assert_eq!(key_path, Path::new(\"/etc/ssl/key.pem\"));\n    /// ```\n    pub fn key(&self) -> either::Either<std::path::PathBuf, &[u8]> {\n        match &self.key {\n            Either::Left(path) => either::Either::Left(path.relative()),\n            Either::Right(bytes) => either::Either::Right(&bytes),\n        }\n    }\n\n    /// Returns an iterator over the enabled cipher suites in their order of\n    /// preference from most to least preferred.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::{TlsConfig, CipherSuite};\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// // The default set is CipherSuite::DEFAULT_SET.\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf);\n    /// assert_eq!(tls_config.ciphers().count(), 9);\n    /// assert!(tls_config.ciphers().eq(CipherSuite::DEFAULT_SET.iter().copied()));\n    ///\n    /// // Enable only the TLS v1.3 ciphers.\n    /// let tls_v13_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_ciphers(CipherSuite::TLS_V13_SET);\n    ///\n    /// assert_eq!(tls_v13_config.ciphers().count(), 3);\n    /// assert!(tls_v13_config.ciphers().eq(CipherSuite::TLS_V13_SET.iter().copied()));\n    /// ```\n    pub fn ciphers(&self) -> impl Iterator<Item = CipherSuite> + '_ {\n        self.ciphers.iter().copied()\n    }\n\n    /// Whether the server's cipher suite ordering is preferred or not.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::TlsConfig;\n    ///\n    /// # let certs_buf = &[];\n    /// # let key_buf = &[];\n    /// // The default prefers the server's order.\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf);\n    /// assert!(!tls_config.prefer_server_cipher_order());\n    ///\n    /// // Which can be overridden with the eponymous builder method.\n    /// let tls_config = TlsConfig::from_bytes(certs_buf, key_buf)\n    ///     .with_preferred_server_cipher_order(true);\n    ///\n    /// assert!(tls_config.prefer_server_cipher_order());\n    /// ```\n    pub fn prefer_server_cipher_order(&self) -> bool {\n        self.prefer_server_cipher_order\n    }\n\n    /// Returns the value of the `mutual` parameter.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::path::Path;\n    /// use rocket::config::{TlsConfig, MutualTls};\n    ///\n    /// # let certs = &[];\n    /// # let key = &[];\n    /// let mtls_config = MutualTls::from_path(\"path/to/cert.pem\").mandatory(true);\n    /// let tls_config = TlsConfig::from_bytes(certs, key).with_mutual(mtls_config);\n    ///\n    /// let mtls = tls_config.mutual().unwrap();\n    /// assert_eq!(mtls.ca_certs().unwrap_left(), Path::new(\"path/to/cert.pem\"));\n    /// assert!(mtls.mandatory);\n    /// ```\n    #[cfg(feature = \"mtls\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\n    pub fn mutual(&self) -> Option<&MutualTls> {\n        self.mutual.as_ref()\n    }\n}\n\n#[cfg(feature = \"mtls\")]\nimpl MutualTls {\n    /// Constructs a `MutualTls` from a path to a PEM file with a certificate\n    /// authority `ca_certs` DER-encoded X.509 TLS certificate chain. This\n    /// method does no validation; it simply creates a structure suitable for\n    /// passing into a [`TlsConfig`].\n    ///\n    /// These certificates will be used to verify client-presented certificates\n    /// in TLS connections.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::MutualTls;\n    ///\n    /// let tls_config = MutualTls::from_path(\"/ssl/ca_certs.pem\");\n    /// ```\n    pub fn from_path<C: AsRef<std::path::Path>>(ca_certs: C) -> Self {\n        MutualTls {\n            ca_certs: Either::Left(ca_certs.as_ref().to_path_buf().into()),\n            mandatory: Default::default()\n        }\n    }\n\n    /// Constructs a `MutualTls` from a byte buffer to a certificate authority\n    /// `ca_certs` DER-encoded X.509 TLS certificate chain. This method does no\n    /// validation; it simply creates a structure suitable for passing into a\n    /// [`TlsConfig`].\n    ///\n    /// These certificates will be used to verify client-presented certificates\n    /// in TLS connections.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::MutualTls;\n    ///\n    /// # let ca_certs_buf = &[];\n    /// let mtls_config = MutualTls::from_bytes(ca_certs_buf);\n    /// ```\n    pub fn from_bytes(ca_certs: &[u8]) -> Self {\n        MutualTls {\n            ca_certs: Either::Right(ca_certs.to_vec()),\n            mandatory: Default::default()\n        }\n    }\n\n    /// Sets whether client authentication is required. Disabled by default.\n    ///\n    /// When `true`, client authentication will be required. TLS connections\n    /// where the client does not present a certificate will be immediately\n    /// terminated. When `false`, the client is not required to present a\n    /// certificate. In either case, if a certificate _is_ presented, it must be\n    /// valid or the connection is terminated.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::MutualTls;\n    ///\n    /// # let ca_certs_buf = &[];\n    /// let mtls_config = MutualTls::from_bytes(ca_certs_buf).mandatory(true);\n    /// ```\n    pub fn mandatory(mut self, mandatory: bool) -> Self {\n        self.mandatory = mandatory;\n        self\n    }\n\n    /// Returns the value of the `ca_certs` parameter.\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::config::MutualTls;\n    ///\n    /// # let ca_certs_buf = &[];\n    /// let mtls_config = MutualTls::from_bytes(ca_certs_buf).mandatory(true);\n    /// assert_eq!(mtls_config.ca_certs().unwrap_right(), ca_certs_buf);\n    /// ```\n    pub fn ca_certs(&self) -> either::Either<std::path::PathBuf, &[u8]> {\n        match &self.ca_certs {\n            Either::Left(path) => either::Either::Left(path.relative()),\n            Either::Right(bytes) => either::Either::Right(&bytes),\n        }\n    }\n}\n\n#[cfg(feature = \"tls\")]\nmod with_tls_feature {\n    use std::fs;\n    use std::io::{self, Error};\n\n    use crate::http::tls::Config;\n    use crate::http::tls::rustls::SupportedCipherSuite as RustlsCipher;\n    use crate::http::tls::rustls::cipher_suite;\n\n    use yansi::Paint;\n\n    use super::{Either, RelativePathBuf, TlsConfig, CipherSuite};\n\n    type Reader = Box<dyn std::io::BufRead + Sync + Send>;\n\n    fn to_reader(value: &Either<RelativePathBuf, Vec<u8>>) -> io::Result<Reader> {\n        match value {\n            Either::Left(path) => {\n                let path = path.relative();\n                let file = fs::File::open(&path).map_err(move |e| {\n                    let source = figment::Source::File(path);\n                    let msg = format!(\"error reading TLS file `{}`: {}\", source.primary(), e);\n                    Error::new(e.kind(), msg)\n                })?;\n\n                Ok(Box::new(io::BufReader::new(file)))\n            }\n            Either::Right(vec) => Ok(Box::new(io::Cursor::new(vec.clone()))),\n        }\n    }\n\n    impl TlsConfig {\n        /// This is only called when TLS is enabled.\n        pub(crate) fn to_native_config(&self) -> io::Result<Config<Reader>> {\n            Ok(Config {\n                cert_chain: to_reader(&self.certs)?,\n                private_key: to_reader(&self.key)?,\n                ciphersuites: self.rustls_ciphers().collect(),\n                prefer_server_order: self.prefer_server_cipher_order,\n                #[cfg(not(feature = \"mtls\"))]\n                mandatory_mtls: false,\n                #[cfg(not(feature = \"mtls\"))]\n                ca_certs: None,\n                #[cfg(feature = \"mtls\")]\n                mandatory_mtls: self.mutual.as_ref().map_or(false, |m| m.mandatory),\n                #[cfg(feature = \"mtls\")]\n                ca_certs: match self.mutual {\n                    Some(ref mtls) => Some(to_reader(&mtls.ca_certs)?),\n                    None => None\n                },\n            })\n        }\n\n        fn rustls_ciphers(&self) -> impl Iterator<Item = RustlsCipher> + '_ {\n            self.ciphers().map(|ciphersuite| match ciphersuite {\n                CipherSuite::TLS_CHACHA20_POLY1305_SHA256 =>\n                    cipher_suite::TLS13_CHACHA20_POLY1305_SHA256,\n                CipherSuite::TLS_AES_256_GCM_SHA384 =>\n                    cipher_suite::TLS13_AES_256_GCM_SHA384,\n                CipherSuite::TLS_AES_128_GCM_SHA256 =>\n                    cipher_suite::TLS13_AES_128_GCM_SHA256,\n                CipherSuite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 =>\n                    cipher_suite::TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,\n                CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 =>\n                    cipher_suite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n                CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 =>\n                    cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n                CipherSuite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 =>\n                    cipher_suite::TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n                CipherSuite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 =>\n                    cipher_suite::TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n                CipherSuite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 =>\n                    cipher_suite::TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n            })\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "/// Number of bytes read/written and whether that consisted of the entire\n/// stream.\n#[derive(Debug, Copy, Clone)]\npub struct N {\n    /// The number of bytes written out.\n    pub written: u64,\n    /// Whether the entire stream was read and written out.\n    pub complete: bool,\n}\n\nimpl std::fmt::Display for N {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.written.fmt(f)\n    }\n}\n\nimpl std::ops::Deref for N {\n    type Target = u64;\n\n    fn deref(&self) -> &Self::Target {\n        &self.written\n    }\n}\n\n/// Encapsulates a value capped to a data limit.\n///\n/// A `Capped<T>` type represents a `T` that has been limited (capped) to some\n/// number of bytes. The internal [`N`] specifies whether the value is complete\n/// (also [`Capped::is_complete()`]) or whether it was capped prematurely. A\n/// [`Capped`] is returned by various methods of [`DataStream`]. Some\n/// `Capped<T>` types, like `Capped<String>` and `Capped<TempFile>`, implement\n/// traits like [`FromData`] and [`FromForm`].\n///\n/// # Example\n///\n/// Since `Capped<TempFile>` implements `FromData`, it can be used as a data\n/// guard. The following Rocket route accepts a raw upload and stores the upload\n/// in a different directory depending on whether the file exceeded the data\n/// limit or not. See [`TempFile`] for details on temporary file storage\n/// locations and limits.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::data::Capped;\n/// use rocket::fs::TempFile;\n///\n/// #[post(\"/upload\", data = \"<file>\")]\n/// async fn upload(mut file: Capped<TempFile<'_>>) -> std::io::Result<()> {\n///     if file.is_complete() {\n///         file.persist_to(\"/tmp/complete/file.txt\").await?;\n///     } else {\n///         file.persist_to(\"/tmp/incomplete/file.txt\").await?;\n///     }\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// [`DataStream`]: crate::data::DataStream\n/// [`FromData`]: crate::data::FromData\n/// [`FromForm`]: crate::form::FromForm\n/// [`TempFile`]: crate::fs::TempFile\n// TODO: `Capped` not particularly usable outside Rocket due to coherence.\n#[derive(Debug, Copy, Clone)]\npub struct Capped<T> {\n    /// The capped value itself.\n    pub value: T,\n    /// The number of bytes written and whether `value` is complete.\n    pub n: N\n}\n\nimpl<T> Capped<T> {\n    /// Creates a new `Capped` from a `value` and an `n`. Prefer to use\n    /// [`Capped::from()`] when possible.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let n = N { written: 2, complete: true };\n    /// let capped = Capped::new(\"hi\".to_string(), n);\n    /// ```\n    #[inline(always)]\n    pub fn new(value: T, n: N) -> Self {\n        Capped { value, n, }\n    }\n\n    /// Creates a new `Capped` from a `value` and the length of `value` `n`,\n    /// marking `value` as complete. Prefer to use [`Capped::from()`] when\n    /// possible.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let string = \"hi\";\n    /// let capped = Capped::complete(\"hi\", string.len());\n    /// ```\n    #[inline(always)]\n    pub fn complete(value: T, len: usize) -> Self {\n        Capped { value, n: N { written: len as u64, complete: true } }\n    }\n\n    /// Converts a `Capped<T>` to `Capped<U>` by applying `f` to the contained\n    /// value.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let n = N { written: 2, complete: true };\n    /// let capped: Capped<usize> = Capped::new(10usize, n);\n    /// let mapped: Capped<String> = capped.map(|n| n.to_string());\n    /// ```\n    #[inline(always)]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Capped<U> {\n        Capped { value: f(self.value), n: self.n }\n    }\n\n    /// Returns `true` if `self.n.written` is `0`, that is, no bytes were\n    /// written to `value`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let n = N { written: 2, complete: true };\n    /// let capped = Capped::new(\"hi\".to_string(), n);\n    /// assert!(!capped.is_empty());\n    ///\n    /// let n = N { written: 0, complete: true };\n    /// let capped = Capped::new(\"\".to_string(), n);\n    /// assert!(capped.is_empty());\n    /// ```\n    #[inline(always)]\n    pub fn is_empty(&self) -> bool {\n        self.n.written == 0\n    }\n\n    /// Returns `true` if `self.n.complete`, that is, `value` represents the\n    /// entire data stream.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let n = N { written: 2, complete: true };\n    /// let capped = Capped::new(\"hi\".to_string(), n);\n    /// assert!(capped.is_complete());\n    ///\n    /// let n = N { written: 4, complete: false };\n    /// let capped = Capped::new(\"hell\".to_string(), n);\n    /// assert!(!capped.is_complete());\n    /// ```\n    #[inline(always)]\n    pub fn is_complete(&self) -> bool {\n        self.n.complete\n    }\n\n    /// Returns the internal value.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Capped, N};\n    ///\n    /// let n = N { written: 2, complete: true };\n    /// let capped = Capped::new(\"hi\".to_string(), n);\n    /// assert_eq!(capped.into_inner(), \"hi\");\n    /// ```\n    #[inline(always)]\n    pub fn into_inner(self) -> T {\n        self.value\n    }\n}\n\nimpl<T> std::ops::Deref for Capped<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.value\n    }\n}\n\nimpl<T> std::ops::DerefMut for Capped<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.value\n    }\n}\n\nimpl<T: AsRef<[u8]>> From<T> for Capped<T> {\n    /// Creates a `Capped<T>` from a `value`, setting `complete` to `true`.\n    fn from(value: T) -> Self {\n        let len = value.as_ref().len();\n        Capped::complete(value, len)\n    }\n}\n\nuse crate::response::{self, Responder};\nuse crate::request::Request;\n\nimpl<'r, 'o: 'r, T: Responder<'r, 'o>> Responder<'r, 'o> for Capped<T> {\n    fn respond_to(self, request: &'r Request<'_>) -> response::Result<'o> {\n        self.value.respond_to(request)\n    }\n}\n\nmacro_rules! impl_strict_from_form_field_from_capped {\n    ($T:ty) => (const _: () = {\n        use $crate::form::{FromFormField, ValueField, DataField, Result};\n        use $crate::data::Capped;\n\n        #[crate::async_trait]\n        impl<'v> FromFormField<'v> for $T {\n            fn default() -> Option<Self> {\n                <Capped<$T> as FromFormField<'v>>::default().map(|c| c.value)\n            }\n\n            fn from_value(f: ValueField<'v>) -> Result<'v, Self> {\n                let capped = <Capped<$T> as FromFormField<'v>>::from_value(f)?;\n                if !capped.is_complete() {\n                    Err((None, Some(capped.n.written)))?;\n                }\n\n                Ok(capped.value)\n            }\n\n            async fn from_data(field: DataField<'v, '_>) -> Result<'v, Self> {\n                let capped = <Capped<$T> as FromFormField<'v>>::from_data(field);\n                let capped = capped.await?;\n                if !capped.is_complete() {\n                    Err((None, Some(capped.n.written)))?;\n                }\n\n                Ok(capped.value)\n            }\n        }\n    };)\n}\n\nmacro_rules! impl_strict_from_data_from_capped {\n    ($T:ty) => (\n        #[crate::async_trait]\n        impl<'r> $crate::data::FromData<'r> for $T {\n            type Error = <$crate::data::Capped<Self> as $crate::data::FromData<'r>>::Error;\n\n            async fn from_data(\n                r: &'r $crate::Request<'_>,\n                d: $crate::Data<'r>\n            ) -> $crate::data::Outcome<'r, Self> {\n                use $crate::outcome::Outcome::*;\n                use std::io::{Error, ErrorKind::UnexpectedEof};\n\n                match <$crate::data::Capped<$T> as FromData>::from_data(r, d).await {\n                    Success(p) if p.is_complete() => Success(p.into_inner()),\n                    Success(_) => {\n                        let e = Error::new(UnexpectedEof, \"data limit exceeded\");\n                        Error((Status::BadRequest, e.into()))\n                    },\n                    Forward(d) => Forward(d),\n                    Error((s, e)) => Error((s, e)),\n                }\n            }\n        }\n    )\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::tokio::io::AsyncReadExt;\nuse crate::data::data_stream::DataStream;\nuse crate::data::{ByteUnit, StreamReader};\n\n/// The number of bytes to read into the \"peek\" buffer.\npub const PEEK_BYTES: usize = 512;\n\n/// Type representing the body data of a request.\n///\n/// This type is the only means by which the body of a request can be retrieved.\n/// This type is not usually used directly. Instead, data guards (types that\n/// implement [`FromData`](crate::data::FromData)) are created indirectly via\n/// code generation by specifying the `data = \"<var>\"` route parameter as\n/// follows:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type DataGuard = String;\n/// #[post(\"/submit\", data = \"<var>\")]\n/// fn submit(var: DataGuard) { /* ... */ }\n/// # fn main() { }\n/// ```\n///\n/// Above, `DataGuard` can be any type that implements `FromData`. Note that\n/// `Data` itself implements `FromData`.\n///\n/// # Reading Data\n///\n/// Data may be read from a `Data` object by calling either the\n/// [`open()`](Data::open()) or [`peek()`](Data::peek()) methods.\n///\n/// The `open` method consumes the `Data` object and returns the raw data\n/// stream. The `Data` object is consumed for safety reasons: consuming the\n/// object ensures that holding a `Data` object means that all of the data is\n/// available for reading.\n///\n/// The `peek` method returns a slice containing at most 512 bytes of buffered\n/// body data. This enables partially or fully reading from a `Data` object\n/// without consuming the `Data` object.\npub struct Data<'r> {\n    buffer: Vec<u8>,\n    is_complete: bool,\n    stream: StreamReader<'r>,\n}\n\nimpl<'r> Data<'r> {\n    /// Create a `Data` from a recognized `stream`.\n    pub(crate) fn from<S: Into<StreamReader<'r>>>(stream: S) -> Data<'r> {\n        // TODO.async: This used to also set the read timeout to 5 seconds.\n        // Such a short read timeout is likely no longer necessary, but some\n        // kind of idle timeout should be implemented.\n\n        let stream = stream.into();\n        let buffer = Vec::with_capacity(PEEK_BYTES / 8);\n        Data { buffer, stream, is_complete: false }\n    }\n\n    /// This creates a `data` object from a local data source `data`.\n    #[inline]\n    pub(crate) fn local(data: Vec<u8>) -> Data<'r> {\n        Data {\n            buffer: data,\n            stream: StreamReader::empty(),\n            is_complete: true,\n        }\n    }\n\n    /// Returns the raw data stream, limited to `limit` bytes.\n    ///\n    /// The stream contains all of the data in the body of the request,\n    /// including that in the `peek` buffer. The method consumes the `Data`\n    /// instance. This ensures that a `Data` type _always_ represents _all_ of\n    /// the data in a request.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// # const SIZE_LIMIT: u64 = 2 << 20; // 2MiB\n    /// fn handler(data: Data<'_>) {\n    ///     let stream = data.open(2.mebibytes());\n    /// }\n    /// ```\n    pub fn open(self, limit: ByteUnit) -> DataStream<'r> {\n        DataStream::new(self.buffer, self.stream, limit.into())\n    }\n\n    /// Retrieve at most `num` bytes from the `peek` buffer without consuming\n    /// `self`.\n    ///\n    /// The peek buffer contains at most 512 bytes of the body of the request.\n    /// The actual size of the returned buffer is the `min` of the request's\n    /// body, `num` and `512`. The [`peek_complete`](#method.peek_complete)\n    /// method can be used to determine if this buffer contains _all_ of the\n    /// data in the body of the request.\n    ///\n    /// # Examples\n    ///\n    /// In a data guard:\n    ///\n    /// ```rust\n    /// use rocket::request::{self, Request, FromRequest};\n    /// use rocket::data::{Data, FromData, Outcome};\n    /// use rocket::http::Status;\n    /// # struct MyType;\n    /// # type MyError = String;\n    ///\n    /// #[rocket::async_trait]\n    /// impl<'r> FromData<'r> for MyType {\n    ///     type Error = MyError;\n    ///\n    ///     async fn from_data(r: &'r Request<'_>, mut data: Data<'r>) -> Outcome<'r, Self> {\n    ///         if data.peek(2).await != b\"hi\" {\n    ///             return Outcome::Forward((data, Status::BadRequest))\n    ///         }\n    ///\n    ///         /* .. */\n    ///         # unimplemented!()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// In a fairing:\n    ///\n    /// ```\n    /// use rocket::{Rocket, Request, Data, Response};\n    /// use rocket::fairing::{Fairing, Info, Kind};\n    /// # struct MyType;\n    ///\n    /// #[rocket::async_trait]\n    /// impl Fairing for MyType {\n    ///     fn info(&self) -> Info {\n    ///         Info {\n    ///             name: \"Data Peeker\",\n    ///             kind: Kind::Request\n    ///         }\n    ///     }\n    ///\n    ///     async fn on_request(&self, req: &mut Request<'_>, data: &mut Data<'_>) {\n    ///         if data.peek(2).await == b\"hi\" {\n    ///             /* do something; body data starts with `\"hi\"` */\n    ///         }\n    ///\n    ///         /* .. */\n    ///         # unimplemented!()\n    ///     }\n    /// }\n    /// ```\n    pub async fn peek(&mut self, num: usize) -> &[u8] {\n        let num = std::cmp::min(PEEK_BYTES, num);\n        let mut len = self.buffer.len();\n        if len >= num {\n            return &self.buffer[..num];\n        }\n\n        while len < num {\n            match self.stream.read_buf(&mut self.buffer).await {\n                Ok(0) => { self.is_complete = true; break },\n                Ok(n) => len += n,\n                Err(e) => {\n                    error_!(\"Failed to read into peek buffer: {:?}.\", e);\n                    break;\n                }\n            }\n        }\n\n        &self.buffer[..std::cmp::min(len, num)]\n    }\n\n    /// Returns true if the `peek` buffer contains all of the data in the body\n    /// of the request. Returns `false` if it does not or if it is not known if\n    /// it does.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::Data;\n    ///\n    /// async fn handler(mut data: Data<'_>) {\n    ///     if data.peek_complete() {\n    ///         println!(\"All of the data: {:?}\", data.peek(512).await);\n    ///     }\n    /// }\n    /// ```\n    #[inline(always)]\n    pub fn peek_complete(&self) -> bool {\n        self.is_complete\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::pin::Pin;\nuse std::task::{Context, Poll};\nuse std::path::Path;\nuse std::io::{self, Cursor};\n\nuse tokio::fs::File;\nuse tokio::io::{AsyncRead, AsyncWrite, AsyncReadExt, ReadBuf, Take};\nuse futures::stream::Stream;\nuse futures::ready;\nuse yansi::Paint;\n\nuse crate::http::hyper;\nuse crate::ext::{PollExt, Chain};\nuse crate::data::{Capped, N};\n\n/// Raw data stream of a request body.\n///\n/// This stream can only be obtained by calling\n/// [`Data::open()`](crate::data::Data::open()) with a data limit. The stream\n/// contains all of the data in the body of the request.\n///\n/// Reading from a `DataStream` is accomplished via the various methods on the\n/// structure. In general, methods exists in two variants: those that _check_\n/// whether the entire stream was read and those that don't. The former either\n/// directly or indirectly (via [`Capped`]) return an [`N`] which allows\n/// checking if the stream was read to completion while the latter do not.\n///\n/// | Read Into | Method                               | Notes                            |\n/// |-----------|--------------------------------------|----------------------------------|\n/// | `String`  | [`DataStream::into_string()`]        | Completeness checked. Preferred. |\n/// | `String`  | [`AsyncReadExt::read_to_string()`]   | Unchecked w/existing `String`.   |\n/// | `Vec<u8>` | [`DataStream::into_bytes()`]         | Checked. Preferred.              |\n/// | `Vec<u8>` | [`DataStream::stream_to(&mut vec)`]  | Checked w/existing `Vec`.        |\n/// | `Vec<u8>` | [`DataStream::stream_precise_to()`]  | Unchecked w/existing `Vec`.      |\n/// | `File`    | [`DataStream::into_file()`]          | Checked. Preferred.              |\n/// | `File`    | [`DataStream::stream_to(&mut file)`] | Checked w/ existing `File`.      |\n/// | `File`    | [`DataStream::stream_precise_to()`]  | Unchecked w/ existing `File`.    |\n/// | `T`       | [`DataStream::stream_to()`]          | Checked. Any `T: AsyncWrite`.    |\n/// | `T`       | [`DataStream::stream_precise_to()`]  | Unchecked. Any `T: AsyncWrite`.  |\n///\n/// [`DataStream::stream_to(&mut vec)`]: DataStream::stream_to()\n/// [`DataStream::stream_to(&mut file)`]: DataStream::stream_to()\npub struct DataStream<'r> {\n    pub(crate) chain: Take<Chain<Cursor<Vec<u8>>, StreamReader<'r>>>,\n}\n\n/// An adapter: turns a `T: Stream` (in `StreamKind`) into a `tokio::AsyncRead`.\npub struct StreamReader<'r> {\n    state: State,\n    inner: StreamKind<'r>,\n}\n\n/// The current state of `StreamReader` `AsyncRead` adapter.\nenum State {\n    Pending,\n    Partial(Cursor<hyper::body::Bytes>),\n    Done,\n}\n\n/// The kinds of streams we accept as `Data`.\nenum StreamKind<'r> {\n    Empty,\n    Body(&'r mut hyper::Body),\n    Multipart(multer::Field<'r>)\n}\n\nimpl<'r> DataStream<'r> {\n    pub(crate) fn new(buf: Vec<u8>, stream: StreamReader<'r>, limit: u64) -> Self {\n        let chain = Chain::new(Cursor::new(buf), stream).take(limit).into();\n        Self { chain }\n    }\n\n    /// Whether a previous read exhausted the set limit _and then some_.\n    async fn limit_exceeded(&mut self) -> io::Result<bool> {\n        #[cold]\n        async fn _limit_exceeded(stream: &mut DataStream<'_>) -> io::Result<bool> {\n            // Read one more byte after reaching limit to see if we cut early.\n            stream.chain.set_limit(1);\n            let mut buf = [0u8; 1];\n            Ok(stream.read(&mut buf).await? != 0)\n        }\n\n        Ok(self.chain.limit() == 0 && _limit_exceeded(self).await?)\n    }\n\n    /// Number of bytes a full read from `self` will _definitely_ read.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn f(data: Data<'_>) {\n    ///     let definitely_have_n_bytes = data.open(1.kibibytes()).hint();\n    /// }\n    /// ```\n    pub fn hint(&self) -> usize {\n        let buf_len = self.chain.get_ref().get_ref().0.get_ref().len();\n        std::cmp::min(buf_len, self.chain.limit() as usize)\n    }\n\n    /// A helper method to write the body of the request to any `AsyncWrite`\n    /// type. Returns an [`N`] which indicates how many bytes were written and\n    /// whether the entire stream was read. An additional read from `self` may\n    /// be required to check if all of the stream has been read. If that\n    /// information is not needed, use [`DataStream::stream_precise_to()`].\n    ///\n    /// This method is identical to `tokio::io::copy(&mut self, &mut writer)`\n    /// except in that it returns an `N` to check for completeness.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn data_guard(mut data: Data<'_>) -> io::Result<String> {\n    ///     // write all of the data to stdout\n    ///     let written = data.open(512.kibibytes())\n    ///         .stream_to(tokio::io::stdout()).await?;\n    ///\n    ///     Ok(format!(\"Wrote {} bytes.\", written))\n    /// }\n    /// ```\n    #[inline(always)]\n    pub async fn stream_to<W>(mut self, mut writer: W) -> io::Result<N>\n        where W: AsyncWrite + Unpin\n    {\n        let written = tokio::io::copy(&mut self, &mut writer).await?;\n        Ok(N { written, complete: !self.limit_exceeded().await? })\n    }\n\n    /// Like [`DataStream::stream_to()`] except that no end-of-stream check is\n    /// conducted and thus read/write completeness is unknown.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn data_guard(mut data: Data<'_>) -> io::Result<String> {\n    ///     // write all of the data to stdout\n    ///     let written = data.open(512.kibibytes())\n    ///         .stream_precise_to(tokio::io::stdout()).await?;\n    ///\n    ///     Ok(format!(\"Wrote {} bytes.\", written))\n    /// }\n    /// ```\n    #[inline(always)]\n    pub async fn stream_precise_to<W>(mut self, mut writer: W) -> io::Result<u64>\n        where W: AsyncWrite + Unpin\n    {\n        tokio::io::copy(&mut self, &mut writer).await\n    }\n\n    /// A helper method to write the body of the request to a `Vec<u8>`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn data_guard(data: Data<'_>) -> io::Result<Vec<u8>> {\n    ///     let bytes = data.open(4.kibibytes()).into_bytes().await?;\n    ///     if !bytes.is_complete() {\n    ///         println!(\"there are bytes remaining in the stream\");\n    ///     }\n    ///\n    ///     Ok(bytes.into_inner())\n    /// }\n    /// ```\n    pub async fn into_bytes(self) -> io::Result<Capped<Vec<u8>>> {\n        let mut vec = Vec::with_capacity(self.hint());\n        let n = self.stream_to(&mut vec).await?;\n        Ok(Capped { value: vec, n })\n    }\n\n    /// A helper method to write the body of the request to a `String`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn data_guard(data: Data<'_>) -> io::Result<String> {\n    ///     let string = data.open(10.bytes()).into_string().await?;\n    ///     if !string.is_complete() {\n    ///         println!(\"there are bytes remaining in the stream\");\n    ///     }\n    ///\n    ///     Ok(string.into_inner())\n    /// }\n    /// ```\n    pub async fn into_string(mut self) -> io::Result<Capped<String>> {\n        let mut string = String::with_capacity(self.hint());\n        let written = self.read_to_string(&mut string).await?;\n        let n = N { written: written as u64, complete: !self.limit_exceeded().await? };\n        Ok(Capped { value: string, n })\n    }\n\n    /// A helper method to write the body of the request to a file at the path\n    /// determined by `path`. If a file at the path already exists, it is\n    /// overwritten. The opened file is returned.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::data::{Data, ToByteUnit};\n    ///\n    /// async fn data_guard(mut data: Data<'_>) -> io::Result<String> {\n    ///     let file = data.open(1.megabytes()).into_file(\"/static/file\").await?;\n    ///     if !file.is_complete() {\n    ///         println!(\"there are bytes remaining in the stream\");\n    ///     }\n    ///\n    ///     Ok(format!(\"Wrote {} bytes to /static/file\", file.n))\n    /// }\n    /// ```\n    pub async fn into_file<P: AsRef<Path>>(self, path: P) -> io::Result<Capped<File>> {\n        let mut file = File::create(path).await?;\n        let n = self.stream_to(&mut tokio::io::BufWriter::new(&mut file)).await?;\n        Ok(Capped { value: file, n })\n    }\n}\n\n// TODO.async: Consider implementing `AsyncBufRead`.\n\nimpl StreamReader<'_> {\n    pub fn empty() -> Self {\n        Self { inner: StreamKind::Empty, state: State::Done }\n    }\n}\n\nimpl<'r> From<&'r mut hyper::Body> for StreamReader<'r> {\n    fn from(body: &'r mut hyper::Body) -> Self {\n        Self { inner: StreamKind::Body(body), state: State::Pending }\n    }\n}\n\nimpl<'r> From<multer::Field<'r>> for StreamReader<'r> {\n    fn from(field: multer::Field<'r>) -> Self {\n        Self { inner: StreamKind::Multipart(field), state: State::Pending }\n    }\n}\n\nimpl AsyncRead for DataStream<'_> {\n    #[inline(always)]\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        if self.chain.limit() == 0 {\n            let stream: &StreamReader<'_> = &self.chain.get_ref().get_ref().1;\n            let kind = match stream.inner {\n                StreamKind::Empty => \"an empty stream (vacuous)\",\n                StreamKind::Body(_) => \"the request body\",\n                StreamKind::Multipart(_) => \"a multipart form field\",\n            };\n\n            warn_!(\"Data limit reached while reading {}.\", kind.primary().bold());\n        }\n\n        Pin::new(&mut self.chain).poll_read(cx, buf)\n    }\n}\n\nimpl Stream for StreamKind<'_> {\n    type Item = io::Result<hyper::body::Bytes>;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Option<Self::Item>> {\n        match self.get_mut() {\n            StreamKind::Body(body) => Pin::new(body).poll_next(cx)\n                .map_err_ext(|e| io::Error::new(io::ErrorKind::Other, e)),\n            StreamKind::Multipart(mp) => Pin::new(mp).poll_next(cx)\n                .map_err_ext(|e| io::Error::new(io::ErrorKind::Other, e)),\n            StreamKind::Empty => Poll::Ready(None),\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        match self {\n            StreamKind::Body(body) => body.size_hint(),\n            StreamKind::Multipart(mp) => mp.size_hint(),\n            StreamKind::Empty => (0, Some(0)),\n        }\n    }\n}\n\nimpl AsyncRead for StreamReader<'_> {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        loop {\n            self.state = match self.state {\n                State::Pending => {\n                    match ready!(Pin::new(&mut self.inner).poll_next(cx)) {\n                        Some(Err(e)) => return Poll::Ready(Err(e)),\n                        Some(Ok(bytes)) => State::Partial(Cursor::new(bytes)),\n                        None => State::Done,\n                    }\n                },\n                State::Partial(ref mut cursor) => {\n                    let rem = buf.remaining();\n                    match ready!(Pin::new(cursor).poll_read(cx, buf)) {\n                        Ok(()) if rem == buf.remaining() => State::Pending,\n                        result => return Poll::Ready(result),\n                    }\n                }\n                State::Done => return Poll::Ready(Ok(())),\n            }\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::http::{RawStr, Status};\nuse crate::request::{Request, local_cache};\nuse crate::data::{Data, Limits};\nuse crate::outcome::{self, IntoOutcome, try_outcome, Outcome::*};\n\n/// Type alias for the `Outcome` of [`FromData`].\n///\n/// [`FromData`]: crate::data::FromData\npub type Outcome<'r, T, E = <T as FromData<'r>>::Error>\n    = outcome::Outcome<T, (Status, E), (Data<'r>, Status)>;\n\n/// Trait implemented by data guards to derive a value from request body data.\n///\n/// # Data Guards\n///\n/// A data guard is a guard that operates on a request's body data. Data guards\n/// validate and parse request body data via implementations of `FromData`. In\n/// other words, a type is a data guard _iff_ it implements `FromData`.\n///\n/// Data guards are the target of the `data` route attribute parameter:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type DataGuard = String;\n/// #[post(\"/submit\", data = \"<var>\")]\n/// fn submit(var: DataGuard) { /* ... */ }\n/// ```\n///\n/// A route can have at most one data guard. Above, `var` is used as the\n/// argument name for the data guard type `DataGuard`. When the `submit` route\n/// matches, Rocket will call the `FromData` implementation for the type `T`.\n/// The handler will only be called if the guard returns successfully.\n///\n/// ## Build-In Guards\n///\n/// Rocket provides implementations for `FromData` for many types. Their\n/// behavior is documented here:\n///\n///   * `Data`: Returns the untouched `Data`.\n///\n///     - **Fails:** Never.\n///\n///     - **Succeeds:** Always.\n///\n///     - **Forwards:** Never.\n///\n///   * Strings: `Cow<str>`, `&str`, `&RawStr`, `String`\n///\n///     _Limited by the `string` [data limit]._\n///\n///     Reads the body data into a string via [`DataStream::into_string()`].\n///\n///     - **Fails:** If the body data is not valid UTF-8 or on I/O errors while\n///     reading. The error type is [`io::Error`].\n///\n///     - **Succeeds:** If the body data _is_ valid UTF-8. If the limit is\n///     exceeded, the string is truncated to the limit.\n///\n///     - **Forwards:** Never.\n///\n///   * Bytes: `&[u8]`, `Vec<u8>`\n///\n///     _Limited by the `bytes` [data limit]._\n///\n///     Reads the body data into a byte vector via [`DataStream::into_bytes()`].\n///\n///     - **Fails:** On I/O errors while reading. The error type is\n///     [`io::Error`].\n///\n///     - **Succeeds:** As long as no I/O error occurs. If the limit is\n///     exceeded, the slice is truncated to the limit.\n///\n///     - **Forwards:** Never.\n///\n///   * [`TempFile`](crate::fs::TempFile)\n///\n///     _Limited by the `file` and/or `file/$ext` [data limit]._\n///\n///     Streams the body data directly into a temporary file. The data is never\n///     buffered in memory.\n///\n///     - **Fails:** On I/O errors while reading data or creating the temporary\n///     file. The error type is [`io::Error`].\n///\n///     - **Succeeds:** As long as no I/O error occurs and the temporary file\n///     could be created. If the limit is exceeded, only data up to the limit is\n///     read and subsequently written.\n///\n///     - **Forwards:** Never.\n///\n///   * Deserializers: [`Json<T>`], [`MsgPack<T>`]\n///\n///     _Limited by the `json`, `msgpack` [data limit], respectively._\n///\n///     Reads up to the configured limit and deserializes the read data into `T`\n///     using the respective format's parser.\n///\n///     - **Fails:** On I/O errors while reading the data, or if the data fails\n///     to parse as a `T` according to the deserializer. The error type for\n///     `Json` is [`json::Error`](crate::serde::json::Error) and the error type\n///     for `MsgPack` is [`msgpack::Error`](crate::serde::msgpack::Error).\n///\n///     - **Succeeds:** As long as no I/O error occurs and the (limited) body\n///     data was successfully deserialized as a `T`.\n///\n///     - **Forwards:** Never.\n///\n///   * Forms: [`Form<T>`]\n///\n///     _Limited by the `form` or `data-form` [data limit]._\n///\n///     Parses the incoming data stream into fields according to Rocket's [field\n///     wire format], pushes each field to `T`'s [`FromForm`] [push parser], and\n///     finalizes the form. Parsing is done on the stream without reading the\n///     data into memory. If the request has as a [`ContentType::Form`], the\n///     `form` limit is applied, otherwise if the request has a\n///     [`ContentType::FormData`], the `data-form` limit is applied.\n///\n///     - **Fails:** On I/O errors while reading the data, or if the data fails\n///     to parse as a `T` according to its `FromForm` implementation. The errors\n///     are collected into an [`Errors`](crate::form::Errors), the error type.\n///\n///     - **Succeeds:** As long as no I/O error occurs and the (limited) body\n///     data was successfully parsed as a `T`.\n///\n///     - **Forwards:** If the request's `Content-Type` is neither\n///     [`ContentType::Form`] nor [`ContentType::FormData`].\n///\n///   * `Option<T>`\n///\n///     Forwards to `T`'s `FromData` implementation, capturing the outcome.\n///\n///     - **Fails:** Never.\n///\n///     - **Succeeds:** Always. If `T`'s `FromData` implementation succeeds, the\n///     parsed value is returned in `Some`. If its implementation forwards or\n///     fails, `None` is returned.\n///\n///     - **Forwards:** Never.\n///\n///   * `Result<T, T::Error>`\n///\n///     Forwards to `T`'s `FromData` implementation, capturing the outcome.\n///\n///     - **Fails:** Never.\n///\n///     - **Succeeds:** If `T`'s `FromData` implementation succeeds or fails. If\n///     it succeeds, the value is returned in `Ok`. If it fails, the error value\n///     is returned in `Err`.\n///\n///     - **Forwards:** If `T`'s implementation forwards.\n///\n///   * [`Capped<T>`]\n///\n///     Forwards to `T`'s `FromData` implementation, recording whether the data\n///     was truncated (a.k.a. capped) due to `T`'s limit being exceeded.\n///\n///     - **Fails:** If `T`'s implementation fails.\n///     - **Succeeds:** If `T`'s implementation succeeds.\n///     - **Forwards:** If `T`'s implementation forwards.\n///\n/// [data limit]: crate::data::Limits#built-in-limits\n/// [`DataStream::into_string()`]: crate::data::DataStream::into_string()\n/// [`DataStream::into_bytes()`]: crate::data::DataStream::into_bytes()\n/// [`io::Error`]: std::io::Error\n/// [`Json<T>`]: crate::serde::json::Json\n/// [`MsgPack<T>`]: crate::serde::msgpack::MsgPack\n/// [`Form<T>`]: crate::form::Form\n/// [field wire format]: crate::form#field-wire-format\n/// [`FromForm`]: crate::form::FromForm\n/// [push parser]: crate::form::FromForm#push-parsing\n/// [`ContentType::Form`]: crate::http::ContentType::Form\n/// [`ContentType::FormData`]: crate::http::ContentType::FormData\n///\n/// ## Async Trait\n///\n/// [`FromData`] is an _async_ trait. Implementations of `FromData` must be\n/// decorated with an attribute of `#[rocket::async_trait]`:\n///\n/// ```rust\n/// use rocket::request::Request;\n/// use rocket::data::{self, Data, FromData};\n/// # struct MyType;\n/// # type MyError = String;\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromData<'r> for MyType {\n///     type Error = MyError;\n///\n///     async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> data::Outcome<'r, Self> {\n///         /* .. */\n///         # unimplemented!()\n///     }\n/// }\n/// ```\n///\n/// # Example\n///\n/// Say that you have a custom type, `Person`:\n///\n/// ```rust\n/// struct Person<'r> {\n///     name: &'r str,\n///     age: u16\n/// }\n/// ```\n///\n/// `Person` has a custom serialization format, so the built-in `Json` type\n/// doesn't suffice. The format is `<name>:<age>` with `Content-Type:\n/// application/x-person`. You'd like to use `Person` as a data guard, so that\n/// you can retrieve it directly from a client's request body:\n///\n/// ```rust\n/// # use rocket::post;\n/// # type Person<'r> = &'r rocket::http::RawStr;\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person(person: Person<'_>) -> &'static str {\n///     \"Saved the new person to the database!\"\n/// }\n/// ```\n///\n/// A `FromData` implementation for such a type might look like:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// #\n/// # #[derive(Debug)]\n/// # struct Person<'r> { name: &'r str, age: u16 }\n/// #\n/// use rocket::request::{self, Request};\n/// use rocket::data::{self, Data, FromData, ToByteUnit};\n/// use rocket::http::{Status, ContentType};\n/// use rocket::outcome::Outcome;\n///\n/// #[derive(Debug)]\n/// enum Error {\n///     TooLarge,\n///     NoColon,\n///     InvalidAge,\n///     Io(std::io::Error),\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromData<'r> for Person<'r> {\n///     type Error = Error;\n///\n///     async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> data::Outcome<'r, Self> {\n///         use Error::*;\n///\n///         // Ensure the content type is correct before opening the data.\n///         let person_ct = ContentType::new(\"application\", \"x-person\");\n///         if req.content_type() != Some(&person_ct) {\n///             return Outcome::Forward((data, Status::UnsupportedMediaType));\n///         }\n///\n///         // Use a configured limit with name 'person' or fallback to default.\n///         let limit = req.limits().get(\"person\").unwrap_or(256.bytes());\n///\n///         // Read the data into a string.\n///         let string = match data.open(limit).into_string().await {\n///             Ok(string) if string.is_complete() => string.into_inner(),\n///             Ok(_) => return Outcome::Error((Status::PayloadTooLarge, TooLarge)),\n///             Err(e) => return Outcome::Error((Status::InternalServerError, Io(e))),\n///         };\n///\n///         // We store `string` in request-local cache for long-lived borrows.\n///         let string = request::local_cache!(req, string);\n///\n///         // Split the string into two pieces at ':'.\n///         let (name, age) = match string.find(':') {\n///             Some(i) => (&string[..i], &string[(i + 1)..]),\n///             None => return Outcome::Error((Status::UnprocessableEntity, NoColon)),\n///         };\n///\n///         // Parse the age.\n///         let age: u16 = match age.parse() {\n///             Ok(age) => age,\n///             Err(_) => return Outcome::Error((Status::UnprocessableEntity, InvalidAge)),\n///         };\n///\n///         Outcome::Success(Person { name, age })\n///     }\n/// }\n///\n/// // The following routes now typecheck...\n///\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person(person: Person<'_>) { /* .. */ }\n///\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person2(person: Result<Person<'_>, Error>) { /* .. */ }\n///\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person3(person: Option<Person<'_>>) { /* .. */ }\n///\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person4(person: Person<'_>) -> &str {\n///     // Note that this is only possible because the data in `person` live\n///     // as long as the request through request-local cache.\n///     person.name\n/// }\n/// ```\n#[crate::async_trait]\npub trait FromData<'r>: Sized {\n    /// The associated error to be returned when the guard fails.\n    type Error: Send + std::fmt::Debug;\n\n    /// Asynchronously validates, parses, and converts an instance of `Self`\n    /// from the incoming request body data.\n    ///\n    /// If validation and parsing succeeds, an outcome of `Success` is returned.\n    /// If the data is not appropriate given the type of `Self`, `Forward` is\n    /// returned. If parsing fails, `Error` is returned.\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self>;\n}\n\nuse crate::data::Capped;\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<String> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let limit = req.limits().get(\"string\").unwrap_or(Limits::STRING);\n        data.open(limit).into_string().await.or_error(Status::BadRequest)\n    }\n}\n\nimpl_strict_from_data_from_capped!(String);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<&'r str> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let capped = try_outcome!(<Capped<String>>::from_data(req, data).await);\n        let string = capped.map(|s| local_cache!(req, s));\n        Success(string)\n    }\n}\n\nimpl_strict_from_data_from_capped!(&'r str);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<&'r RawStr> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let capped = try_outcome!(<Capped<String>>::from_data(req, data).await);\n        let raw = capped.map(|s| RawStr::new(local_cache!(req, s)));\n        Success(raw)\n    }\n}\n\nimpl_strict_from_data_from_capped!(&'r RawStr);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<std::borrow::Cow<'_, str>> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let capped = try_outcome!(<Capped<String>>::from_data(req, data).await);\n        Success(capped.map(|s| s.into()))\n    }\n}\n\nimpl_strict_from_data_from_capped!(std::borrow::Cow<'_, str>);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<&'r [u8]> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let capped = try_outcome!(<Capped<Vec<u8>>>::from_data(req, data).await);\n        let raw = capped.map(|b| local_cache!(req, b));\n        Success(raw)\n    }\n}\n\nimpl_strict_from_data_from_capped!(&'r [u8]);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<Vec<u8>> {\n    type Error = std::io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        let limit = req.limits().get(\"bytes\").unwrap_or(Limits::BYTES);\n        data.open(limit).into_bytes().await.or_error(Status::BadRequest)\n    }\n}\n\nimpl_strict_from_data_from_capped!(Vec<u8>);\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Data<'r> {\n    type Error = std::convert::Infallible;\n\n    async fn from_data(_: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        Success(data)\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromData<'r> + 'r> FromData<'r> for Result<T, T::Error> {\n    type Error = std::convert::Infallible;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        match T::from_data(req, data).await {\n            Success(v) => Success(Ok(v)),\n            Error((_, e)) => Success(Err(e)),\n            Forward(d) => Forward(d),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromData<'r>> FromData<'r> for Option<T> {\n    type Error = std::convert::Infallible;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        match T::from_data(req, data).await {\n            Success(v) => Success(Some(v)),\n            Error(..) | Forward(..) => Success(None),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::io;\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\n\nuse tokio::io::{AsyncRead, AsyncWrite, ReadBuf};\n\nuse crate::http::hyper::upgrade::Upgraded;\n\n/// A bidirectional, raw stream to the client.\n///\n/// An instance of `IoStream` is passed to an [`IoHandler`] in response to a\n/// successful upgrade request initiated by responders via\n/// [`Response::add_upgrade()`] or the equivalent builder method\n/// [`Builder::upgrade()`]. For details on upgrade connections, see\n/// [`Response`#upgrading].\n///\n/// An `IoStream` is guaranteed to be [`AsyncRead`], [`AsyncWrite`], and\n/// `Unpin`. Bytes written to the stream are sent directly to the client. Bytes\n/// read from the stream are those sent directly _by_ the client. See\n/// [`IoHandler`] for one example of how values of this type are used.\n///\n/// [`Response::add_upgrade()`]: crate::Response::add_upgrade()\n/// [`Builder::upgrade()`]: crate::response::Builder::upgrade()\n/// [`Response`#upgrading]: crate::response::Response#upgrading\npub struct IoStream {\n    kind: IoStreamKind,\n}\n\n/// Just in case we want to add stream kinds in the future.\nenum IoStreamKind {\n    Upgraded(Upgraded)\n}\n\n/// An upgraded connection I/O handler.\n///\n/// An I/O handler performs raw I/O via the passed in [`IoStream`], which is\n/// [`AsyncRead`], [`AsyncWrite`], and `Unpin`.\n///\n/// # Example\n///\n/// The example below implements an `EchoHandler` that echos the raw bytes back\n/// to the client.\n///\n/// ```rust\n/// use std::pin::Pin;\n///\n/// use rocket::tokio::io;\n/// use rocket::data::{IoHandler, IoStream};\n///\n/// struct EchoHandler;\n///\n/// #[rocket::async_trait]\n/// impl IoHandler for EchoHandler {\n///     async fn io(self: Pin<Box<Self>>, io: IoStream) -> io::Result<()> {\n///         let (mut reader, mut writer) = io::split(io);\n///         io::copy(&mut reader, &mut writer).await?;\n///         Ok(())\n///     }\n/// }\n///\n/// # use rocket::Response;\n/// # rocket::async_test(async {\n/// # let mut response = Response::new();\n/// # response.add_upgrade(\"raw-echo\", EchoHandler);\n/// # assert!(response.upgrade(\"raw-echo\").is_some());\n/// # })\n/// ```\n#[crate::async_trait]\npub trait IoHandler: Send {\n    /// Performs the raw I/O.\n    async fn io(self: Pin<Box<Self>>, io: IoStream) -> io::Result<()>;\n}\n\n#[doc(hidden)]\nimpl From<Upgraded> for IoStream {\n    fn from(io: Upgraded) -> Self {\n        IoStream { kind: IoStreamKind::Upgraded(io) }\n    }\n}\n\n/// A \"trait alias\" of sorts so we can use `AsyncRead + AsyncWrite + Unpin` in `dyn`.\npub trait AsyncReadWrite: AsyncRead + AsyncWrite + Unpin { }\n\n/// Implemented for all `AsyncRead + AsyncWrite + Unpin`, of course.\nimpl<T: AsyncRead + AsyncWrite + Unpin> AsyncReadWrite for T {  }\n\nimpl IoStream {\n    /// Returns the internal I/O stream.\n    fn inner_mut(&mut self) -> Pin<&mut dyn AsyncReadWrite> {\n        match self.kind {\n            IoStreamKind::Upgraded(ref mut io) => Pin::new(io),\n        }\n    }\n\n    /// Returns `true` if the inner I/O stream is write vectored.\n    fn inner_is_write_vectored(&self) -> bool {\n        match self.kind {\n            IoStreamKind::Upgraded(ref io) => io.is_write_vectored(),\n        }\n    }\n}\n\nimpl AsyncRead for IoStream {\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        self.get_mut().inner_mut().poll_read(cx, buf)\n    }\n}\n\nimpl AsyncWrite for IoStream {\n    fn poll_write(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        self.get_mut().inner_mut().poll_write(cx, buf)\n    }\n\n    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.get_mut().inner_mut().poll_flush(cx)\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.get_mut().inner_mut().poll_shutdown(cx)\n    }\n\n    fn poll_write_vectored(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        bufs: &[io::IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        self.get_mut().inner_mut().poll_write_vectored(cx, bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner_is_write_vectored()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_unpin() {\n        fn check_traits<T: AsyncRead + AsyncWrite + Unpin + Send>() {}\n        check_traits::<IoStream>();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse serde::{Serialize, Deserialize};\nuse crate::request::{Request, FromRequest, Outcome};\n\nuse crate::data::ByteUnit;\nuse crate::http::uncased::Uncased;\n\n/// Mapping from (hierarchical) data types to size limits.\n///\n/// A `Limits` structure contains a mapping from a given hierarchical data type\n/// (\"form\", \"data-form\", \"ext/pdf\", and so on) to the maximum size in bytes\n/// that should be accepted by Rocket for said data type. For instance, if the\n/// limit for \"form\" is set to `256`, only 256 bytes from an incoming non-data\n/// form (that is, url-encoded) will be accepted.\n///\n/// To help in preventing DoS attacks, all incoming data reads must capped by a\n/// limit. As such, all data guards impose a limit. The _name_ of the limit is\n/// dictated by the data guard or type itself. For instance, [`Form`] imposes\n/// the `form` limit for value-based forms and `data-form` limit for data-based\n/// forms.\n///\n/// If a limit is exceeded, a guard will typically fail. The [`Capped`] type\n/// allows retrieving some data types even when the limit is exceeded.\n///\n/// [`Capped`]: crate::data::Capped\n/// [`Form`]: crate::form::Form\n///\n/// # Hierarchy\n///\n/// Data limits are hierarchical. The `/` (forward slash) character delimits the\n/// levels, or layers, of a given limit. To obtain a limit value for a given\n/// name, layers are peeled from right to left until a match is found, if any.\n/// For example, fetching the limit named `pet/dog/bingo` will return the first\n/// of `pet/dog/bingo`, `pet/dog` or `pet`:\n///\n/// ```rust\n/// use rocket::data::{Limits, ToByteUnit};\n///\n/// let limits = Limits::default()\n///     .limit(\"pet\", 64.kibibytes())\n///     .limit(\"pet/dog\", 128.kibibytes())\n///     .limit(\"pet/dog/bingo\", 96.kibibytes());\n///\n/// assert_eq!(limits.get(\"pet/dog/bingo\"), Some(96.kibibytes()));\n/// assert_eq!(limits.get(\"pet/dog/ralph\"), Some(128.kibibytes()));\n/// assert_eq!(limits.get(\"pet/cat/bingo\"), Some(64.kibibytes()));\n///\n/// assert_eq!(limits.get(\"pet/dog/bingo/hat\"), Some(96.kibibytes()));\n/// ```\n///\n/// # Built-in Limits\n///\n/// The following table details recognized built-in limits used by Rocket.\n///\n/// | Limit Name        | Default | Type         | Description                           |\n/// |-------------------|---------|--------------|---------------------------------------|\n/// | `form`            | 32KiB   | [`Form`]     | entire non-data-based form            |\n/// | `data-form`       | 2MiB    | [`Form`]     | entire data-based form                |\n/// | `file`            | 1MiB    | [`TempFile`] | [`TempFile`] data guard or form field |\n/// | `file/$ext`       | _N/A_   | [`TempFile`] | file form field with extension `$ext` |\n/// | `string`          | 8KiB    | [`String`]   | data guard or form field              |\n/// | `string`          | 8KiB    | [`&str`]     | data guard or form field              |\n/// | `bytes`           | 8KiB    | [`Vec<u8>`]  | data guard                            |\n/// | `bytes`           | 8KiB    | [`&[u8]`]    | data guard or form field              |\n/// | `json`            | 1MiB    | [`Json`]     | JSON data and form payloads           |\n/// | `msgpack`         | 1MiB    | [`MsgPack`]  | MessagePack data and form payloads    |\n///\n/// [`TempFile`]: crate::fs::TempFile\n/// [`Json`]: crate::serde::json::Json\n/// [`MsgPack`]: crate::serde::msgpack::MsgPack\n///\n/// # Usage\n///\n/// A `Limits` structure is created following the builder pattern:\n///\n/// ```rust\n/// use rocket::data::{Limits, ToByteUnit};\n///\n/// // Set a limit of 64KiB for forms, 3MiB for PDFs, and 1MiB for JSON.\n/// let limits = Limits::default()\n///     .limit(\"form\", 64.kibibytes())\n///     .limit(\"file/pdf\", 3.mebibytes())\n///     .limit(\"json\", 2.mebibytes());\n/// ```\n///\n/// The [`Limits::default()`](#impl-Default) method populates the `Limits`\n/// structure with default limits in the [table above](#built-in-limits). A\n/// configured limit can be retrieved via the `&Limits` request guard:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use std::io;\n///\n/// use rocket::data::{Data, Limits, ToByteUnit};\n///\n/// #[post(\"/echo\", data = \"<data>\")]\n/// async fn echo(data: Data<'_>, limits: &Limits) -> io::Result<String> {\n///     let limit = limits.get(\"data\").unwrap_or(1.mebibytes());\n///     Ok(data.open(limit).into_string().await?.value)\n/// }\n/// ```\n///\n/// ...or via the [`Request::limits()`] method:\n///\n/// ```\n/// # #[macro_use] extern crate rocket;\n/// use rocket::request::Request;\n/// use rocket::data::{self, Data, FromData};\n///\n/// # struct MyType;\n/// # type MyError = ();\n/// #[rocket::async_trait]\n/// impl<'r> FromData<'r> for MyType {\n///     type Error = MyError;\n///\n///     async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> data::Outcome<'r, Self> {\n///         let limit = req.limits().get(\"my-data-type\");\n///         /* .. */\n///         # unimplemented!()\n///     }\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(transparent)]\npub struct Limits {\n    #[serde(deserialize_with = \"Limits::deserialize\")]\n    #[serde(serialize_with = \"figment::util::vec_tuple_map::serialize\")]\n    limits: Vec<(Uncased<'static>, ByteUnit)>,\n}\n\nimpl Default for Limits {\n    fn default() -> Limits {\n        Limits::new()\n            .limit(\"form\", Limits::FORM)\n            .limit(\"data-form\", Limits::DATA_FORM)\n            .limit(\"file\", Limits::FILE)\n            .limit(\"string\", Limits::STRING)\n            .limit(\"bytes\", Limits::BYTES)\n            .limit(\"json\", Limits::JSON)\n            .limit(\"msgpack\", Limits::MESSAGE_PACK)\n    }\n}\n\nimpl Limits {\n    /// Default limit for value-based forms.\n    pub const FORM: ByteUnit = ByteUnit::Kibibyte(32);\n\n    /// Default limit for data-based forms.\n    pub const DATA_FORM: ByteUnit = ByteUnit::Mebibyte(2);\n\n    /// Default limit for temporary files.\n    pub const FILE: ByteUnit = ByteUnit::Mebibyte(1);\n\n    /// Default limit for strings.\n    pub const STRING: ByteUnit = ByteUnit::Kibibyte(8);\n\n    /// Default limit for bytes.\n    pub const BYTES: ByteUnit = ByteUnit::Kibibyte(8);\n\n    /// Default limit for JSON payloads.\n    pub const JSON: ByteUnit = ByteUnit::Mebibyte(1);\n\n    /// Default limit for MessagePack payloads.\n    pub const MESSAGE_PACK: ByteUnit = ByteUnit::Mebibyte(1);\n\n    /// Construct a new `Limits` structure with no limits set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Limits, ToByteUnit};\n    ///\n    /// let limits = Limits::default();\n    /// assert_eq!(limits.get(\"form\"), Some(32.kibibytes()));\n    ///\n    /// let limits = Limits::new();\n    /// assert_eq!(limits.get(\"form\"), None);\n    /// ```\n    #[inline]\n    pub fn new() -> Self {\n        Limits { limits: vec![] }\n    }\n\n    /// Adds or replaces a limit in `self`, consuming `self` and returning a new\n    /// `Limits` structure with the added or replaced limit.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Limits, ToByteUnit};\n    ///\n    /// let limits = Limits::default();\n    /// assert_eq!(limits.get(\"form\"), Some(32.kibibytes()));\n    /// assert_eq!(limits.get(\"json\"), Some(1.mebibytes()));\n    /// assert_eq!(limits.get(\"cat\"), None);\n    ///\n    /// let limits = limits.limit(\"cat\", 1.mebibytes());\n    /// assert_eq!(limits.get(\"form\"), Some(32.kibibytes()));\n    /// assert_eq!(limits.get(\"cat\"), Some(1.mebibytes()));\n    ///\n    /// let limits = limits.limit(\"json\", 64.mebibytes());\n    /// assert_eq!(limits.get(\"json\"), Some(64.mebibytes()));\n    /// ```\n    pub fn limit<S: Into<Uncased<'static>>>(mut self, name: S, limit: ByteUnit) -> Self {\n        let name = name.into();\n        match self.limits.binary_search_by(|(k, _)| k.cmp(&name)) {\n            Ok(i) => self.limits[i].1 = limit,\n            Err(i) => self.limits.insert(i, (name, limit))\n        }\n\n        self\n    }\n\n    /// Returns the limit named `name`, proceeding hierarchically from right\n    /// to left until one is found, or returning `None` if none is found.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Limits, ToByteUnit};\n    ///\n    /// let limits = Limits::default()\n    ///     .limit(\"json\", 2.mebibytes())\n    ///     .limit(\"file/jpeg\", 4.mebibytes())\n    ///     .limit(\"file/jpeg/special\", 8.mebibytes());\n    ///\n    /// assert_eq!(limits.get(\"form\"), Some(32.kibibytes()));\n    /// assert_eq!(limits.get(\"json\"), Some(2.mebibytes()));\n    /// assert_eq!(limits.get(\"data-form\"), Some(Limits::DATA_FORM));\n    ///\n    /// assert_eq!(limits.get(\"file\"), Some(1.mebibytes()));\n    /// assert_eq!(limits.get(\"file/png\"), Some(1.mebibytes()));\n    /// assert_eq!(limits.get(\"file/jpeg\"), Some(4.mebibytes()));\n    /// assert_eq!(limits.get(\"file/jpeg/inner\"), Some(4.mebibytes()));\n    /// assert_eq!(limits.get(\"file/jpeg/special\"), Some(8.mebibytes()));\n    ///\n    /// assert!(limits.get(\"cats\").is_none());\n    /// ```\n    pub fn get<S: AsRef<str>>(&self, name: S) -> Option<ByteUnit> {\n        let mut name = name.as_ref();\n        let mut indices = name.rmatch_indices('/');\n        loop {\n            let exact_limit = self.limits\n                .binary_search_by(|(k, _)| k.as_uncased_str().cmp(name.into()))\n                .map(|i| self.limits[i].1);\n\n            if let Ok(exact) = exact_limit {\n                return Some(exact);\n            }\n\n            let (i, _) = indices.next()?;\n            name = &name[..i];\n        }\n    }\n\n    /// Returns the limit for the name created by joining the strings in\n    /// `layers` with `/` as a separator, then proceeding like\n    /// [`Limits::get()`], hierarchically from right to left until one is found,\n    /// or returning `None` if none is found.\n    ///\n    /// This methods exists to allow finding hierarchical limits without\n    /// constructing a string to call `get()` with but otherwise returns the\n    /// same results.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::{Limits, ToByteUnit};\n    ///\n    /// let limits = Limits::default()\n    ///     .limit(\"json\", 2.mebibytes())\n    ///     .limit(\"file/jpeg\", 4.mebibytes())\n    ///     .limit(\"file/jpeg/special\", 8.mebibytes());\n    ///\n    /// assert_eq!(limits.find([\"json\"]), Some(2.mebibytes()));\n    /// assert_eq!(limits.find([\"json\", \"person\"]), Some(2.mebibytes()));\n    ///\n    /// assert_eq!(limits.find([\"file\"]), Some(1.mebibytes()));\n    /// assert_eq!(limits.find([\"file\", \"png\"]), Some(1.mebibytes()));\n    /// assert_eq!(limits.find([\"file\", \"jpeg\"]), Some(4.mebibytes()));\n    /// assert_eq!(limits.find([\"file\", \"jpeg\", \"inner\"]), Some(4.mebibytes()));\n    /// assert_eq!(limits.find([\"file\", \"jpeg\", \"special\"]), Some(8.mebibytes()));\n    ///\n    /// # let s: &[&str] = &[]; assert_eq!(limits.find(s), None);\n    /// ```\n    pub fn find<S: AsRef<str>, L: AsRef<[S]>>(&self, layers: L) -> Option<ByteUnit> {\n        let layers = layers.as_ref();\n        for j in (1..=layers.len()).rev() {\n            let layers = &layers[..j];\n            let opt = self.limits\n                .binary_search_by(|(k, _)| {\n                    let k_layers = k.as_str().split('/');\n                    k_layers.cmp(layers.iter().map(|s| s.as_ref()))\n                })\n                .map(|i| self.limits[i].1);\n\n            if let Ok(byte_unit) = opt {\n                return Some(byte_unit);\n            }\n        }\n\n        None\n    }\n\n    /// Deserialize a `Limits` vector from a map. Ensures that the resulting\n    /// vector is properly sorted for futures lookups via binary search.\n    fn deserialize<'de, D>(de: D) -> Result<Vec<(Uncased<'static>, ByteUnit)>, D::Error>\n        where D: serde::Deserializer<'de>\n    {\n        let mut limits = figment::util::vec_tuple_map::deserialize(de)?;\n        limits.sort();\n        Ok(limits)\n    }\n}\n\nimpl fmt::Display for Limits {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for (i, (k, v)) in self.limits.iter().enumerate() {\n            if i != 0 { f.write_str(\", \")? }\n            write!(f, \"{} = {}\", k, v)?;\n        }\n\n        Ok(())\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Limits {\n    type Error = std::convert::Infallible;\n\n    async fn from_request(req: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n        Outcome::Success(req.limits())\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types and traits for handling incoming body data.\n\n#[macro_use]\nmod capped;\nmod data;\nmod data_stream;\nmod from_data;\nmod limits;\nmod io_stream;\n\npub use self::data::Data;\npub use self::data_stream::DataStream;\npub use self::from_data::{FromData, Outcome};\npub use self::limits::Limits;\npub use self::capped::{N, Capped};\npub use self::io_stream::{IoHandler, IoStream};\npub use ubyte::{ByteUnit, ToByteUnit};\n\npub(crate) use self::data_stream::StreamReader;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use futures::future::{Future, BoxFuture, FutureExt};\nuse parking_lot::Mutex;\n\nuse crate::{Rocket, Request, Response, Data, Build, Orbit};\nuse crate::fairing::{Fairing, Kind, Info, Result};\n\n/// A ad-hoc fairing that can be created from a function or closure.\n///\n/// This enum can be used to create a fairing from a simple function or closure\n/// without creating a new structure or implementing `Fairing` directly.\n///\n/// # Usage\n///\n/// Use [`AdHoc::on_ignite`], [`AdHoc::on_liftoff`], [`AdHoc::on_request()`], or\n/// [`AdHoc::on_response()`] to create an `AdHoc` structure from a function or\n/// closure. Then, simply attach the structure to the `Rocket` instance.\n///\n/// # Example\n///\n/// The following snippet creates a `Rocket` instance with two ad-hoc fairings.\n/// The first, a liftoff fairing named \"Liftoff Printer\", simply prints a message\n/// indicating that Rocket has launched. The second named \"Put Rewriter\", a\n/// request fairing, rewrites the method of all requests to be `PUT`.\n///\n/// ```rust\n/// use rocket::fairing::AdHoc;\n/// use rocket::http::Method;\n///\n/// rocket::build()\n///     .attach(AdHoc::on_liftoff(\"Liftoff Printer\", |_| Box::pin(async move {\n///         println!(\"...annnddd we have liftoff!\");\n///     })))\n///     .attach(AdHoc::on_request(\"Put Rewriter\", |req, _| Box::pin(async move {\n///         req.set_method(Method::Put);\n///     })));\n/// ```\npub struct AdHoc {\n    name: &'static str,\n    kind: AdHocKind,\n}\n\nstruct Once<F: ?Sized>(Mutex<Option<Box<F>>>);\n\nimpl<F: ?Sized> Once<F> {\n    fn new(f: Box<F>) -> Self { Once(Mutex::new(Some(f))) }\n\n    #[track_caller]\n    fn take(&self) -> Box<F> {\n        self.0.lock().take().expect(\"Once::take() called once\")\n    }\n}\n\nenum AdHocKind {\n    /// An ad-hoc **ignite** fairing. Called during ignition.\n    Ignite(Once<dyn FnOnce(Rocket<Build>) -> BoxFuture<'static, Result> + Send + 'static>),\n\n    /// An ad-hoc **liftoff** fairing. Called just after Rocket launches.\n    Liftoff(Once<dyn for<'a> FnOnce(&'a Rocket<Orbit>) -> BoxFuture<'a, ()> + Send + 'static>),\n\n    /// An ad-hoc **request** fairing. Called when a request is received.\n    Request(Box<dyn for<'a> Fn(&'a mut Request<'_>, &'a Data<'_>)\n        -> BoxFuture<'a, ()> + Send + Sync + 'static>),\n\n    /// An ad-hoc **response** fairing. Called when a response is ready to be\n    /// sent to a client.\n    Response(Box<dyn for<'r, 'b> Fn(&'r Request<'_>, &'b mut Response<'r>)\n        -> BoxFuture<'b, ()> + Send + Sync + 'static>),\n\n    /// An ad-hoc **shutdown** fairing. Called on shutdown.\n    Shutdown(Once<dyn for<'a> FnOnce(&'a Rocket<Orbit>) -> BoxFuture<'a, ()> + Send + 'static>),\n}\n\nimpl AdHoc {\n    /// Constructs an `AdHoc` ignite fairing named `name`. The function `f` will\n    /// be called by Rocket during the [`Rocket::ignite()`] phase.\n    ///\n    /// This version of an `AdHoc` ignite fairing cannot abort ignite. For a\n    /// fallible version that can, see [`AdHoc::try_on_ignite()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // The no-op ignite fairing.\n    /// let fairing = AdHoc::on_ignite(\"Boom!\", |rocket| async move {\n    ///     rocket\n    /// });\n    /// ```\n    pub fn on_ignite<F, Fut>(name: &'static str, f: F) -> AdHoc\n        where F: FnOnce(Rocket<Build>) -> Fut + Send + 'static,\n              Fut: Future<Output = Rocket<Build>> + Send + 'static,\n    {\n        AdHoc::try_on_ignite(name, |rocket| f(rocket).map(Ok))\n    }\n\n    /// Constructs an `AdHoc` ignite fairing named `name`. The function `f` will\n    /// be called by Rocket during the [`Rocket::ignite()`] phase. Returning an\n    /// `Err` aborts ignition and thus launch.\n    ///\n    /// For an infallible version, see [`AdHoc::on_ignite()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // The no-op try ignite fairing.\n    /// let fairing = AdHoc::try_on_ignite(\"No-Op\", |rocket| async { Ok(rocket) });\n    /// ```\n    pub fn try_on_ignite<F, Fut>(name: &'static str, f: F) -> AdHoc\n        where F: FnOnce(Rocket<Build>) -> Fut + Send + 'static,\n              Fut: Future<Output = Result> + Send + 'static,\n    {\n        AdHoc { name, kind: AdHocKind::Ignite(Once::new(Box::new(|r| f(r).boxed()))) }\n    }\n\n    /// Constructs an `AdHoc` liftoff fairing named `name`. The function `f`\n    /// will be called by Rocket just after [`Rocket::launch()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // A fairing that prints a message just before launching.\n    /// let fairing = AdHoc::on_liftoff(\"Boom!\", |_| Box::pin(async move {\n    ///     println!(\"Rocket has lifted off!\");\n    /// }));\n    /// ```\n    pub fn on_liftoff<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc\n        where F: for<'a> FnOnce(&'a Rocket<Orbit>) -> BoxFuture<'a, ()>\n    {\n        AdHoc { name, kind: AdHocKind::Liftoff(Once::new(Box::new(f))) }\n    }\n\n    /// Constructs an `AdHoc` request fairing named `name`. The function `f`\n    /// will be called and the returned `Future` will be `await`ed by Rocket\n    /// when a new request is received.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // The no-op request fairing.\n    /// let fairing = AdHoc::on_request(\"Dummy\", |req, data| {\n    ///     Box::pin(async move {\n    ///         // do something with the request and data...\n    /// #       let (_, _) = (req, data);\n    ///     })\n    /// });\n    /// ```\n    pub fn on_request<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc\n        where F: for<'a> Fn(&'a mut Request<'_>, &'a Data<'_>) -> BoxFuture<'a, ()>\n    {\n        AdHoc { name, kind: AdHocKind::Request(Box::new(f)) }\n    }\n\n    // FIXME(rustc): We'd like to allow passing `async fn` to these methods...\n    // https://github.com/rust-lang/rust/issues/64552#issuecomment-666084589\n\n    /// Constructs an `AdHoc` response fairing named `name`. The function `f`\n    /// will be called and the returned `Future` will be `await`ed by Rocket\n    /// when a response is ready to be sent.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // The no-op response fairing.\n    /// let fairing = AdHoc::on_response(\"Dummy\", |req, resp| {\n    ///     Box::pin(async move {\n    ///         // do something with the request and pending response...\n    /// #       let (_, _) = (req, resp);\n    ///     })\n    /// });\n    /// ```\n    pub fn on_response<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc\n        where F: for<'b, 'r> Fn(&'r Request<'_>, &'b mut Response<'r>) -> BoxFuture<'b, ()>\n    {\n        AdHoc { name, kind: AdHocKind::Response(Box::new(f)) }\n    }\n\n    /// Constructs an `AdHoc` shutdown fairing named `name`. The function `f`\n    /// will be called by Rocket when [shutdown is triggered].\n    ///\n    /// [shutdown is triggered]: crate::config::Shutdown#triggers\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// // A fairing that prints a message just before launching.\n    /// let fairing = AdHoc::on_shutdown(\"Bye!\", |_| Box::pin(async move {\n    ///     println!(\"Rocket is on its way back!\");\n    /// }));\n    /// ```\n    pub fn on_shutdown<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc\n        where F: for<'a> FnOnce(&'a Rocket<Orbit>) -> BoxFuture<'a, ()>\n    {\n        AdHoc { name, kind: AdHocKind::Shutdown(Once::new(Box::new(f))) }\n    }\n\n    /// Constructs an `AdHoc` launch fairing that extracts a configuration of\n    /// type `T` from the configured provider and stores it in managed state. If\n    /// extractions fails, pretty-prints the error message and aborts launch.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::launch;\n    /// use serde::Deserialize;\n    /// use rocket::fairing::AdHoc;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Config {\n    ///     field: String,\n    ///     other: usize,\n    ///     /* and so on.. */\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().attach(AdHoc::config::<Config>())\n    /// }\n    /// ```\n    pub fn config<'de, T>() -> AdHoc\n        where T: serde::Deserialize<'de> + Send + Sync + 'static\n    {\n        AdHoc::try_on_ignite(std::any::type_name::<T>(), |rocket| async {\n            let app_config = match rocket.figment().extract::<T>() {\n                Ok(config) => config,\n                Err(e) => {\n                    crate::config::pretty_print_error(e);\n                    return Err(rocket);\n                }\n            };\n\n            Ok(rocket.manage(app_config))\n        })\n    }\n}\n\n#[crate::async_trait]\nimpl Fairing for AdHoc {\n    fn info(&self) -> Info {\n        let kind = match self.kind {\n            AdHocKind::Ignite(_) => Kind::Ignite,\n            AdHocKind::Liftoff(_) => Kind::Liftoff,\n            AdHocKind::Request(_) => Kind::Request,\n            AdHocKind::Response(_) => Kind::Response,\n            AdHocKind::Shutdown(_) => Kind::Shutdown,\n        };\n\n        Info { name: self.name, kind }\n    }\n\n    async fn on_ignite(&self, rocket: Rocket<Build>) -> Result {\n        match self.kind {\n            AdHocKind::Ignite(ref f) => (f.take())(rocket).await,\n            _ => Ok(rocket)\n        }\n    }\n\n    async fn on_liftoff(&self, rocket: &Rocket<Orbit>) {\n        if let AdHocKind::Liftoff(ref f) = self.kind {\n            (f.take())(rocket).await\n        }\n    }\n\n    async fn on_request(&self, req: &mut Request<'_>, data: &mut Data<'_>) {\n        if let AdHocKind::Request(ref f) = self.kind {\n            f(req, data).await\n        }\n    }\n\n    async fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n        if let AdHocKind::Response(ref f) = self.kind {\n            f(req, res).await\n        }\n    }\n\n    async fn on_shutdown(&self, rocket: &Rocket<Orbit>) {\n        if let AdHocKind::Shutdown(ref f) = self.kind {\n            (f.take())(rocket).await\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::collections::HashSet;\n\nuse crate::{Rocket, Request, Response, Data, Build, Orbit};\nuse crate::fairing::{Fairing, Info, Kind};\nuse crate::log::PaintExt;\n\nuse yansi::Paint;\n\n#[derive(Default)]\npub struct Fairings {\n    // NOTE: This is a push-only vector due to the index-vectors below!\n    all_fairings: Vec<Box<dyn Fairing>>,\n    // Ignite fairings that have failed.\n    failures: Vec<Info>,\n    // The number of ignite fairings from `self.ignite` we've run.\n    num_ignited: usize,\n    // The vectors below hold indices into `all_fairings`.\n    ignite: Vec<usize>,\n    liftoff: Vec<usize>,\n    request: Vec<usize>,\n    response: Vec<usize>,\n    shutdown: Vec<usize>,\n}\n\nmacro_rules! iter {\n    ($_self:ident . $kind:ident) => ({\n        iter!($_self, $_self.$kind.iter()).map(|v| v.1)\n    });\n    ($_self:ident, $indices:expr) => ({\n        let all_fairings = &$_self.all_fairings;\n        $indices.filter_map(move |i| {\n            debug_assert!(all_fairings.get(*i).is_some());\n            let f = all_fairings.get(*i).map(|f| &**f)?;\n            Some((*i, f))\n        })\n    })\n}\n\nimpl Fairings {\n    #[inline]\n    pub fn new() -> Fairings {\n        Fairings::default()\n    }\n\n    pub fn active(&self) -> impl Iterator<Item = &usize> {\n        self.ignite.iter()\n            .chain(self.liftoff.iter())\n            .chain(self.request.iter())\n            .chain(self.response.iter())\n            .chain(self.shutdown.iter())\n    }\n\n    pub fn add(&mut self, fairing: Box<dyn Fairing>) {\n        let this = &fairing;\n        let this_info = this.info();\n        if this_info.kind.is(Kind::Singleton) {\n            // If we already ran a duplicate on ignite, then fail immediately.\n            // There is no way to uphold the \"only run last singleton\" promise.\n            //\n            // How can this happen? Like this:\n            //   1. Attach A (singleton).\n            //   2. Attach B (any fairing).\n            //   3. Ignite.\n            //   4. A executes on_ignite.\n            //   5. B executes on_ignite, attaches another A.\n            //   6. --- (A would run if not for this code)\n            let ignite_dup = iter!(self.ignite).position(|f| f.type_id() == this.type_id());\n            if let Some(dup_ignite_index) = ignite_dup {\n                if dup_ignite_index < self.num_ignited {\n                    self.failures.push(this_info);\n                    return;\n                }\n            }\n\n            // Finds `k` in `from` and removes it if it's there.\n            let remove = |k: usize, from: &mut Vec<usize>| {\n                if let Ok(j) = from.binary_search(&k) {\n                    from.remove(j);\n                }\n            };\n\n            // Collect all of the active duplicates.\n            let mut dups: Vec<usize> = iter!(self, self.active())\n                .filter(|(_, f)| f.type_id() == this.type_id())\n                .map(|(i, _)| i)\n                .collect();\n\n            // Reverse the dup indices so `remove` is stable given shifts.\n            dups.sort(); dups.dedup(); dups.reverse();\n            for i in dups {\n                remove(i, &mut self.ignite);\n                remove(i, &mut self.liftoff);\n                remove(i, &mut self.request);\n                remove(i, &mut self.response);\n                remove(i, &mut self.shutdown);\n            }\n        }\n\n        let index = self.all_fairings.len();\n        self.all_fairings.push(fairing);\n        if this_info.kind.is(Kind::Ignite) { self.ignite.push(index); }\n        if this_info.kind.is(Kind::Liftoff) { self.liftoff.push(index); }\n        if this_info.kind.is(Kind::Request) { self.request.push(index); }\n        if this_info.kind.is(Kind::Response) { self.response.push(index); }\n        if this_info.kind.is(Kind::Shutdown) { self.shutdown.push(index); }\n    }\n\n    pub fn append(&mut self, others: &mut Fairings) {\n        for fairing in others.all_fairings.drain(..) {\n            self.add(fairing);\n        }\n    }\n\n    pub async fn handle_ignite(mut rocket: Rocket<Build>) -> Rocket<Build> {\n        while rocket.fairings.num_ignited < rocket.fairings.ignite.len() {\n            // We're going to move `rocket` while borrowing `fairings`...\n            let mut fairings = std::mem::replace(&mut rocket.fairings, Fairings::new());\n            for fairing in iter!(fairings.ignite).skip(fairings.num_ignited) {\n                let info = fairing.info();\n                rocket = match fairing.on_ignite(rocket).await {\n                    Ok(rocket) => rocket,\n                    Err(rocket) => {\n                        fairings.failures.push(info);\n                        rocket\n                    }\n                };\n\n                fairings.num_ignited += 1;\n            }\n\n            // Note that `rocket.fairings` may now be non-empty since ignite\n            // fairings could have added more fairings! Move them to the end.\n            fairings.append(&mut rocket.fairings);\n            rocket.fairings = fairings;\n        }\n\n        rocket\n    }\n\n    #[inline(always)]\n    pub async fn handle_liftoff(&self, rocket: &Rocket<Orbit>) {\n        let liftoff_futures = iter!(self.liftoff).map(|f| f.on_liftoff(rocket));\n        futures::future::join_all(liftoff_futures).await;\n    }\n\n    #[inline(always)]\n    pub async fn handle_request(&self, req: &mut Request<'_>, data: &mut Data<'_>) {\n        for fairing in iter!(self.request) {\n            fairing.on_request(req, data).await\n        }\n    }\n\n    #[inline(always)]\n    pub async fn handle_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n        for fairing in iter!(self.response) {\n            fairing.on_response(req, res).await;\n        }\n    }\n\n    #[inline(always)]\n    pub async fn handle_shutdown(&self, rocket: &Rocket<Orbit>) {\n        let shutdown_futures = iter!(self.shutdown).map(|f| f.on_shutdown(rocket));\n        futures::future::join_all(shutdown_futures).await;\n    }\n\n    pub fn audit(&self) -> Result<(), &[Info]> {\n        match self.failures.is_empty() {\n            true => Ok(()),\n            false => Err(&self.failures)\n        }\n    }\n\n    pub fn pretty_print(&self) {\n        let active_fairings = self.active().collect::<HashSet<_>>();\n        if !active_fairings.is_empty() {\n            launch_meta!(\"{}{}:\", \" \".emoji(), \"Fairings\".magenta());\n\n            for (_, fairing) in iter!(self, active_fairings.into_iter()) {\n                let (name, kind) = (fairing.info().name, fairing.info().kind);\n                launch_meta_!(\"{} ({})\", name.primary().bold(), kind.blue().bold());\n            }\n        }\n    }\n}\n\nimpl std::fmt::Debug for Fairings {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        fn debug_info<'a>(iter: impl Iterator<Item = &'a dyn Fairing>) -> Vec<Info> {\n            iter.map(|f| f.info()).collect()\n        }\n\n        f.debug_struct(\"Fairings\")\n            .field(\"launch\", &debug_info(iter!(self.ignite)))\n            .field(\"liftoff\", &debug_info(iter!(self.liftoff)))\n            .field(\"request\", &debug_info(iter!(self.request)))\n            .field(\"response\", &debug_info(iter!(self.response)))\n            .field(\"shutdown\", &debug_info(iter!(self.shutdown)))\n            .finish()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::BitOr;\n\n/// Information about a [`Fairing`](crate::fairing::Fairing).\n///\n/// The `name` field is an arbitrary name for a fairing. The `kind` field is a\n/// is an `or`d set of [`Kind`] structures. Rocket uses the values set in `Kind`\n/// to determine which callbacks from a given `Fairing` implementation to\n/// actually call.\n///\n/// # Example\n///\n/// A simple `Info` structure that can be used for a `Fairing` that implements\n/// all callbacks:\n///\n/// ```\n/// use rocket::fairing::{Info, Kind};\n///\n/// # let _unused_info =\n/// Info {\n///     name: \"Example Fairing\",\n///     kind: Kind::Ignite | Kind::Liftoff | Kind::Request | Kind::Response | Kind::Shutdown\n/// }\n/// # ;\n/// ```\n#[derive(Debug, Copy, Clone)]\npub struct Info {\n    /// The name of the fairing.\n    pub name: &'static str,\n    /// A set representing the callbacks the fairing wishes to receive.\n    pub kind: Kind,\n}\n\n/// A bitset representing the kinds of callbacks a\n/// [`Fairing`](crate::fairing::Fairing) wishes to receive.\n///\n/// A fairing can request any combination of any of the following kinds of\n/// callbacks:\n///\n///   * Ignite\n///   * Liftoff\n///   * Request\n///   * Response\n///   * Shutdown\n///\n/// Two `Kind` structures can be `or`d together to represent a combination. For\n/// instance, to represent a fairing that is both an ignite and request fairing,\n/// use `Kind::Ignite | Kind::Request`. Similarly, to represent a fairing that\n/// is only an ignite fairing, use `Kind::Ignite`.\n///\n/// Additionally, a fairing can request to be treated as a\n/// [singleton](crate::fairing::Fairing#singletons) by specifying the\n/// `Singleton` kind.\n#[derive(Debug, Clone, Copy)]\npub struct Kind(usize);\n\n#[allow(non_upper_case_globals)]\nimpl Kind {\n    /// `Kind` flag representing a request for a 'ignite' callback.\n    pub const Ignite: Kind = Kind(1 << 0);\n\n    /// `Kind` flag representing a request for a 'liftoff' callback.\n    pub const Liftoff: Kind = Kind(1 << 1);\n\n    /// `Kind` flag representing a request for a 'request' callback.\n    pub const Request: Kind = Kind(1 << 2);\n\n    /// `Kind` flag representing a request for a 'response' callback.\n    pub const Response: Kind = Kind(1 << 3);\n\n    /// `Kind` flag representing a request for a 'shutdown' callback.\n    pub const Shutdown: Kind = Kind(1 << 4);\n\n    /// `Kind` flag representing a\n    /// [singleton](crate::fairing::Fairing#singletons) fairing.\n    pub const Singleton: Kind = Kind(1 << 5);\n\n    /// Returns `true` if `self` is a superset of `other`. In other words,\n    /// returns `true` if all of the kinds in `other` are also in `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::Kind;\n    ///\n    /// let ignite_and_req = Kind::Ignite | Kind::Request;\n    /// assert!(ignite_and_req.is(Kind::Ignite | Kind::Request));\n    ///\n    /// assert!(ignite_and_req.is(Kind::Ignite));\n    /// assert!(ignite_and_req.is(Kind::Request));\n    ///\n    /// assert!(!ignite_and_req.is(Kind::Liftoff));\n    /// assert!(!ignite_and_req.is(Kind::Response));\n    /// assert!(!ignite_and_req.is(Kind::Ignite | Kind::Response));\n    /// assert!(!ignite_and_req.is(Kind::Ignite | Kind::Request | Kind::Response));\n    /// ```\n    #[inline]\n    pub fn is(self, other: Kind) -> bool {\n        (other.0 & self.0) == other.0\n    }\n\n    /// Returns `true` if `self` is exactly `other`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fairing::Kind;\n    ///\n    /// let ignite_and_req = Kind::Ignite | Kind::Request;\n    /// assert!(ignite_and_req.is_exactly(Kind::Ignite | Kind::Request));\n    ///\n    /// assert!(!ignite_and_req.is_exactly(Kind::Ignite));\n    /// assert!(!ignite_and_req.is_exactly(Kind::Request));\n    /// assert!(!ignite_and_req.is_exactly(Kind::Response));\n    /// assert!(!ignite_and_req.is_exactly(Kind::Ignite | Kind::Response));\n    /// ```\n    #[inline]\n    pub fn is_exactly(self, other: Kind) -> bool {\n        self.0 == other.0\n    }\n}\n\nimpl BitOr for Kind {\n    type Output = Self;\n\n    #[inline(always)]\n    fn bitor(self, rhs: Self) -> Self {\n        Kind(self.0 | rhs.0)\n    }\n}\n\nimpl std::fmt::Display for Kind {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let mut is_first = true;\n        let mut write = |string, kind| {\n            if self.is(kind) {\n                if !is_first { f.write_str(\", \")?; }\n                f.write_str(string)?;\n                is_first = false;\n            }\n\n            Ok(())\n        };\n\n        write(\"ignite\", Kind::Ignite)?;\n        write(\"liftoff\", Kind::Liftoff)?;\n        write(\"request\", Kind::Request)?;\n        write(\"response\", Kind::Response)?;\n        write(\"shutdown\", Kind::Shutdown)?;\n        write(\"singleton\", Kind::Singleton)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Fairings: callbacks at launch, liftoff, request, and response time.\n//!\n//! Fairings allow for structured interposition at various points in the\n//! application lifetime. Fairings can be seen as a restricted form of\n//! \"middleware\". A fairing is an arbitrary structure with methods representing\n//! callbacks that Rocket will run at requested points in a program. You can use\n//! fairings to rewrite or record information about requests and responses, or\n//! to perform an action once a Rocket application has launched.\n//!\n//! To learn more about writing a fairing, see the [`Fairing`] trait\n//! documentation. You can also use [`AdHoc`] to create a fairing on-the-fly\n//! from a closure or function.\n//!\n//! ## Attaching\n//!\n//! You must inform Rocket about fairings that you wish to be active by calling\n//! [`Rocket::attach()`] method on the application's [`Rocket`] instance and\n//! passing in the appropriate [`Fairing`]. For instance, to attach fairings\n//! named `req_fairing` and `res_fairing` to a new Rocket instance, you might\n//! write:\n//!\n//! ```rust\n//! # use rocket::fairing::AdHoc;\n//! # let req_fairing = AdHoc::on_request(\"Request\", |_, _| Box::pin(async move {}));\n//! # let res_fairing = AdHoc::on_response(\"Response\", |_, _| Box::pin(async move {}));\n//! let rocket = rocket::build()\n//!     .attach(req_fairing)\n//!     .attach(res_fairing);\n//! ```\n//!\n//! Once a fairing is attached, Rocket will execute it at the appropriate time,\n//! which varies depending on the fairing implementation. See the [`Fairing`]\n//! trait documentation for more information on the dispatching of fairing\n//! methods.\n//!\n//! [`Fairing`]: crate::fairing::Fairing\n//!\n//! ## Ordering\n//!\n//! `Fairing`s are executed in the order in which they are attached: the first\n//! attached fairing has its callbacks executed before all others. A fairing can\n//! be attached any number of times. Except for [singleton\n//! fairings](Fairing#singletons), all attached instances are polled at runtime.\n//! Fairing callbacks may not be commutative; the order in which fairings are\n//! attached may be significant. It is thus important to communicate specific\n//! fairing functionality clearly.\n//!\n//! Furthermore, a `Fairing` should take care to act locally so that the actions\n//! of other `Fairings` are not jeopardized. For instance, unless it is made\n//! abundantly clear, a fairing should not rewrite every request.\n\nuse std::any::Any;\n\nuse crate::{Rocket, Request, Response, Data, Build, Orbit};\n\nmod fairings;\nmod ad_hoc;\nmod info_kind;\n\npub(crate) use self::fairings::Fairings;\npub use self::ad_hoc::AdHoc;\npub use self::info_kind::{Info, Kind};\n\n/// A type alias for the return `Result` type of [`Fairing::on_ignite()`].\npub type Result<T = Rocket<Build>, E = Rocket<Build>> = std::result::Result<T, E>;\n\n// We might imagine that a request fairing returns an `Outcome`. If it returns\n// `Success`, we don't do any routing and use that response directly. Same if it\n// returns `Error`. We only route if it returns `Forward`. I've chosen not to\n// go this direction because I feel like request guards are the correct\n// mechanism to use here. In other words, enabling this at the fairing level\n// encourages implicit handling, a bad practice. Fairings can still, however,\n// return a default `Response` if routing fails via a response fairing. For\n// instance, to automatically handle preflight in CORS, a response fairing can\n// check that the user didn't handle the `OPTIONS` request (404) and return an\n// appropriate response. This allows the users to handle `OPTIONS` requests\n// when they'd like but default to the fairing when they don't want to.\n\n/// Trait implemented by fairings: Rocket's structured middleware.\n///\n/// # Considerations\n///\n/// Fairings are a large hammer that can easily be abused and misused. If you\n/// are considering writing a `Fairing` implementation, first consider if it is\n/// appropriate to do so. While middleware is often the best solution to some\n/// problems in other frameworks, it is often a suboptimal solution in Rocket.\n/// This is because Rocket provides richer mechanisms such as [request guards]\n/// and [data guards] that can be used to accomplish the same objective in a\n/// cleaner, more composable, and more robust manner.\n///\n/// As a general rule of thumb, only _globally applicable actions_ should be\n/// implemented via fairings. For instance, you should _not_ use a fairing to\n/// implement authentication or authorization (preferring to use a [request\n/// guard] instead) _unless_ the authentication or authorization applies to the\n/// entire application. On the other hand, you _should_ use a fairing to record\n/// timing and/or usage statistics or to implement global security policies.\n///\n/// [request guard]: crate::request::FromRequest\n/// [request guards]: crate::request::FromRequest\n/// [data guards]: crate::data::FromData\n///\n/// ## Fairing Callbacks\n///\n/// There are five kinds of fairing callbacks: launch, liftoff, request,\n/// response, and shutdown. A fairing can request any combination of these\n/// callbacks through the `kind` field of the [`Info`] structure returned from\n/// the `info` method. Rocket will only invoke the callbacks identified in the\n/// fairing's [`Kind`].\n///\n/// The callback kinds are as follows:\n///\n///   * **<a name=\"ignite\">Ignite</a> (`on_ignite`)**\n///\n///     An ignite callback, represented by the [`Fairing::on_ignite()`] method,\n///     is called just prior to liftoff, during ignition. The state of the\n///     `Rocket` instance is, at this point, not finalized, as it may be\n///     modified at will by other ignite fairings.\n///\n///     All ignite callbacks are executed in breadth-first `attach()` order. A\n///     callback `B` executing after a callback `A` can view changes made by `A`\n///     but not vice-versa.\n///\n///     An ignite callback can arbitrarily modify the `Rocket` instance being\n///     constructed. It should take care not to introduce infinite recursion by\n///     recursively attaching ignite fairings. It returns `Ok` if it would like\n///     ignition and launch to proceed nominally and `Err` otherwise. If an\n///     ignite fairing returns `Err`, launch will be aborted. All ignite\n///     fairings are executed even if one or more signal an error.\n///\n///   * **<a name=\"liftoff\">Liftoff</a> (`on_liftoff`)**\n///\n///     A liftoff callback, represented by the [`Fairing::on_liftoff()`] method,\n///     is called immediately after a Rocket application has launched. At this\n///     point, Rocket has opened a socket for listening but has not yet begun\n///     accepting connections. A liftoff callback can inspect the `Rocket`\n///     instance that has launched and even schedule a shutdown using\n///     [`Shutdown::notify()`](crate::Shutdown::notify()) via\n///     [`Rocket::shutdown()`].\n///\n///     Liftoff fairings are run concurrently; resolution of all fairings is\n///     awaited before resuming request serving.\n///\n///   * **<a name=\"request\">Request</a> (`on_request`)**\n///\n///     A request callback, represented by the [`Fairing::on_request()`] method,\n///     is called just after a request is received, immediately after\n///     pre-processing the request with method changes due to `_method` form\n///     fields. At this point, Rocket has parsed the incoming HTTP request into\n///     [`Request`] and [`Data`] structures but has not routed the request. A\n///     request callback can modify the request at will and [`Data::peek()`]\n///     into the incoming data. It may not, however, abort or respond directly\n///     to the request; these issues are better handled via [request guards] or\n///     via response callbacks. Any modifications to a request are persisted and\n///     can potentially alter how a request is routed.\n///\n///   * **<a name=\"response\">Response</a> (`on_response`)**\n///\n///     A response callback, represented by the [`Fairing::on_response()`]\n///     method, is called when a response is ready to be sent to the client. At\n///     this point, Rocket has completed all routing, including to error\n///     catchers, and has generated the would-be final response. A response\n///     callback can modify the response at will. For example, a response\n///     callback can provide a default response when the user fails to handle\n///     the request by checking for 404 responses. Note that a given `Request`\n///     may have changed between `on_request` and `on_response` invocations.\n///     Apart from any change made by other fairings, Rocket sets the method for\n///     `HEAD` requests to `GET` if there is no matching `HEAD` handler for that\n///     request. Additionally, Rocket will automatically strip the body for\n///     `HEAD` requests _after_ response fairings have run.\n///\n///   * **<a name=\"shutdown\">Shutdown</a> (`on_shutdown`)**\n///\n///     A shutdown callback, represented by the [`Fairing::on_shutdown()`]\n///     method, is called when [shutdown is triggered]. At this point, graceful\n///     shutdown has commenced but not completed; no new requests are accepted\n///     but the application may still be actively serving existing requests.\n///\n///     Rocket guarantees, however, that all requests are completed or aborted\n///     once [grace and mercy periods] have expired. This implies that a\n///     shutdown fairing that (asynchronously) sleeps for `grace + mercy + `\n///     seconds before executing any logic will execute said logic after all\n///     requests have been processed or aborted. Note that such fairings may\n///     wish to operate using the `Ok` return value of [`Rocket::launch()`]\n///     instead.\n///\n///     All registered shutdown fairings are run concurrently; resolution of all\n///     fairings is awaited before resuming shutdown. Shutdown fairings do not\n///     affect grace and mercy periods. In other words, any time consumed by\n///     shutdown fairings is not added to grace and mercy periods.\n///\n///     ***Note: Shutdown fairings are only run during testing if the `Client`\n///     is terminated using [`Client::terminate()`].***\n///\n///     [shutdown is triggered]: crate::config::Shutdown#triggers\n///     [grace and mercy periods]: crate::config::Shutdown#summary\n///     [`Client::terminate()`]: crate::local::blocking::Client::terminate()\n///\n/// # Singletons\n///\n/// In general, any number of instances of a given fairing type can be attached\n/// to one instance of `Rocket`. If this is not desired, a fairing can request\n/// to be a singleton by specifying [`Kind::Singleton`]. Only the _last_\n/// attached instance of a singleton will be preserved at ignite-time. That is,\n/// an attached singleton instance will replace any previously attached\n/// instance. The [`Shield`](crate::shield::Shield) fairing is an example of a\n/// singleton fairing.\n///\n/// # Implementing\n///\n/// A `Fairing` implementation has one required method: [`info`]. A `Fairing`\n/// can also implement any of the available callbacks: `on_ignite`, `on_liftoff`,\n/// `on_request`, and `on_response`. A `Fairing` _must_ set the appropriate\n/// callback kind in the `kind` field of the returned `Info` structure from\n/// [`info`] for a callback to actually be called by Rocket.\n///\n/// ## Fairing `Info`\n///\n/// Every `Fairing` must implement the [`info`] method, which returns an\n/// [`Info`] structure. This structure is used by Rocket to:\n///\n///   1. Assign a name to the `Fairing`.\n///\n///      This is the `name` field, which can be any arbitrary string. Name your\n///      fairing something illustrative. The name will be logged during the\n///      application's ignition procedures.\n///\n///   2. Determine which callbacks to actually issue on the `Fairing`.\n///\n///      This is the `kind` field of type [`Kind`]. This field is a bitset that\n///      represents the kinds of callbacks the fairing wishes to receive. Rocket\n///      will only invoke the callbacks that are flagged in this set. `Kind`\n///      structures can be `or`d together to represent any combination of kinds\n///      of callbacks. For instance, to request liftoff and response callbacks,\n///      return a `kind` field with the value `Kind::Liftoff | Kind::Response`.\n///\n/// [`info`]: Fairing::info()\n///\n/// ## Restrictions\n///\n/// A `Fairing` must be [`Send`] + [`Sync`] + `'static`. This means that the\n/// fairing must be sendable across thread boundaries (`Send`), thread-safe\n/// (`Sync`), and have only `'static` references, if any (`'static`). Note that\n/// these bounds _do not_ prohibit a `Fairing` from holding state: the state\n/// need simply be thread-safe and statically available or heap allocated.\n///\n/// ## Async Trait\n///\n/// [`Fairing`] is an _async_ trait. Implementations of `Fairing` must be\n/// decorated with an attribute of `#[rocket::async_trait]`:\n///\n/// ```rust\n/// use rocket::{Rocket, Request, Data, Response, Build, Orbit};\n/// use rocket::fairing::{self, Fairing, Info, Kind};\n///\n/// # struct MyType;\n/// #[rocket::async_trait]\n/// impl Fairing for MyType {\n///     fn info(&self) -> Info {\n///         /* ... */\n///         # unimplemented!()\n///     }\n///\n///     async fn on_ignite(&self, rocket: Rocket<Build>) -> fairing::Result {\n///         /* ... */\n///         # unimplemented!()\n///     }\n///\n///     async fn on_liftoff(&self, rocket: &Rocket<Orbit>) {\n///         /* ... */\n///         # unimplemented!()\n///     }\n///\n///     async fn on_request(&self, req: &mut Request<'_>, data: &mut Data<'_>) {\n///         /* ... */\n///         # unimplemented!()\n///     }\n///\n///     async fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n///         /* ... */\n///         # unimplemented!()\n///     }\n///\n///     async fn on_shutdown(&self, rocket: &Rocket<Orbit>) {\n///         /* ... */\n///         # unimplemented!()\n///     }\n/// }\n/// ```\n///\n/// ## Example\n///\n/// As an example, we want to record the number of `GET` and `POST` requests\n/// that our application has received. While we could do this with [request\n/// guards] and [managed state](crate::State), it would require us to annotate\n/// every `GET` and `POST` request with custom types, polluting handler\n/// signatures. Instead, we can create a simple fairing that acts globally.\n///\n/// The `Counter` fairing below records the number of all `GET` and `POST`\n/// requests received. It makes these counts available at a special `'/counts'`\n/// path.\n///\n/// ```rust\n/// use std::future::Future;\n/// use std::io::Cursor;\n/// use std::pin::Pin;\n/// use std::sync::atomic::{AtomicUsize, Ordering};\n///\n/// use rocket::{Request, Data, Response};\n/// use rocket::fairing::{Fairing, Info, Kind};\n/// use rocket::http::{Method, ContentType, Status};\n///\n/// #[derive(Default)]\n/// struct Counter {\n///     get: AtomicUsize,\n///     post: AtomicUsize,\n/// }\n///\n/// #[rocket::async_trait]\n/// impl Fairing for Counter {\n///     fn info(&self) -> Info {\n///         Info {\n///             name: \"GET/POST Counter\",\n///             kind: Kind::Request | Kind::Response\n///         }\n///     }\n///\n///     async fn on_request(&self, req: &mut Request<'_>, _: &mut Data<'_>) {\n///         if req.method() == Method::Get {\n///             self.get.fetch_add(1, Ordering::Relaxed);\n///         } else if req.method() == Method::Post {\n///             self.post.fetch_add(1, Ordering::Relaxed);\n///         }\n///     }\n///\n///     async fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n///         // Don't change a successful user's response, ever.\n///         if res.status() != Status::NotFound {\n///             return\n///         }\n///\n///         if req.method() == Method::Get && req.uri().path() == \"/counts\" {\n///             let get_count = self.get.load(Ordering::Relaxed);\n///             let post_count = self.post.load(Ordering::Relaxed);\n///\n///             let body = format!(\"Get: {}\\nPost: {}\", get_count, post_count);\n///             res.set_status(Status::Ok);\n///             res.set_header(ContentType::Plain);\n///             res.set_sized_body(body.len(), Cursor::new(body));\n///         }\n///     }\n/// }\n/// ```\n///\n/// ## Request-Local State\n///\n/// Fairings can use [request-local state] to persist or carry data between\n/// requests and responses, or to pass data to a request guard.\n///\n/// As an example, the following fairing uses request-local state to time\n/// requests, setting an `X-Response-Time` header on all responses with the\n/// elapsed time. It also exposes the start time of a request via a `StartTime`\n/// request guard.\n///\n/// ```rust\n/// # use std::future::Future;\n/// # use std::pin::Pin;\n/// # use std::time::{Duration, SystemTime};\n/// # use rocket::{Request, Data, Response};\n/// # use rocket::fairing::{Fairing, Info, Kind};\n/// # use rocket::http::Status;\n/// # use rocket::request::{self, FromRequest};\n/// #\n/// /// Fairing for timing requests.\n/// pub struct RequestTimer;\n///\n/// /// Value stored in request-local state.\n/// #[derive(Copy, Clone)]\n/// struct TimerStart(Option<SystemTime>);\n///\n/// #[rocket::async_trait]\n/// impl Fairing for RequestTimer {\n///     fn info(&self) -> Info {\n///         Info {\n///             name: \"Request Timer\",\n///             kind: Kind::Request | Kind::Response\n///         }\n///     }\n///\n///     /// Stores the start time of the request in request-local state.\n///     async fn on_request(&self, request: &mut Request<'_>, _: &mut Data<'_>) {\n///         // Store a `TimerStart` instead of directly storing a `SystemTime`\n///         // to ensure that this usage doesn't conflict with anything else\n///         // that might store a `SystemTime` in request-local cache.\n///         request.local_cache(|| TimerStart(Some(SystemTime::now())));\n///     }\n///\n///     /// Adds a header to the response indicating how long the server took to\n///     /// process the request.\n///     async fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n///         let start_time = req.local_cache(|| TimerStart(None));\n///         if let Some(Ok(duration)) = start_time.0.map(|st| st.elapsed()) {\n///             let ms = duration.as_secs() * 1000 + duration.subsec_millis() as u64;\n///             res.set_raw_header(\"X-Response-Time\", format!(\"{} ms\", ms));\n///         }\n///     }\n/// }\n///\n/// /// Request guard used to retrieve the start time of a request.\n/// #[derive(Copy, Clone)]\n/// pub struct StartTime(pub SystemTime);\n///\n/// // Allows a route to access the time a request was initiated.\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for StartTime {\n///     type Error = ();\n///\n///     async fn from_request(request: &'r Request<'_>) -> request::Outcome<Self, ()> {\n///         match *request.local_cache(|| TimerStart(None)) {\n///             TimerStart(Some(time)) => request::Outcome::Success(StartTime(time)),\n///             TimerStart(None) => request::Outcome::Error((Status::InternalServerError, ())),\n///         }\n///     }\n/// }\n/// ```\n///\n/// [request-local state]: https://rocket.rs/v0.5/guide/state/#request-local-state\n#[crate::async_trait]\npub trait Fairing: Send + Sync + Any + 'static {\n    /// Returns an [`Info`] structure containing the `name` and [`Kind`] of this\n    /// fairing. The `name` can be any arbitrary string. `Kind` must be an `or`d\n    /// set of `Kind` variants.\n    ///\n    /// This is the only required method of a `Fairing`. All other methods have\n    /// no-op default implementations.\n    ///\n    /// Rocket will only dispatch callbacks to this fairing for the kinds in the\n    /// `kind` field of the returned `Info` structure. For instance, if\n    /// `Kind::Ignite | Kind::Request` is used, then Rocket will only call the\n    /// `on_ignite` and `on_request` methods of the fairing. Similarly, if\n    /// `Kind::Response` is used, Rocket will only call the `on_response` method\n    /// of this fairing.\n    ///\n    /// # Example\n    ///\n    /// An `info` implementation for `MyFairing`: a fairing named \"My Custom\n    /// Fairing\" that is both an ignite and response fairing.\n    ///\n    /// ```rust\n    /// use rocket::fairing::{Fairing, Info, Kind};\n    ///\n    /// struct MyFairing;\n    ///\n    /// impl Fairing for MyFairing {\n    ///     fn info(&self) -> Info {\n    ///         Info {\n    ///             name: \"My Custom Fairing\",\n    ///             kind: Kind::Ignite | Kind::Response\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    fn info(&self) -> Info;\n\n    /// The ignite callback. Returns `Ok` if ignition should proceed and `Err`\n    /// if ignition and launch should be aborted.\n    ///\n    /// See [Fairing Callbacks](#ignite) for complete semantics.\n    ///\n    /// This method is called during ignition and if `Kind::Ignite` is in the\n    /// `kind` field of the `Info` structure for this fairing. The `rocket`\n    /// parameter is the `Rocket` instance that is currently being built for\n    /// this application.\n    ///\n    /// ## Default Implementation\n    ///\n    /// The default implementation of this method simply returns `Ok(rocket)`.\n    async fn on_ignite(&self, rocket: Rocket<Build>) -> Result { Ok(rocket) }\n\n    /// The liftoff callback.\n    ///\n    /// See [Fairing Callbacks](#liftoff) for complete semantics.\n    ///\n    /// This method is called just after launching the application if\n    /// `Kind::Liftoff` is in the `kind` field of the `Info` structure for this\n    /// fairing. The `Rocket` parameter corresponds to the launched application.\n    ///\n    /// ## Default Implementation\n    ///\n    /// The default implementation of this method does nothing.\n    async fn on_liftoff(&self, _rocket: &Rocket<Orbit>) { }\n\n    /// The request callback.\n    ///\n    /// See [Fairing Callbacks](#request) for complete semantics.\n    ///\n    /// This method is called when a new request is received if `Kind::Request`\n    /// is in the `kind` field of the `Info` structure for this fairing. The\n    /// `&mut Request` parameter is the incoming request, and the `&Data`\n    /// parameter is the incoming data in the request.\n    ///\n    /// ## Default Implementation\n    ///\n    /// The default implementation of this method does nothing.\n    async fn on_request(&self, _req: &mut Request<'_>, _data: &mut Data<'_>) {}\n\n    /// The response callback.\n    ///\n    /// See [Fairing Callbacks](#response) for complete semantics.\n    ///\n    /// This method is called when a response is ready to be issued to a client\n    /// if `Kind::Response` is in the `kind` field of the `Info` structure for\n    /// this fairing. The `&Request` parameter is the request that was routed,\n    /// and the `&mut Response` parameter is the resulting response.\n    ///\n    /// ## Default Implementation\n    ///\n    /// The default implementation of this method does nothing.\n    async fn on_response<'r>(&self, _req: &'r Request<'_>, _res: &mut Response<'r>) {}\n\n    /// The shutdown callback.\n    ///\n    /// See [Fairing Callbacks](#shutdown) for complete semantics.\n    ///\n    /// This method is called when [shutdown is triggered] if `Kind::Shutdown`\n    /// is in the `kind` field of the `Info` structure for this fairing. The\n    /// `Rocket` parameter corresponds to the running application.\n    ///\n    /// [shutdown is triggered]: crate::config::Shutdown#triggers\n    ///\n    /// ## Default Implementation\n    ///\n    /// The default implementation of this method does nothing.\n    async fn on_shutdown(&self, _rocket: &Rocket<Orbit>) { }\n}\n\n#[crate::async_trait]\nimpl<T: Fairing + ?Sized> Fairing for std::sync::Arc<T> {\n    #[inline]\n    fn info(&self) -> Info {\n        (self as &T).info()\n    }\n\n    #[inline]\n    async fn on_ignite(&self, rocket: Rocket<Build>) -> Result {\n        (self as &T).on_ignite(rocket).await\n    }\n\n    #[inline]\n    async fn on_liftoff(&self, rocket: &Rocket<Orbit>) {\n        (self as &T).on_liftoff(rocket).await\n    }\n\n    #[inline]\n    async fn on_request(&self, req: &mut Request<'_>, data: &mut Data<'_>) {\n        (self as &T).on_request(req, data).await\n    }\n\n    #[inline]\n    async fn on_response<'r>(&self, req: &'r Request<'_>, res: &mut Response<'r>) {\n        (self as &T).on_response(req, res).await\n    }\n\n    #[inline]\n    async fn on_shutdown(&self, rocket: &Rocket<Orbit>) {\n        (self as &T).on_shutdown(rocket).await\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::{Index, RangeFrom, RangeTo};\nuse std::cell::UnsafeCell;\n\nuse parking_lot::{RawMutex, lock_api::RawMutex as _};\n\nmod private {\n    /// Sealed trait for types that can be shared in a `SharedStack`.\n    ///\n    /// The type of values passed to\n    /// [`local_cache`](crate::request::local_cache) must implement this trait.\n    /// Since this trait is sealed, the types implementing this trait are known\n    /// and finite: `String` and `Vec<T> for all T: Sync + Send + 'static`.\n    // UNSAFE: Needs to have a stable address when deref'd.\n    pub unsafe trait Shareable: std::ops::Deref + Sync + Send + 'static {\n        /// The current length of the owned shareable.\n        fn len(&self) -> usize;\n    }\n\n    unsafe impl Shareable for String {\n        fn len(&self) -> usize { self.len() }\n    }\n\n    unsafe impl<T: Send + Sync + 'static> Shareable for Vec<T> {\n        fn len(&self) -> usize { self.len() }\n    }\n}\n\npub use private::Shareable;\n\n/// A stack of strings (chars of bytes) that can be shared between threads while\n/// remaining internally mutable and while allowing references into the stack to\n/// persist across mutations.\npub struct SharedStack<T: Shareable> {\n    stack: UnsafeCell<Vec<T>>,\n    mutex: RawMutex,\n}\n\nimpl<T: Shareable> SharedStack<T>\n    where T::Target: Index<RangeFrom<usize>, Output = T::Target> +\n                     Index<RangeTo<usize>, Output = T::Target>\n{\n    /// Creates a new stack.\n    pub fn new() -> Self {\n        SharedStack {\n            stack: UnsafeCell::new(vec![]),\n            mutex: RawMutex::INIT,\n        }\n    }\n\n    /// Pushes the string `S` onto the stack. Returns a reference of the string\n    /// in the stack.\n    pub(crate) fn push<S: Into<T>>(&self, string: S) -> &T::Target {\n        // SAFETY:\n        //   * Aliasing: We retrieve a mutable reference to the last slot (via\n        //     `push()`) and then return said reference as immutable; these\n        //     occur in serial, so they don't alias. This method accesses a\n        //     unique slot each call: the last slot, subsequently replaced by\n        //     `push()` each next call. No other method accesses the internal\n        //     buffer directly. Thus, the outstanding reference to the last slot\n        //     is never accessed again mutably, preserving aliasing guarantees.\n        //   * Liveness: The returned reference is to a `String`; we must ensure\n        //     that the `String` is never dropped while `self` lives. This is\n        //     guaranteed by returning a reference with the same lifetime as\n        //     `self`, so `self` can't be dropped while the string is live, and\n        //     by never removing elements from the internal `Vec` thus not\n        //     dropping `String` itself: `push()` is the only mutating operation\n        //     called on `Vec`, which preserves all previous elements; the\n        //     stability of `String` itself means that the returned address\n        //     remains valid even after internal realloc of `Vec`.\n        //   * Thread-Safety: Parallel calls to `push_one` without exclusion\n        //     would result in a race to `vec.push()`; `RawMutex` ensures that\n        //     this doesn't occur.\n        unsafe {\n            self.mutex.lock();\n            let vec: &mut Vec<T> = &mut *self.stack.get();\n            vec.push(string.into());\n            let last = vec.last().expect(\"push() => non-empty\");\n            self.mutex.unlock();\n            last\n        }\n    }\n\n    /// Just like `push` but `string` must already be the owned `T`.\n    pub fn push_owned(&self, string: T) -> &T::Target {\n        self.push(string)\n    }\n\n    /// Pushes the string `S` onto the stack which is assumed to internally\n    /// contain two strings with the first string being of length `n`. Returns\n    /// references to the two strings on the stack.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `string.len() < len`.\n    pub(crate) fn push_split<S: Into<T>>(&self, string: S, n: usize) -> (&T::Target, &T::Target) {\n        let buffered = self.push(string);\n        let a = &buffered[..n];\n        let b = &buffered[n..];\n        (a, b)\n    }\n\n    /// Pushes the strings `a` and `b` onto the stack without allocating for\n    /// both strings. Returns references to the two strings on the stack.\n    pub(crate) fn push_two<'a, V>(&'a self, a: V, b: V) -> (&'a T::Target, &'a T::Target)\n        where T: From<V> + Extend<V>,\n    {\n        let mut value = T::from(a);\n        let split_len = value.len();\n        value.extend(Some(b));\n        self.push_split(value, split_len)\n    }\n}\n\nunsafe impl<T: Shareable> Sync for SharedStack<T> {}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use serde::Serialize;\nuse indexmap::{IndexMap, IndexSet};\n\nuse crate::form::prelude::*;\nuse crate::http::Status;\n\n/// An infallible form guard that records form fields and errors during parsing.\n///\n/// This form guard _never fails_. It should be use _only_ when the form\n/// [`Context`] is required. In all other cases, prefer to use `T` directly.\n///\n/// # Usage\n///\n/// `Contextual` acts as a proxy for any form type, recording all submitted form\n/// values and produced errors and associating them with their corresponding\n/// field name. `Contextual` is particularly useful for rendering forms with\n/// previously submitted values and errors associated with form input.\n///\n/// To retrieve the context for a form, use `Form<Contextual<'_, T>>` as a data\n/// guard, where `T` implements `FromForm`. The `context` field contains the\n/// form's [`Context`]:\n///\n/// ```rust\n/// # use rocket::post;\n/// # type T = String;\n/// use rocket::form::{Form, Contextual};\n///\n/// #[post(\"/submit\", data = \"<form>\")]\n/// fn submit(form: Form<Contextual<'_, T>>) {\n///     if let Some(ref value) = form.value {\n///         // The form parsed successfully. `value` is the `T`.\n///     }\n///\n///     // We can retrieve raw field values and errors.\n///     let raw_id_value = form.context.field_value(\"id\");\n///     let id_errors = form.context.field_errors(\"id\");\n/// }\n/// ```\n///\n/// `Context` serializes as a map, so it can be rendered in templates that\n/// require `Serialize` types. See the [forms guide] for further usage details.\n///\n/// [forms guide]: https://rocket.rs/v0.5/guide/requests/#context\n#[derive(Debug)]\npub struct Contextual<'v, T> {\n    /// The value, if it was successfully parsed, or `None` otherwise.\n    pub value: Option<T>,\n    /// The context with all submitted fields and associated values and errors.\n    pub context: Context<'v>,\n}\n\n/// A form context containing received fields, values, and encountered errors.\n///\n/// A value of this type is produced by the [`Contextual`] form guard in its\n/// [`context`](Contextual::context) field. `Context` contains an entry for\n/// every form field submitted by the client regardless of whether the field\n/// parsed or validated successfully.\n///\n/// # Field Values\n///\n/// The original, submitted field value(s) for a _value_ field can be retrieved\n/// via [`Context::field_value()`] or [`Context::field_values()`]. Data fields do not have\n/// their values recorded. All submitted field names, including data field\n/// names, can be retrieved via [`Context::fields()`].\n///\n/// # Field Errors\n///\n/// # Serialization\n///\n/// When a value of this type is serialized, a `struct` or map with the\n/// following fields is emitted:\n///\n/// | field         | type                               | description                          |\n/// |---------------|------------------------------------|--------------------------------------|\n/// | `errors`      | map: string to array of [`Error`]s | maps a field name to its errors      |\n/// | `values`      | map: string to array of strings    | maps a field name to its form values |\n/// | `data_fields` | array of strings                   | field names of all form data fields  |\n/// | `form_errors` | array of [`Error`]s                | errors not associated with a field   |\n///\n/// See [`Error`](Error#serialization) for `Error` serialization details.\n#[derive(Debug, Default, Serialize)]\npub struct Context<'v> {\n    errors: IndexMap<NameBuf<'v>, Errors<'v>>,\n    values: IndexMap<&'v Name, Vec<&'v str>>,\n    data_fields: IndexSet<&'v Name>,\n    form_errors: Errors<'v>,\n    #[serde(skip)]\n    status: Status,\n}\n\nimpl<'v> Context<'v> {\n    /// Returns the names of all submitted form fields, both _value_ and _data_\n    /// fields.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     let field_names = form.context.fields();\n    /// }\n    /// ```\n    pub fn fields(&self) -> impl Iterator<Item = &'v Name> + '_ {\n        self.values.iter()\n            .map(|(name, _)| *name)\n            .chain(self.data_fields.iter().copied())\n    }\n\n    /// Returns the _first_ value, if any, submitted for the _value_ field named\n    /// `name`.\n    ///\n    /// The type of `name` may be `&Name`, `&str`, or `&RawStr`. Lookup is\n    /// case-sensitive but key-separator (`.` or `[]`) insensitive.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     let first_value_for_id = form.context.field_value(\"id\");\n    ///     let first_value_for_foo_bar = form.context.field_value(\"foo.bar\");\n    /// }\n    /// ```\n    pub fn field_value<N: AsRef<Name>>(&self, name: N) -> Option<&'v str> {\n        self.values.get(name.as_ref())?.get(0).cloned()\n    }\n\n    /// Returns the values, if any, submitted for the _value_ field named\n    /// `name`.\n    ///\n    /// The type of `name` may be `&Name`, `&str`, or `&RawStr`. Lookup is\n    /// case-sensitive but key-separator (`.` or `[]`) insensitive.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     let values_for_id = form.context.field_values(\"id\");\n    ///     let values_for_foo_bar = form.context.field_values(\"foo.bar\");\n    /// }\n    /// ```\n    pub fn field_values<N>(&self, name: N) -> impl Iterator<Item = &'v str> + '_\n        where N: AsRef<Name>\n    {\n        self.values\n            .get(name.as_ref())\n            .map(|e| e.iter().cloned())\n            .into_iter()\n            .flatten()\n    }\n\n    /// Returns an iterator over all of the errors in the context, including\n    /// those not associated with any field.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     let errors = form.context.errors();\n    /// }\n    /// ```\n    pub fn errors(&self) -> impl Iterator<Item = &Error<'v>> {\n        self.errors.values()\n            .map(|e| e.iter())\n            .flatten()\n            .chain(self.form_errors.iter())\n    }\n\n    /// Returns the errors associated with the field `name`. This method is\n    /// roughly equivalent to:\n    ///\n    /// ```rust\n    /// # use rocket::form::{Context, name::Name};\n    /// # let context = Context::default();\n    /// # let name = Name::new(\"foo\");\n    /// context.errors().filter(|e| e.is_for(name))\n    /// # ;\n    /// ```\n    ///\n    /// That is, it uses [`Error::is_for()`] to determine which errors are\n    /// associated with the field named `name`. This considers all errors whose\n    /// associated field name is a prefix of `name` to be an error for the field\n    /// named `name`. In other words, it associates parent field errors with\n    /// their children: `a.b`'s errors apply to `a.b.c`, `a.b.d` and so on but\n    /// not `a.c`.\n    ///\n    /// Lookup is case-sensitive but key-separator (`.` or `[]`) insensitive.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     // Get all errors for field `id`.\n    ///     let id = form.context.field_errors(\"id\");\n    ///\n    ///     // Get all errors for `foo.bar` or `foo` if `foo` failed first.\n    ///     let foo_bar = form.context.field_errors(\"foo.bar\");\n    /// }\n    /// ```\n    pub fn field_errors<'a, N>(&'a self, name: N) -> impl Iterator<Item = &Error<'v>> + '_\n        where N: AsRef<Name> + 'a\n    {\n        self.errors.values()\n            .map(|e| e.iter())\n            .flatten()\n            .filter(move |e| e.is_for(&name))\n    }\n\n    /// Returns the errors associated _exactly_ with the field `name`. Prefer\n    /// [`Context::field_errors()`] instead.\n    ///\n    /// This method is roughly equivalent to:\n    ///\n    /// ```rust\n    /// # use rocket::form::{Context, name::Name};\n    /// # let context = Context::default();\n    /// # let name = Name::new(\"foo\");\n    /// context.errors().filter(|e| e.is_for_exactly(name))\n    /// # ;\n    /// ```\n    ///\n    /// That is, it uses [`Error::is_for_exactly()`] to determine which errors\n    /// are associated with the field named `name`. This considers _only_ errors\n    /// whose associated field name is _exactly_ `name` to be an error for the\n    /// field named `name`. This is _not_ what is typically desired as it\n    /// ignores errors that occur in the parent which will result in missing\n    /// errors associated with its children. Use [`Context::field_errors()`] in\n    /// almost all cases.\n    ///\n    /// Lookup is case-sensitive but key-separator (`.` or `[]`) insensitive.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) {\n    ///     // Get all errors for field `id`.\n    ///     let id = form.context.exact_field_errors(\"id\");\n    ///\n    ///     // Get all errors exactly for `foo.bar`. If `foo` failed, we will\n    ///     // this will return no errors. Use `Context::field_errors()`.\n    ///     let foo_bar = form.context.exact_field_errors(\"foo.bar\");\n    /// }\n    /// ```\n    pub fn exact_field_errors<'a, N>(&'a self, name: N) -> impl Iterator<Item = &Error<'v>> + '_\n        where N: AsRef<Name> + 'a\n    {\n        self.errors.values()\n            .map(|e| e.iter())\n            .flatten()\n            .filter(move |e| e.is_for_exactly(&name))\n    }\n\n    /// Returns the `max` of the statuses associated with all field errors.\n    ///\n    /// See [`Error::status()`] for details on how an error status is computed.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::http::Status;\n    /// use rocket::form::{Form, Contextual};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Contextual<'_, T>>) -> (Status, &'static str) {\n    ///     (form.context.status(), \"Thanks!\")\n    /// }\n    /// ```\n    pub fn status(&self) -> Status {\n        self.status\n    }\n\n    /// Inject a single error `error` into the context.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::http::Status;\n    /// use rocket::form::{Form, Contextual, Error};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(mut form: Form<Contextual<'_, T>>) {\n    ///     let error = Error::validation(\"a good error message\")\n    ///         .with_name(\"field_name\")\n    ///         .with_value(\"some field value\");\n    ///\n    ///     form.context.push_error(error);\n    /// }\n    /// ```\n    pub fn push_error(&mut self, error: Error<'v>) {\n        self.status = std::cmp::max(self.status, error.status());\n        match error.name {\n            Some(ref name) => match self.errors.get_mut(name) {\n                Some(errors) => errors.push(error),\n                None => { self.errors.insert(name.clone(), error.into()); },\n            }\n            None => self.form_errors.push(error)\n        }\n    }\n\n    /// Inject all of the errors in `errors` into the context.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::post;\n    /// # type T = String;\n    /// use rocket::http::Status;\n    /// use rocket::form::{Form, Contextual, Error};\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(mut form: Form<Contextual<'_, T>>) {\n    ///     let error = Error::validation(\"a good error message\")\n    ///         .with_name(\"field_name\")\n    ///         .with_value(\"some field value\");\n    ///\n    ///     form.context.push_errors(vec![error]);\n    /// }\n    /// ```\n    pub fn push_errors<E: Into<Errors<'v>>>(&mut self, errors: E) {\n        errors.into().into_iter().for_each(|e| self.push_error(e))\n    }\n}\n\nimpl<'f> From<Errors<'f>> for Context<'f> {\n    fn from(errors: Errors<'f>) -> Self {\n        let mut context = Context::default();\n        context.push_errors(errors);\n        context\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v>> FromForm<'v> for Contextual<'v, T> {\n    type Context = (<T as FromForm<'v>>::Context, Context<'v>);\n\n    fn init(opts: Options) -> Self::Context {\n        (T::init(opts), Context::default())\n    }\n\n    fn push_value((ref mut val_ctxt, ctxt): &mut Self::Context, field: ValueField<'v>) {\n        ctxt.values.entry(field.name.source()).or_default().push(field.value);\n        T::push_value(val_ctxt, field);\n    }\n\n    async fn push_data((ref mut val_ctxt, ctxt): &mut Self::Context, field: DataField<'v, '_>) {\n        ctxt.data_fields.insert(field.name.source());\n        T::push_data(val_ctxt, field).await;\n    }\n\n    fn push_error((_, ref mut ctxt): &mut Self::Context, e: Error<'v>) {\n        ctxt.push_error(e);\n    }\n\n    fn finalize((val_ctxt, mut context): Self::Context) -> Result<'v, Self> {\n        let value = match T::finalize(val_ctxt) {\n            Ok(value) => Some(value),\n            Err(errors) => {\n                context.push_errors(errors);\n                None\n            }\n        };\n\n        Ok(Contextual { value, context })\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Form error types.\n\nuse std::{fmt, io};\nuse std::num::{ParseIntError, ParseFloatError};\nuse std::str::{Utf8Error, ParseBoolError};\nuse std::char::ParseCharError;\nuse std::net::AddrParseError;\nuse std::borrow::Cow;\n\nuse serde::{Serialize, ser::{Serializer, SerializeStruct}};\n\nuse crate::http::Status;\nuse crate::form::name::{NameBuf, Name};\nuse crate::data::ByteUnit;\n\n/// A collection of [`Error`]s.\n///\n/// `Errors` is a thin wrapper around a `Vec<Error>` with convenient methods for\n/// modifying the internal `Error`s. It `Deref`s and `DerefMut`s to\n/// `Vec<Error>` for transparent access to the underlying vector.\n///\n/// # Matching Errors to Fields\n///\n/// To find the errors that correspond to a given field, use\n/// [`Error::is_for()`]. For example, to get all of the errors that correspond\n/// to the field `foo.bar`, you might write the following:\n///\n/// ```rust\n/// use rocket::form::Errors;\n///\n/// let errors = Errors::new();\n/// let errors_for_foo = errors.iter().filter(|e| e.is_for(\"foo.bar\"));\n/// ```\n///\n/// ## Constructing\n///\n/// An `Errors` can be constructed from anything that an `Error` can be\n/// constructed from. This includes [`Error`], [`ErrorKind`], and all of the\n/// types an `ErrorKind` can be constructed from. See\n/// [`ErrorKind`](ErrorKind#constructing) for the full list.\n///\n/// ```rust\n/// use rocket::form;\n///\n/// fn at_most_10() -> form::Result<'static, usize> {\n///     // Using `From<PartIntError> => ErrorKind::Int => Errors`.\n///     let i: usize = \"foo\".parse()?;\n///\n///     if i > 10 {\n///         // `(Option<isize>, Option<isize>) => ErrorKind::OutOfRange => Errors`\n///         return Err((None, Some(10isize)).into());\n///     }\n///\n///     Ok(i)\n/// }\n/// ```\n#[derive(Default, Debug, PartialEq, Serialize)]\n#[serde(transparent)]\npub struct Errors<'v>(Vec<Error<'v>>);\n\n/// A form error, potentially tied to a specific form field.\n///\n/// An `Error` is returned by [`FromForm`], [`FromFormField`], and [`validate`]\n/// procedures, typically as a collection of [`Errors`]. It potentially\n/// identifies a specific field that triggered the error via [`Error::name`] and\n/// the field's value via [`Error::value`].\n///\n/// An `Error` can occur because of a field's value that failed to parse or\n/// because other parts of a field or form were malformed; the [`Error::entity`]\n/// identifies the part of the form that resulted in the error.\n///\n/// [`FromForm`]: crate::form::FromForm\n/// [`FromFormField`]: crate::form::FromFormField\n/// [`validate`]: crate::form::validate\n///\n/// # Constructing\n///\n/// An `Error` can be constructed via [`Error::validation()`],\n/// [`Error::custom()`], or anything that an [`ErrorKind`] can be constructed\n/// from. See [`ErrorKind`](ErrorKind#constructing).\n///\n/// ```rust\n/// use rocket::form::Error;\n///\n/// fn at_most_10_not_even() -> Result<usize, Error<'static>> {\n///     // Using `From<PartIntError> => ErrorKind::Int`.\n///     let i: usize = \"foo\".parse()?;\n///\n///     if i > 10 {\n///         // `From<(Option<isize>, Option<isize>)> => ErrorKind::OutOfRange`\n///         return Err((None, Some(10isize)).into());\n///     } else if i % 2 == 0 {\n///         return Err(Error::validation(\"integer cannot be even\"));\n///     }\n///\n///     Ok(i)\n/// }\n/// ```\n///\n/// # Setting Field Metadata\n///\n/// When implementing [`FromFormField`], nothing has to be done for a field's\n/// metadata to be set: the blanket [`FromForm`] implementation sets it\n/// automatically.\n///\n/// When constructed from an `ErrorKind`, the entity is set to\n/// [`Entity::default_for()`] by default. Occasionally, the error's `entity` may\n/// need to be set manually. Return what would be useful to the end-consumer.\n///\n/// # Matching Errors to Fields\n///\n/// To determine whether an error corresponds to a given field, use\n/// [`Error::is_for()`]. For example, to get all of the errors that correspond\n/// to the field `foo.bar`, you might write the following:\n///\n/// ```rust\n/// use rocket::form::Errors;\n///\n/// let errors = Errors::new();\n/// let errors_for_foo = errors.iter().filter(|e| e.is_for(\"foo.bar\"));\n/// ```\n///\n/// # Serialization\n///\n/// When a value of this type is serialized, a `struct` or map with the\n/// following fields is emitted:\n///\n/// | field    | type           | description                                      |\n/// |----------|----------------|--------------------------------------------------|\n/// | `name`   | `Option<&str>` | the erroring field's name, if known              |\n/// | `value`  | `Option<&str>` | the erroring field's value, if known             |\n/// | `entity` | `&str`         | string representation of the erroring [`Entity`] |\n/// | `msg`    | `&str`         | concise message of the error                     |\n#[derive(Debug, PartialEq)]\npub struct Error<'v> {\n    /// The name of the field, if it is known.\n    pub name: Option<NameBuf<'v>>,\n    /// The field's value, if it is known.\n    pub value: Option<Cow<'v, str>>,\n    /// The kind of error that occurred.\n    pub kind: ErrorKind<'v>,\n    /// The entity that caused the error.\n    pub entity: Entity,\n}\n\n/// The kind of form error that occurred.\n///\n/// ## Constructing\n///\n/// An `ErrorKind` can be constructed directly or via a `From` of the following\n/// types:\n///\n///   * `(Option<u64>, Option<u64>)` => [`ErrorKind::InvalidLength`]\n///   * `(Option<ByteUnit>, Option<ByteUnit>)` => [`ErrorKind::InvalidLength`]\n///   * `(Option<isize>, Option<isize>)` => [`ErrorKind::OutOfRange`]\n///   * `&[Cow<'_, str>]` or `Vec<Cow<'_, str>>` => [`ErrorKind::InvalidChoice`]\n///   * [`Utf8Error`] => [`ErrorKind::Utf8`]\n///   * [`ParseIntError`] => [`ErrorKind::Int`]\n///   * [`ParseFloatError`] => [`ErrorKind::Float`]\n///   * [`ParseBoolError`] => [`ErrorKind::Bool`]\n///   * [`AddrParseError`] => [`ErrorKind::Addr`]\n///   * [`io::Error`] => [`ErrorKind::Io`]\n///   * `Box<dyn std::error::Error + Send` => [`ErrorKind::Custom`]\n///   * `(Status, Box<dyn std::error::Error + Send)` => [`ErrorKind::Custom`]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum ErrorKind<'v> {\n    /// The value's length, in bytes, was outside the range `[min, max]`.\n    InvalidLength {\n        /// The minimum length required, inclusive.\n        min: Option<u64>,\n        /// The maximum length required, inclusive.\n        max: Option<u64>,\n    },\n    /// The value wasn't one of the valid `choices`.\n    InvalidChoice {\n        /// The choices that were expected.\n        choices: Cow<'v, [Cow<'v, str>]>,\n    },\n    /// The integer value was outside the range `[start, end]`.\n    OutOfRange {\n        /// The start of the acceptable range, inclusive.\n        start: Option<isize>,\n        /// The end of the acceptable range, inclusive.\n        end: Option<isize>,\n    },\n    /// A custom validation routine failed with message `.0`.\n    Validation(Cow<'v, str>),\n    /// One entity was expected but more than one was received.\n    Duplicate,\n    /// An entity was expected but was not received.\n    Missing,\n    /// An unexpected entity was received.\n    Unexpected,\n    /// An unknown entity was received.\n    Unknown,\n    /// A custom error occurred. Status defaults to\n    /// [`Status::UnprocessableEntity`] if one is not directly specified.\n    Custom(Status, Box<dyn std::error::Error + Send>),\n    /// An error while parsing a multipart form occurred.\n    Multipart(multer::Error),\n    /// A string was invalid UTF-8.\n    Utf8(Utf8Error),\n    /// A value failed to parse as a char.\n    Char(ParseCharError),\n    /// A value failed to parse as an integer.\n    Int(ParseIntError),\n    /// A value failed to parse as a boolean.\n    Bool(ParseBoolError),\n    /// A value failed to parse as a float.\n    Float(ParseFloatError),\n    /// A value failed to parse as an IP or socket address.\n    Addr(AddrParseError),\n    /// An I/O error occurred.\n    Io(io::Error),\n}\n\n/// The erroneous form entity or form component.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Entity {\n    /// The form itself.\n    Form,\n    /// A field.\n    Field,\n    /// A [`ValueField`](crate::form::ValueField).\n    ValueField,\n    /// A [`DataField`](crate::form::DataField).\n    DataField,\n    /// A field name.\n    Name,\n    /// A field value.\n    Value,\n    /// A field name key.\n    Key,\n    /// A field name key index at index `.0`.\n    Index(usize),\n}\n\nimpl<'v> Errors<'v> {\n    /// Create an empty collection of errors.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::Errors;\n    ///\n    /// let errors = Errors::new();\n    /// assert!(errors.is_empty());\n    /// ```\n    pub fn new() -> Self {\n        Errors(vec![])\n    }\n\n    /// Consumes `self` and returns a new `Errors` with each field name set to\n    /// `name` if it was not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Errors, ErrorKind};\n    ///\n    /// let mut errors = Errors::from(ErrorKind::Missing);\n    /// assert!(errors[0].name.is_none());\n    ///\n    /// let mut errors = errors.with_name(\"foo\");\n    /// assert_eq!(errors[0].name.as_ref().unwrap(), \"foo\");\n    ///\n    /// errors.push(ErrorKind::Duplicate.into());\n    /// let errors = errors.with_name(\"bar\");\n    /// assert_eq!(errors[0].name.as_ref().unwrap(), \"foo\");\n    /// assert_eq!(errors[1].name.as_ref().unwrap(), \"bar\");\n    /// ```\n    pub fn with_name<N: Into<NameBuf<'v>>>(mut self, name: N) -> Self {\n        self.set_name(name);\n        self\n    }\n\n    /// Set the field name of each error in `self` to `name` if it is not\n    /// already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Errors, ErrorKind};\n    ///\n    /// let mut errors = Errors::from(ErrorKind::Missing);\n    /// assert!(errors[0].name.is_none());\n    ///\n    /// errors.set_name(\"foo\");\n    /// assert_eq!(errors[0].name.as_ref().unwrap(), \"foo\");\n    ///\n    /// errors.push(ErrorKind::Duplicate.into());\n    /// let errors = errors.with_name(\"bar\");\n    /// assert_eq!(errors[0].name.as_ref().unwrap(), \"foo\");\n    /// assert_eq!(errors[1].name.as_ref().unwrap(), \"bar\");\n    /// ```\n    pub fn set_name<N: Into<NameBuf<'v>>>(&mut self, name: N) {\n        let name = name.into();\n        for error in self.iter_mut() {\n            if error.name.is_none() {\n                error.set_name(name.clone());\n            }\n        }\n    }\n\n    /// Consumes `self` and returns a new `Errors` with each field value set to\n    /// `value` if it was not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Errors, ErrorKind};\n    ///\n    /// let mut errors = Errors::from(ErrorKind::Missing);\n    /// assert!(errors[0].value.is_none());\n    ///\n    /// let mut errors = errors.with_value(\"foo\");\n    /// assert_eq!(errors[0].value.as_ref().unwrap(), \"foo\");\n    ///\n    /// errors.push(ErrorKind::Duplicate.into());\n    /// let errors = errors.with_value(\"bar\");\n    /// assert_eq!(errors[0].value.as_ref().unwrap(), \"foo\");\n    /// assert_eq!(errors[1].value.as_ref().unwrap(), \"bar\");\n    /// ```\n    pub fn with_value(mut self, value: &'v str) -> Self {\n        self.set_value(value);\n        self\n    }\n\n    /// Set the field value of each error in `self` to `value` if it is not\n    /// already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Errors, ErrorKind};\n    ///\n    /// let mut errors = Errors::from(ErrorKind::Missing);\n    /// assert!(errors[0].value.is_none());\n    ///\n    /// errors.set_value(\"foo\");\n    /// assert_eq!(errors[0].value.as_ref().unwrap(), \"foo\");\n    ///\n    /// errors.push(ErrorKind::Duplicate.into());\n    /// let errors = errors.with_value(\"bar\");\n    /// assert_eq!(errors[0].value.as_ref().unwrap(), \"foo\");\n    /// assert_eq!(errors[1].value.as_ref().unwrap(), \"bar\");\n    /// ```\n    pub fn set_value(&mut self, value: &'v str) {\n        self.iter_mut().for_each(|e| e.set_value(value));\n    }\n\n    /// Returns the highest [`Error::status()`] of all of the errors in `self`\n    /// or [`Status::InternalServerError`] if `self` is empty. This is the\n    /// status that is set by the [`Form`](crate::form::Form) data guard on\n    /// error.\n    ///\n    /// See [`Error::status()`] for the corresponding status code of each\n    /// [`Error`] variant.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, Errors, ErrorKind};\n    /// use rocket::http::Status;\n    ///\n    /// let mut errors = Errors::new();\n    /// assert_eq!(errors.status(), Status::InternalServerError);\n    ///\n    /// errors.push(Error::from((None, Some(10u64))));\n    /// assert_eq!(errors.status(), Status::PayloadTooLarge);\n    ///\n    /// errors.push(Error::from(ErrorKind::Missing));\n    /// assert_eq!(errors.status(), Status::UnprocessableEntity);\n    /// ```\n    pub fn status(&self) -> Status {\n        let max = self.iter().map(|e| e.status()).max();\n        max.unwrap_or(Status::InternalServerError)\n    }\n}\n\nimpl crate::http::ext::IntoOwned for Errors<'_> {\n    type Owned = Errors<'static>;\n\n    fn into_owned(self) -> Self::Owned {\n        Errors(self.0.into_owned())\n    }\n}\n\nimpl fmt::Display for Errors<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} error(s):\", self.len())?;\n        for error in self.iter() {\n            write!(f, \"\\n{}\", error)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl<'v> std::ops::Deref for Errors<'v> {\n    type Target = Vec<Error<'v>>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<'v> std::ops::DerefMut for Errors<'v> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<'v, T: Into<Error<'v>>> From<T> for Errors<'v> {\n    #[inline(always)]\n    fn from(e: T) -> Self {\n        Errors(vec![e.into()])\n    }\n}\n\nimpl<'v> From<Vec<Error<'v>>> for Errors<'v> {\n    #[inline(always)]\n    fn from(v: Vec<Error<'v>>) -> Self {\n        Errors(v)\n    }\n}\n\nimpl<'v> IntoIterator for Errors<'v> {\n    type Item = Error<'v>;\n\n    type IntoIter = <Vec<Error<'v>> as IntoIterator>::IntoIter;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\nimpl<'v> Error<'v> {\n    /// Creates a new `Error` with `ErrorKind::Custom`.\n    ///\n    /// For validation errors, use [`Error::validation()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::Error;\n    ///\n    /// fn from_fmt(error: std::fmt::Error) -> Error<'static> {\n    ///     Error::custom(error)\n    /// }\n    /// ```\n    pub fn custom<E>(error: E) -> Self\n        where E: std::error::Error + Send + 'static\n    {\n        (Box::new(error) as Box<dyn std::error::Error + Send>).into()\n    }\n\n    /// Creates a new `Error` with `ErrorKind::Validation` and message `msg`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind, Entity};\n    ///\n    /// let error = Error::validation(\"invalid foo: need bar\");\n    /// assert!(matches!(error.kind, ErrorKind::Validation(_)));\n    /// assert_eq!(error.entity, Entity::Value);\n    /// ```\n    pub fn validation<S: Into<Cow<'v, str>>>(msg: S) -> Self {\n        ErrorKind::Validation(msg.into()).into()\n    }\n\n    /// Consumes `self` and returns a new `Error` with the entity set to\n    /// `entity`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind, Entity};\n    ///\n    /// let error = Error::from(ErrorKind::Missing);\n    /// assert_eq!(error.entity, Entity::Field);\n    ///\n    /// let error = error.with_entity(Entity::Key);\n    /// assert_eq!(error.entity, Entity::Key);\n    /// ```\n    pub fn with_entity(mut self, entity: Entity) -> Self {\n        self.set_entity(entity);\n        self\n    }\n\n    /// Sets the error's entity to `entity.`\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind, Entity};\n    ///\n    /// let mut error = Error::from(ErrorKind::Missing);\n    /// assert_eq!(error.entity, Entity::Field);\n    ///\n    /// error.set_entity(Entity::Key);\n    /// assert_eq!(error.entity, Entity::Key);\n    /// ```\n    pub fn set_entity(&mut self, entity: Entity) {\n        self.entity = entity;\n    }\n\n    /// Consumes `self` and returns a new `Error` with the field name set to\n    /// `name` if it was not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind};\n    ///\n    /// let error = Error::from(ErrorKind::Missing);\n    /// assert!(error.name.is_none());\n    ///\n    /// let error = error.with_name(\"foo\");\n    /// assert_eq!(error.name.as_ref().unwrap(), \"foo\");\n    ///\n    /// let error = error.with_name(\"bar\");\n    /// assert_eq!(error.name.as_ref().unwrap(), \"foo\");\n    /// ```\n    pub fn with_name<N: Into<NameBuf<'v>>>(mut self, name: N) -> Self {\n        self.set_name(name);\n        self\n    }\n\n    /// Sets the field name of `self` to `name` if it is not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind};\n    ///\n    /// let mut error = Error::from(ErrorKind::Missing);\n    /// assert!(error.name.is_none());\n    ///\n    /// error.set_name(\"foo\");\n    /// assert_eq!(error.name.as_ref().unwrap(), \"foo\");\n    ///\n    /// let error = error.with_name(\"bar\");\n    /// assert_eq!(error.name.as_ref().unwrap(), \"foo\");\n    /// ```\n    pub fn set_name<N: Into<NameBuf<'v>>>(&mut self, name: N) {\n        if self.name.is_none() {\n            self.name = Some(name.into());\n        }\n    }\n\n    /// Consumes `self` and returns a new `Error` with the value set to `value`\n    /// if it was not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind};\n    ///\n    /// let error = Error::from(ErrorKind::Missing);\n    /// assert!(error.value.is_none());\n    ///\n    /// let error = error.with_value(\"foo\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"foo\");\n    ///\n    /// let error = error.with_value(\"bar\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"foo\");\n    /// ```\n    pub fn with_value(mut self, value: &'v str) -> Self {\n        self.set_value(value);\n        self\n    }\n\n    /// Set the field value of `self` to `value` if it is not already set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::error::{Error, ErrorKind};\n    ///\n    /// let mut error = Error::from(ErrorKind::Missing);\n    /// assert!(error.value.is_none());\n    ///\n    /// error.set_value(\"foo\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"foo\");\n    ///\n    /// error.set_value(\"bar\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"foo\");\n    /// ```\n    pub fn set_value(&mut self, value: &'v str) {\n        if self.value.is_none() {\n            self.value = Some(value.into());\n        }\n    }\n\n    /// Returns `true` if this error applies to a field named `name`. **This is\n    /// _different_ than simply comparing `name`.**\n    ///\n    /// Unlike [`Error::is_for_exactly()`], this method returns `true` if the\n    /// error's field name is a **prefix of `name`**. This is typically what is\n    /// desired as errors apply to a field and its children: `a.b` applies to\n    /// the nested fields `a.b.c`, `a.b.d` and so on.\n    ///\n    /// Returns `false` if `self` has no field name.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::Error;\n    ///\n    /// // returns `false` without a field name\n    /// let error = Error::validation(\"bad `foo`\");\n    /// assert!(!error.is_for_exactly(\"a.b\"));\n    ///\n    /// // `a.b` is a prefix all of these field names\n    /// let error = error.with_name(\"a.b\");\n    /// assert!(error.is_for(\"a.b\"));\n    /// assert!(error.is_for(\"a[b]\"));\n    /// assert!(error.is_for(\"a.b.c\"));\n    /// assert!(error.is_for(\"a.b[c]\"));\n    /// assert!(error.is_for(\"a.b.c[d]\"));\n    /// assert!(error.is_for(\"a.b.c.d.foo\"));\n    ///\n    /// // ...but not of these.\n    /// assert!(!error.is_for(\"a.c\"));\n    /// assert!(!error.is_for(\"a\"));\n    /// ```\n    pub fn is_for<N: AsRef<Name>>(&self, name: N) -> bool {\n        self.name.as_ref().map(|e_name| {\n            if e_name.is_empty() != name.as_ref().is_empty() {\n                return false;\n            }\n\n            let mut e_keys = e_name.keys();\n            let mut n_keys = name.as_ref().keys();\n            loop {\n                match (e_keys.next(), n_keys.next()) {\n                    (Some(e), Some(n)) if e == n => continue,\n                    (Some(_), Some(_)) => return false,\n                    (Some(_), None) => return false,\n                    (None, _) => break,\n                }\n            }\n\n            true\n        })\n        .unwrap_or(false)\n    }\n\n    /// Returns `true` if this error applies to exactly the field named `name`.\n    /// Returns `false` if `self` has no field name.\n    ///\n    /// Unlike [`Error::is_for()`], this method returns `true` only when the\n    /// error's field name is exactly `name`. This is _not_ typically what is\n    /// desired.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::Error;\n    ///\n    /// // returns `false` without a field name\n    /// let error = Error::validation(\"bad `foo`\");\n    /// assert!(!error.is_for_exactly(\"a.b\"));\n    ///\n    /// let error = error.with_name(\"a.b\");\n    /// assert!(error.is_for_exactly(\"a.b\"));\n    /// assert!(error.is_for_exactly(\"a[b]\"));\n    ///\n    /// // does not return `true` when the name is a prefix\n    /// assert!(!error.is_for_exactly(\"a.b.c\"));\n    /// assert!(!error.is_for_exactly(\"a.b[c]\"));\n    /// assert!(!error.is_for_exactly(\"a.b.c[d]\"));\n    /// assert!(!error.is_for_exactly(\"a.b.c.d.foo\"));\n    ///\n    /// // does not return `true` when the name is different\n    /// assert!(!error.is_for(\"a.c\"));\n    /// assert!(!error.is_for(\"a\"));\n    /// ```\n    pub fn is_for_exactly<N: AsRef<Name>>(&self, name: N) -> bool {\n        self.name.as_ref()\n            .map(|n| name.as_ref() == n)\n            .unwrap_or(false)\n    }\n\n    /// Returns the most reasonable [`Status`] associated with this error.\n    ///\n    /// For an [`ErrorKind::Custom`], this is the variant's `Status`, which\n    /// defaults to [`Status::UnprocessableEntity`]. For all others, it is:\n    ///\n    ///  * **`PayloadTooLarge`** if the [error kind](ErrorKind) is:\n    ///    - `InvalidLength` with min of `None`\n    ///    - `Multipart(FieldSizeExceeded)` or `Multipart(StreamSizeExceeded)`\n    ///  * **`InternalServerError`** if the [error kind](ErrorKind) is:\n    ///    - `Unknown`\n    ///  * **`BadRequest`** if the [error kind](ErrorKind) is:\n    ///    - `Io` with an `entity` of `Form`\n    ///  * **`UnprocessableEntity`** for all other variants\n    ///\n    /// # Example\n    ///\n    ///  ```rust\n    ///  use rocket::form::error::{Error, ErrorKind, Entity};\n    ///  use rocket::http::Status;\n    ///\n    ///  let error = Error::validation(\"bad `foo`\");\n    ///  assert_eq!(error.status(), Status::UnprocessableEntity);\n    ///\n    ///  let error = Error::from((None, Some(10u64)));\n    ///  assert_eq!(error.status(), Status::PayloadTooLarge);\n    ///\n    ///  let error = Error::from(ErrorKind::Unknown);\n    ///  assert_eq!(error.status(), Status::InternalServerError);\n    ///\n    ///  // default entity for `io::Error` is `Form`.\n    ///  let error = Error::from(std::io::Error::last_os_error());\n    ///  assert_eq!(error.status(), Status::BadRequest);\n    ///\n    ///  let error = error.with_entity(Entity::Value);\n    ///  assert_eq!(error.status(), Status::UnprocessableEntity);\n    ///  ```\n    pub fn status(&self) -> Status {\n        use ErrorKind::*;\n        use multer::Error::*;\n\n        match self.kind {\n            | InvalidLength { min: None, .. }\n            | Multipart(FieldSizeExceeded { .. })\n            | Multipart(StreamSizeExceeded { .. }) => Status::PayloadTooLarge,\n            Unknown => Status::InternalServerError,\n            Io(_) | _ if self.entity == Entity::Form => Status::BadRequest,\n            Custom(status, _) => status,\n            _ => Status::UnprocessableEntity\n        }\n    }\n}\n\nimpl<'v> Serialize for Error<'v> {\n    fn serialize<S: Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {\n        let mut err = ser.serialize_struct(\"Error\", 3)?;\n        err.serialize_field(\"name\", &self.name)?;\n        err.serialize_field(\"value\", &self.value)?;\n        err.serialize_field(\"entity\", &self.entity.to_string())?;\n        err.serialize_field(\"msg\", &self.to_string())?;\n        err.end()\n    }\n}\n\nimpl crate::http::ext::IntoOwned for Error<'_> {\n    type Owned = Error<'static>;\n\n    fn into_owned(self) -> Self::Owned {\n        Error {\n            name: self.name.into_owned(),\n            value: self.value.into_owned(),\n            kind: self.kind.into_owned(),\n            entity: self.entity,\n        }\n    }\n}\n\nimpl<'v> std::ops::Deref for Error<'v> {\n    type Target = ErrorKind<'v>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.kind\n    }\n}\n\nimpl fmt::Display for Error<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.kind.fmt(f)\n    }\n}\n\nimpl<'v, T: Into<ErrorKind<'v>>> From<T> for Error<'v> {\n    #[inline(always)]\n    fn from(k: T) -> Self {\n        let kind = k.into();\n        let entity = Entity::default_for(&kind);\n        Error { name: None, value: None, kind, entity }\n    }\n}\n\nimpl<'a> From<multer::Error> for Error<'a> {\n    fn from(error: multer::Error) -> Self {\n        use multer::Error::*;\n        use self::ErrorKind::*;\n\n        let incomplete = Error::from(InvalidLength { min: None, max: None });\n        match error {\n            UnknownField { field_name: Some(name) } => Error::from(Unexpected).with_name(name),\n            UnknownField { field_name: None } => Error::from(Unexpected),\n            FieldSizeExceeded { limit, field_name } => {\n                let e = Error::from((None, Some(limit)));\n                match field_name {\n                    Some(name) => e.with_name(name),\n                    None => e\n                }\n            },\n            StreamSizeExceeded { limit } => {\n                Error::from((None, Some(limit))).with_entity(Entity::Form)\n            }\n            IncompleteFieldData { field_name: Some(name) } => incomplete.with_name(name),\n            IncompleteFieldData { field_name: None } => incomplete,\n            IncompleteStream | IncompleteHeaders => incomplete.with_entity(Entity::Form),\n            e => Error::from(ErrorKind::Multipart(e))\n        }\n    }\n}\n\nimpl fmt::Display for ErrorKind<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorKind::InvalidLength { min, max } => {\n                match (min, max) {\n                    (None, None) => write!(f, \"invalid length: incomplete\")?,\n                    (None, Some(k)) if *k < 1024 => write!(f, \"length cannot exceed {}\", k)?,\n                    (None, Some(k)) => write!(f, \"size must not exceed {}\", ByteUnit::from(*k))?,\n                    (Some(1), None) => write!(f, \"cannot be empty\")?,\n                    (Some(k), None) if *k < 1024 => write!(f, \"expected at least {}\", k)?,\n                    (Some(k), None) => write!(f, \"size must be at least {}\", ByteUnit::from(*k))?,\n                    (Some(i), Some(j)) if *i < 1024 && *j < 1024 => {\n                        write!(f, \"length must be between {} and {}\", i, j)?;\n                    }\n                    (Some(i), Some(j)) => {\n                        let (i, j) = (ByteUnit::from(*i), ByteUnit::from(*j));\n                        write!(f, \"size must be between {} and {}\", i, j)?;\n                    }\n                }\n            }\n            ErrorKind::InvalidChoice { choices } => {\n                match *choices.as_ref() {\n                    [] => write!(f, \"invalid choice\")?,\n                    [ref choice] => write!(f, \"expected {}\", choice)?,\n                    _ => {\n                        write!(f, \"expected one of \")?;\n                        for (i, choice) in choices.iter().enumerate() {\n                            if i != 0 { write!(f, \", \")?; }\n                            write!(f, \"`{}`\", choice)?;\n                        }\n                    }\n                }\n            }\n            ErrorKind::OutOfRange { start, end } => {\n                match (start, end) {\n                    (None, None) => write!(f, \"value is out of range\")?,\n                    (None, Some(k)) => write!(f, \"value cannot exceed {}\", k)?,\n                    (Some(k), None) => write!(f, \"value must be at least {}\", k)?,\n                    (Some(i), Some(j)) => write!(f, \"value must be between {} and {}\", i, j)?,\n                }\n            }\n            ErrorKind::Validation(msg) => msg.fmt(f)?,\n            ErrorKind::Duplicate => \"duplicate\".fmt(f)?,\n            ErrorKind::Missing => \"missing\".fmt(f)?,\n            ErrorKind::Unexpected => \"unexpected\".fmt(f)?,\n            ErrorKind::Unknown => \"unknown internal error\".fmt(f)?,\n            ErrorKind::Custom(_, e) => e.fmt(f)?,\n            ErrorKind::Multipart(e) => write!(f, \"invalid multipart: {}\", e)?,\n            ErrorKind::Utf8(e) => write!(f, \"invalid UTF-8: {}\", e)?,\n            ErrorKind::Char(e) => write!(f, \"invalid character: {}\", e)?,\n            ErrorKind::Int(e) => write!(f, \"invalid integer: {}\", e)?,\n            ErrorKind::Bool(e) => write!(f, \"invalid boolean: {}\", e)?,\n            ErrorKind::Float(e) => write!(f, \"invalid float: {}\", e)?,\n            ErrorKind::Addr(e) => write!(f, \"invalid address: {}\", e)?,\n            ErrorKind::Io(e) => write!(f, \"i/o error: {}\", e)?,\n        }\n\n        Ok(())\n    }\n}\n\nimpl crate::http::ext::IntoOwned for ErrorKind<'_> {\n    type Owned = ErrorKind<'static>;\n\n    fn into_owned(self) -> Self::Owned {\n        use ErrorKind::*;\n\n        match self {\n            InvalidLength { min, max } => InvalidLength { min, max },\n            OutOfRange { start, end } => OutOfRange { start, end },\n            Validation(s) => Validation(s.into_owned().into()),\n            Duplicate => Duplicate,\n            Missing => Missing,\n            Unexpected => Unexpected,\n            Unknown => Unknown,\n            Custom(s, e) => Custom(s, e),\n            Multipart(e) => Multipart(e),\n            Utf8(e) => Utf8(e),\n            Char(e) => Char(e),\n            Int(e) => Int(e),\n            Bool(e) => Bool(e),\n            Float(e) => Float(e),\n            Addr(e) => Addr(e),\n            Io(e) => Io(e),\n            InvalidChoice { choices } => InvalidChoice {\n                choices: choices.iter()\n                    .map(|s| Cow::Owned(s.to_string()))\n                    .collect::<Vec<_>>()\n                    .into()\n            }\n        }\n    }\n}\n\nimpl<'a, 'b> PartialEq<ErrorKind<'b>> for ErrorKind<'a> {\n    fn eq(&self, other: &ErrorKind<'b>) -> bool {\n        use ErrorKind::*;\n        match (self, other) {\n            (InvalidLength { min: a, max: b }, InvalidLength { min, max }) => min == a && max == b,\n            (InvalidChoice { choices: a }, InvalidChoice { choices }) => choices == a,\n            (OutOfRange { start: a, end: b }, OutOfRange { start, end }) => start == a && end == b,\n            (Validation(a), Validation(b)) => a == b,\n            (Duplicate, Duplicate) => true,\n            (Missing, Missing) => true,\n            (Unexpected, Unexpected) => true,\n            (Custom(a, _), Custom(b, _)) => a == b,\n            (Multipart(a), Multipart(b)) => a == b,\n            (Utf8(a), Utf8(b)) => a == b,\n            (Int(a), Int(b)) => a == b,\n            (Bool(a), Bool(b)) => a == b,\n            (Float(a), Float(b)) => a == b,\n            (Addr(a), Addr(b)) => a == b,\n            (Io(a), Io(b)) => a.kind() == b.kind(),\n            _ => false,\n        }\n    }\n}\n\nimpl From<(Option<u64>, Option<u64>)> for ErrorKind<'_> {\n    fn from((min, max): (Option<u64>, Option<u64>)) -> Self {\n        ErrorKind::InvalidLength { min, max }\n    }\n}\n\nimpl<'a, 'v: 'a> From<&'static [Cow<'v, str>]> for ErrorKind<'a> {\n    fn from(choices: &'static [Cow<'v, str>]) -> Self {\n        ErrorKind::InvalidChoice { choices: choices.into() }\n    }\n}\n\nimpl<'a, 'v: 'a> From<Vec<Cow<'v, str>>> for ErrorKind<'a> {\n    fn from(choices: Vec<Cow<'v, str>>) -> Self {\n        ErrorKind::InvalidChoice { choices: choices.into() }\n    }\n}\n\nimpl From<(Option<isize>, Option<isize>)> for ErrorKind<'_> {\n    fn from((start, end): (Option<isize>, Option<isize>)) -> Self {\n        ErrorKind::OutOfRange { start, end }\n    }\n}\n\nimpl From<(Option<ByteUnit>, Option<ByteUnit>)> for ErrorKind<'_> {\n    fn from((start, end): (Option<ByteUnit>, Option<ByteUnit>)) -> Self {\n        ErrorKind::from((start.map(ByteUnit::as_u64), end.map(ByteUnit::as_u64)))\n    }\n}\n\nimpl<'a, 'v: 'a, const N: usize> From<&'static [Cow<'v, str>; N]> for ErrorKind<'a> {\n    fn from(choices: &'static [Cow<'v, str>; N]) -> Self {\n        let choices = &choices[..];\n        ErrorKind::InvalidChoice { choices: choices.into() }\n    }\n}\n\nimpl<'a> From<Box<dyn std::error::Error + Send>> for ErrorKind<'a> {\n    fn from(e: Box<dyn std::error::Error + Send>) -> Self {\n        ErrorKind::Custom(Status::UnprocessableEntity, e)\n    }\n}\n\nimpl<'a> From<(Status, Box<dyn std::error::Error + Send>)> for ErrorKind<'a> {\n    fn from((status, e): (Status, Box<dyn std::error::Error + Send>)) -> Self {\n        ErrorKind::Custom(status, e)\n    }\n}\n\nmacro_rules! impl_from_for {\n    (<$l:lifetime> $T:ty => $V:ty as $variant:ident) => (\n        impl<$l> From<$T> for $V {\n            fn from(value: $T) -> Self {\n                <$V>::$variant(value)\n            }\n        }\n    )\n}\n\nimpl_from_for!(<'a> Utf8Error => ErrorKind<'a> as Utf8);\nimpl_from_for!(<'a> ParseIntError => ErrorKind<'a> as Int);\nimpl_from_for!(<'a> ParseCharError => ErrorKind<'a> as Char);\nimpl_from_for!(<'a> ParseFloatError => ErrorKind<'a> as Float);\nimpl_from_for!(<'a> ParseBoolError => ErrorKind<'a> as Bool);\nimpl_from_for!(<'a> AddrParseError => ErrorKind<'a> as Addr);\nimpl_from_for!(<'a> io::Error => ErrorKind<'a> as Io);\n\nimpl fmt::Display for Entity {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let string = match self {\n            Entity::Form => \"form\",\n            Entity::Field => \"field\",\n            Entity::ValueField => \"value field\",\n            Entity::DataField => \"data field\",\n            Entity::Name => \"name\",\n            Entity::Value => \"value\",\n            Entity::Key => \"key\",\n            Entity::Index(k) => return write!(f, \"index {}\", k),\n        };\n\n        string.fmt(f)\n    }\n}\n\nimpl Entity {\n    /// The default entity for an [`Error`] created for `ErrorKind`.\n    ///\n    ///  * **[`Field`]** if `Duplicate`, `Missing`, `Unexpected`, or `Unknown`\n    ///  * **[`Form`]** if `Multipart` or `Io`\n    ///  * **[`Value`]** otherwise\n    ///\n    /// [`Field`]: Entity::Field\n    /// [`Form`]: Entity::Form\n    /// [`Value`]: Entity::Value\n    pub const fn default_for(kind: &ErrorKind<'_>) -> Self {\n        match kind {\n            | ErrorKind::InvalidLength { .. }\n            | ErrorKind::InvalidChoice { .. }\n            | ErrorKind::OutOfRange { .. }\n            | ErrorKind::Validation { .. }\n            | ErrorKind::Utf8(_)\n            | ErrorKind::Char(_)\n            | ErrorKind::Int(_)\n            | ErrorKind::Float(_)\n            | ErrorKind::Bool(_)\n            | ErrorKind::Custom(..)\n            | ErrorKind::Addr(_) => Entity::Value,\n\n            | ErrorKind::Duplicate\n            | ErrorKind::Missing\n            | ErrorKind::Unknown\n            | ErrorKind::Unexpected => Entity::Field,\n\n            | ErrorKind::Multipart(_)\n            | ErrorKind::Io(_) => Entity::Form,\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::form::{name::NameView, error::{Error, ErrorKind, Entity}};\nuse crate::http::{ContentType, RawStr};\nuse crate::{Request, Data};\nuse crate::fs::FileName;\n\n/// A form field with a string value.\n///\n/// Rocket preprocesses all form fields into either [`ValueField`]s or\n/// [`DataField`]s. All fields from url-encoded forms, and fields without\n/// Content-Types from multipart forms, are preprocessed as a `ValueField`.\n#[derive(Debug, Clone)]\npub struct ValueField<'r> {\n    /// The (decoded) name of the form field.\n    pub name: NameView<'r>,\n    /// The (decoded) value of the form field.\n    pub value: &'r str,\n}\n\n/// A multipart form field with an underlying data stream.\n///\n/// Rocket preprocesses all form fields into either [`ValueField`]s or\n/// [`DataField`]s. Multipart form fields with a `Content-Type` are preprocessed\n/// as a `DataField`. The underlying data is _not_ read into memory, but\n/// instead, streamable from the contained [`Data`] structure.\npub struct DataField<'r, 'i> {\n    /// The (decoded) name of the form field.\n    pub name: NameView<'r>,\n    /// The form fields's file name.\n    pub file_name: Option<&'r FileName>,\n    /// The form field's Content-Type, as submitted, which may or may not\n    /// reflect on `data`.\n    pub content_type: ContentType,\n    /// The request in which the form field was submitted.\n    pub request: &'r Request<'i>,\n    /// The raw data stream.\n    pub data: Data<'r>,\n}\n\nimpl<'v> ValueField<'v> {\n    /// Parse a field string, where both the key and value are assumed to be\n    /// URL-decoded while preserving the `=` delimiter, into a `ValueField`.\n    ///\n    /// This implements 3.2, 3.3 of [section 5.1 of the WHATWG living standard].\n    ///\n    /// [section 5.1 of the WHATWG living standard]: https://url.spec.whatwg.org/#urlencoded-parsing\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::ValueField;\n    ///\n    /// let parsed = ValueField::parse(\"a cat=an A+ pet\");\n    /// assert_eq!(parsed.name, \"a cat\");\n    /// assert_eq!(parsed.value, \"an A+ pet\");\n    ///\n    /// let parsed = ValueField::parse(\"a cat is an A+ pet\");\n    /// assert_eq!(parsed.name, \"a cat is an A+ pet\");\n    /// assert_eq!(parsed.value, \"\");\n    ///\n    /// let parsed = ValueField::parse(\"cat.food=yum?\");\n    /// assert_eq!(parsed.name, \"cat\");\n    /// assert_eq!(parsed.name.source(), \"cat.food\");\n    /// assert_eq!(parsed.value, \"yum?\");\n    /// ```\n    pub fn parse(field: &'v str) -> Self {\n        // WHATWG URL Living Standard 5.1 steps 3.2, 3.3.\n        let (name, val) = RawStr::new(field).split_at_byte(b'=');\n        ValueField::from((name.as_str(), val.as_str()))\n    }\n\n    /// Create a `ValueField` from a value, which is assumed to be URL-decoded.\n    /// The field `name` will be empty.\n    ///\n    /// This is equivalent to `ValueField::from((\"\", value))`. To create a\n    /// `ValueField` from both a `name` and a `value`, use\n    /// `ValueField::from((name, value))`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::ValueField;\n    ///\n    /// let parsed = ValueField::from_value(\"A+=kitten\");\n    /// assert_eq!(parsed.name, \"\");\n    /// assert_eq!(parsed.value, \"A+=kitten\");\n    /// ```\n    pub fn from_value(value: &'v str) -> Self {\n        ValueField::from((\"\", value))\n    }\n\n    /// Shift the `name` of `self` and return `self` with the shifted `name`.\n    ///\n    /// See [`NameView::shift()`] for the details on name \"shifting\".\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::ValueField;\n    ///\n    /// let parsed = ValueField::parse(\"cat.food=yum?\");\n    /// assert_eq!(parsed.name, \"cat\");\n    /// assert_eq!(parsed.name.source(), \"cat.food\");\n    /// assert_eq!(parsed.name.key_lossy(), \"cat\");\n    ///\n    /// let shifted = parsed.shift();\n    /// assert_eq!(shifted.name, \"cat.food\");\n    /// assert_eq!(shifted.name.key_lossy(), \"food\");\n    /// ```\n    pub fn shift(mut self) -> Self {\n        self.name.shift();\n        self\n    }\n\n    /// Creates a complete unexpected value field [`Error`] from `self`.\n    ///\n    /// The error will have the following properties:\n    ///   * `kind`: [`ErrorKind::Unexpected`]\n    ///   * `name`: [`self.name.source()`](NameView::source())\n    ///   * `value`: [`self.value`](ValueField::value)\n    ///   * `entity`: [`Entity::ValueField`]\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::ValueField;\n    /// use rocket::form::error::{ErrorKind, Entity};\n    ///\n    /// let field = ValueField::parse(\"cat.food=yum?\");\n    /// let error = field.unexpected();\n    ///\n    /// assert_eq!(error.name.as_ref().unwrap(), \"cat.food\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"yum?\");\n    /// assert_eq!(error.kind, ErrorKind::Unexpected);\n    /// assert_eq!(error.entity, Entity::ValueField);\n    /// ```\n    pub fn unexpected(&self) -> Error<'v> {\n        Error::from(ErrorKind::Unexpected)\n            .with_name(self.name.source())\n            .with_value(self.value)\n            .with_entity(Entity::ValueField)\n    }\n\n    /// Creates a complete missing value field [`Error`] from `self`.\n    ///\n    /// The error will have the following properties:\n    ///   * `kind`: [`ErrorKind::Missing`]\n    ///   * `name`: [`self.name.source()`](NameView::source())\n    ///   * `value`: [`self.value`](ValueField::value)\n    ///   * `entity`: [`Entity::ValueField`]\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::ValueField;\n    /// use rocket::form::error::{ErrorKind, Entity};\n    ///\n    /// let field = ValueField::parse(\"cat.food=yum?\");\n    /// let error = field.missing();\n    ///\n    /// assert_eq!(error.name.as_ref().unwrap(), \"cat.food\");\n    /// assert_eq!(error.value.as_ref().unwrap(), \"yum?\");\n    /// assert_eq!(error.kind, ErrorKind::Missing);\n    /// assert_eq!(error.entity, Entity::ValueField);\n    /// ```\n    pub fn missing(&self) -> Error<'v> {\n        Error::from(ErrorKind::Missing)\n            .with_name(self.name.source())\n            .with_value(self.value)\n            .with_entity(Entity::ValueField)\n    }\n}\n\nimpl<'v> DataField<'v, '_> {\n    /// Shift the `name` of `self` and return `self` with the shifted `name`.\n    ///\n    /// This is identical to [`ValueField::shift()`] but for `DataField`s. See\n    /// [`NameView::shift()`] for the details on name \"shifting\".\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::DataField;\n    ///\n    /// fn push_data(field: DataField<'_, '_>) {\n    ///     let shifted = field.shift();\n    /// }\n    /// ```\n    pub fn shift(mut self) -> Self {\n        self.name.shift();\n        self\n    }\n\n    /// Creates a complete unexpected data field [`Error`] from `self`.\n    ///\n    /// The error will have the following properties:\n    ///   * `kind`: [`ErrorKind::Unexpected`]\n    ///   * `name`: [`self.name.source()`](NameView::source())\n    ///   * `value`: `None`\n    ///   * `entity`: [`Entity::DataField`]\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::DataField;\n    ///\n    /// fn push_data(field: DataField<'_, '_>) {\n    ///     let error = field.unexpected();\n    /// }\n    /// ```\n    pub fn unexpected(&self) -> Error<'v> {\n        Error::from(ErrorKind::Unexpected)\n            .with_name(self.name.source())\n            .with_entity(Entity::DataField)\n    }\n}\n\nimpl<'a> From<(&'a str, &'a str)> for ValueField<'a> {\n    fn from((name, value): (&'a str, &'a str)) -> Self {\n        ValueField { name: NameView::new(name), value }\n    }\n}\n\nimpl<'a, 'b> PartialEq<ValueField<'b>> for ValueField<'a> {\n    fn eq(&self, other: &ValueField<'b>) -> bool {\n        self.name == other.name && self.value == other.value\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::{Deref, DerefMut};\n\nuse crate::Request;\nuse crate::outcome::try_outcome;\nuse crate::data::{Data, FromData, Outcome};\nuse crate::http::{RawStr, ext::IntoOwned};\nuse crate::form::{SharedStack, parser::{Parser, RawStrParser}};\nuse crate::form::prelude::*;\n\n/// A data guard for [`FromForm`] types.\n///\n/// This type implements the [`FromData`] trait. It provides a generic means to\n/// parse arbitrary structures from incoming form data.\n///\n/// See the [forms guide](https://rocket.rs/v0.5/guide/requests#forms) for\n/// general form support documentation.\n///\n/// # Leniency\n///\n/// A `Form<T>` will parse successfully from an incoming form if the form\n/// contains a superset of the fields in `T`. Said another way, a `Form<T>`\n/// automatically discards extra fields without error. For instance, if an\n/// incoming form contains the fields \"a\", \"b\", and \"c\" while `T` only contains\n/// \"a\" and \"c\", the form _will_ parse as `Form<T>`. To parse strictly, use the\n/// [`Strict`](crate::form::Strict) form guard.\n///\n/// # Usage\n///\n/// This type can be used with any type that implements the `FromForm` trait.\n/// The trait can be automatically derived; see the [`FromForm`] documentation\n/// for more information on deriving or implementing the trait.\n///\n/// Because `Form` implements `FromData`, it can be used directly as a target of\n/// the `data = \"<param>\"` route parameter as long as its generic type\n/// implements the `FromForm` trait:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::form::Form;\n/// use rocket::http::RawStr;\n///\n/// #[derive(FromForm)]\n/// struct UserInput<'r> {\n///     value: &'r str\n/// }\n///\n/// #[post(\"/submit\", data = \"<user_input>\")]\n/// fn submit_task(user_input: Form<UserInput<'_>>) -> String {\n///     format!(\"Your value: {}\", user_input.value)\n/// }\n/// ```\n///\n/// A type of `Form<T>` automatically dereferences into an `&T` or `&mut T`,\n/// though you can also transform a `Form<T>` into a `T` by calling\n/// [`into_inner()`](Form::into_inner()). Thanks to automatic dereferencing, you\n/// can access fields of `T` transparently through a `Form<T>`, as seen above\n/// with `user_input.value`.\n///\n/// ## Errors\n///\n/// A `Form<T>` data guard may fail, forward, or succeed.\n///\n/// If a request's content-type is neither [`ContentType::Form`] nor\n/// [`ContentType::FormData`], the guard **forwards**.\n///\n/// If the request `ContentType` _does_ identify as a form but the form data\n/// does not parse as `T`, according to `T`'s [`FromForm`] implementation, the\n/// guard **fails**. The `Error` variant contains a vector of the [`Errors`]\n/// emitted by `T`'s `FromForm` parser. If the error is not caught by a\n/// [`form::Result<T>`](Result) or `Option<Form<T>>` data guard, the status code\n/// is set to [`Errors::status()`], and the corresponding error catcher is\n/// called.\n///\n/// Otherwise the guard **succeeds**.\n///\n/// [`ContentType::Form`]: crate::http::ContentType::Form\n/// [`ContentType::FormData`]: crate::http::ContentType::FormData\n///\n/// ## Data Limits\n///\n/// The total amount of data accepted by the `Form` data guard is limited by the\n/// following limits:\n///\n/// | Limit Name  | Default | Description                        |\n/// |-------------|---------|------------------------------------|\n/// | `form`      | 32KiB   | total limit for url-encoded forms  |\n/// | `data-form` | 2MiB    | total limit for multipart forms    |\n/// | `*`         | N/A     | each field type has its own limits |\n///\n/// As noted above, each form field type (a form guard) typically imposes its\n/// own limits. For example, the `&str` form guard imposes a data limit of\n/// `string` when multipart data is streamed.\n///\n/// ### URL-Encoded Forms\n///\n/// The `form` limit specifies the data limit for an entire url-encoded form\n/// data. It defaults to 32KiB. URL-encoded form data is percent-decoded, stored\n/// in-memory, and parsed into [`ValueField`]s. If the incoming data exceeds\n/// this limit, the `Form` data guard fails without attempting to parse fields\n/// with a `413: Payload Too Large` error.\n///\n/// ### Multipart Forms\n///\n/// The `data-form` limit specifies the data limit for an entire multipart form\n/// data stream. It defaults to 2MiB. Multipart data is streamed, and form\n/// fields are processed into [`DataField`]s or [`ValueField`]s as they arrive.\n/// If the commutative data received while streaming exceeds the limit, parsing\n/// is aborted, an error is created and pushed via [`FromForm::push_error()`],\n/// and the form is finalized.\n///\n/// ### Individual Fields\n///\n/// Individual fields _may_ have data limits as well. The type of the field\n/// determines whether there is a data limit. For instance, the `&str` type\n/// imposes the `string` data limit. Consult the type's documentation or\n/// [`FromFormField`] for details.\n///\n/// ### Changing Limits\n///\n/// To change data limits, set the `limits.form` and/or `limits.data-form`\n/// configuration parameters. For instance, to increase the URL-encoded forms\n/// limit to 128KiB for all environments, you might add the following to your\n/// `Rocket.toml`:\n///\n/// ```toml\n/// [global.limits]\n/// form = 128KiB\n/// ```\n///\n/// See the [`Limits`](crate::data::Limits) and [`config`](crate::config) docs\n/// for more.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Form<T>(T);\n\nimpl<T> Form<T> {\n    /// Consumes `self` and returns the inner value.\n    ///\n    /// Note that since `Form` implements [`Deref`] and [`DerefMut`] with\n    /// target `T`, reading and writing an inner value can be accomplished\n    /// transparently.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::form::Form;\n    ///\n    /// #[derive(FromForm)]\n    /// struct MyForm {\n    ///     field: String,\n    /// }\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<MyForm>) -> String {\n    ///     // We can read or mutate a value transparently:\n    ///     let field: &str = &form.field;\n    ///\n    ///     // To gain ownership, however, use `into_inner()`:\n    ///     form.into_inner().field\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\nimpl<T> From<T> for Form<T> {\n    #[inline]\n    fn from(val: T) -> Form<T> {\n        Form(val)\n    }\n}\n\nimpl<'r, T: FromForm<'r>> Form<T> {\n    /// Leniently parses a `T` from a **percent-decoded**\n    /// `x-www-form-urlencoded` form string. Specifically, this method\n    /// implements [5.1 of the WHATWG URL Living Standard] with the exception\n    /// of steps 3.4 and 3.5, which are assumed to already be reflected in\n    /// `string`, and then parses the fields as `T`.\n    ///\n    /// [5.1 of the WHATWG URL Living Standard]: https://url.spec.whatwg.org/#application/x-www-form-urlencoded\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::{Form, FromForm};\n    ///\n    /// #[derive(FromForm)]\n    /// struct Pet<'r> {\n    ///     name: &'r str,\n    ///     wags: bool,\n    /// }\n    ///\n    /// let string = \"name=Benson Wagger!&wags=true\";\n    /// let pet: Pet<'_> = Form::parse(string).unwrap();\n    /// assert_eq!(pet.name, \"Benson Wagger!\");\n    /// assert_eq!(pet.wags, true);\n    /// ```\n    #[inline]\n    pub fn parse(string: &'r str) -> Result<'r, T> {\n        // WHATWG URL Living Standard 5.1 steps 1, 2, 3.1 - 3.3.\n        Self::parse_iter(Form::values(string))\n    }\n\n    /// Leniently parses a `T` from the **percent-decoded** `fields`.\n    /// Specifically, this method implements [5.1 of the WHATWG URL Living\n    /// Standard] with the exception of step 3.\n    ///\n    /// [5.1 of the WHATWG URL Living Standard]: https://url.spec.whatwg.org/#application/x-www-form-urlencoded\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::{Form, FromForm, ValueField};\n    ///\n    /// #[derive(FromForm)]\n    /// struct Pet<'r> {\n    ///     name: &'r str,\n    ///     wags: bool,\n    /// }\n    ///\n    /// let fields = vec![\n    ///     ValueField::parse(\"name=Bob, the cat. :)\"),\n    ///     ValueField::parse(\"wags=no\"),\n    /// ];\n    ///\n    /// let pet: Pet<'_> = Form::parse_iter(fields).unwrap();\n    /// assert_eq!(pet.name, \"Bob, the cat. :)\");\n    /// assert_eq!(pet.wags, false);\n    /// ```\n    pub fn parse_iter<I>(fields: I) -> Result<'r, T>\n        where I: IntoIterator<Item = ValueField<'r>>\n    {\n        // WHATWG URL Living Standard 5.1 steps 1, 2, 3.1 - 3.3.\n        let mut ctxt = T::init(Options::Lenient);\n        fields.into_iter().for_each(|f| T::push_value(&mut ctxt, f));\n        T::finalize(ctxt)\n    }\n}\n\nimpl<T: for<'a> FromForm<'a> + 'static> Form<T> {\n    /// Leniently parses a `T` from a raw, `x-www-form-urlencoded` form string.\n    /// Specifically, this method implements [5.1 of the WHATWG URL Living\n    /// Standard]. Because percent-decoding might modify the input string, the\n    /// output type `T` must be `'static`.\n    ///\n    /// [5.1 of the WHATWG URL Living Standard]:https://url.spec.whatwg.org/#application/x-www-form-urlencoded\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::RawStr;\n    /// use rocket::form::{Form, FromForm};\n    ///\n    /// #[derive(FromForm)]\n    /// struct Pet {\n    ///     name: String,\n    ///     wags: bool,\n    /// }\n    ///\n    /// let string = RawStr::new(\"name=Benson+Wagger%21&wags=true\");\n    /// let pet: Pet = Form::parse_encoded(string).unwrap();\n    /// assert_eq!(pet.name, \"Benson Wagger!\");\n    /// assert_eq!(pet.wags, true);\n    /// ```\n    pub fn parse_encoded(string: &RawStr) -> Result<'static, T> {\n        let buffer = SharedStack::new();\n        let mut ctxt = T::init(Options::Lenient);\n        for field in RawStrParser::new(&buffer, string) {\n            T::push_value(&mut ctxt, field)\n        }\n\n        T::finalize(ctxt).map_err(|e| e.into_owned())\n    }\n}\n\nimpl Form<()> {\n    /// Returns an iterator of fields parsed from a `x-www-form-urlencoded` form\n    /// string. Specifically, this method implements steps 1, 2, and 3.1 - 3.3\n    /// of [5.1 of the WHATWG URL Living Standard]. Fields in the returned\n    /// iterator _are not_ percent-decoded.\n    ///\n    /// [5.1 of the WHATWG URL Living Standard]:https://url.spec.whatwg.org/#application/x-www-form-urlencoded\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::{Form, ValueField};\n    ///\n    /// let string = \"name=Bobby Brown&&&email=me@rocket.rs\";\n    /// let mut values = Form::values(string);\n    /// assert_eq!(values.next().unwrap(), ValueField::parse(\"name=Bobby Brown\"));\n    /// assert_eq!(values.next().unwrap(), ValueField::parse(\"email=me@rocket.rs\"));\n    /// assert!(values.next().is_none());\n    /// ```\n    pub fn values(string: &str) -> impl Iterator<Item = ValueField<'_>> {\n        // WHATWG URL Living Standard 5.1 steps 1, 2, 3.1 - 3.3.\n        string.split('&')\n            .filter(|s| !s.is_empty())\n            .map(ValueField::parse)\n    }\n}\n\nimpl<T> Deref for Form<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for Form<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromForm<'r>> FromData<'r> for Form<T> {\n    type Error = Errors<'r>;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        use either::Either;\n\n        let mut parser = try_outcome!(Parser::new(req, data).await);\n        let mut context = T::init(Options::Lenient);\n        while let Some(field) = parser.next().await {\n            match field {\n                Ok(Either::Left(value)) => T::push_value(&mut context, value),\n                Ok(Either::Right(data)) => T::push_data(&mut context, data).await,\n                Err(e) => T::push_error(&mut context, e),\n            }\n        }\n\n        match T::finalize(context) {\n            Ok(value) => Outcome::Success(Form(value)),\n            Err(e) => Outcome::Error((e.status(), e)),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::borrow::Cow;\nuse std::collections::{HashMap, BTreeMap};\nuse std::hash::Hash;\nuse std::sync::Arc;\n\nuse either::Either;\nuse indexmap::IndexMap;\n\nuse crate::form::prelude::*;\nuse crate::http::uncased::AsUncased;\n\n/// Trait implemented by form guards: types parseable from HTTP forms.\n///\n/// Only form guards that are _collections_, that is, collect more than one form\n/// field while parsing, should implement `FromForm`. All other types should\n/// implement [`FromFormField`] instead, which offers a simplified interface to\n/// parsing a single form field.\n///\n/// For a gentle introduction to forms in Rocket, see the [forms guide].\n///\n/// # Form Guards\n///\n/// A form guard is a guard that operates on form fields, typically those with a\n/// particular name prefix. Form guards validate and parse form field data via\n/// implementations of `FromForm`. In other words, a type is a form guard _iff_\n/// it implements `FromForm`.\n///\n/// Form guards are used as the inner type of the [`Form`] data guard:\n///\n/// ```rust\n/// # use rocket::post;\n/// use rocket::form::Form;\n///\n/// # type FormGuard = String;\n/// #[post(\"/submit\", data = \"<var>\")]\n/// fn submit(var: Form<FormGuard>) { /* ... */ }\n/// ```\n///\n/// # Deriving\n///\n/// This trait can, and largely _should_, be automatically derived. When\n/// deriving `FromForm`, every field in the structure must implement\n/// [`FromForm`]. Form fields with the struct field's name are [shifted] and\n/// then pushed to the struct field's `FromForm` parser.\n///\n/// [shifted]: NameView::shift()\n///\n/// ```rust\n/// use rocket::form::FromForm;\n///\n/// #[derive(FromForm)]\n/// struct TodoTask<'r> {\n///     #[field(validate = len(1..))]\n///     description: &'r str,\n///     #[field(name = \"done\")]\n///     completed: bool\n/// }\n/// ```\n///\n/// For full details on deriving `FromForm`, see the [`FromForm` derive].\n///\n/// [`Form`]: crate::form::Form\n/// [`FromForm`]: crate::form::FromForm\n/// [`FromForm` derive]: derive@crate::FromForm\n/// [FromFormField]: crate::form::FromFormField\n/// [`shift()`ed]: NameView::shift()\n/// [`key()`]: NameView::key()\n/// [forms guide]: https://rocket.rs/v0.5/guide/requests/#forms\n///\n/// # Parsing Strategy\n///\n/// Form parsing is either _strict_ or _lenient_, controlled by\n/// [`Options::strict`]. A _strict_ parse errors when there are missing or extra\n/// fields, while a _lenient_ parse allows both, providing there is a\n/// [`default()`](FromForm::default()) in the case of a missing field.\n///\n/// Most type inherit their strategy on [`FromForm::init()`], but some types\n/// like `Option` override the requested strategy. The strategy can also be\n/// overwritten manually, per-field or per-value, by using the [`Strict`] or\n/// [`Lenient`] form guard:\n///\n/// ```rust\n/// use rocket::form::{self, FromForm, Strict, Lenient};\n///\n/// #[derive(FromForm)]\n/// struct TodoTask<'r> {\n///     strict_bool: Strict<bool>,\n///     lenient_inner_option: Option<Lenient<bool>>,\n///     strict_inner_result: form::Result<'r, Strict<bool>>,\n/// }\n/// ```\n///\n/// # Defaults\n///\n/// A form guard may have a _default_ which is used in case of a missing field\n/// when parsing is _lenient_. When parsing is strict, all errors, including\n/// missing fields, are propagated directly.\n///\n/// # Provided Implementations\n///\n/// Rocket implements `FromForm` for many common types. As a result, most\n/// applications will never need a custom implementation of `FromForm` or\n/// `FromFormField`. Their behavior is documented in the table below.\n///\n/// | Type                   | Strategy    | Default           | Data   | Value  | Notes                                              |\n/// |------------------------|-------------|-------------------|--------|--------|----------------------------------------------------|\n/// | [`Strict<T>`]          | **strict**  | if `strict` `T`   | if `T` | if `T` | `T: FromForm`                                      |\n/// | [`Lenient<T>`]         | **lenient** | if `lenient` `T`  | if `T` | if `T` | `T: FromForm`                                      |\n/// | `Option<T>`            | **strict**  | `None`            | if `T` | if `T` | Infallible, `T: FromForm`                          |\n/// | [`Result<T>`]          | _inherit_   | `T::finalize()`   | if `T` | if `T` | Infallible, `T: FromForm`                          |\n/// | `Vec<T>`               | _inherit_   | `vec![]`          | if `T` | if `T` | `T: FromForm`                                      |\n/// | [`HashMap<K, V>`]      | _inherit_   | `HashMap::new()`  | if `V` | if `V` | `K: FromForm + Eq + Hash`, `V: FromForm`           |\n/// | [`BTreeMap<K, V>`]     | _inherit_   | `BTreeMap::new()` | if `V` | if `V` | `K: FromForm + Ord`, `V: FromForm`                 |\n/// | [`Range<T>`]           | _inherit_   | **no default**    | if `T` | if `T` | `T: FromForm`, expects `start`, `end` fields       |\n/// | [`RangeFrom<T>`]       | _inherit_   | **no default**    | if `T` | if `T` | `T: FromForm`, expects `start` field               |\n/// | [`RangeTo<T>`]         | _inherit_   | **no default**    | if `T` | if `T` | `T: FromForm`, expects `end` field                 |\n/// | [`RangeToInclusive<T>`]| _inherit_   | **no default**    | if `T` | if `T` | `T: FromForm`, expects `end` field                 |\n/// | `bool`                 | _inherit_   | `false`           | No     | Yes    | `\"yes\"/\"on\"/\"true\"`, `\"no\"/\"off\"/\"false\"`          |\n/// | (un)signed int         | _inherit_   | **no default**    | No     | Yes    | `{u,i}{size,8,16,32,64,128}`                       |\n/// | _nonzero_ int          | _inherit_   | **no default**    | No     | Yes    | `NonZero{I,U}{size,8,16,32,64,128}`                |\n/// | float                  | _inherit_   | **no default**    | No     | Yes    | `f{32,64}`                                         |\n/// | `&str`                 | _inherit_   | **no default**    | Yes    | Yes    | Percent-decoded. Data limit `string` applies.      |\n/// | `&[u8]`                | _inherit_   | **no default**    | Yes    | Yes    | Raw bytes. Data limit `bytes` applies.             |\n/// | `String`               | _inherit_   | **no default**    | Yes    | Yes    | Exactly `&str`, but owned. Prefer `&str`.          |\n/// | IP Address             | _inherit_   | **no default**    | No     | Yes    | [`IpAddr`], [`Ipv4Addr`], [`Ipv6Addr`]             |\n/// | Socket Address         | _inherit_   | **no default**    | No     | Yes    | [`SocketAddr`], [`SocketAddrV4`], [`SocketAddrV6`] |\n/// | [`TempFile`]           | _inherit_   | **no default**    | Yes    | Yes    | Data limits apply. See [`TempFile`].               |\n/// | [`Capped<C>`]          | _inherit_   | **no default**    | Yes    | Yes    | `C` is `&str`, `String`, `&[u8]` or `TempFile`.    |\n/// | [`time::Date`]         | _inherit_   | **no default**    | No     | Yes    | `%F` (`YYYY-MM-DD`). HTML \"date\" input.            |\n/// | [`time::DateTime`]     | _inherit_   | **no default**    | No     | Yes    | `%FT%R` or `%FT%T` (`YYYY-MM-DDTHH:MM[:SS]`)       |\n/// | [`time::Time`]         | _inherit_   | **no default**    | No     | Yes    | `%R` or `%T` (`HH:MM[:SS]`)                        |\n///\n/// [`Result<T>`]: crate::form::Result\n/// [`Strict<T>`]: crate::form::Strict\n/// [`Lenient<T>`]: crate::form::Lenient\n/// [`HashMap<K, V>`]: std::collections::HashMap\n/// [`BTreeMap<K, V>`]: std::collections::BTreeMap\n/// [`TempFile`]: crate::fs::TempFile\n/// [`Capped<C>`]: crate::data::Capped\n/// [`time::DateTime`]: time::PrimitiveDateTime\n/// [`IpAddr`]: std::net::IpAddr\n/// [`Ipv4Addr`]: std::net::Ipv4Addr\n/// [`Ipv6Addr`]: std::net::Ipv6Addr\n/// [`SocketAddr`]: std::net::SocketAddr\n/// [`SocketAddrV4`]: std::net::SocketAddrV4\n/// [`SocketAddrV6`]: std::net::SocketAddrV6\n/// [`Range<T>`]: https://doc.rust-lang.org/stable/std/ops/struct.Range.html\n/// [`RangeFrom<T>`]: https://doc.rust-lang.org/stable/std/ops/struct.RangeFrom.html\n/// [`RangeTo<T>`]: https://doc.rust-lang.org/stable/std/ops/struct.RangeTo.html\n/// [`RangeToInclusive<T>`]: https://doc.rust-lang.org/stable/std/ops/struct.RangeToInclusive.html\n///\n/// ## Additional Notes\n///\n///   * **`Vec<T>` where `T: FromForm`**\n///\n///     Parses a sequence of `T`'s. A new `T` is created whenever the field\n///     name's key changes or is empty; the previous `T` is finalized and errors\n///     are stored. While the key remains the same and non-empty, form values\n///     are pushed to the current `T` after being shifted. All collected errors\n///     are returned at finalization, if any, or the successfully created vector\n///     is returned.\n///\n///   * **`HashMap<K, V>` where `K: FromForm + Eq + Hash`, `V: FromForm`**\n///\n///     **`BTreeMap<K, V>` where `K: FromForm + Ord`, `V: FromForm`**\n///\n///     Parses a sequence of `(K, V)`'s. A new pair is created for every unique\n///     first index of the key.\n///\n///     If the key has only one index (`map[index]=value`), the index itself is\n///     pushed to `K`'s parser and the remaining shifted field is pushed to\n///     `V`'s parser.\n///\n///     If the key has two indices (`map[k:index]=value` or\n///     `map[v:index]=value`), the first index must start with `k` or `v`. If\n///     the first index starts with `k`, the shifted field is pushed to `K`'s\n///     parser. If the first index starts with `v`, the shifted field is pushed\n///     to `V`'s parser. If the first index is anything else, an error is\n///     created for the offending form field.\n///\n///     Errors are collected as they occur. Finalization finalizes all pairs and\n///     returns errors, if any, or the map.\n///\n///   * **`bool`**\n///\n///     Parses as `false` for missing values (when lenient) and case-insensitive\n///     values of `off`, `false`, and `no`. Parses as `true` for values of `on`,\n///     `true`, `yes`, and the empty value. Failed to parse otherwise.\n///\n///   * **[`time::DateTime`]**\n///\n///     Parses a date in `%FT%R` or `%FT%T` format, that is, `YYYY-MM-DDTHH:MM`\n///     or `YYYY-MM-DDTHH:MM:SS`. This is the `\"datetime-local\"` HTML input type\n///     without support for the millisecond variant.\n///\n///   * **[`time::Time`]**\n///\n///     Parses a time in `%R` or `%T` format, that is, `HH:MM` or `HH:MM:SS`.\n///     This is the `\"time\"` HTML input type without support for the millisecond\n///     variant.\n///\n/// # Push Parsing\n///\n/// `FromForm` describes a push-based parser for Rocket's [field wire format].\n/// Fields are preprocessed into either [`ValueField`]s or [`DataField`]s which\n/// are then pushed to the parser in [`FromForm::push_value()`] or\n/// [`FromForm::push_data()`], respectively. Both url-encoded forms and\n/// multipart forms are supported. All url-encoded form fields are preprocessed\n/// as [`ValueField`]s. Multipart form fields with Content-Types are processed\n/// as [`DataField`]s while those without a set Content-Type are processed as\n/// [`ValueField`]s. `ValueField` field names and values are percent-decoded.\n///\n/// [field wire format]: crate::form#field-wire-format\n///\n/// Parsing is split into 3 stages. After preprocessing, the three stages are:\n///\n///   1. **Initialization.** The type sets up a context for later `push`es.\n///\n///      ```rust\n///      # use rocket::form::prelude::*;\n///      # struct Foo;\n///      use rocket::form::Options;\n///\n///      # #[rocket::async_trait]\n///      # impl<'r> FromForm<'r> for Foo {\n///          # type Context = std::convert::Infallible;\n///      fn init(opts: Options) -> Self::Context {\n///          todo!(\"return a context for storing parse state\")\n///      }\n///          # fn push_value(ctxt: &mut Self::Context, field: ValueField<'r>) { todo!() }\n///          # async fn push_data(ctxt: &mut Self::Context, field: DataField<'r, '_>) { todo!() }\n///          # fn finalize(ctxt: Self::Context) -> Result<'r, Self> { todo!() }\n///      # }\n///      ```\n///\n///   2. **Push.** The structure is repeatedly pushed form fields; the latest\n///      context is provided with each `push`. If the structure contains\n///      children, it uses the first [`key()`] to identify a child to which it\n///      then `push`es the remaining `field` to, likely with a [`shift()`ed]\n///      name. Otherwise, the structure parses the `value` itself. The context\n///      is updated as needed.\n///\n///      ```rust\n///      # use rocket::form::prelude::*;\n///      # struct Foo;\n///      use rocket::form::{ValueField, DataField};\n///\n///      # #[rocket::async_trait]\n///      # impl<'r> FromForm<'r> for Foo {\n///          # type Context = std::convert::Infallible;\n///          # fn init(opts: Options) -> Self::Context { todo!() }\n///      fn push_value(ctxt: &mut Self::Context, field: ValueField<'r>) {\n///          todo!(\"modify context as necessary for `field`\")\n///      }\n///\n///      async fn push_data(ctxt: &mut Self::Context, field: DataField<'r, '_>) {\n///          todo!(\"modify context as necessary for `field`\")\n///      }\n///          # fn finalize(ctxt: Self::Context) -> Result<'r, Self> { todo!() }\n///      # }\n///      ```\n///\n///   3. **Finalization.** The structure is informed that there are no further\n///      fields. It systemizes the effects of previous `push`es via its context\n///      to return a parsed structure or generate [`Errors`].\n///\n///      ```rust\n///      # use rocket::form::prelude::*;\n///      # struct Foo;\n///      use rocket::form::Result;\n///\n///      # #[rocket::async_trait]\n///      # impl<'r> FromForm<'r> for Foo {\n///          # type Context = std::convert::Infallible;\n///          # fn init(opts: Options) -> Self::Context { todo!() }\n///          # fn push_value(ctxt: &mut Self::Context, field: ValueField<'r>) { todo!() }\n///          # async fn push_data(ctxt: &mut Self::Context, field: DataField<'r, '_>) { todo!() }\n///      fn finalize(ctxt: Self::Context) -> Result<'r, Self> {\n///          todo!(\"inspect context to generate `Self` or `Errors`\")\n///      }\n///      # }\n///      ```\n///\n/// These three stages make up the entirety of the `FromForm` trait.\n///\n/// ## Nesting and [`NameView`]\n///\n/// Each field name key typically identifies a unique child of a structure. As\n/// such, when processed left-to-right, the keys of a field jointly identify a\n/// unique leaf of a structure. The value of the field typically represents the\n/// desired value of the leaf.\n///\n/// A [`NameView`] captures and simplifies this \"left-to-right\" processing of a\n/// field's name by exposing a sliding-prefix view into a name. A [`shift()`]\n/// shifts the view one key to the right. Thus, a `Name` of `a.b.c` when viewed\n/// through a new [`NameView`] is `a`. Shifted once, the view is `a.b`.\n/// [`key()`] returns the last (or \"current\") key in the view. A nested\n/// structure can thus handle a field with a `NameView`, operate on the\n/// [`key()`], [`shift()`] the `NameView`, and pass the field with the shifted\n/// `NameView` to the next processor which handles `b` and so on.\n///\n/// [`shift()`]: NameView::shift()\n/// [`key()`]: NameView::key()\n///\n/// ## A Simple Example\n///\n/// The following example uses `f1=v1&f2=v2` to illustrate field/value pairs\n/// `(f1, v2)` and `(f2, v2)`. This is the same encoding used to send HTML forms\n/// over HTTP, though Rocket's push-parsers are unaware of any specific\n/// encoding, dealing only with logical `field`s, `index`es, and `value`s.\n///\n/// ### A Single Field (`T: FormFormField`)\n///\n/// The simplest example parses a single value of type `T` from a string with an\n/// optional default value: this is `impl<T: FromFormField> FromForm for T`:\n///\n///   1. **Initialization.** The context stores form options and an `Option` of\n///      `Result<T, form::Error>` for storing the `result` of parsing `T`, which\n///      is initially set to `None`.\n///\n///      ```rust\n///      use rocket::form::{self, FromFormField};\n///\n///      struct Context<'r, T: FromFormField<'r>> {\n///          opts: form::Options,\n///          result: Option<form::Result<'r, T>>,\n///      }\n///\n///      # impl<'r, T: FromFormField<'r>> Context<'r, T> {\n///      fn init(opts: form::Options) -> Context<'r, T> {\n///         Context { opts, result: None }\n///      }\n///      # }\n///      ```\n///\n///   2. **Push.** If `ctxt.result` is `None`, `T` is parsed from `field`, and\n///      the result is stored in `context.result`. Otherwise a field has already\n///      been parsed and nothing is done.\n///\n///      ```rust\n///      # use rocket::form::{self, ValueField, FromFormField};\n///      # struct Context<'r, T: FromFormField<'r>> {\n///      #     opts: form::Options,\n///      #     result: Option<form::Result<'r, T>>,\n///      # }\n///      # impl<'r, T: FromFormField<'r>> Context<'r, T> {\n///      fn push_value(ctxt: &mut Context<'r, T>, field: ValueField<'r>) {\n///          if ctxt.result.is_none() {\n///              ctxt.result = Some(T::from_value(field));\n///          }\n///      }\n///      # }\n///      ```\n///\n///   3. **Finalization.** If `ctxt.result` is `None`, parsing is lenient, and\n///      `T` has a default, the default is returned. Otherwise a `Missing` error\n///      is returned. If `ctxt.result` is `Some(v)`, the result `v` is returned.\n///\n///      ```rust\n///      # use rocket::form::{self, FromFormField, error::{Errors, ErrorKind}};\n///      # struct Context<'r, T: FromFormField<'r>> {\n///      #     opts: form::Options,\n///      #     result: Option<form::Result<'r, T>>,\n///      # }\n///      # impl<'r, T: FromFormField<'r>> Context<'r, T> {\n///      fn finalize(ctxt: Context<'r, T>) -> form::Result<'r, T> {\n///          match ctxt.result {\n///              Some(result) => result,\n///              None if ctxt.opts.strict => Err(Errors::from(ErrorKind::Missing)),\n///              None => match T::default() {\n///                  Some(default) => Ok(default),\n///                  None => Err(Errors::from(ErrorKind::Missing)),\n///              }\n///          }\n///      }\n///      # }\n///      ```\n///\n/// This implementation is complete except for the following details:\n///\n///   * handling both `push_data` and `push_value`\n///   * checking for duplicate pushes when parsing is `strict`\n///   * tracking the field's name and value to generate a complete [`Error`]\n///\n/// # Implementing\n///\n/// Implementing `FromForm` should be a rare occurrence. Prefer instead to use\n/// Rocket's built-in derivation or, for custom types, implementing\n/// [`FromFormField`].\n///\n/// An implementation of `FromForm` consists of implementing the three stages\n/// outlined above. `FromForm` is an async trait, so implementations must be\n/// decorated with an attribute of `#[rocket::async_trait]`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # struct MyType;\n/// # struct MyContext;\n/// use rocket::form::{self, FromForm, DataField, ValueField};\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromForm<'r> for MyType {\n///     type Context = MyContext;\n///\n///     fn init(opts: form::Options) -> Self::Context {\n///         todo!()\n///     }\n///\n///     fn push_value(ctxt: &mut Self::Context, field: ValueField<'r>) {\n///         todo!()\n///     }\n///\n///     async fn push_data(ctxt: &mut Self::Context, field: DataField<'r, '_>) {\n///         todo!()\n///     }\n///\n///     fn finalize(this: Self::Context) -> form::Result<'r, Self> {\n///         todo!()\n///     }\n/// }\n/// ```\n///\n/// The lifetime `'r` corresponds to the lifetime of the request.\n///\n/// ## A More Involved Example\n///\n/// We illustrate implementation of `FromForm` through an example. The example\n/// implements `FromForm` for a `Pair(A, B)` type where `A: FromForm` and `B:\n/// FromForm`, parseable from forms with at least two fields, one with a key of\n/// `0` and the other with a key of `1`. The field with key `0` is parsed as an\n/// `A` while the field with key `1` is parsed as a `B`. Specifically, to parse\n/// a `Pair(A, B)` from a field with prefix `pair`, a form with the following\n/// fields must be submitted:\n///\n///   * `pair[0]` - type A\n///   * `pair[1]` - type B\n///\n/// Examples include:\n///\n///   * `pair[0]=id&pair[1]=100` as `Pair(&str, usize)`\n///   * `pair[0]=id&pair[1]=100` as `Pair(&str, &str)`\n///   * `pair[0]=2012-10-12&pair[1]=100` as `Pair(time::Date, &str)`\n///   * `pair.0=2012-10-12&pair.1=100` as `Pair(time::Date, usize)`\n///\n/// ```rust\n/// use either::Either;\n/// use rocket::form::{self, FromForm, ValueField, DataField, Error, Errors};\n///\n/// /// A form guard parseable from fields `.0` and `.1`.\n/// struct Pair<A, B>(A, B);\n///\n/// // The parsing context. We'll be pushing fields with key `.0` to `left`\n/// // and fields with `.1` to `right`. We'll collect errors along the way.\n/// struct PairContext<'v, A: FromForm<'v>, B: FromForm<'v>> {\n///     left: A::Context,\n///     right: B::Context,\n///     errors: Errors<'v>,\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'v, A: FromForm<'v>, B: FromForm<'v>> FromForm<'v> for Pair<A, B> {\n///     type Context = PairContext<'v, A, B>;\n///\n///     // We initialize the `PairContext` as expected.\n///     fn init(opts: form::Options) -> Self::Context {\n///         PairContext {\n///             left: A::init(opts),\n///             right: B::init(opts),\n///             errors: Errors::new()\n///         }\n///     }\n///\n///     // For each value, we determine if the key is `.0` (left) or `.1`\n///     // (right) and push to the appropriate parser. If it was neither, we\n///     // store the error for emission on finalization. The parsers for `A` and\n///     // `B` will handle duplicate values and so on.\n///     fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n///         match ctxt.context(field.name) {\n///             Ok(Either::Left(ctxt)) => A::push_value(ctxt, field.shift()),\n///             Ok(Either::Right(ctxt)) => B::push_value(ctxt, field.shift()),\n///             Err(e) => ctxt.errors.push(e),\n///         }\n///     }\n///\n///     // This is identical to `push_value` but for data fields.\n///     async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n///         match ctxt.context(field.name) {\n///             Ok(Either::Left(ctxt)) => A::push_data(ctxt, field.shift()).await,\n///             Ok(Either::Right(ctxt)) => B::push_data(ctxt, field.shift()).await,\n///             Err(e) => ctxt.errors.push(e),\n///         }\n///     }\n///\n///     // Finally, we finalize `A` and `B`. If both returned `Ok` and we\n///     // encountered no errors during the push phase, we return our pair. If\n///     // there were errors, we return them. If `A` and/or `B` failed, we\n///     // return the commutative errors.\n///     fn finalize(mut ctxt: Self::Context) -> form::Result<'v, Self> {\n///         match (A::finalize(ctxt.left), B::finalize(ctxt.right)) {\n///             (Ok(l), Ok(r)) if ctxt.errors.is_empty() => Ok(Pair(l, r)),\n///             (Ok(_), Ok(_)) => Err(ctxt.errors),\n///             (left, right) => {\n///                 if let Err(e) = left { ctxt.errors.extend(e); }\n///                 if let Err(e) = right { ctxt.errors.extend(e); }\n///                 Err(ctxt.errors)\n///             }\n///         }\n///     }\n/// }\n///\n/// impl<'v, A: FromForm<'v>, B: FromForm<'v>> PairContext<'v, A, B> {\n///     // Helper method used by `push_{value, data}`. Determines which context\n///     // we should push to based on the field name's key. If the key is\n///     // neither `0` nor `1`, we return an error.\n///     fn context(\n///         &mut self,\n///         name: form::name::NameView<'v>\n///     ) -> Result<Either<&mut A::Context, &mut B::Context>, Error<'v>> {\n///         use std::borrow::Cow;\n///\n///         match name.key().map(|k| k.as_str()) {\n///             Some(\"0\") => Ok(Either::Left(&mut self.left)),\n///             Some(\"1\") => Ok(Either::Right(&mut self.right)),\n///             _ => Err(Error::from(&[Cow::Borrowed(\"0\"), Cow::Borrowed(\"1\")])\n///                 .with_entity(form::error::Entity::Index(0))\n///                 .with_name(name)),\n///         }\n///     }\n/// }\n/// ```\n#[crate::async_trait]\npub trait FromForm<'r>: Send + Sized {\n    /// The form guard's parsing context.\n    type Context: Send;\n\n    /// Initializes and returns the parsing context for `Self`.\n    fn init(opts: Options) -> Self::Context;\n\n    /// Processes the value field `field`.\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'r>);\n\n    /// Processes the data field `field`.\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'r, '_>);\n\n    /// Processes the external form or field error `_error`.\n    ///\n    /// The default implementation does nothing, which is always correct.\n    fn push_error(_ctxt: &mut Self::Context, _error: Error<'r>) { }\n\n    /// Finalizes parsing. Returns the parsed value when successful or\n    /// collection of [`Errors`] otherwise.\n    fn finalize(ctxt: Self::Context) -> Result<'r, Self>;\n\n    /// Returns a default value, if any, to use when a value is desired and\n    /// parsing fails.\n    ///\n    /// The default implementation initializes `Self` with `opts` and finalizes\n    /// immediately, returning the value if finalization succeeds. This is\n    /// always correct and should likely not be changed. Returning a different\n    /// value may result in ambiguous parses.\n    fn default(opts: Options) -> Option<Self> {\n        Self::finalize(Self::init(opts)).ok()\n    }\n}\n\n#[doc(hidden)]\npub struct VecContext<'v, T: FromForm<'v>> {\n    opts: Options,\n    last_key: Option<&'v Key>,\n    current: Option<T::Context>,\n    errors: Errors<'v>,\n    items: Vec<T>\n}\n\nimpl<'v, T: FromForm<'v>> VecContext<'v, T> {\n    fn new(opts: Options) -> Self {\n        VecContext {\n            opts,\n            last_key: None,\n            current: None,\n            items: vec![],\n            errors: Errors::new(),\n        }\n    }\n\n    fn shift(&mut self) {\n        if let Some(current) = self.current.take() {\n            match T::finalize(current) {\n                Ok(v) => self.items.push(v),\n                Err(e) => self.errors.extend(e)\n            }\n        }\n    }\n\n    fn context(&mut self, name: &NameView<'v>) -> &mut T::Context {\n        let this_key = name.key();\n        let keys_match = match (self.last_key, this_key) {\n            (Some(k1), Some(k2)) => k1 == k2,\n            _ => false\n        };\n\n        if !keys_match {\n            self.shift();\n            self.current = Some(T::init(self.opts));\n        }\n\n        self.last_key = name.key();\n        self.current.as_mut().expect(\"must have current if last == index\")\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v> + 'v> FromForm<'v> for Vec<T> {\n    type Context = VecContext<'v, T>;\n\n    fn init(opts: Options) -> Self::Context {\n        VecContext::new(opts)\n    }\n\n    fn push_value(this: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(this.context(&field.name), field.shift());\n    }\n\n    async fn push_data(this: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(this.context(&field.name), field.shift()).await\n    }\n\n    fn finalize(mut this: Self::Context) -> Result<'v, Self> {\n        this.shift();\n        if !this.errors.is_empty() {\n            Err(this.errors)\n        } else if this.opts.strict && this.items.is_empty() {\n            Err(Errors::from(ErrorKind::Missing))\n        } else {\n            Ok(this.items)\n        }\n    }\n}\n\n// impl_strict_from_form_field_from_capped!(Vec<u8>);\n\n#[doc(hidden)]\npub struct MapContext<'v, K, V> where K: FromForm<'v>, V: FromForm<'v> {\n    opts: Options,\n    /// Maps an index key (&str, map.key=foo, map.k:key) to its entry.\n    /// NOTE: `table`, `entries`, and `metadata` are always the same size.\n    table: IndexMap<&'v str, usize>,\n    /// The `FromForm` context for the (key, value) indexed by `table`.\n    entries: Vec<(K::Context, V::Context)>,\n    /// Recorded metadata for a given key/value pair.\n    metadata: Vec<NameView<'v>>,\n    /// Errors collected while finalizing keys and values.\n    errors: Errors<'v>,\n}\n\nimpl<'v, K, V> MapContext<'v, K, V>\n    where K: FromForm<'v>, V: FromForm<'v>\n{\n    fn new(opts: Options) -> Self {\n        MapContext {\n            opts,\n            table: IndexMap::new(),\n            entries: vec![],\n            metadata: vec![],\n            errors: Errors::new(),\n        }\n    }\n\n    fn ctxt(&mut self, key: &'v str, name: NameView<'v>) -> &mut (K::Context, V::Context) {\n        match self.table.get(key) {\n            Some(i) => &mut self.entries[*i],\n            None => {\n                let i = self.entries.len();\n                self.table.insert(key, i);\n                self.entries.push((K::init(self.opts), V::init(self.opts)));\n                self.metadata.push(name);\n                &mut self.entries[i]\n            }\n        }\n    }\n\n    fn push(&mut self, name: NameView<'v>) -> Option<Either<&mut K::Context, &mut V::Context>> {\n        let index_pair = name.key()\n            .map(|k| k.indices())\n            .map(|mut i| (i.next(), i.next()))\n            .unwrap_or_default();\n\n        match index_pair {\n            (Some(key), None) => {\n                let is_new_key = !self.table.contains_key(key);\n                let (key_ctxt, val_ctxt) = self.ctxt(key, name);\n                if is_new_key {\n                    K::push_value(key_ctxt, ValueField::from_value(key));\n                }\n\n                return Some(Either::Right(val_ctxt));\n            },\n            (Some(kind), Some(key)) => {\n                if kind.as_uncased().starts_with(\"k\") {\n                    return Some(Either::Left(&mut self.ctxt(key, name).0));\n                } else if kind.as_uncased().starts_with(\"v\") {\n                    return Some(Either::Right(&mut self.ctxt(key, name).1));\n                } else {\n                    let error = Error::from(&[Cow::Borrowed(\"k\"), Cow::Borrowed(\"v\")])\n                        .with_entity(Entity::Index(0))\n                        .with_name(name);\n\n                    self.errors.push(error);\n                }\n            }\n            _ => {\n                let error = Error::from(ErrorKind::Missing)\n                    .with_entity(Entity::Key)\n                    .with_name(name);\n\n                self.errors.push(error);\n            }\n        };\n\n        None\n    }\n\n    fn push_value(&mut self, field: ValueField<'v>) {\n        match self.push(field.name) {\n            Some(Either::Left(ctxt)) => K::push_value(ctxt, field.shift()),\n            Some(Either::Right(ctxt)) => V::push_value(ctxt, field.shift()),\n            _ => {}\n        }\n    }\n\n    async fn push_data(&mut self, field: DataField<'v, '_>) {\n        match self.push(field.name) {\n            Some(Either::Left(ctxt)) => K::push_data(ctxt, field.shift()).await,\n            Some(Either::Right(ctxt)) => V::push_data(ctxt, field.shift()).await,\n            _ => {}\n        }\n    }\n\n    fn finalize<T: std::iter::FromIterator<(K, V)>>(mut self) -> Result<'v, T> {\n        let map: T = self.entries.into_iter()\n            .zip(self.metadata.iter())\n            .zip(self.table.keys())\n            .filter_map(|(((k_ctxt, v_ctxt), name), idx)| {\n                let key = K::finalize(k_ctxt)\n                    .map_err(|e| {\n                        // FIXME: Fix `NameBuf` to take in `k` and add it.\n                        // FIXME: Perhaps the `k` should come after: `map.0:k`.\n                        let form_key = format!(\"k:{}\", idx);\n                        self.errors.extend(e.with_name((name.parent(), form_key)));\n                    })\n                    .ok();\n\n                let val = V::finalize(v_ctxt)\n                    .map_err(|e| self.errors.extend(e.with_name((name.parent(), *idx))))\n                    .ok();\n\n                Some((key?, val?))\n            })\n            .collect();\n\n        if !self.errors.is_empty() {\n            Err(self.errors)\n        } else if self.opts.strict && self.table.is_empty() {\n            Err(Errors::from(ErrorKind::Missing))\n        } else {\n            Ok(map)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, K, V> FromForm<'v> for HashMap<K, V>\n    where K: FromForm<'v> + Eq + Hash, V: FromForm<'v>\n{\n    type Context = MapContext<'v, K, V>;\n\n    fn init(opts: Options) -> Self::Context {\n        MapContext::new(opts)\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        ctxt.push_value(field);\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        ctxt.push_data(field).await;\n    }\n\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        this.finalize()\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, K, V> FromForm<'v> for BTreeMap<K, V>\n    where K: FromForm<'v> + Ord, V: FromForm<'v>\n{\n    type Context = MapContext<'v, K, V>;\n\n    fn init(opts: Options) -> Self::Context {\n        MapContext::new(opts)\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        ctxt.push_value(field);\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        ctxt.push_data(field).await;\n    }\n\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        this.finalize()\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v>> FromForm<'v> for Option<T> {\n    type Context = <T as FromForm<'v>>::Context;\n\n    fn init(opts: Options) -> Self::Context {\n        T::init(Options { strict: true, ..opts })\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(ctxt, field)\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(ctxt, field).await\n    }\n\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        Ok(T::finalize(this).ok())\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v>> FromForm<'v> for Result<'v, T> {\n    type Context = <T as FromForm<'v>>::Context;\n\n    fn init(opts: Options) -> Self::Context {\n        T::init(opts)\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(ctxt, field)\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(ctxt, field).await\n    }\n\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        Ok(T::finalize(this))\n    }\n}\n\n#[doc(hidden)]\npub struct PairContext<'v, A: FromForm<'v>, B: FromForm<'v>> {\n    left: A::Context,\n    right: B::Context,\n    errors: Errors<'v>,\n}\n\nimpl<'v, A: FromForm<'v>, B: FromForm<'v>> PairContext<'v, A, B> {\n    fn context(\n        &mut self,\n        name: NameView<'v>\n    ) -> std::result::Result<Either<&mut A::Context, &mut B::Context>, Error<'v>> {\n        match name.key().map(|k| k.as_str()) {\n            Some(\"0\") => Ok(Either::Left(&mut self.left)),\n            Some(\"1\") => Ok(Either::Right(&mut self.right)),\n            _ => Err(Error::from(&[Cow::Borrowed(\"0\"), Cow::Borrowed(\"1\")])\n                .with_entity(Entity::Index(0))\n                .with_name(name)),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, A: FromForm<'v>, B: FromForm<'v>> FromForm<'v> for (A, B) {\n    type Context = PairContext<'v, A, B>;\n\n    fn init(opts: Options) -> Self::Context {\n        PairContext {\n            left: A::init(opts),\n            right: B::init(opts),\n            errors: Errors::new()\n        }\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        match ctxt.context(field.name) {\n            Ok(Either::Left(ctxt)) => A::push_value(ctxt, field.shift()),\n            Ok(Either::Right(ctxt)) => B::push_value(ctxt, field.shift()),\n            Err(e) => ctxt.errors.push(e),\n        }\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        match ctxt.context(field.name) {\n            Ok(Either::Left(ctxt)) => A::push_data(ctxt, field.shift()).await,\n            Ok(Either::Right(ctxt)) => B::push_data(ctxt, field.shift()).await,\n            Err(e) => ctxt.errors.push(e),\n        }\n    }\n\n    fn finalize(mut ctxt: Self::Context) -> Result<'v, Self> {\n        match (A::finalize(ctxt.left), B::finalize(ctxt.right)) {\n            (Ok(key), Ok(val)) if ctxt.errors.is_empty() => Ok((key, val)),\n            (Ok(_), Ok(_)) => Err(ctxt.errors)?,\n            (left, right) => {\n                if let Err(e) = left { ctxt.errors.extend(e); }\n                if let Err(e) = right { ctxt.errors.extend(e); }\n                Err(ctxt.errors)?\n            }\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v> + Sync> FromForm<'v> for Arc<T> {\n    type Context = <T as FromForm<'v>>::Context;\n\n    fn init(opts: Options) -> Self::Context {\n        T::init(opts)\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(ctxt, field)\n    }\n\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(ctxt, field).await\n    }\n\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        T::finalize(this).map(Arc::new)\n    }\n}\n\nmacro_rules! impl_via_proxy {\n    ($R:ident => struct $T:ident <$($G:ident),*> { $($f:ident : $F:ident),* }) => {\n        const _: () = {\n            use super::*;\n\n            mod proxy {\n                #[derive(rocket::FromForm)]\n                pub struct $T<$($G),*> {\n                    $(pub $f : $F),*\n                }\n            }\n\n            #[crate::async_trait]\n            impl<'v, $($G: Send),*> FromForm<'v> for $R<$($G),*>\n                where proxy::$T<$($G),*>: FromForm<'v>\n            {\n                type Context = <proxy::$T<$($G),*> as FromForm<'v>>::Context;\n\n                fn init(opts: Options) -> Self::Context {\n                    <proxy::$T<$($G),*>>::init(opts)\n                }\n\n                fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n                    <proxy::$T<$($G),*>>::push_value(ctxt, field)\n                }\n\n                async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n                    <proxy::$T<$($G),*>>::push_data(ctxt, field).await\n                }\n\n                fn finalize(this: Self::Context) -> Result<'v, Self> {\n                    let proxy = <proxy::$T<$($G),*>>::finalize(this)?;\n                    Ok($R {\n                        $($f : proxy.$f),*\n                    })\n                }\n            }\n        };\n    }\n}\n\nuse std::ops::{Range, RangeFrom, RangeTo, RangeToInclusive};\n\nimpl_via_proxy!(Range => struct Range<T> { start: T, end: T });\nimpl_via_proxy!(RangeFrom => struct RangeFrom<T> { start: T });\nimpl_via_proxy!(RangeTo => struct RangeTo<T> { end: T });\nimpl_via_proxy!(RangeToInclusive => struct RangeToInclusive<T> { end: T });"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::borrow::Cow;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6, SocketAddr};\nuse std::num::{\n    NonZeroIsize, NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128,\n    NonZeroUsize, NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128,\n};\n\nuse time::{Date, Time, PrimitiveDateTime};\nuse time::{macros::format_description, format_description::FormatItem};\n\nuse crate::data::Capped;\nuse crate::http::uncased::AsUncased;\nuse crate::form::prelude::*;\n\n/// Implied form guard ([`FromForm`]) for parsing a single form field.\n///\n/// Types that implement `FromFormField` automatically implement [`FromForm`]\n/// via a blanket implementation. As such, all `FromFormField` types are form\n/// guards and can appear as the type of values in derived `FromForm` struct\n/// fields:\n///\n/// ```rust\n/// # use rocket::form::FromForm;\n/// #[derive(FromForm)]\n/// struct Person<'r> {\n///     name: &'r str,\n///     age: u16\n/// }\n/// ```\n///\n/// # Semantics\n///\n/// The implementation of `FromForm` for a `T: FromFormField` type operates as\n/// follows:\n///\n///   * When parsing is **strict**, the parser accepts the _first_ value or data\n///     field with the corresponding field name and calls `T::from_value()` or\n///     `T::from_data()` with the field's value, respectively. If more than one\n///     field value is seen, an [`ErrorKind::Duplicate`) is emitted. If no\n///     matching field is seen, an [`ErrorKind::Missing`] is emitted. Otherwise,\n///     the result from the call is emitted.\n///\n///   * When parsing is **lenient**, the parser accepts the first _expected_\n///     value or data field with the corresponding field name and calls\n///     `T::from_value()` or `T::from_data()` with the field's value,\n///     respectively. Unexpected values, identified by returning an\n///     [`ErrorKind::Unexpected`] from `from_value()` or `from_data()` are\n///     ignored. Any additional fields with a matching field name are ignored.\n///     If no matching field is seen and `T` has a default, it is used,\n///     otherwise an [`ErrorKind::Missing`] is emitted.\n///\n/// # Deriving\n///\n/// `FromFormField` can be derived for C-like enums, where the generated\n/// implementation case-insensitively parses fields with values equal to the\n/// name of the variant or the value in `field()`.\n///\n/// ```rust\n/// # use rocket::form::FromFormField;\n/// /// Fields with value `\"simple\"` parse as `Kind::Simple`. Fields with value\n/// /// `\"fancy\"` parse as `Kind::SoFancy`.\n/// #[derive(FromFormField)]\n/// enum Kind {\n///     Simple,\n///     #[field(value = \"fancy\")]\n///     SoFancy,\n/// }\n/// ```\n///\n/// # Provided Implementations\n///\n/// See [`FromForm`](crate::form::FromForm#provided-implementations) for a list\n/// of all form guards, including those implemented via `FromFormField`.\n///\n/// # Implementing\n///\n/// Implementing `FromFormField` requires implementing one or both of\n/// `from_value` or `from_data`, depending on whether the type can be parsed\n/// from a value field (text) and/or streaming binary data. Typically, a value\n/// can be parsed from either, either directly or by using request-local cache\n/// as an intermediary, and parsing from both should be preferred when sensible.\n///\n/// `FromFormField` is an async trait, so implementations must be decorated with\n/// an attribute of `#[rocket::async_trait]`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # struct MyType;\n/// use rocket::form::{self, FromFormField, DataField, ValueField};\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromFormField<'r> for MyType {\n///     fn from_value(field: ValueField<'r>) -> form::Result<'r, Self> {\n///         todo!(\"parse from a value or use default impl\")\n///     }\n///\n///     async fn from_data(field: DataField<'r, '_>) -> form::Result<'r, Self> {\n///         todo!(\"parse from a value or use default impl\")\n///     }\n/// }\n/// ```\n///\n/// ## Example\n///\n/// The following example parses a custom `Person` type with the format\n/// `$name:$data`, where `$name` is expected to be string and `data` is expected\n/// to be any slice of bytes.\n///\n/// ```rust\n/// # use rocket::post;\n/// use rocket::data::ToByteUnit;\n/// use rocket::form::{self, FromFormField, DataField, ValueField};\n///\n/// use memchr::memchr;\n///\n/// struct Person<'r> {\n///     name: &'r str,\n///     data: &'r [u8]\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromFormField<'r> for Person<'r> {\n///     fn from_value(field: ValueField<'r>) -> form::Result<'r, Self> {\n///         match field.value.find(':') {\n///             Some(i) => Ok(Person {\n///                 name: &field.value[..i],\n///                 data: field.value[(i + 1)..].as_bytes()\n///             }),\n///             None => Err(form::Error::validation(\"does not contain ':'\"))?\n///         }\n///     }\n///\n///     async fn from_data(field: DataField<'r, '_>) -> form::Result<'r, Self> {\n///         // Retrieve the configured data limit or use `256KiB` as default.\n///         let limit = field.request.limits()\n///             .get(\"person\")\n///             .unwrap_or(256.kibibytes());\n///\n///         // Read the capped data stream, returning a limit error as needed.\n///         let bytes = field.data.open(limit).into_bytes().await?;\n///         if !bytes.is_complete() {\n///             Err((None, Some(limit)))?;\n///         }\n///\n///         // Store the bytes in request-local cache and split at ':'.\n///         let bytes = bytes.into_inner();\n///         let bytes = rocket::request::local_cache!(field.request, bytes);\n///         let (raw_name, data) = match memchr(b':', bytes) {\n///             Some(i) => (&bytes[..i], &bytes[(i + 1)..]),\n///             None => Err(form::Error::validation(\"does not contain ':'\"))?\n///         };\n///\n///         // Try to parse the name as UTF-8 or return an error if it fails.\n///         let name = std::str::from_utf8(raw_name)?;\n///         Ok(Person { name, data })\n///     }\n/// }\n///\n/// use rocket::form::{Form, FromForm};\n///\n/// // The type can be used directly, if only one field is expected...\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn person(person: Form<Person<'_>>) { /* ... */ }\n///\n/// // ...or as a named field in another form guard...\n/// #[derive(FromForm)]\n/// struct NewPerson<'r> {\n///     person: Person<'r>\n/// }\n///\n/// #[post(\"/person\", data = \"<person>\")]\n/// fn new_person(person: Form<NewPerson<'_>>) { /* ... */ }\n/// ```\n// NOTE: Ideally, we would have two traits instead one with two fallible\n// methods: `FromFormValue` and `FromFormData`. This would be especially nice\n// for use with query values, where `FromFormData` would make no sense.\n//\n// However, blanket implementations of `FromForm` for these traits would result\n// in duplicate implementations of `FromForm`; we need specialization to resolve\n// this concern. Thus, for now, we keep this as one trait.\n#[crate::async_trait]\npub trait FromFormField<'v>: Send + Sized {\n    /// Parse a value of `T` from a form value field.\n    ///\n    /// The default implementation returns an error of\n    /// [`ValueField::unexpected()`].\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        Err(field.unexpected())?\n    }\n\n    /// Parse a value of `T` from a form data field.\n    ///\n    /// The default implementation returns an error of\n    /// [`DataField::unexpected()`].\n    async fn from_data(field: DataField<'v, '_>) -> Result<'v, Self> {\n        Err(field.unexpected())?\n    }\n\n    /// Returns a default value, if any exists, to be used during lenient\n    /// parsing when the form field is missing.\n    ///\n    /// A return value of `None` means that field is required to exist and parse\n    /// successfully, always. A return value of `Some(default)` means that\n    /// `default` should be used when a field is missing.\n    ///\n    /// The default implementation returns `None`.\n    fn default() -> Option<Self> { None }\n}\n\n#[doc(hidden)]\npub struct FromFieldContext<'v, T: FromFormField<'v>> {\n    field_name: Option<NameView<'v>>,\n    field_value: Option<&'v str>,\n    opts: Options,\n    value: Option<Result<'v, T>>,\n    pushes: usize\n}\n\nimpl<'v, T: FromFormField<'v>> FromFieldContext<'v, T> {\n    fn should_push(&mut self) -> bool {\n        self.pushes += 1;\n        self.value.is_none()\n    }\n\n    fn push(&mut self, name: NameView<'v>, result: Result<'v, T>) {\n        fn is_unexpected(e: &Errors<'_>) -> bool {\n            matches!(e.last().map(|e| &e.kind), Some(ErrorKind::Unexpected))\n        }\n\n        self.field_name = Some(name);\n        match result {\n            Err(e) if !self.opts.strict && is_unexpected(&e) => { /* ok */ },\n            result => self.value = Some(result),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromFormField<'v>> FromForm<'v> for T {\n    type Context = FromFieldContext<'v, T>;\n\n    fn init(opts: Options) -> Self::Context {\n        FromFieldContext {\n            opts,\n            field_name: None,\n            field_value: None,\n            value: None,\n            pushes: 0,\n        }\n    }\n\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        if ctxt.should_push() {\n            ctxt.field_value = Some(field.value);\n            ctxt.push(field.name, Self::from_value(field))\n        }\n    }\n\n    async fn push_data(ctxt: &mut FromFieldContext<'v, T>, field: DataField<'v, '_>) {\n        if ctxt.should_push() {\n            ctxt.push(field.name, Self::from_data(field).await);\n        }\n    }\n\n    fn finalize(ctxt: Self::Context) -> Result<'v, Self> {\n        let mut errors = match ctxt.value {\n            Some(Ok(val)) if !ctxt.opts.strict || ctxt.pushes <= 1 => return Ok(val),\n            Some(Ok(_)) => Errors::from(ErrorKind::Duplicate),\n            Some(Err(errors)) => errors,\n            None if !ctxt.opts.strict => match <T as FromFormField>::default() {\n                Some(default) => return Ok(default),\n                None => Errors::from(ErrorKind::Missing)\n            },\n            None => Errors::from(ErrorKind::Missing),\n        };\n\n        if let Some(name) = ctxt.field_name {\n            errors.set_name(name);\n        }\n\n        if let Some(value) = ctxt.field_value {\n            errors.set_value(value);\n        }\n\n        Err(errors)\n    }\n}\n\n#[crate::async_trait]\nimpl<'v> FromFormField<'v> for Capped<&'v str> {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        Ok(Capped::from(field.value))\n    }\n\n    async fn from_data(f: DataField<'v, '_>) -> Result<'v, Self> {\n        use crate::data::{Capped, Outcome, FromData};\n\n        match <Capped<&'v str> as FromData>::from_data(f.request, f.data).await {\n            Outcome::Success(p) => Ok(p),\n            Outcome::Error((_, e)) => Err(e)?,\n            Outcome::Forward(..) => {\n                Err(Error::from(ErrorKind::Unexpected).with_entity(Entity::DataField))?\n            }\n        }\n    }\n}\n\nimpl_strict_from_form_field_from_capped!(&'v str);\n\n#[crate::async_trait]\nimpl<'v> FromFormField<'v> for Capped<String> {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        Ok(Capped::from(field.value.to_string()))\n    }\n\n    async fn from_data(f: DataField<'v, '_>) -> Result<'v, Self> {\n        use crate::data::{Capped, Outcome, FromData};\n\n        match <Capped<String> as FromData>::from_data(f.request, f.data).await {\n            Outcome::Success(p) => Ok(p),\n            Outcome::Error((_, e)) => Err(e)?,\n            Outcome::Forward(..) => {\n                Err(Error::from(ErrorKind::Unexpected).with_entity(Entity::DataField))?\n            }\n        }\n    }\n}\n\nimpl_strict_from_form_field_from_capped!(String);\n\nimpl<'v> FromFormField<'v> for bool {\n    fn default() -> Option<Self> {\n        Some(false)\n    }\n\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        match field.value.as_uncased() {\n            v if v == \"off\" || v == \"no\" || v == \"false\" => Ok(false),\n            v if v.is_empty() || v == \"on\" || v == \"yes\" || v == \"true\" => Ok(true),\n            // force a `ParseBoolError`\n            _ => Ok(\"\".parse()?),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v> FromFormField<'v> for Capped<&'v [u8]> {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        Ok(Capped::from(field.value.as_bytes()))\n    }\n\n    async fn from_data(f: DataField<'v, '_>) -> Result<'v, Self> {\n        use crate::data::{Capped, Outcome, FromData};\n\n        match <Capped<&'v [u8]> as FromData>::from_data(f.request, f.data).await {\n            Outcome::Success(p) => Ok(p),\n            Outcome::Error((_, e)) => Err(e)?,\n            Outcome::Forward(..) => {\n                Err(Error::from(ErrorKind::Unexpected).with_entity(Entity::DataField))?\n            }\n        }\n    }\n}\n\nimpl_strict_from_form_field_from_capped!(&'v [u8]);\n\n#[crate::async_trait]\nimpl<'v> FromFormField<'v> for Capped<Cow<'v, str>> {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        let capped = <Capped<&'v str>>::from_value(field)?;\n        Ok(capped.map(|s| s.into()))\n    }\n\n    async fn from_data(field: DataField<'v, '_>) -> Result<'v, Self> {\n        let capped = <Capped<&'v str>>::from_data(field).await?;\n        Ok(capped.map(|s| s.into()))\n    }\n}\n\nimpl_strict_from_form_field_from_capped!(Cow<'v, str>);\n\nmacro_rules! impl_with_parse {\n    ($($T:ident),+ $(,)?) => ($(\n        impl<'v> FromFormField<'v> for $T {\n            #[inline(always)]\n            fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n                Ok(field.value.parse()?)\n            }\n        }\n    )+)\n}\n\nimpl_with_parse!(\n    char,\n    f32, f64,\n    isize, i8, i16, i32, i64, i128,\n    usize, u8, u16, u32, u64, u128,\n    NonZeroIsize, NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128,\n    NonZeroUsize, NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128,\n    Ipv4Addr, IpAddr, Ipv6Addr, SocketAddrV4, SocketAddrV6, SocketAddr\n);\n\n// Keep formats in sync with 'FromFormField' impls.\nstatic DATE_FMT: &[FormatItem<'_>] = format_description!(\"[year padding:none]-[month]-[day]\");\nstatic TIME_FMT1: &[FormatItem<'_>] = format_description!(\"[hour padding:none]:[minute]:[second]\");\nstatic TIME_FMT2: &[FormatItem<'_>] = format_description!(\"[hour padding:none]:[minute]\");\nstatic DATE_TIME_FMT1: &[FormatItem<'_>] =\n    format_description!(\"[year padding:none]-[month]-[day]T[hour padding:none]:[minute]:[second]\");\nstatic DATE_TIME_FMT2: &[FormatItem<'_>] =\n    format_description!(\"[year padding:none]-[month]-[day]T[hour padding:none]:[minute]\");\n\nimpl<'v> FromFormField<'v> for Date {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        let date = Self::parse(field.value, &DATE_FMT)\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send>)?;\n\n        Ok(date)\n    }\n}\n\nimpl<'v> FromFormField<'v> for Time {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        let time = Self::parse(field.value, &TIME_FMT1)\n            .or_else(|_| Self::parse(field.value, &TIME_FMT2))\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send>)?;\n\n        Ok(time)\n    }\n}\n\nimpl<'v> FromFormField<'v> for PrimitiveDateTime {\n    fn from_value(field: ValueField<'v>) -> Result<'v, Self> {\n        let dt = Self::parse(field.value, &DATE_TIME_FMT1)\n            .or_else(|_| Self::parse(field.value, &DATE_TIME_FMT2))\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error + Send>)?;\n\n        Ok(dt)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::{Deref, DerefMut};\n\nuse crate::form::prelude::*;\nuse crate::http::uri::fmt::{Query, FromUriParam};\n\n/// A form guard for parsing form types leniently.\n///\n/// This type implements the [`FromForm`] trait and thus can be used as a\n/// generic parameter to the [`Form`] data guard: `Form<Lenient<T>>`, where `T`\n/// implements `FromForm`. Unlike using `Form` directly, this type uses a\n/// _lenient_ parsing strategy.\n///\n/// # Lenient Parsing\n///\n/// A `Lenient<T>` will parse successfully from an incoming form even if the\n/// form contains extra or missing fields. If fields are missing, the form field\n/// type's default will be used, if there is one. Extra fields are ignored; only\n/// the first is parsed and validated. This is the default strategy for\n/// [`Form`].\n///\n/// # Usage\n///\n/// `Lenient<T>` implements [`FromForm`] as long as `T` implements `FromForm`.\n/// As such, `Form<Lenient<T>>` is a data guard.\n///\n/// Note that `Form<T>` _already_ parses leniently, so a `Form<Lenient<T>>` is\n/// redundant and equal to `Form<T>`. `Lenient`, however, can be used to make\n/// otherwise strict parses lenient, for example, in `Option<Lenient<T>>`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::form::Lenient;\n///\n/// #[derive(FromForm)]\n/// struct UserInput {\n///     // Parses as `Some(false)` when `lenient_inner_option` isn't present.\n///     // Without `Lenient`, this would otherwise parse as `None`.\n///     lenient_inner_option: Option<Lenient<bool>>,\n/// }\n/// ```\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Lenient<T>(T);\n\nimpl<T> Lenient<T> {\n    /// Consumes `self` and returns the inner value.\n    ///\n    /// Note that since `Lenient` implements [`Deref`] and [`DerefMut`] with\n    /// target `T`, reading and writing an inner value can be accomplished\n    /// transparently.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::form::{Form, Lenient};\n    ///\n    /// #[derive(FromForm)]\n    /// struct MyForm {\n    ///     field: String,\n    /// }\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Lenient<MyForm>>) -> String {\n    ///     // We can read or mutate a value transparently:\n    ///     let field: &str = &form.field;\n    ///\n    ///     // To gain ownership, however, use `into_inner()`:\n    ///     form.into_inner().into_inner().field\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v>> FromForm<'v> for Lenient<T> {\n    type Context = T::Context;\n\n    #[inline(always)]\n    fn init(opts: Options) -> Self::Context {\n        T::init(Options { strict: false, ..opts })\n    }\n\n    #[inline(always)]\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(ctxt, field)\n    }\n\n    #[inline(always)]\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(ctxt, field).await\n    }\n\n    #[inline(always)]\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        T::finalize(this).map(Self)\n    }\n}\n\nimpl<T> Deref for Lenient<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for Lenient<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<T> From<T> for Lenient<T> {\n    #[inline]\n    fn from(val: T) -> Lenient<T> {\n        Lenient(val)\n    }\n}\n\nimpl<'f, A, T: FromUriParam<Query, A> + FromForm<'f>> FromUriParam<Query, A> for Lenient<T> {\n    type Target = T::Target;\n\n    #[inline(always)]\n    fn from_uri_param(param: A) -> Self::Target {\n        T::from_uri_param(param)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Parsing and validation of HTTP forms and fields.\n//!\n//! See the [forms guide](https://rocket.rs/v0.5/guide/requests#forms) for\n//! general form support documentation.\n//!\n//! # Field Wire Format\n//!\n//! Rocket's field wire format is a flexible, non-self-descriptive, text-based\n//! encoding of arbitrarily nested structure keys and their corresponding\n//! values. The general grammar is:\n//!\n//! ```ebnf\n//! field := name ('=' value)?\n//!\n//! name := key*\n//!\n//! key := indices\n//!       | '[' indices ']'\n//!       | '.' indices\n//!\n//! indices := index (':' index)*\n//!\n//! index := STRING except ':', ']'\n//!\n//! value := STRING\n//! ```\n//!\n//! Each field name consists of any number of `key`s and at most one `value`.\n//! Keys are delimited by `[` or `.`. A `key` consists of indices delimited by\n//! `:`.\n//!\n//! The meaning of a key or index is type-dependent, hence the format is\n//! non-self-descriptive. _Any_ structure can be described by this format. The\n//! delimiters `.`, `[`, `:`, and `]` have no semantic meaning.\n//!\n//! Some examples of valid fields are:\n//!\n//!   * `=`\n//!   * `key=value`\n//!   * `key[]=value`\n//!   * `.0=value`\n//!   * `[0]=value`\n//!   * `people[].name=Bob`\n//!   * `bob.cousin.names[]=Bob`\n//!   * `map[k:1]=Bob`\n//!   * `people[bob]nickname=Stan`\n//!\n//! See [`FromForm`] for full details on push-parsing and complete examples, and\n//! [`Form`] for how to accept forms in a request handler.\n\n// ## Maps w/named Fields (`struct`)\n//\n// A `struct` with named fields parses values of multiple types, indexed by the\n// name of its fields:\n//\n// ```rust,ignore\n// struct Dog { name: String, barks: bool, friends: Vec<Cat>, }\n// struct Cat { name: String, meows: bool }\n// ```\n//\n// Candidates for parsing into a `Dog` include:\n//\n//   * `name=Fido&barks=0`\n//\n//     `Dog { \"Fido\", false }`\n//\n//   * `name=Fido&barks=1&friends[0]name=Sally&friends[0]meows=0`\n//     `name=Fido&barks=1&friends[0].name=Sally&friends[0].meows=0`\n//     `name=Fido&barks=1&friends.0.name=Sally&friends.0.meows=0`\n//\n//     `Dog { \"Fido\", true, vec![Cat { \"Sally\", false }] }`\n//\n// Parsers for structs are code-generated to proceed as follows:\n//\n//   1. **Initialization.** The context stores parsing options, a `T::Context`\n//      for each field of type `T`, and a vector called `extra`.\n//\n//      ```rust,ignore\n//      struct Context<'v> {\n//          opts: FormOptions,\n//          field_a: A::Context,\n//          field_b: B::Context,\n//          /* ... */\n//          extra: Vec<FormField<'v>>\n//      }\n//      ```\n//\n//   2. **Push.** The index of the first key is compared to known field names.\n//      If none matches, the index is added to `extra`. Otherwise the key is\n//      stripped from the field, and the remaining field is pushed to `T`.\n//\n//      ```rust,ignore\n//      fn push(this: &mut Self::Context, field: FormField<'v>) {\n//          match field.key() {\n//              \"field_a\" => A::push(&mut this.field_a, field.next()),\n//              \"field_b\" => B::push(&mut this.field_b, field.next()),\n//              /* ... */\n//              _ => this.extra.push(field)\n//          }\n//      }\n//      ```\n//\n//   3. **Finalization.** Every context is finalized; errors and `Ok` values\n//      are collected. If parsing is strict and extras is non-empty, an error\n//      added to the collection of errors. If there are no errors, all `Ok`\n//      values are used to create the `struct`, and the created struct is\n//      returned. Otherwise, `Err(errors)` is returned.\n//\n//      ```rust,ignore\n//      fn finalize(mut this: Self::Context) -> Result<Self, Self::Error> {\n//          let mut errors = vec![];\n//\n//          let field_a = A::finalize(&mut this.field_a)\n//             .map_err(|e| errors.push(e))\n//             .map(Some).unwrap_or(None);\n//\n//          let field_b = B::finalize(&mut this.field_b)\n//             .map_err(|e| errors.push(e))\n//             .map(Some).unwrap_or(None);\n//\n//          /* .. */\n//\n//          if !errors.is_empty() {\n//              return Err(Values(errors));\n//          } else if this.opts.is_strict() && !this.extra.is_empty() {\n//              return Err(Extra(this.extra));\n//          } else {\n//              // NOTE: All unwraps will succeed since `errors.is_empty()`.\n//              Struct {\n//                 field_a: field_a.unwrap(),\n//                 field_b: field_b.unwrap(),\n//                 /* .. */\n//              }\n//          }\n//      }\n//      ```\n//\n// ## Sequences: (`Vec<T: FromForm>`)\n//\n// A `Vec<T: FromForm>` invokes `T`'s push-parser on every push, adding instances\n// of `T` to an internal vector. The instance of `T` whose parser is invoked\n// depends on the index of the first key:\n//\n//   * if it is the first push, the index differs from the previous, or there is no\n//     index, a new `T::Context` is `init`ialized and added to the internal vector\n//   * if the index matches the previously seen index, the last initialized\n//     `T::Context` is `push`ed to.\n//\n// For instance, the sequentially pushed values `=1`, `=2`, and `=3` for a\n// `Vec<usize>` (or any other integer) is expected to parse as `vec![1, 2, 3]`. The\n// same is true for `[]=1&[]=2&[]=3`. In the first example (`=1&..`), the fields\n// passed to `Vec`'s push-parser (`=1`, ..) have no key and thus no index. In the\n// second example (`[]=1&..`), the key is `[]` (`[]=1`) without an index. In both\n// cases, there is no index. The `Vec` parser takes this to mean that a _new_ `T`\n// should be parsed using the field's value.\n//\n// If, instead, the index was non-empty and equal to the index of the field in the\n// _previous_ push, `Vec` pushes the value to the parser of the previously parsed\n// `T`: `[]=1&[0]=2&[0]=3` results in `vec![1, 2]` and `[0]=1&[0]=2&[]=3` results\n// in `vec![1, 3]` (see [`FromFormValue`]).\n//\n// This generalizes. Consider a `Vec<Vec<usize>>` named `x`, so `x` and an\n// optional `=` are stripped before being passed to `Vec`'s push-parser:\n//\n//   * `x=1&x=2&x=3` parses as `vec![vec![1], vec![2], vec![3]]`\n//\n//     Every push (`1`, `2`, `3`) has no key, thus no index: a new `T` (here,\n//     `Vec<usize>`) is thus initialized for every `push()` and passed the\n//     value (here, `1`, `2`, and `3`). Each of these `push`es proceeds\n//     recursively: every push again has no key, thus no index, so a new `T` is\n//     initialized for every push (now a `usize`), which finally parse as\n//     integers `1`, `2`, and `3`.\n//\n//     Note: `x=1&x=2&x=3` _also_ can also parse as `vec![1, 2, 3]` when viewed\n//     as a `Vec<usize>`; this is the non-self-descriptive part of the format.\n//\n//   * `x[]=1&x[]=2&x[]=3` parses as `vec![vec![1], vec![2], vec![3]]`\n//\n//     This proceeds nearly identically to the previous example, with the exception\n//     that the top-level `Vec` sees the values `[]=1`, `[]=2`, and `[]=3`.\n//\n//   * `x[0]=1&x[0]=2&x[]=3` parses as `vec![vec![1, 2], vec![3]]`\n//\n//     The top-level `Vec` sees the values `[0]=1`, `[0]=2`, and `[]=3`. The first\n//     value results in a new `Vec<usize>` being initialized, as before, which is\n//     pushed a `1`. The second value has the same index as the first, `0`, and so\n//     `2` is pushed to the previous `T`, the `Vec` which contains the `1`.\n//     Finally, the third value has no index, so a new `Vec<usize>` is initialized\n//     and pushed a `3`.\n//\n//   * `x[0]=1&x[0]=2&x[]=3&x[]=4` parses as `vec![vec![1, 2], vec![3], vec![4]]`\n//   * `x[0]=1&x[0]=2&x[1]=3&x[1]=4` parses as `vec![vec![1, 2], vec![3, 4]]`\n//\n// The indexing kind `[]` is purely by convention: the first two examples are\n// equivalent to `x.=1&x.=2`, while the third to `x.0=1&x.0=&x.=3`.\n//\n// The parser proceeds as follows:\n//\n//   1. **Initialization.** The context stores parsing options, the\n//      `last_index` encountered in a `push`, an `Option` of a `T::Context` for\n//      the `current` value being parsed, a `Vec<T::Errors>` of `errors`, and\n//      finally a `Vec<T>` of already parsed `items`.\n//\n//      ```rust,ignore\n//      struct VecContext<'v, T: FromForm<'v>> {\n//          opts: FormOptions,\n//          last_index: Index<'v>,\n//          current: Option<T::Context>,\n//          errors: Vec<T::Error>,\n//          items: Vec<T>\n//      }\n//      ```\n//\n//   2. **Push.** The index of the first key is compared against `last_index`.\n//      If it differs, a new context for `T` is created and the previous is\n//      finalized. The `Ok` result from finalization is stored in `items` and\n//      the `Err` in `errors`. Otherwise the `index` is the same, the `current`\n//      context is retrieved, and the field stripped of the current key is\n//      pushed to `T`. `last_index` is updated.\n//\n//      ```rust,ignore\n//      fn push(this: &mut Self::Context, field: FormField<'v>) {\n//          if this.last_index != field.index() {\n//              this.shift(); // finalize `current`, add to `items`, `errors`\n//              let mut context = T::init(this.opts);\n//              T::push(&mut context, field.next());\n//              this.current = Some(context);\n//          } else {\n//              let context = this.current.as_mut();\n//              T::push(context, field.next())\n//          }\n//\n//          this.last_index = field.index();\n//      }\n//      ```\n//\n//   3. **Finalization.** Any `current` context is finalized, storing the `Ok`\n//      or `Err` as before. `Ok(items)` is returned if `errors` is empty,\n//      otherwise `Err(errors)` is returned.\n//\n//      ```rust,ignore\n//      fn finalize(mut this: Self::Context) -> Result<Self, Self::Error> {\n//          this.shift(); // finalizes `current`, as before.\n//          match this.errors.is_empty() {\n//              true => Ok(this.items),\n//              false => Err(this.errors)\n//          }\n//      }\n//      ```\n//\n// ## Arbitrary Maps (`HashMap<K: FromForm, V: FromForm>`)\n//\n// A `HashMap<K, V>` can be parsed from keys with one index or, for composite\n// key values, such as structures or sequences, multiple indices. We begin with\n// a discussion of the simpler case: non-composite keys.\n//\n// ### Non-Composite Keys\n//\n// A non-composite value can be described by a single field with no indices.\n// Strings and integers are examples of non-composite values. The push-parser\n// for `HashMap<K, V>` for a non-composite `K` uses the index of the first key\n// as the value of `K`; the remainder of the field is pushed to `V`'s parser:\n//\n//   1. **Initialization.** The context stores a column-based representation of\n//      `keys` and `values`, a `key_map` from a string key to the column index,\n//      an `errors` vector for storing errors as they arise, and the parsing\n//      options.\n//\n//      ```rust,ignore\n//      struct MapContext<'v, K: FromForm<'v>, V: FromForm<'v>> {\n//          opts: FormOptions,\n//          key_map: HashMap<&'v str, usize>,\n//          keys: Vec<K::Context>,\n//          values: Vec<V::Context>,\n//          errors: Vec<MapError<'v, K::Error, V::Error>>,\n//      }\n//      ```\n//\n//   2. **Push.** The `key_map` index for the key associated with the index of\n//      the first key in the field is retrieved. If such a key has not yet been\n//      seen, a new key and value context are created, the key is pushed to\n//      `K`'s parser, and the field minus the first key is pushed to `V`'s\n//      parser.\n//\n//      ```rust,ignore\n//      fn push(this: &mut Self::Context, field: FormField<'v>) {\n//          let key = field.index();\n//          let value_context = match this.key_map.get(Key) {\n//              Some(i) => &mut this.values[i],\n//              None => {\n//                  let i = this.keys.len();\n//                  this.key_map.insert(key, i);\n//                  this.keys.push(K::init(this.opts));\n//                  this.values.push(V::init(this.opts));\n//                  K::push(&mut this.keys[i], key.into());\n//                  &mut this.values[i]\n//              }\n//          };\n//\n//          V::push(value_context, field.next());\n//      }\n//      ```\n//\n//   3. **Finalization.** All key and value contexts are finalized; any errors\n//      are collected in `errors`. If there are no errors, `keys` and `values`\n//      are collected into a `HashMap` and returned. Otherwise, the errors are\n//      returned.\n//\n//      ```rust,ignore\n//      fn finalize(mut this: Self::Context) -> Result<Self, Self::Error> {\n//          this.finalize_keys();\n//          this.finalize_values();\n//          if this.errors.is_empty() {\n//              Ok(this.keys.into_iter().zip(this.values.into_iter()).collect())\n//          } else {\n//              Err(this.errors)\n//          }\n//      }\n//      ```\n//\n// Examples of forms parseable via this parser are:\n//\n//   * `x[0].name=Bob&x[0].meows=true`as a `HashMap<usize, Cat>` parses with\n//     `0` mapping to `Cat { name: \"Bob\", meows: true }`\n//   * `x[0]name=Bob&x[0]meows=true`as a `HashMap<usize, Cat>` parses just as\n//      above.\n//   * `x[0]=Bob&x[0]=Sally&x[1]=Craig`as a `HashMap<usize, Vec<String>>`\n//      just as `{ 0 => vec![\"Bob\", \"Sally\"], 1 => vec![\"Craig\"] }`.\n//\n// A `HashMap<K, V>` can be thought of as a vector of key-value pairs: `Vec<(K,\n// V)` (row-based) or equivalently, as two vectors of keys and values: `Vec<K>`\n// and `Vec<V>` (column-based). The implication is that indexing into a\n// specific key or value requires _two_ indexes: the first to determine whether\n// a key or value is being indexed to, and the second to determine _which_ key\n// or value. The push-parser for maps thus optionally accepts two indexes for a\n// single key to allow piece-by-piece build-up of arbitrary keys and values.\n//\n// The parser proceeds as follows:\n//\n//   1. **Initialization.** The context stores parsing options, a vector of\n//      `key_contexts: Vec<K::Context>`, a vector of `value_contexts:\n//      Vec<V::Context>`, a `mapping` from a string index to an integer index\n//      into the `contexts`, and a vector of `errors`.\n//   2. **Push.** An index is required; an error is emitted and `push` returns\n//      if they field's first key does not contain an index. If the first key\n//      contains _one_ index, a new `K::Context` and `V::Context` are created.\n//      The key is pushed as the value to `K` and the remaining field as the\n//      value to `V`. The key and value are finalized; if both succeed, the key\n//      and value are stored in `keys` and `values`; otherwise the error(s) is\n//      stored in `errors`.\n//\n//      If the first keys contains _two_ indices, the first must starts with\n//      `k` or `v`, while the `second` is arbitrary. `mapping` is indexed by\n//      `second`; the integer is retrieved. If none exists, new contexts are\n//      created an added to `{key,value}_contexts`, and their index is mapped\n//      to `second` in `mapping`. If the first index is `k`, the field,\n//      stripped of the first key, is pushed to the key's context; the same is\n//      done for the value's context is the first index is `v`.\n//   3. **Finalization.** Every context is finalized; errors and `Ok` values\n//      are collected. TODO: FINISH. Split this into two: one for single-index,\n//      another for two-indices.\n\nmod field;\nmod options;\nmod from_form;\nmod from_form_field;\nmod form;\nmod context;\nmod strict;\nmod lenient;\nmod parser;\nmod buffer;\npub mod validate;\npub mod name;\npub mod error;\n\n#[cfg(test)]\nmod tests;\n\n/// Type alias for `Result` with an error type of [`Errors`].\npub type Result<'v, T> = std::result::Result<T, Errors<'v>>;\n\n#[doc(hidden)]\npub use rocket_codegen::{FromForm, FromFormField};\n\n#[doc(inline)]\npub use self::error::{Errors, Error};\n\n#[doc(hidden)]\npub use self::buffer::{SharedStack, Shareable};\n\npub use field::*;\npub use options::*;\npub use from_form_field::*;\npub use from_form::*;\npub use form::*;\npub use context::*;\npub use strict::*;\npub use lenient::*;\n\n#[doc(hidden)]\npub mod prelude {\n    pub use super::*;\n    pub use super::name::*;\n    pub use super::error::*;\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "/// Form guard options.\n///\n/// See [`Form#leniency`](crate::form::Form#leniency) for details.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub struct Options {\n    /// Whether parsing should be strict (no extra parameters) or not.\n    pub strict: bool,\n}\n\n#[allow(non_upper_case_globals, dead_code)]\nimpl Options {\n    /// `Options` with `strict` set to `false`.\n    pub const Lenient: Self = Options { strict: false };\n\n    /// `Options` with `strict` set to `true`.\n    pub const Strict: Self = Options { strict: true };\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use multer::Multipart;\nuse either::Either;\n\nuse crate::request::{Request, local_cache_once};\nuse crate::data::{Data, Limits, Outcome};\nuse crate::form::{SharedStack, prelude::*};\nuse crate::http::{RawStr, Status};\n\ntype Result<'r, T> = std::result::Result<T, Error<'r>>;\n\ntype Field<'r, 'i> = Either<ValueField<'r>, DataField<'r, 'i>>;\n\npub struct MultipartParser<'r, 'i> {\n    request: &'r Request<'i>,\n    buffer: &'r SharedStack<String>,\n    source: Multipart<'r>,\n    done: bool,\n}\n\npub struct RawStrParser<'r> {\n    buffer: &'r SharedStack<String>,\n    source: &'r RawStr,\n}\n\npub enum Parser<'r, 'i> {\n    Multipart(MultipartParser<'r, 'i>),\n    RawStr(RawStrParser<'r>),\n}\n\nimpl<'r, 'i> Parser<'r, 'i> {\n    pub async fn new(\n        req: &'r Request<'i>,\n        data: Data<'r>\n    ) -> Outcome<'r, Parser<'r, 'i>, Errors<'r>> {\n        let parser = match req.content_type() {\n            Some(c) if c.is_form() => Self::from_form(req, data).await,\n            Some(c) if c.is_form_data() => Self::from_multipart(req, data).await,\n            _ => return Outcome::Forward((data, Status::UnsupportedMediaType)),\n        };\n\n        match parser {\n            Ok(storage) => Outcome::Success(storage),\n            Err(e) => Outcome::Error((e.status(), e.into()))\n        }\n    }\n\n    async fn from_form(req: &'r Request<'i>, data: Data<'r>) -> Result<'r, Parser<'r, 'i>> {\n        let limit = req.limits().get(\"form\").unwrap_or(Limits::FORM);\n        let string = data.open(limit).into_string().await?;\n        if !string.is_complete() {\n            Err((None, Some(limit.as_u64())))?;\n        }\n\n        Ok(Parser::RawStr(RawStrParser {\n            buffer: local_cache_once!(req, SharedStack::new()),\n            source: RawStr::new(local_cache_once!(req, string.into_inner())),\n        }))\n    }\n\n    async fn from_multipart(req: &'r Request<'i>, data: Data<'r>) -> Result<'r, Parser<'r, 'i>> {\n        let boundary = req.content_type()\n            .ok_or(multer::Error::NoMultipart)?\n            .param(\"boundary\")\n            .ok_or(multer::Error::NoBoundary)?;\n\n        let form_limit = req.limits()\n            .get(\"data-form\")\n            .unwrap_or(Limits::DATA_FORM);\n\n        // Increase internal limit by 1 so multer can limit to `form_limit`.\n        let stream = data.open(form_limit + 1);\n        let constraints = multer::Constraints::new()\n            .size_limit(multer::SizeLimit::new()\n                .whole_stream(form_limit.into())\n                .per_field(form_limit.into()));\n\n        Ok(Parser::Multipart(MultipartParser {\n            request: req,\n            buffer: local_cache_once!(req, SharedStack::new()),\n            source: Multipart::with_reader_with_constraints(stream, boundary, constraints),\n            done: false,\n        }))\n    }\n\n    pub async fn next(&mut self) -> Option<Result<'r, Field<'r, 'i>>> {\n        match self {\n            Parser::Multipart(ref mut p) => p.next().await,\n            Parser::RawStr(ref mut p) => p.next().map(|f| Ok(Either::Left(f)))\n        }\n    }\n}\n\nimpl<'r> RawStrParser<'r> {\n    pub fn new(buffer: &'r SharedStack<String>, source: &'r RawStr) -> Self {\n        RawStrParser { buffer, source }\n    }\n}\n\nimpl<'r> Iterator for RawStrParser<'r> {\n    type Item = ValueField<'r>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        use std::borrow::Cow::*;\n\n        let (name, value) = loop {\n            if self.source.is_empty() {\n                return None;\n            }\n\n            let (field_str, rest) = self.source.split_at_byte(b'&');\n            self.source = rest;\n\n            if !field_str.is_empty() {\n                break field_str.split_at_byte(b'=');\n            }\n        };\n\n        trace_!(\"url-encoded field: {:?}\", (name, value));\n        let name_val = match (name.url_decode_lossy(), value.url_decode_lossy()) {\n            (Borrowed(name), Borrowed(val)) => (name, val),\n            (Borrowed(name), Owned(v)) => (name, self.buffer.push(v)),\n            (Owned(name), Borrowed(val)) => (self.buffer.push(name), val),\n            (Owned(mut name), Owned(val)) => {\n                let len = name.len();\n                name.push_str(&val);\n                self.buffer.push_split(name, len)\n            }\n        };\n\n        Some(ValueField::from(name_val))\n    }\n}\n\n#[cfg(test)]\nmod raw_str_parse_tests {\n    use crate::form::ValueField as Field;\n\n    #[test]\n    fn test_skips_empty() {\n        let buffer = super::SharedStack::new();\n        let fields: Vec<_> = super::RawStrParser::new(&buffer, \"a&b=c&&&c\".into()).collect();\n        assert_eq!(fields, &[Field::parse(\"a\"), Field::parse(\"b=c\"), Field::parse(\"c\")]);\n    }\n\n    #[test]\n    fn test_decodes() {\n        let buffer = super::SharedStack::new();\n        let fields: Vec<_> = super::RawStrParser::new(&buffer, \"a+b=c%20d&%26\".into()).collect();\n        assert_eq!(fields, &[Field::parse(\"a b=c d\"), Field::parse(\"&\")]);\n    }\n}\n\nimpl<'r, 'i> MultipartParser<'r, 'i> {\n    /// Returns `None` when there are no further fields. Otherwise tries to\n    /// parse the next multipart form field and returns the result.\n    async fn next(&mut self) -> Option<Result<'r, Field<'r, 'i>>> {\n        if self.done {\n            return None;\n        }\n\n        let field = match self.source.next_field().await {\n            Ok(Some(field)) => field,\n            Ok(None) => return None,\n            Err(e) => {\n                self.done = true;\n                return Some(Err(e.into()));\n            }\n        };\n\n        // A field with a content-type is data; one without is \"value\".\n        trace_!(\"multipart field: {:?}\", field);\n        let content_type = field.content_type().and_then(|m| m.as_ref().parse().ok());\n        let field = if let Some(content_type) = content_type {\n            let (name, file_name) = match (field.name(), field.file_name()) {\n                (None, None) => (\"\", None),\n                (None, Some(file_name)) => (\"\", Some(self.buffer.push(file_name))),\n                (Some(name), None) => (self.buffer.push(name), None),\n                (Some(a), Some(b)) => {\n                    let (field_name, file_name) = self.buffer.push_two(a, b);\n                    (field_name, Some(file_name))\n                }\n            };\n\n            Either::Right(DataField {\n                content_type,\n                request: self.request,\n                name: NameView::new(name),\n                file_name: file_name.map(crate::fs::FileName::new),\n                data: Data::from(field),\n            })\n        } else {\n            let (mut buf, len) = match field.name() {\n                Some(s) => (s.to_string(), s.len()),\n                None => (String::new(), 0)\n            };\n\n            match field.text().await {\n                Ok(text) => buf.push_str(&text),\n                Err(e) => return Some(Err(e.into())),\n            };\n\n            let name_val = self.buffer.push_split(buf, len);\n            Either::Left(ValueField::from(name_val))\n        };\n\n        Some(Ok(field))\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::{Deref, DerefMut};\n\nuse crate::form::prelude::*;\nuse crate::http::uri::fmt::{Query, FromUriParam};\n\n/// A form guard for parsing form types strictly.\n///\n/// This type implements the [`FromForm`] trait and thus can be used as a\n/// generic parameter to the [`Form`] data guard: `Form<Strict<T>>`, where `T`\n/// implements `FromForm`. Unlike using `Form` directly, this type uses a\n/// _strict_ parsing strategy: forms that contains a superset of the expected\n/// fields (i.e, extra fields) will fail to parse and defaults will not be use\n/// for missing fields.\n///\n/// # Strictness\n///\n/// A `Strict<T>` will parse successfully from an incoming form only if\n/// the form contains the exact set of fields in `T`. Said another way, a\n/// `Strict<T>` will error on missing and/or extra fields. For instance, if an\n/// incoming form contains the fields \"a\", \"b\", and \"c\" while `T` only contains\n/// \"a\" and \"c\", the form _will not_ parse as `Strict<T>`.\n///\n/// # Usage\n///\n/// `Strict<T>` implements [`FromForm`] as long as `T` implements `FromForm`. As\n/// such, `Form<Strict<T>>` is a data guard:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::form::{Form, Strict};\n///\n/// #[derive(FromForm)]\n/// struct UserInput {\n///     value: String\n/// }\n///\n/// #[post(\"/submit\", data = \"<user_input>\")]\n/// fn submit_task(user_input: Form<Strict<UserInput>>) -> String {\n///     format!(\"Your value: {}\", user_input.value)\n/// }\n/// ```\n///\n/// `Strict` can also be used to make individual fields strict while keeping the\n/// overall structure and remaining fields lenient:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::form::{Form, Strict};\n///\n/// #[derive(FromForm)]\n/// struct UserInput {\n///     required: Strict<bool>,\n///     uses_default: bool\n/// }\n/// ```\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Strict<T>(T);\n\nimpl<T> Strict<T> {\n    /// Consumes `self` and returns the inner value.\n    ///\n    /// Note that since `Strict` implements [`Deref`] and [`DerefMut`] with\n    /// target `T`, reading and writing an inner value can be accomplished\n    /// transparently.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::form::{Form, Strict};\n    ///\n    /// #[derive(FromForm)]\n    /// struct MyForm {\n    ///     field: String,\n    /// }\n    ///\n    /// #[post(\"/submit\", data = \"<form>\")]\n    /// fn submit(form: Form<Strict<MyForm>>) -> String {\n    ///     // We can read or mutate a value transparently:\n    ///     let field: &str = &form.field;\n    ///\n    ///     // To gain ownership, however, use `into_inner()`:\n    ///     form.into_inner().into_inner().field\n    /// }\n    /// ```\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: FromForm<'v>> FromForm<'v> for Strict<T> {\n    type Context = T::Context;\n\n    #[inline(always)]\n    fn init(opts: Options) -> Self::Context {\n        T::init(Options { strict: true, ..opts })\n    }\n\n    #[inline(always)]\n    fn push_value(ctxt: &mut Self::Context, field: ValueField<'v>) {\n        T::push_value(ctxt, field)\n    }\n\n    #[inline(always)]\n    async fn push_data(ctxt: &mut Self::Context, field: DataField<'v, '_>) {\n        T::push_data(ctxt, field).await\n    }\n\n    #[inline(always)]\n    fn finalize(this: Self::Context) -> Result<'v, Self> {\n        T::finalize(this).map(Self)\n    }\n}\n\nimpl<T> Deref for Strict<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for Strict<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        &mut self.0\n    }\n}\n\nimpl<T> From<T> for Strict<T> {\n    #[inline]\n    fn from(val: T) -> Strict<T> {\n        Strict(val)\n    }\n}\n\nimpl<'f, A, T: FromUriParam<Query, A> + FromForm<'f>> FromUriParam<Query, A> for Strict<T> {\n    type Target = T::Target;\n\n    #[inline(always)]\n    fn from_uri_param(param: A) -> Self::Target {\n        T::from_uri_param(param)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::collections::HashMap;\n\nuse crate::form::*;\n\nfn parse<'v, T: FromForm<'v>>(values: &[&'v str]) -> Result<'v, T> {\n    Form::parse_iter(values.iter().cloned().map(ValueField::parse))\n}\n\nmacro_rules! map {\n    ($($key:expr => $value:expr),* $(,)?) => ({\n        let mut map = std::collections::HashMap::new();\n        $(map.insert($key.into(), $value.into());)*\n        map\n    });\n}\n\nmacro_rules! vec {\n    ($($value:expr),* $(,)?) => ({\n        let mut vec = Vec::new();\n        $(vec.push($value.into());)*\n        vec\n    });\n}\n\nmacro_rules! assert_values_parse_eq {\n    ($($v:expr => $T:ty = $expected:expr),* $(,)?) => (\n        $(\n            assert_value_parse_eq!($v as &[&str] => $T = $expected);\n        )*\n    )\n}\n\nmacro_rules! assert_value_parse_eq {\n    ($v:expr => $T:ty = $expected:expr) => (\n        let expected: $T = $expected;\n        match parse::<$T>($v) {\n            Ok(actual) if actual == expected => { /* ok */ },\n            Ok(actual) => {\n                panic!(\"unexpected parse of {:?} ({:?} instead of {:?})\",\n                    $v, actual, expected)\n            }\n            Err(e) => panic!(\"parse `{:?} {}` failed: {:?}\", $v, stringify!(=> $T = $expected), e)\n        }\n    )\n}\n\nmacro_rules! assert_parses_fail {\n    ($($v:expr => $T:ty),* $(,)?) => (\n        $(\n            assert_parse_fails!($v as &[&str] => $T);\n        )*\n    )\n}\n\nmacro_rules! assert_parse_fails {\n    ($v:expr => $T:ty) => (\n        let diag = format!(\"{:?} {}\", $v, stringify!(=> $T));\n        match parse::<$T>($v) {\n            Ok(actual) => panic!(\"unexpectedly parsed {} as {:?}\", diag, actual),\n            Err(_) => { /* ok */ }\n        }\n    )\n}\n\n#[test]\nfn time() {\n    use time::{macros::{date, time}, Date, Time, PrimitiveDateTime as DateTime};\n\n    assert_values_parse_eq! {\n        &[\"=2010-10-20\"] => Date = date!(2010-10-20),\n        &[\"=2012-01-20\"] => Date = date!(2012-01-20),\n        &[\"=2020-01-20T02:30\"] => DateTime = DateTime::new(date!(2020-01-20), time!(2:30)),\n        &[\"=2020-01-01T02:30:12\"] => DateTime = DateTime::new(date!(2020-01-01), time!(2:30:12)),\n        &[\"=20:20:52\"] => Time = time!(20:20:52),\n        &[\"=06:08\"] => Time = time!(06:08),\n    }\n}\n\n#[test]\nfn bool() {\n    assert_values_parse_eq! {\n        &[\"=true\", \"=yes\", \"=on\", \"\"] => Vec<bool> = vec![true, true, true, true],\n        &[\"=false\", \"=no\", \"=off\"] => Vec<bool> = vec![false, false, false],\n        &[\"=tRuE\", \"=YES\", \"=On\"] => Vec<bool> = vec![true, true, true],\n        &[\"=fAlSE\", \"=NO\", \"=OFF\"] => Vec<bool> = vec![false, false, false],\n    }\n\n    assert_parses_fail! {\n        &[] => Strict<bool>,\n        &[\"=unknown\"] => bool,\n        &[\"=unknown\", \"=please\"] => Vec<bool>,\n    }\n}\n\n#[test]\nfn defaults() {\n    assert_values_parse_eq! {\n        &[] => bool = false,\n        &[] => Option<&str> = None,\n        &[] => Option<time::Date> = None,\n\n        &[] => Option<bool> = None,\n        &[] => Option<Strict<bool>> = None,\n\n        &[] => Result<'_, bool> = Ok(false),\n        &[] => Result<'_, Strict<bool>> = Err(error::ErrorKind::Missing.into()),\n\n        &[\"=unknown\"] => Option<bool> = None,\n        &[\"=unknown\"] => Option<Strict<bool>> = None,\n        &[\"=unknown\"] => Option<Lenient<bool>> = None,\n\n        &[] => Option<Lenient<bool>> = Some(false.into()),\n        &[\"=123\"] => Option<time::Date> = None,\n\n        &[\"=no\"] => Option<bool> = Some(false),\n        &[\"=yes\"] => Option<bool> = Some(true),\n        &[\"=yes\"] => Option<Lenient<bool>> = Some(true.into()),\n        &[\"=yes\"] => Option<Strict<bool>> = Some(true.into()),\n    }\n}\n\n#[test]\nfn potpourri() {\n    assert_values_parse_eq! {\n        &[\"a.b=10\"] => usize = 10,\n        &[\"a=10\"] => u8 = 10,\n        &[\"=10\"] => u8 = 10,\n        &[\"=5\", \"=3\", \"=4\"] => Vec<&str> = vec![\"5\", \"3\", \"4\"],\n        &[\"=5\", \"=3\", \"=4\"] => Vec<&str> = vec![\"5\", \"3\", \"4\"],\n        &[\"a=3\", \"b=4\", \"c=5\"] => Vec<u8> = vec![3, 4, 5],\n        &[\"=3\", \"=4\", \"=5\"] => Vec<u8> = vec![3, 4, 5],\n        &[\"=3\", \"=4\", \"=5\"] => Vec<Vec<u8>> = vec![vec![3], vec![4], vec![5]],\n        &[\"[]=3\", \"[]=4\", \"[]=5\"] => Vec<Vec<u8>> = vec![vec![3], vec![4], vec![5]],\n        &[\"[][]=3\", \"[][]=4\", \"[][]=5\"] => Vec<Vec<u8>> = vec![vec![3], vec![4], vec![5]],\n        &[\"[]=5\", \"[]=3\", \"[]=4\"] => Vec<&str> = vec![\"5\", \"3\", \"4\"],\n        &[\"[0]=5\", \"[0]=3\", \"=4\", \"=6\"] => Vec<Vec<u8>>\n            = vec![vec![5, 3], vec![4], vec![6]],\n        &[\".0=5\", \".1=3\"] => (u8, usize) = (5, 3),\n        &[\"0=5\", \"1=3\"] => (u8, usize) = (5, 3),\n        &[\"[bob]=Robert\", \".j=Jack\", \"s=Stan\", \"[s]=Steve\"] => HashMap<&str, &str>\n            = map![\"bob\" => \"Robert\", \"j\" => \"Jack\", \"s\" => \"Stan\"],\n        &[\"[bob]=Robert\", \".j=Jack\", \"s=Stan\", \"[s]=Steve\"]\n            => HashMap<&str, Vec<&str>>\n            = map![\n                \"bob\" => vec![\"Robert\"],\n                \"j\" => vec![\"Jack\"],\n                \"s\" => vec![\"Stan\", \"Steve\"]\n            ],\n        &[\"[k:0]=5\", \"[k:0]=3\", \"[v:0]=20\", \"[56]=2\"] => HashMap<Vec<&str>, usize>\n            = map![vec![\"5\", \"3\"] => 20u8, vec![\"56\"] => 2u8],\n        &[\"[k:0]=5\", \"[k:0]=3\", \"[0]=20\", \"[56]=2\"] => HashMap<Vec<&str>, usize>\n            = map![vec![\"5\", \"3\"] => 20u8, vec![\"56\"] => 2u8],\n        &[\n            \"[k:a]0=5\", \"[a]=hi\", \"[v:b][0]=10\", \"[k:b].0=1\",\n            \"[k:b].1=hi\", \"[a]=hey\", \"[k:a]1=3\"\n        ] => HashMap<(usize, &str), Vec<&str>>\n            = map![\n                (5, \"3\".into()) => vec![\"hi\", \"hey\"],\n                (1, \"hi\".into()) => vec![\"10\"]\n            ],\n        &[\n            \"[0][hi]=10\", \"[0][hey]=12\", \"[1][bob]=0\", \"[1].blam=58\", \"[].0=1\",\n            \"[].whoops=999\",\n        ] => Vec<HashMap<&str, usize>>\n            = vec![\n                map![\"hi\" => 10u8, \"hey\" => 12u8],\n                map![\"bob\" => 0u8, \"blam\" => 58u8],\n                map![\"0\" => 1u8],\n                map![\"whoops\" => 999usize]\n            ],\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Form field validation routines.\n//!\n//! Each function in this module can be used as the target of the\n//! `field(validate)` field attribute of the `FromForm` derive.\n//!\n//! ```rust\n//! use rocket::form::FromForm;\n//!\n//! #[derive(FromForm)]\n//! struct MyForm<'r> {\n//!     #[field(validate = range(2..10))]\n//!     id: usize,\n//!     #[field(validate = omits(\"password\"))]\n//!     password: &'r str,\n//! }\n//! ```\n//!\n//! The `validate` parameter takes any expression that returns a\n//! [`form::Result<()>`](crate::form::Result). If the expression is a function\n//! call, a reference to the field is inserted as the first parameter. Thus,\n//! functions calls to `validate` must take a reference to _some_ type,\n//! typically a generic with some bounds, as their first argument.\n//!\n//! ## Custom Error Messages\n//!\n//! To set a custom error messages, it is useful to chain results:\n//!\n//! ```rust\n//! use rocket::form::{Errors, Error, FromForm};\n//!\n//! #[derive(FromForm)]\n//! struct MyForm<'r> {\n//!     // By defining another function...\n//!     #[field(validate = omits(\"password\").map_err(pass_help))]\n//!     password: &'r str,\n//!     // or inline using the `msg` helper. `or_else` inverts the validator\n//!     #[field(validate = omits(\"password\").or_else(msg!(\"please omit `password`\")))]\n//!     password2: &'r str,\n//!     // You can even refer to the field in the message...\n//!     #[field(validate = range(1..).or_else(msg!(\"`{}` < 1\", self.n)))]\n//!     n: isize,\n//!     // ..or other fields!\n//!     #[field(validate = range(..self.n).or_else(msg!(\"`{}` > `{}`\", self.z, self.n)))]\n//!     z: isize,\n//! }\n//!\n//! fn pass_help<'a>(errors: Errors<'_>) -> Errors<'a> {\n//!     Error::validation(\"passwords can't contain the text \\\"password\\\"\").into()\n//! }\n//! ```\n//!\n//! ## Custom Validation\n//!\n//! Custom validation routines can be defined as regular functions. Consider a\n//! routine that tries to validate a credit card number:\n//!\n//! ```rust\n//! extern crate time;\n//!\n//! use rocket::form::{self, FromForm, Error};\n//!\n//! #[derive(FromForm)]\n//! struct CreditCard {\n//!     #[field(validate = luhn(self.cvv, &self.expiration))]\n//!     number: u64,\n//!     cvv: u16,\n//!     expiration: time::Date,\n//! }\n//!\n//! // Implementation of Luhn validator.\n//! fn luhn<'v>(number: &u64, cvv: u16, exp: &time::Date) -> form::Result<'v, ()> {\n//!     # let valid = false;\n//!     if !valid {\n//!         Err(Error::validation(\"invalid credit card number\"))?;\n//!     }\n//!\n//!     Ok(())\n//! }\n//! ```\n\nuse std::borrow::Cow;\nuse std::ops::{RangeBounds, Bound};\nuse std::fmt::Debug;\n\nuse crate::data::{ByteUnit, Capped};\nuse rocket_http::ContentType;\n\nuse crate::{fs::TempFile, form::{Result, Error}};\n\ncrate::export! {\n    /// A helper macro for custom validation error messages.\n    ///\n    /// The macro works similar to [`std::format!`]. It generates a form\n    /// [`Validation`] error message. While useful in other contexts, it is\n    /// designed to be chained to validation results in derived `FromForm`\n    /// `#[field]` attributes via `.or_else()` and `.and_then()`.\n    ///\n    /// [`Validation`]: crate::form::error::ErrorKind::Validation\n    /// [`form::validate`]: crate::form::validate\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::FromForm;\n    ///\n    /// #[derive(FromForm)]\n    /// struct Person<'r> {\n    ///     #[field(validate = len(3..).or_else(msg!(\"that's a short name...\")))]\n    ///     name: &'r str,\n    ///     #[field(validate = contains('f').and_then(msg!(\"please, no `f`!\")))]\n    ///     non_f_name: &'r str,\n    /// }\n    /// ```\n    ///\n    /// _**Note:** this macro _never_ needs to be imported when used with a\n    /// `FromForm` derive; all items in [`form::validate`] are automatically in\n    /// scope in `FromForm` derive attributes._\n    ///\n    /// See the [top-level docs](crate::form::validate) for more examples.\n    ///\n    /// # Syntax\n    ///\n    /// The macro has the following \"signatures\":\n    ///\n    /// ## Variant 1\n    ///\n    /// ```rust\n    /// # use rocket::form;\n    /// # trait Expr {}\n    /// fn msg<'a, T, P, E: Expr>(expr: E) -> impl Fn(P) -> form::Result<'a, T>\n    /// # { |_| unimplemented!() }\n    /// ```\n    ///\n    /// Takes any expression and returns a function that takes any argument type\n    /// and evaluates to a [`form::Result`](crate::form::Result) with an `Ok` of\n    /// any type. The `Result` is guaranteed to be an `Err` of kind\n    /// [`Validation`] with `expr` as the message.\n    ///\n    /// ## Variant 2\n    ///\n    /// ```\n    /// # use rocket::form;\n    /// # trait Format {}\n    /// # trait Args {}\n    /// fn msg<'a, T, P, A: Args>(fmt: &str, args: A) -> impl Fn(P) -> form::Result<'a, T>\n    /// # { |_| unimplemented!() }\n    /// ```\n    ///\n    /// Invokes the first variant as `msg!(format!(fmt, args))`.\n    macro_rules! msg {\n        ($e:expr) => (|_| {\n            Err($crate::form::Errors::from(\n                    $crate::form::Error::validation($e)\n            )) as $crate::form::Result<()>\n        });\n        ($($arg:tt)*) => ($crate::form::validate::msg!(format!($($arg)*)));\n    }\n}\n\n/// Equality validator: succeeds exactly when `a` == `b`, using [`PartialEq`].\n///\n/// On error, returns a validation error with the following message:\n///\n/// ```text\n/// value does not match expected value\n/// ```\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(FromFormField, PartialEq)]\n/// enum Kind {\n///     Car,\n///     Truck\n/// }\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = eq(\"Bob Marley\"))]\n///     name: &'r str,\n///     #[field(validate = eq(Kind::Car))]\n///     vehicle: Kind,\n///     #[field(validate = eq(&[5, 7, 8]))]\n///     numbers: Vec<usize>,\n/// }\n/// ```\npub fn eq<'v, A, B>(a: &A, b: B) -> Result<'v, ()>\n    where A: PartialEq<B>\n{\n    if a != &b {\n        Err(Error::validation(\"value does not match expected value\"))?\n    }\n\n    Ok(())\n}\n\n/// Debug equality validator: like [`eq()`] but mentions `b` in the error\n/// message.\n///\n/// The is identical to [`eq()`] except that `b` must be `Debug` and the error\n/// message is as follows, where `$b` is the [`Debug`] representation of `b`:\n///\n/// ```text\n/// value must be $b\n/// ```\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, Debug, Clone, Copy, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// #[derive(FromForm)]\n/// struct Foo {\n///     number: usize,\n///     #[field(validate = dbg_eq(self.number))]\n///     confirm_num: usize,\n///     #[field(validate = dbg_eq(Pet::Dog))]\n///     best_pet: Pet,\n/// }\n/// ```\npub fn dbg_eq<'v, A, B>(a: &A, b: B) -> Result<'v, ()>\n    where A: PartialEq<B>, B: Debug\n{\n    if a != &b {\n        Err(Error::validation(format!(\"value must be {:?}\", b)))?\n    }\n\n    Ok(())\n}\n\n/// Negative equality validator: succeeds exactly when `a` != `b`, using\n/// [`PartialEq`].\n///\n/// On error, returns a validation error with the following message:\n///\n/// ```text\n/// value is equal to an invalid value\n/// ```\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(FromFormField, PartialEq)]\n/// enum Kind {\n///     Car,\n///     Truck\n/// }\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = neq(\"Bob Marley\"))]\n///     name: &'r str,\n///     #[field(validate = neq(Kind::Car))]\n///     vehicle: Kind,\n///     #[field(validate = neq(&[5, 7, 8]))]\n///     numbers: Vec<usize>,\n/// }\n/// ```\npub fn neq<'v, A, B>(a: &A, b: B) -> Result<'v, ()>\n    where A: PartialEq<B>\n{\n    if a == &b {\n        Err(Error::validation(\"value is equal to an invalid value\"))?\n    }\n\n    Ok(())\n}\n\n/// Types for values that have a length.\n///\n/// At present, these are:\n///\n/// | type                              | length description                   |\n/// |-----------------------------------|--------------------------------------|\n/// | `&str`, `String`                  | length in bytes                      |\n/// | `Vec<T>`                          | number of elements in the vector     |\n/// | `HashMap<K, V>`, `BTreeMap<K, V>` | number of key/value pairs in the map |\n/// | [`TempFile`]                      | length of the file in bytes          |\n/// | `Option<T>` where `T: Len`        | length of `T` or 0 if `None`         |\n/// | [`form::Result<'_, T>`]           | length of `T` or 0 if `Err`          |\n///\n/// [`form::Result<'_, T>`]: crate::form::Result\npub trait Len<L> {\n    /// The length of the value.\n    fn len(&self) -> L;\n\n    /// Convert `len` into `u64`.\n    fn len_into_u64(len: L) -> u64;\n\n    /// The zero value for `L`.\n    fn zero_len() -> L;\n}\n\nmacro_rules! impl_len {\n    (<$($gen:ident),*> $T:ty => $L:ty) => (\n        impl <$($gen),*> Len<$L> for $T {\n            fn len(&self) -> $L { self.len() }\n            fn len_into_u64(len: $L) -> u64 { len as u64 }\n            fn zero_len() -> $L { 0 }\n        }\n    )\n}\n\nimpl_len!(<> str => usize);\nimpl_len!(<> String => usize);\nimpl_len!(<T> Vec<T> => usize);\nimpl_len!(<> TempFile<'_> => u64);\nimpl_len!(<K, V> std::collections::HashMap<K, V> => usize);\nimpl_len!(<K, V> std::collections::BTreeMap<K, V> => usize);\n\nimpl Len<ByteUnit> for TempFile<'_> {\n    fn len(&self) -> ByteUnit { self.len().into() }\n    fn len_into_u64(len: ByteUnit) -> u64 { len.into() }\n    fn zero_len() -> ByteUnit { ByteUnit::from(0) }\n}\n\nimpl<L, T: Len<L> + ?Sized> Len<L> for &T {\n    fn len(&self) -> L { <T as Len<L>>::len(self) }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\nimpl<L, T: Len<L>> Len<L> for Option<T> {\n    fn len(&self) -> L { self.as_ref().map(|v| v.len()).unwrap_or_else(T::zero_len) }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\nimpl<L, T: Len<L>> Len<L> for Capped<T> {\n    fn len(&self) -> L { self.value.len() }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\nimpl<L, T: Len<L>> Len<L> for Result<'_, T> {\n    fn len(&self) -> L { self.as_ref().ok().len() }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\n#[cfg(feature = \"json\")]\nimpl<L, T: Len<L>> Len<L> for crate::serde::json::Json<T> {\n    fn len(&self) -> L { self.0.len() }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\n#[cfg(feature = \"msgpack\")]\nimpl<L, T: Len<L>> Len<L> for crate::serde::msgpack::MsgPack<T> {\n    fn len(&self) -> L { self.0.len() }\n    fn len_into_u64(len: L) -> u64 { T::len_into_u64(len) }\n    fn zero_len() -> L { T::zero_len() }\n}\n\n/// Length validator: succeeds when the length of a value is within a `range`.\n///\n/// The value must implement [`Len`]. On error, returns an [`InvalidLength`]\n/// error. See [`Len`] for supported types and how their length is computed.\n///\n/// [`InvalidLength`]: crate::form::error::ErrorKind::InvalidLength\n///\n/// # Data Limits\n///\n/// All form types are constrained by a data limit. As such, the `len()`\n/// validator should be used only when a data limit is insufficiently specific.\n/// For example, prefer to use data [`Limits`](crate::data::Limits) to validate\n/// the length of files as not doing so will result in writing more data to disk\n/// than necessary.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::http::ContentType;\n/// use rocket::form::{FromForm, FromFormField};\n/// use rocket::data::ToByteUnit;\n/// use rocket::fs::TempFile;\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = len(5..20))]\n///     name: &'r str,\n///     #[field(validate = len(..=200))]\n///     maybe_name: Option<&'r str>,\n///     #[field(validate = len(..=2.mebibytes()))]\n///     #[field(validate = ext(ContentType::Plain))]\n///     file: TempFile<'r>,\n/// }\n/// ```\npub fn len<'v, V, L, R>(value: V, range: R) -> Result<'v, ()>\n    where V: Len<L>,\n          L: Copy + PartialOrd,\n          R: RangeBounds<L>\n{\n    if !range.contains(&value.len()) {\n        let start = match range.start_bound() {\n            Bound::Included(v) => Some(V::len_into_u64(*v)),\n            Bound::Excluded(v) => Some(V::len_into_u64(*v).saturating_add(1)),\n            Bound::Unbounded => None\n        };\n\n        let end = match range.end_bound() {\n            Bound::Included(v) => Some(V::len_into_u64(*v)),\n            Bound::Excluded(v) => Some(V::len_into_u64(*v).saturating_sub(1)),\n            Bound::Unbounded => None,\n        };\n\n        Err((start, end))?\n    }\n\n    Ok(())\n}\n\n/// Types for values that contain items.\n///\n/// At present, these are:\n///\n/// | type                    | contains                                           |\n/// |-------------------------|----------------------------------------------------|\n/// | `&str`, `String`        | `&str`, `char`, `&[char]` `F: FnMut(char) -> bool` |\n/// | `Vec<T>`                | `T`, `&T`                                          |\n/// | `Option<T>`             | `I` where `T: Contains<I>`                         |\n/// | [`form::Result<'_, T>`] | `I` where `T: Contains<I>`                         |\n///\n/// [`form::Result<'_, T>`]: crate::form::Result\npub trait Contains<I> {\n    /// Returns `true` if `self` contains `item`.\n    fn contains(&self, item: I) -> bool;\n}\n\nmacro_rules! impl_contains {\n    ([$($gen:tt)*] $T:ty [contains] $I:ty [via] $P:ty) => {\n        impl_contains!([$($gen)*] $T [contains] $I [via] $P [with] |v| v);\n    };\n\n    ([$($gen:tt)*] $T:ty [contains] $I:ty [via] $P:ty [with] $f:expr) => {\n        impl<$($gen)*> Contains<$I> for $T {\n            fn contains(&self, item: $I) -> bool {\n                <$P>::contains(self, $f(item))\n            }\n        }\n    };\n}\n\nfn coerce<T, const N: usize>(slice: &[T; N]) -> &[T] {\n    &slice[..]\n}\n\nimpl_contains!([] str [contains] &str [via] str);\nimpl_contains!([] str [contains] char [via] str);\nimpl_contains!([] str [contains] &[char] [via] str);\nimpl_contains!([const N: usize] str [contains] &[char; N] [via] str [with] coerce);\nimpl_contains!([] String [contains] &str [via] str);\nimpl_contains!([] String [contains] char [via] str);\nimpl_contains!([] String [contains] &[char] [via] str);\nimpl_contains!([const N: usize] String [contains] &[char; N] [via] str [with] coerce);\nimpl_contains!([T: PartialEq] Vec<T> [contains] &T [via] [T]);\n\nimpl<F: FnMut(char) -> bool> Contains<F> for str {\n    fn contains(&self, f: F) -> bool {\n        <str>::contains(self, f)\n    }\n}\n\nimpl<F: FnMut(char) -> bool> Contains<F> for String {\n    fn contains(&self, f: F) -> bool {\n        <str>::contains(self, f)\n    }\n}\n\nimpl<T: PartialEq> Contains<T> for Vec<T> {\n    fn contains(&self, item: T) -> bool {\n        <[T]>::contains(self, &item)\n    }\n}\n\nimpl<I, T: Contains<I>> Contains<I> for Option<T> {\n    fn contains(&self, item: I) -> bool {\n        self.as_ref().map(|v| v.contains(item)).unwrap_or(false)\n    }\n}\n\nimpl<I, T: Contains<I>> Contains<I> for Result<'_, T> {\n    fn contains(&self, item: I) -> bool {\n        self.as_ref().map(|v| v.contains(item)).unwrap_or(false)\n    }\n}\n\nimpl<I, T: Contains<I> + ?Sized> Contains<I> for &T {\n    fn contains(&self, item: I) -> bool {\n        <T as Contains<I>>::contains(self, item)\n    }\n}\n\n/// Contains validator: succeeds when a value contains `item`.\n///\n/// This is the dual of [`omits()`]. The value must implement\n/// [`Contains<I>`](Contains) where `I` is the type of the `item`. See\n/// [`Contains`] for supported types and items.\n///\n/// On error, returns a validation error with the following message:\n///\n/// ```text\n/// value is equal to an invalid value\n/// ```\n///\n/// If the collection is empty, this validator fails.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     best_pet: Pet,\n///     #[field(validate = contains(Pet::Cat))]\n///     #[field(validate = contains(&self.best_pet))]\n///     pets: Vec<Pet>,\n///     #[field(validate = contains('/'))]\n///     #[field(validate = contains(&['/', ':']))]\n///     license: &'r str,\n///     #[field(validate = contains(\"@rust-lang.org\"))]\n///     #[field(validate = contains(|c: char| c.to_ascii_lowercase() == 's'))]\n///     rust_lang_email: &'r str,\n/// }\n/// ```\npub fn contains<'v, V, I>(value: V, item: I) -> Result<'v, ()>\n    where V: Contains<I>\n{\n    if !value.contains(item) {\n        Err(Error::validation(\"value does not contain expected item\"))?\n    }\n\n    Ok(())\n}\n\n/// Debug contains validator: like [`contains()`] but mentions `item` in the\n/// error message.\n///\n/// This is the dual of [`dbg_omits()`]. The is identical to [`contains()`]\n/// except that `item` must be `Debug + Copy` and the error message is as\n/// follows, where `$item` is the [`Debug`] representation of `item`:\n///\n/// ```text\n/// values must contains $item\n/// ```\n///\n/// If the collection is empty, this validator fails.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, Debug, Clone, Copy, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// #[derive(FromForm)]\n/// struct Foo {\n///     best_pet: Pet,\n///     #[field(validate = dbg_contains(Pet::Dog))]\n///     #[field(validate = dbg_contains(&self.best_pet))]\n///     pets: Vec<Pet>,\n/// }\n/// ```\npub fn dbg_contains<'v, V, I>(value: V, item: I) -> Result<'v, ()>\n    where V: Contains<I>, I: Debug + Copy\n{\n    if !value.contains(item) {\n        Err(Error::validation(format!(\"value must contain {:?}\", item)))?\n    }\n\n    Ok(())\n}\n\n/// Omits validator: succeeds when a value _does not_ contains `item`.\n/// error message.\n///\n/// This is the dual of [`contains()`]. The value must implement\n/// [`Contains<I>`](Contains) where `I` is the type of the `item`. See\n/// [`Contains`] for supported types and items.\n///\n/// On error, returns a validation error with the following message:\n///\n/// ```text\n/// value contains a disallowed item\n/// ```\n///\n/// If the collection is empty, this validator succeeds.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = omits(Pet::Cat))]\n///     pets: Vec<Pet>,\n///     #[field(validate = omits('@'))]\n///     not_email: &'r str,\n///     #[field(validate = omits(\"@gmail.com\"))]\n///     non_gmail_email: &'r str,\n/// }\n/// ```\npub fn omits<'v, V, I>(value: V, item: I) -> Result<'v, ()>\n    where V: Contains<I>\n{\n    if value.contains(item) {\n        Err(Error::validation(\"value contains a disallowed item\"))?\n    }\n\n    Ok(())\n}\n\n/// Debug omits validator: like [`omits()`] but mentions `item` in the error\n/// message.\n///\n/// This is the dual of [`dbg_contains()`]. The is identical to [`omits()`]\n/// except that `item` must be `Debug + Copy` and the error message is as\n/// follows, where `$item` is the [`Debug`] representation of `item`:\n///\n/// ```text\n/// value cannot contain $item\n/// ```\n///\n/// If the collection is empty, this validator succeeds.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, Debug, Clone, Copy, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = dbg_omits(Pet::Cat))]\n///     pets: Vec<Pet>,\n///     #[field(validate = dbg_omits('@'))]\n///     not_email: &'r str,\n///     #[field(validate = dbg_omits(\"@gmail.com\"))]\n///     non_gmail_email: &'r str,\n/// }\n/// ```\npub fn dbg_omits<'v, V, I>(value: V, item: I) -> Result<'v, ()>\n    where V: Contains<I>, I: Copy + Debug\n{\n    if value.contains(item) {\n        Err(Error::validation(format!(\"value cannot contain {:?}\", item)))?\n    }\n\n    Ok(())\n}\n\n/// Integer range validator: succeeds when an integer value is within a range.\n///\n/// The value must be an integer type that implement `TryInto<isize> + Copy`. On\n/// error, returns an [`OutOfRange`] error.\n///\n/// [`OutOfRange`]: crate::form::error::ErrorKind::OutOfRange\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::FromForm;\n///\n/// #[derive(FromForm)]\n/// struct Foo {\n///     #[field(validate = range(0..))]\n///     non_negative: isize,\n///     #[field(validate = range(18..=130))]\n///     maybe_adult: u8,\n/// }\n/// ```\npub fn range<'v, V, R>(value: &V, range: R) -> Result<'v, ()>\n    where V: TryInto<isize> + Copy, R: RangeBounds<isize>\n{\n    if let Ok(v) = (*value).try_into() {\n        if range.contains(&v) {\n            return Ok(());\n        }\n    }\n\n    let start = match range.start_bound() {\n        Bound::Included(v) => Some(*v),\n        Bound::Excluded(v) => Some(v.saturating_add(1)),\n        Bound::Unbounded => None\n    };\n\n    let end = match range.end_bound() {\n        Bound::Included(v) => Some(*v),\n        Bound::Excluded(v) => Some(v.saturating_sub(1)),\n        Bound::Unbounded => None,\n    };\n\n\n    Err((start, end))?\n}\n\n/// Contains one of validator: succeeds when a value contains at least one item\n/// in an `items` iterator.\n///\n/// The value must implement [`Contains<I>`](Contains) where `I` is the type of\n/// the `item`. The iterator must be [`Clone`]. See [`Contains`] for supported\n/// types and items. The item must be [`Debug`].\n///\n/// On error, returns a [`InvalidChoice`] error with the debug representation\n/// of each item in `items`.\n///\n/// [`InvalidChoice`]: crate::form::error::ErrorKind::InvalidChoice\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::FromForm;\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = one_of(&[3, 5, 7]))]\n///     single_digit_primes: Vec<u8>,\n///     #[field(validate = one_of(\" \\t\\n\".chars()))]\n///     has_space_char: &'r str,\n///     #[field(validate = one_of(\" \\t\\n\".chars()).and_then(msg!(\"no spaces\")))]\n///     no_space: &'r str,\n/// }\n/// ```\npub fn one_of<'v, V, I, R>(value: V, items: R) -> Result<'v, ()>\n    where V: Contains<I>,\n          I: Debug,\n          R: IntoIterator<Item = I>,\n          <R as IntoIterator>::IntoIter: Clone\n{\n    let items = items.into_iter();\n    for item in items.clone() {\n        if value.contains(item) {\n            return Ok(());\n        }\n    }\n\n    let choices: Vec<Cow<'_, str>> = items\n        .map(|item| format!(\"{:?}\", item).into())\n        .collect();\n\n    Err(choices)?\n}\n\n/// File type validator: succeeds when a [`TempFile`] has the Content-Type\n/// `content_type`.\n///\n/// On error, returns a validation error with one of the following messages:\n///\n/// ```text\n/// // the file has an incorrect extension\n/// file type was .$file_ext but must be $type\n///\n/// // the file does not have an extension\n/// file type must be $type\n/// ```\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::FromForm;\n/// use rocket::data::ToByteUnit;\n/// use rocket::http::ContentType;\n/// use rocket::fs::TempFile;\n///\n/// #[derive(FromForm)]\n/// struct Foo<'r> {\n///     #[field(validate = ext(ContentType::PDF))]\n///     #[field(validate = len(..1.mebibytes()))]\n///     document: TempFile<'r>,\n/// }\n/// ```\npub fn ext<'v>(file: &TempFile<'_>, r#type: ContentType) -> Result<'v, ()> {\n    if let Some(file_ct) = file.content_type() {\n        if file_ct == &r#type {\n            return Ok(());\n        }\n    }\n\n    let msg = match (file.content_type().and_then(|c| c.extension()), r#type.extension()) {\n        (Some(a), Some(b)) => format!(\"invalid file type: .{}, must be .{}\", a, b),\n        (Some(a), None) => format!(\"invalid file type: .{}, must be {}\", a, r#type),\n        (None, Some(b)) => format!(\"file type must be .{}\", b),\n        (None, None) => format!(\"file type must be {}\", r#type),\n    };\n\n    Err(Error::validation(msg))?\n}\n\n/// With validator: succeeds when an arbitrary function or closure does.\n///\n/// This is the most generic validator and, for readability, should only be used\n/// when a more case-specific option does not exist. It succeeds exactly when\n/// `f` returns `true` and fails otherwise.\n///\n/// On error, returns a validation error with the message `msg`.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::form::{FromForm, FromFormField};\n///\n/// #[derive(PartialEq, FromFormField)]\n/// enum Pet { Cat, Dog }\n///\n/// fn is_dog(p: &Pet) -> bool {\n///     matches!(p, Pet::Dog)\n/// }\n///\n/// #[derive(FromForm)]\n/// struct Foo {\n///     // These are equivalent. Prefer the former.\n///     #[field(validate = contains(Pet::Dog))]\n///     #[field(validate = with(|pets| pets.iter().any(|p| *p == Pet::Dog), \"missing dog\"))]\n///     pets: Vec<Pet>,\n///     // These are equivalent. Prefer the former.\n///     #[field(validate = eq(Pet::Dog))]\n///     #[field(validate = with(|p| matches!(p, Pet::Dog), \"expected a dog\"))]\n///     #[field(validate = with(|p| is_dog(p), \"expected a dog\"))]\n///   # #[field(validate = with(|p| is_dog(&self.dog), \"expected a dog\"))]\n///     #[field(validate = with(is_dog, \"expected a dog\"))]\n///     dog: Pet,\n///     // These are equivalent. Prefer the former.\n///     #[field(validate = contains(&self.dog))]\n///   # #[field(validate = with(|p| is_dog(&self.dog), \"expected a dog\"))]\n///     #[field(validate = with(|pets| pets.iter().any(|p| p == &self.dog), \"missing dog\"))]\n///     one_dog_please: Vec<Pet>,\n/// }\n/// ```\npub fn with<'v, V, F, M>(value: V, f: F, msg: M) -> Result<'v, ()>\n    where F: FnOnce(V) -> bool,\n          M: Into<Cow<'static, str>>\n{\n    if !f(value) {\n        Err(Error::validation(msg.into()))?\n    }\n\n    Ok(())\n}\n\n/// _Try_ With validator: succeeds when an arbitrary function or closure does.\n///\n/// Along with [`with`], this is the most generic validator. It succeeds\n/// exactly when `f` returns `Ok` and fails otherwise.\n///\n/// On error, returns a validation error with the message in the `Err`\n/// variant converted into a string.\n///\n/// # Example\n///\n/// Assuming `Token` has a `from_str` method:\n///\n/// ```rust\n/// # use rocket::form::FromForm;\n/// # impl FromStr for Token<'_> {\n/// #     type Err = &'static str;\n/// #     fn from_str(s: &str) -> Result<Self, Self::Err> { todo!() }\n/// # }\n/// use std::str::FromStr;\n///\n/// #[derive(FromForm)]\n/// #[field(validate = try_with(|s| Token::from_str(s)))]\n/// struct Token<'r>(&'r str);\n///\n/// #[derive(FromForm)]\n/// #[field(validate = try_with(|s| s.parse::<Token>()))]\n/// struct Token2<'r>(&'r str);\n/// ```\npub fn try_with<'v, V, F, T, E>(value: V, f: F) -> Result<'v, ()>\n    where F: FnOnce(V) -> std::result::Result<T, E>,\n          E: std::fmt::Display\n{\n    match f(value) {\n        Ok(_) => Ok(()),\n        Err(e) => Err(Error::validation(e.to_string()).into())\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use ref_cast::RefCast;\n\nuse crate::http::RawStr;\n\n/// A file name in a [`TempFile`] or multipart [`DataField`].\n///\n/// A `Content-Disposition` header, either in a response or a multipart field,\n/// can optionally specify a `filename` directive as identifying information for\n/// the attached file. This type represents the value of that directive.\n///\n/// # Safety\n///\n/// There are no restrictions on the value of the directive. In particular, the\n/// value can be wholly unsafe to use as a file name in common contexts. As\n/// such, Rocket sanitizes the value into a version that _is_ safe to use as a\n/// file name in common contexts; this sanitized version can be retrieved via\n/// [`FileName::as_str()`] and is returned by [`TempFile::name()`].\n///\n/// You will likely want to prepend or append random or user-specific components\n/// to the name to avoid collisions; UUIDs make for a good \"random\" data. You\n/// may also prefer to avoid the value in the directive entirely by using a\n/// safe, application-generated name instead.\n///\n/// [`TempFile::name()`]: crate::fs::TempFile::name\n/// [`DataField`]: crate::form::DataField\n/// [`TempFile`]: crate::fs::TempFile\n#[repr(transparent)]\n#[derive(RefCast, Debug)]\npub struct FileName(str);\n\nimpl FileName {\n    /// Wraps a string as a `FileName`. This is cost-free.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::FileName;\n    ///\n    /// let name = FileName::new(\"some-file.txt\");\n    /// assert_eq!(name.as_str(), Some(\"some-file\"));\n    ///\n    /// let name = FileName::new(\"some-file.txt\");\n    /// assert_eq!(name.dangerous_unsafe_unsanitized_raw(), \"some-file.txt\");\n    /// ```\n    pub fn new<S: AsRef<str> + ?Sized>(string: &S) -> &FileName {\n        FileName::ref_cast(string.as_ref())\n    }\n\n    /// The sanitized file name, stripped of any file extension and special\n    /// characters, safe for use as a file name.\n    ///\n    /// # Sanitization\n    ///\n    /// A \"sanitized\" file name is a non-empty string, stripped of its file\n    /// extension, which is not a platform-specific reserved name and does not\n    /// contain any platform-specific special characters.\n    ///\n    /// On Unix, these are the characters `'.', '/', '\\\\', '<', '>', '|', ':',\n    /// '(', ')', '&', ';', '#', '?', '*'`.\n    ///\n    /// On Windows (and non-Unix OSs), these are the characters `'.', '<', '>',\n    /// ':', '\"', '/', '\\', '|', '?', '*', ',', ';', '=', '(', ')', '&', '#'`,\n    /// and the reserved names `\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\",\n    /// \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\",\n    /// \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\"`.\n    ///\n    /// Additionally, all control characters are considered \"special\".\n    ///\n    /// An attempt is made to transform the raw file name into a sanitized\n    /// version by identifying a valid substring of the raw file name that meets\n    /// this criteria. If none is found, `None` is returned.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::FileName;\n    ///\n    /// let name = FileName::new(\"some-file.txt\");\n    /// assert_eq!(name.as_str(), Some(\"some-file\"));\n    ///\n    /// let name = FileName::new(\"some-file.txt.zip\");\n    /// assert_eq!(name.as_str(), Some(\"some-file\"));\n    ///\n    /// let name = FileName::new(\"../../../../etc/shadow\");\n    /// assert_eq!(name.as_str(), Some(\"shadow\"));\n    ///\n    /// let name = FileName::new(\"/etc/.shadow\");\n    /// assert_eq!(name.as_str(), Some(\"shadow\"));\n    ///\n    /// let name = FileName::new(\"/a/b/some/file.txt.zip\");\n    /// assert_eq!(name.as_str(), Some(\"file\"));\n    ///\n    /// let name = FileName::new(\"/a/b/some/.file.txt.zip\");\n    /// assert_eq!(name.as_str(), Some(\"file\"));\n    ///\n    /// let name = FileName::new(\"/a/b/some/.*file.txt.zip\");\n    /// assert_eq!(name.as_str(), Some(\"file\"));\n    ///\n    /// let name = FileName::new(\"a/\\\\b/some/.*file<.txt.zip\");\n    /// assert_eq!(name.as_str(), Some(\"file\"));\n    ///\n    /// let name = FileName::new(\">>>.foo.txt\");\n    /// assert_eq!(name.as_str(), Some(\"foo\"));\n    ///\n    /// let name = FileName::new(\"b:c\");\n    /// #[cfg(unix)] assert_eq!(name.as_str(), Some(\"b\"));\n    /// #[cfg(not(unix))] assert_eq!(name.as_str(), Some(\"c\"));\n    ///\n    /// let name = FileName::new(\"//./.<>\");\n    /// assert_eq!(name.as_str(), None);\n    /// ```\n    pub fn as_str(&self) -> Option<&str> {\n        #[cfg(not(unix))]\n        let (bad_char, bad_name) = {\n            static BAD_CHARS: &[char] = &[\n                // Microsoft says these are invalid.\n                '.', '<', '>', ':', '\"', '/', '\\\\', '|', '?', '*',\n\n                // `cmd.exe` treats these specially.\n                ',', ';', '=',\n\n                // These are treated specially by unix-like shells.\n                '(', ')', '&', '#',\n            ];\n\n            // Microsoft says these are reserved.\n            static BAD_NAMES: &[&str] = &[\n                \"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\", \"COM2\", \"COM3\", \"COM4\",\n                \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\", \"LPT1\", \"LPT2\",\n                \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\",\n            ];\n\n            let bad_char = |c| BAD_CHARS.contains(&c) || c.is_control();\n            let bad_name = |n| BAD_NAMES.contains(&n);\n            (bad_char, bad_name)\n        };\n\n        #[cfg(unix)]\n        let (bad_char, bad_name) = {\n            static BAD_CHARS: &[char] = &[\n                // These have special meaning in a file name.\n                '.', '/', '\\\\',\n\n                // These are treated specially by shells.\n                '<', '>', '|', ':', '(', ')', '&', ';', '#', '?', '*',\n            ];\n\n            let bad_char = |c| BAD_CHARS.contains(&c) || c.is_control();\n            let bad_name = |_| false;\n            (bad_char, bad_name)\n        };\n\n        // Get the file name as a `str` without any extension(s).\n        let file_name = std::path::Path::new(&self.0)\n            .file_name()\n            .and_then(|n| n.to_str())\n            .and_then(|n| n.split(bad_char).find(|s| !s.is_empty()))?;\n\n        // At this point, `file_name` can't contain `bad_chars` because of\n        // `.split()`, but it can be empty or reserved.\n        if file_name.is_empty() || bad_name(file_name) {\n            return None;\n        }\n\n        Some(file_name)\n    }\n\n    /// Returns `true` if the _complete_ raw file name is safe.\n    ///\n    /// Note that `.as_str()` returns a safe _subset_ of the raw file name, if\n    /// there is one. If this method returns `true`, then that subset is the\n    /// complete raw file name.\n    ///\n    /// This method should be use sparingly. In particular, there is no\n    /// advantage to calling `is_safe()` prior to calling `as_str()`; simply\n    /// call `as_str()`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::FileName;\n    ///\n    /// let name = FileName::new(\"some-file.txt\");\n    /// assert_eq!(name.as_str(), Some(\"some-file\"));\n    /// assert!(!name.is_safe());\n    ///\n    /// let name = FileName::new(\"some-file\");\n    /// assert_eq!(name.as_str(), Some(\"some-file\"));\n    /// assert!(name.is_safe());\n    /// ```\n    pub fn is_safe(&self) -> bool {\n        self.as_str().map_or(false, |s| s == &self.0)\n    }\n\n    /// The raw, unsanitized, potentially unsafe file name. Prefer to use\n    /// [`FileName::as_str()`], always.\n    ///\n    /// #  DANGER \n    ///\n    /// This method returns the file name exactly as it was specified by the\n    /// client. You should **_not_** use this name _unless_ you require the\n    /// originally specified `filename` _and_ it is known not to contain\n    /// special, potentially dangerous characters, _and_:\n    ///\n    ///   1. All clients are known to be trusted, perhaps because the server\n    ///      only runs locally, serving known, local requests, or...\n    ///\n    ///   2. You will not use the file name to store a file on disk or any\n    ///      context that expects a file name _and_ you will not use the\n    ///      extension to determine how to handle/parse the data, or...\n    ///\n    ///   3. You will expertly process the raw name into a sanitized version for\n    ///      use in specific contexts.\n    ///\n    /// If not all of these cases apply, use [`FileName::as_str()`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::FileName;\n    ///\n    /// let name = FileName::new(\"some-file.txt\");\n    /// assert_eq!(name.dangerous_unsafe_unsanitized_raw(), \"some-file.txt\");\n    ///\n    /// let name = FileName::new(\"../../../../etc/shadow\");\n    /// assert_eq!(name.dangerous_unsafe_unsanitized_raw(), \"../../../../etc/shadow\");\n    ///\n    /// let name = FileName::new(\"../../.ssh/id_rsa\");\n    /// assert_eq!(name.dangerous_unsafe_unsanitized_raw(), \"../../.ssh/id_rsa\");\n    ///\n    /// let name = FileName::new(\"/Rocket.toml\");\n    /// assert_eq!(name.dangerous_unsafe_unsanitized_raw(), \"/Rocket.toml\");\n    /// ```\n    pub fn dangerous_unsafe_unsanitized_raw(&self) -> &RawStr {\n        self.0.into()\n    }\n}\n\nimpl<'a, S: AsRef<str> + ?Sized> From<&'a S> for &'a FileName {\n    #[inline]\n    fn from(string: &'a S) -> Self {\n        FileName::new(string)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! File serving, file accepting, and file metadata types.\n\nmod server;\nmod named_file;\nmod temp_file;\nmod file_name;\n\npub use server::*;\npub use named_file::*;\npub use temp_file::*;\npub use file_name::*;\npub use server::relative;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::io;\nuse std::path::{Path, PathBuf};\nuse std::ops::{Deref, DerefMut};\n\nuse tokio::fs::File;\n\nuse crate::request::Request;\nuse crate::response::{self, Responder};\nuse crate::http::ContentType;\n\n/// A [`Responder`] that sends file data with a Content-Type based on its\n/// file extension.\n///\n/// # Example\n///\n/// A simple static file server mimicking [`FileServer`]:\n///\n/// ```rust\n/// # use rocket::get;\n/// use std::path::{PathBuf, Path};\n///\n/// use rocket::fs::{NamedFile, relative};\n///\n/// #[get(\"/file/<path..>\")]\n/// pub async fn second(path: PathBuf) -> Option<NamedFile> {\n///     let mut path = Path::new(relative!(\"static\")).join(path);\n///     if path.is_dir() {\n///         path.push(\"index.html\");\n///     }\n///\n///     NamedFile::open(path).await.ok()\n/// }\n/// ```\n///\n/// Always prefer to use [`FileServer`] which has more functionality and a\n/// pithier API.\n///\n/// [`FileServer`]: crate::fs::FileServer\n#[derive(Debug)]\npub struct NamedFile(PathBuf, File);\n\nimpl NamedFile {\n    /// Attempts to open a file in read-only mode.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if path does not already exist. Other\n    /// errors may also be returned according to\n    /// [`OpenOptions::open()`](std::fs::OpenOptions::open()).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::get;\n    /// use rocket::fs::NamedFile;\n    ///\n    /// #[get(\"/\")]\n    /// async fn index() -> Option<NamedFile> {\n    ///     NamedFile::open(\"index.html\").await.ok()\n    /// }\n    /// ```\n    pub async fn open<P: AsRef<Path>>(path: P) -> io::Result<NamedFile> {\n        // FIXME: Grab the file size here and prohibit `seek`ing later (or else\n        // the file's effective size may change), to save on the cost of doing\n        // all of those `seek`s to determine the file size. But, what happens if\n        // the file gets changed between now and then?\n        let file = File::open(path.as_ref()).await?;\n        Ok(NamedFile(path.as_ref().to_path_buf(), file))\n    }\n\n    /// Retrieve the underlying `File`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::NamedFile;\n    ///\n    /// # async fn f() -> std::io::Result<()> {\n    /// let named_file = NamedFile::open(\"index.html\").await?;\n    /// let file = named_file.file();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn file(&self) -> &File {\n        &self.1\n    }\n\n    /// Retrieve a mutable borrow to the underlying `File`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::NamedFile;\n    ///\n    /// # async fn f() -> std::io::Result<()> {\n    /// let mut named_file = NamedFile::open(\"index.html\").await?;\n    /// let file = named_file.file_mut();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn file_mut(&mut self) -> &mut File {\n        &mut self.1\n    }\n\n    /// Take the underlying `File`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::NamedFile;\n    ///\n    /// # async fn f() -> std::io::Result<()> {\n    /// let named_file = NamedFile::open(\"index.html\").await?;\n    /// let file = named_file.take_file();\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn take_file(self) -> File {\n        self.1\n    }\n\n    /// Retrieve the path of this file.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use rocket::fs::NamedFile;\n    ///\n    /// # async fn demo_path() -> std::io::Result<()> {\n    /// let file = NamedFile::open(\"foo.txt\").await?;\n    /// assert_eq!(file.path().as_os_str(), \"foo.txt\");\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub fn path(&self) -> &Path {\n        self.0.as_path()\n    }\n}\n\n/// Streams the named file to the client. Sets or overrides the Content-Type in\n/// the response according to the file's extension if the extension is\n/// recognized. See [`ContentType::from_extension()`] for more information. If\n/// you would like to stream a file with a different Content-Type than that\n/// implied by its extension, use a [`File`] directly.\nimpl<'r> Responder<'r, 'static> for NamedFile {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        let mut response = self.1.respond_to(req)?;\n        if let Some(ext) = self.0.extension() {\n            if let Some(ct) = ContentType::from_extension(&ext.to_string_lossy()) {\n                response.set_header(ct);\n            }\n        }\n\n        Ok(response)\n    }\n}\n\nimpl Deref for NamedFile {\n    type Target = File;\n\n    fn deref(&self) -> &File {\n        &self.1\n    }\n}\n\nimpl DerefMut for NamedFile {\n    fn deref_mut(&mut self) -> &mut File {\n        &mut self.1\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::path::{PathBuf, Path};\n\nuse crate::{Request, Data};\nuse crate::http::{Method, Status, uri::Segments, ext::IntoOwned};\nuse crate::route::{Route, Handler, Outcome};\nuse crate::response::{Redirect, Responder};\nuse crate::outcome::IntoOutcome;\nuse crate::fs::NamedFile;\n\n/// Custom handler for serving static files.\n///\n/// This handler makes it simple to serve static files from a directory on the\n/// local file system. To use it, construct a `FileServer` using either\n/// [`FileServer::from()`] or [`FileServer::new()`] then simply `mount` the\n/// handler at a desired path. When mounted, the handler will generate route(s)\n/// that serve the desired static files. If a requested file is not found, the\n/// routes _forward_ the incoming request. The default rank of the generated\n/// routes is `10`. To customize route ranking, use the [`FileServer::rank()`]\n/// method.\n///\n/// # Options\n///\n/// The handler's functionality can be customized by passing an [`Options`] to\n/// [`FileServer::new()`].\n///\n/// # Example\n///\n/// To serve files from the `/static` directory on the local file system at the\n/// `/public` path, allowing `index.html` files to be used to respond to\n/// requests for a directory (the default), you might write the following:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::FileServer;\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/public\", FileServer::from(\"/static\"))\n/// }\n/// ```\n///\n/// With this, requests for files at `/public/<path..>` will be handled by\n/// returning the contents of `/static/<path..>`. Requests for _directories_ at\n/// `/public/<directory>` will be handled by returning the contents of\n/// `/static/<directory>/index.html`.\n///\n/// ## Relative Paths\n///\n/// In the example above, `/static` is an absolute path. If your static files\n/// are stored relative to your crate and your project is managed by Rocket, use\n/// the [`relative!`] macro to obtain a path that is relative to your\n/// crate's root. For example, to serve files in the `static` subdirectory of\n/// your crate at `/`, you might write:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::{FileServer, relative};\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", FileServer::from(relative!(\"static\")))\n/// }\n/// ```\n#[derive(Debug, Clone)]\npub struct FileServer {\n    root: PathBuf,\n    options: Options,\n    rank: isize,\n}\n\nimpl FileServer {\n    /// The default rank use by `FileServer` routes.\n    const DEFAULT_RANK: isize = 10;\n\n    /// Constructs a new `FileServer` that serves files from the file system\n    /// `path`. By default, [`Options::Index`] is set, and the generated routes\n    /// have a rank of `10`. To serve static files with other options, use\n    /// [`FileServer::new()`]. To choose a different rank for generated routes,\n    /// use [`FileServer::rank()`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `path` does not exist or is not a directory.\n    ///\n    /// # Example\n    ///\n    /// Serve the static files in the `/www/public` local directory on path\n    /// `/static`.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::FileServer;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().mount(\"/static\", FileServer::from(\"/www/public\"))\n    /// }\n    /// ```\n    ///\n    /// Exactly as before, but set the rank for generated routes to `30`.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::FileServer;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().mount(\"/static\", FileServer::from(\"/www/public\").rank(30))\n    /// }\n    /// ```\n    #[track_caller]\n    pub fn from<P: AsRef<Path>>(path: P) -> Self {\n        FileServer::new(path, Options::default())\n    }\n\n    /// Constructs a new `FileServer` that serves files from the file system\n    /// `path` with `options` enabled. By default, the handler's routes have a\n    /// rank of `10`. To choose a different rank, use [`FileServer::rank()`].\n    ///\n    /// # Panics\n    ///\n    /// If [`Options::Missing`] is not set, panics if `path` does not exist or\n    /// is not a directory. Otherwise does not panic.\n    ///\n    /// # Example\n    ///\n    /// Serve the static files in the `/www/public` local directory on path\n    /// `/static` without serving index files or dot files. Additionally, serve\n    /// the same files on `/pub` with a route rank of -1 while also serving\n    /// index files and dot files.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, Options};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let options = Options::Index | Options::DotFiles;\n    ///     rocket::build()\n    ///         .mount(\"/static\", FileServer::from(\"/www/public\"))\n    ///         .mount(\"/pub\", FileServer::new(\"/www/public\", options).rank(-1))\n    /// }\n    /// ```\n    #[track_caller]\n    pub fn new<P: AsRef<Path>>(path: P, options: Options) -> Self {\n        use crate::yansi::Paint;\n\n        let path = path.as_ref();\n        if !options.contains(Options::Missing) {\n            if !options.contains(Options::IndexFile) && !path.is_dir() {\n                let path = path.display();\n                error!(\"FileServer path '{}' is not a directory.\", path.primary());\n                warn_!(\"Aborting early to prevent inevitable handler error.\");\n                panic!(\"invalid directory: refusing to continue\");\n            } else if !path.exists() {\n                let path = path.display();\n                error!(\"FileServer path '{}' is not a file.\", path.primary());\n                warn_!(\"Aborting early to prevent inevitable handler error.\");\n                panic!(\"invalid file: refusing to continue\");\n            }\n        }\n\n        FileServer { root: path.into(), options, rank: Self::DEFAULT_RANK }\n    }\n\n    /// Sets the rank for generated routes to `rank`.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// use rocket::fs::{FileServer, Options};\n    ///\n    /// // A `FileServer` created with `from()` with routes of rank `3`.\n    /// FileServer::from(\"/public\").rank(3);\n    ///\n    /// // A `FileServer` created with `new()` with routes of rank `-15`.\n    /// FileServer::new(\"/public\", Options::Index).rank(-15);\n    /// ```\n    pub fn rank(mut self, rank: isize) -> Self {\n        self.rank = rank;\n        self\n    }\n}\n\nimpl From<FileServer> for Vec<Route> {\n    fn from(server: FileServer) -> Self {\n        let source = figment::Source::File(server.root.clone());\n        let mut route = Route::ranked(server.rank, Method::Get, \"/<path..>\", server);\n        route.name = Some(format!(\"FileServer: {}\", source).into());\n        vec![route]\n    }\n}\n\n#[crate::async_trait]\nimpl Handler for FileServer {\n    async fn handle<'r>(&self, req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r> {\n        use crate::http::uri::fmt::Path;\n\n        // TODO: Should we reject dotfiles for `self.root` if !DotFiles?\n        let options = self.options;\n        if options.contains(Options::IndexFile) && self.root.is_file() {\n            let segments = match req.segments::<Segments<'_, Path>>(0..) {\n                Ok(segments) => segments,\n                Err(never) => match never {},\n            };\n\n            if segments.is_empty() {\n                let file = NamedFile::open(&self.root).await;\n                return file.respond_to(req).or_forward((data, Status::NotFound));\n            } else {\n                return Outcome::forward(data, Status::NotFound);\n            }\n        }\n\n        // Get the segments as a `PathBuf`, allowing dotfiles requested.\n        let allow_dotfiles = options.contains(Options::DotFiles);\n        let path = req.segments::<Segments<'_, Path>>(0..).ok()\n            .and_then(|segments| segments.to_path_buf(allow_dotfiles).ok())\n            .map(|path| self.root.join(path));\n\n        match path {\n            Some(p) if p.is_dir() => {\n                // Normalize '/a/b/foo' to '/a/b/foo/'.\n                if options.contains(Options::NormalizeDirs) && !req.uri().path().ends_with('/') {\n                    let normal = req.uri().map_path(|p| format!(\"{}/\", p))\n                        .expect(\"adding a trailing slash to a known good path => valid path\")\n                        .into_owned();\n\n                    return Redirect::permanent(normal)\n                        .respond_to(req)\n                        .or_forward((data, Status::InternalServerError));\n                }\n\n                if !options.contains(Options::Index) {\n                    return Outcome::forward(data, Status::NotFound);\n                }\n\n                let index = NamedFile::open(p.join(\"index.html\")).await;\n                index.respond_to(req).or_forward((data, Status::NotFound))\n            },\n            Some(p) => {\n                let file = NamedFile::open(p).await;\n                file.respond_to(req).or_forward((data, Status::NotFound))\n            }\n            None => Outcome::forward(data, Status::NotFound),\n        }\n    }\n}\n\n/// A bitset representing configurable options for [`FileServer`].\n///\n/// The valid options are:\n///\n///   * [`Options::None`] - Return only present, visible files.\n///   * [`Options::DotFiles`] - In addition to visible files, return dotfiles.\n///   * [`Options::Index`] - Render `index.html` pages for directory requests.\n///   * [`Options::IndexFile`] - Allow serving a single file as the index.\n///   * [`Options::Missing`] - Don't fail if the path to serve is missing.\n///   * [`Options::NormalizeDirs`] - Redirect directories without a trailing\n///     slash to ones with a trailing slash.\n///\n/// `Options` structures can be `or`d together to select two or more options.\n/// For instance, to request that both dot files and index pages be returned,\n/// use `Options::DotFiles | Options::Index`.\n#[derive(Debug, Clone, Copy)]\npub struct Options(u8);\n\n#[allow(non_upper_case_globals, non_snake_case)]\nimpl Options {\n    /// All options disabled.\n    ///\n    /// This is different than [`Options::default()`](#impl-Default), which\n    /// enables `Options::Index`.\n    pub const None: Options = Options(0);\n\n    /// Respond to requests for a directory with the `index.html` file in that\n    /// directory, if it exists.\n    ///\n    /// When enabled, [`FileServer`] will respond to requests for a directory\n    /// `/foo` or `/foo/` with the file at `${root}/foo/index.html` if it\n    /// exists. When disabled, requests to directories will always forward.\n    ///\n    /// **Enabled by default.**\n    pub const Index: Options = Options(1 << 0);\n\n    /// Allow serving dotfiles.\n    ///\n    /// When enabled, [`FileServer`] will respond to requests for files or\n    /// directories beginning with `.`. When disabled, any dotfiles will be\n    /// treated as missing.\n    ///\n    /// **Disabled by default.**\n    pub const DotFiles: Options = Options(1 << 1);\n\n    /// Normalizes directory requests by redirecting requests to directory paths\n    /// without a trailing slash to ones with a trailing slash.\n    ///\n    /// When enabled, the [`FileServer`] handler will respond to requests for a\n    /// directory without a trailing `/` with a permanent redirect (308) to the\n    /// same path with a trailing `/`. This ensures relative URLs within any\n    /// document served from that directory will be interpreted relative to that\n    /// directory rather than its parent.\n    ///\n    /// **Disabled by default.**\n    ///\n    /// # Example\n    ///\n    /// Given the following directory structure...\n    ///\n    /// ```text\n    /// static/\n    ///  foo/\n    ///      cat.jpeg\n    ///      index.html\n    /// ```\n    ///\n    /// ...with `FileServer::from(\"static\")`, both requests to `/foo` and\n    /// `/foo/` will serve `static/foo/index.html`. If `index.html` references\n    /// `cat.jpeg` as a relative URL, the browser will request `/cat.jpeg`\n    /// (`static/cat.jpeg`) when the request for `/foo` was handled and\n    /// `/foo/cat.jpeg` (`static/foo/cat.jpeg`) if `/foo/` was handled. As a\n    /// result, the request in the former case will fail. To avoid this,\n    /// `NormalizeDirs` will redirect requests to `/foo` to `/foo/` if the file\n    /// that would be served is a directory.\n    pub const NormalizeDirs: Options = Options(1 << 2);\n\n    /// Allow serving a file instead of a directory.\n    ///\n    /// By default, `FileServer` will error on construction if the path to serve\n    /// does not point to a directory. When this option is enabled, if a path to\n    /// a file is provided, `FileServer` will serve the file as the root of the\n    /// mount path.\n    ///\n    /// # Example\n    ///\n    /// If the file tree looks like:\n    ///\n    /// ```text\n    /// static/\n    ///  cat.jpeg\n    /// ```\n    ///\n    /// Then `cat.jpeg` can be served at `/cat` with:\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, Options};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .mount(\"/cat\", FileServer::new(\"static/cat.jpeg\", Options::IndexFile))\n    /// }\n    /// ```\n    pub const IndexFile: Options = Options(1 << 3);\n\n    /// Don't fail if the file or directory to serve is missing.\n    ///\n    /// By default, `FileServer` will error if the path to serve is missing to\n    /// prevent inevitable 404 errors. This option overrides that.\n    pub const Missing: Options = Options(1 << 4);\n\n    /// Returns `true` if `self` is a superset of `other`. In other words,\n    /// returns `true` if all of the options in `other` are also in `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::fs::Options;\n    ///\n    /// let index_request = Options::Index | Options::DotFiles;\n    /// assert!(index_request.contains(Options::Index));\n    /// assert!(index_request.contains(Options::DotFiles));\n    ///\n    /// let index_only = Options::Index;\n    /// assert!(index_only.contains(Options::Index));\n    /// assert!(!index_only.contains(Options::DotFiles));\n    ///\n    /// let dot_only = Options::DotFiles;\n    /// assert!(dot_only.contains(Options::DotFiles));\n    /// assert!(!dot_only.contains(Options::Index));\n    /// ```\n    #[inline]\n    pub fn contains(self, other: Options) -> bool {\n        (other.0 & self.0) == other.0\n    }\n}\n\n/// The default set of options: `Options::Index`.\nimpl Default for Options {\n    fn default() -> Self {\n        Options::Index\n    }\n}\n\nimpl std::ops::BitOr for Options {\n    type Output = Self;\n\n    #[inline(always)]\n    fn bitor(self, rhs: Self) -> Self {\n        Options(self.0 | rhs.0)\n    }\n}\n\ncrate::export! {\n    /// Generates a crate-relative version of a path.\n    ///\n    /// This macro is primarily intended for use with [`FileServer`] to serve\n    /// files from a path relative to the crate root.\n    ///\n    /// The macro accepts one parameter, `$path`, an absolute or (preferably)\n    /// relative path. It returns a path as an `&'static str` prefixed with the\n    /// path to the crate root. Use `Path::new(relative!($path))` to retrieve an\n    /// `&'static Path`.\n    ///\n    /// # Example\n    ///\n    /// Serve files from the crate-relative `static/` directory:\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, relative};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build().mount(\"/\", FileServer::from(relative!(\"static\")))\n    /// }\n    /// ```\n    ///\n    /// Path equivalences:\n    ///\n    /// ```rust\n    /// use std::path::Path;\n    ///\n    /// use rocket::fs::relative;\n    ///\n    /// let manual = Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"static\");\n    /// let automatic_1 = Path::new(relative!(\"static\"));\n    /// let automatic_2 = Path::new(relative!(\"/static\"));\n    /// assert_eq!(manual, automatic_1);\n    /// assert_eq!(automatic_1, automatic_2);\n    /// ```\n    ///\n    macro_rules! relative {\n        ($path:expr) => {\n            if cfg!(windows) {\n                concat!(env!(\"CARGO_MANIFEST_DIR\"), \"\\\\\", $path)\n            } else {\n                concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/\", $path)\n            }\n        };\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{io, mem};\nuse std::path::{PathBuf, Path};\n\nuse crate::Request;\nuse crate::http::{ContentType, Status};\nuse crate::data::{self, FromData, Data, Capped, N, Limits};\nuse crate::form::{FromFormField, ValueField, DataField, error::Errors};\nuse crate::outcome::IntoOutcome;\nuse crate::fs::FileName;\n\nuse tokio::task;\nuse tokio::fs::{self, File};\nuse tokio::io::{AsyncBufRead, BufReader};\nuse tempfile::{NamedTempFile, TempPath};\nuse either::Either;\n\n/// A data and form guard that streams data into a temporary file.\n///\n/// `TempFile` is a data and form field (both value and data fields) guard that\n/// streams incoming data into file in a temporary location. The file is deleted\n/// when the `TempFile` handle is dropped unless it is persisted with\n/// [`TempFile::persist_to()`] or copied with [`TempFile::copy_to()`].\n///\n/// # Hazards\n///\n/// Temporary files are cleaned by system file cleaners periodically. While an\n/// attempt is made not to delete temporary files in use, _detection_ of when a\n/// temporary file is being used is unreliable. As a result, a time-of-check to\n/// time-of-use race condition from the creation of a `TempFile` to the\n/// persistence of the `TempFile` may occur. Specifically, the following\n/// sequence may occur:\n///\n/// 1. A `TempFile` is created at random path `foo`.\n/// 2. The system cleaner removes the file at path `foo`.\n/// 3. Another application creates a file at path `foo`.\n/// 4. The `TempFile`, ostensibly at path `foo`, is persisted unexpectedly\n///    with contents different from those in step 1.\n///\n/// To safe-guard against this issue, you should ensure that your temporary file\n/// cleaner, if any, does not delete files too eagerly.\n///\n/// # Configuration\n///\n/// `TempFile` is configured via the following [`config`](crate::config)\n/// parameters:\n///\n/// | Name               | Default             | Description                             |\n/// |--------------------|---------------------|-----------------------------------------|\n/// | `temp_dir`         | [`env::temp_dir()`] | Directory for temporary file storage.   |\n/// | `limits.file`      | 1MiB                | Default limit for all file extensions.  |\n/// | `limits.file/$ext` | _N/A_               | Limit for files with extension `$ext`.  |\n///\n/// [`env::temp_dir()`]: std::env::temp_dir()\n///\n/// When used as a form guard, the extension `$ext` is identified by the form\n/// field's `Content-Type` ([`ContentType::extension()`]). When used as a data\n/// guard, the extension is identified by the Content-Type of the request, if\n/// any. If there is no Content-Type, the limit `file` is used.\n///\n/// # Cappable\n///\n/// A data stream can be partially read into a `TempFile` even if the incoming\n/// stream exceeds the data limit via the [`Capped<TempFile>`] data and form\n/// guard.\n///\n/// # Examples\n///\n/// **Data Guard**\n///\n/// ```rust\n/// # use rocket::post;\n/// use rocket::fs::TempFile;\n///\n/// #[post(\"/upload\", data = \"<file>\")]\n/// async fn upload(mut file: TempFile<'_>) -> std::io::Result<()> {\n///     file.persist_to(\"/tmp/complete/file.txt\").await?;\n///     Ok(())\n/// }\n/// ```\n///\n/// **Form Field**\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::TempFile;\n/// use rocket::form::Form;\n///\n/// #[derive(FromForm)]\n/// struct Upload<'f> {\n///     upload: TempFile<'f>\n/// }\n///\n/// #[post(\"/form\", data = \"<form>\")]\n/// async fn upload(mut form: Form<Upload<'_>>) -> std::io::Result<()> {\n///     form.upload.persist_to(\"/tmp/complete/file.txt\").await?;\n///     Ok(())\n/// }\n/// ```\n///\n/// See also the [`Capped`] documentation for an example of `Capped<TempFile>`\n/// as a data guard.\n#[derive(Debug)]\npub enum TempFile<'v> {\n    #[doc(hidden)]\n    File {\n        file_name: Option<&'v FileName>,\n        content_type: Option<ContentType>,\n        path: Either<TempPath, PathBuf>,\n        len: u64,\n    },\n    #[doc(hidden)]\n    Buffered {\n        content: &'v [u8],\n    }\n}\n\nimpl<'v> TempFile<'v> {\n    /// Persists the temporary file, moving it to `path`. If a file exists at\n    /// the target path, `self` will atomically replace it. `self.path()` is\n    /// updated to `path`.\n    ///\n    /// This method _does not_ create a copy of `self`, nor a new link to the\n    /// contents of `self`: it renames the temporary file to `path` and marks it\n    /// as non-temporary. As a result, this method _cannot_ be used to create\n    /// multiple copies of `self`. To create multiple links, use\n    /// [`std::fs::hard_link()`] with `path` as the `src` _after_ calling this\n    /// method.\n    ///\n    /// # Cross-Device Persistence\n    ///\n    /// Attempting to persist a temporary file across logical devices (or mount\n    /// points) will result in an error. This is a limitation of the underlying\n    /// OS. Your options are thus:\n    ///\n    ///   1. Store temporary file in the same logical device.\n    ///\n    ///      Change the `temp_dir` configuration parameter to be in the same\n    ///      logical device as the permanent location. This is the preferred\n    ///      solution.\n    ///\n    ///   2. Copy the temporary file using [`TempFile::copy_to()`] or\n    ///      [`TempFile::move_copy_to()`] instead.\n    ///\n    ///      This is a _full copy_ of the file, creating a duplicate version of\n    ///      the file at the destination. This should be avoided for performance\n    ///      reasons.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) -> std::io::Result<()> {\n    ///     # assert!(file.path().is_none());\n    ///     # let some_path = std::env::temp_dir().join(\"some-persist.txt\");\n    ///     file.persist_to(&some_path).await?;\n    ///     assert_eq!(file.path(), Some(&*some_path));\n    ///\n    ///     Ok(())\n    /// }\n    /// # let file = TempFile::Buffered { content: \"hi\".as_bytes() };\n    /// # rocket::async_test(handle(file)).unwrap();\n    /// ```\n    pub async fn persist_to<P>(&mut self, path: P) -> io::Result<()>\n        where P: AsRef<Path>\n    {\n        let new_path = path.as_ref().to_path_buf();\n        match self {\n            TempFile::File { path: either, .. } => {\n                let path = mem::replace(either, Either::Right(new_path.clone()));\n                match path {\n                    Either::Left(temp) => {\n                        let result = task::spawn_blocking(move || temp.persist(new_path)).await\n                            .map_err(|_| io::Error::new(io::ErrorKind::BrokenPipe, \"spawn_block\"))?;\n\n                        if let Err(e) = result {\n                            *either = Either::Left(e.path);\n                            return Err(e.error);\n                        }\n                    },\n                    Either::Right(prev) => {\n                        if let Err(e) = fs::rename(&prev, new_path).await {\n                            *either = Either::Right(prev);\n                            return Err(e);\n                        }\n                    }\n                }\n            }\n            TempFile::Buffered { content } => {\n                fs::write(&new_path, &content).await?;\n                *self = TempFile::File {\n                    file_name: None,\n                    content_type: None,\n                    path: Either::Right(new_path),\n                    len: content.len() as u64\n                };\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Persists the temporary file at its temporary path and creates a full\n    /// copy at `path`. The `self.path()` is _not_ updated, unless no temporary\n    /// file existed prior, and the temporary file is _not_ removed. Thus, there\n    /// will be _two_ files with the same contents.\n    ///\n    /// Unlike [`TempFile::persist_to()`], this method does not incur\n    /// cross-device limitations, at the performance cost of a full copy. Prefer\n    /// to use `persist_to()` with a valid `temp_dir` configuration parameter if\n    /// no more than one copy of a file is required.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) -> std::io::Result<()> {\n    ///     # assert!(file.path().is_none());\n    ///     # let some_path = std::env::temp_dir().join(\"some-file.txt\");\n    ///     file.copy_to(&some_path).await?;\n    ///     # assert_eq!(file.path(), Some(&*some_path));\n    ///     # let some_other_path = std::env::temp_dir().join(\"some-other.txt\");\n    ///     file.copy_to(&some_other_path).await?;\n    ///     assert_eq!(file.path(), Some(&*some_path));\n    ///     # assert_eq!(std::fs::read(some_path).unwrap(), b\"hi\");\n    ///     # assert_eq!(std::fs::read(some_other_path).unwrap(), b\"hi\");\n    ///\n    ///     Ok(())\n    /// }\n    /// # let file = TempFile::Buffered { content: b\"hi\" };\n    /// # rocket::async_test(handle(file)).unwrap();\n    /// ```\n    pub async fn copy_to<P>(&mut self, path: P) -> io::Result<()>\n        where P: AsRef<Path>\n    {\n        match self {\n            TempFile::File { path: either, .. } => {\n                let old_path = mem::replace(either, Either::Right(either.to_path_buf()));\n                match old_path {\n                    Either::Left(temp) => {\n                        let result = task::spawn_blocking(move || temp.keep()).await\n                            .map_err(|_| io::Error::new(io::ErrorKind::BrokenPipe, \"spawn_block\"))?;\n\n                        if let Err(e) = result {\n                            *either = Either::Left(e.path);\n                            return Err(e.error);\n                        }\n                    },\n                    Either::Right(_) => { /* do nada */ }\n                };\n\n                tokio::fs::copy(&either, path).await?;\n            }\n            TempFile::Buffered { content } => {\n                let path = path.as_ref();\n                fs::write(&path, &content).await?;\n                *self = TempFile::File {\n                    file_name: None,\n                    content_type: None,\n                    path: Either::Right(path.to_path_buf()),\n                    len: content.len() as u64\n                };\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Persists the temporary file at its temporary path, creates a full copy\n    /// at `path`, and then deletes the temporary file. `self.path()` is updated\n    /// to `path`.\n    ///\n    /// Like [`TempFile::copy_to()`] and unlike [`TempFile::persist_to()`], this\n    /// method does not incur cross-device limitations, at the performance cost\n    /// of a full copy and file deletion. Prefer to use `persist_to()` with a\n    /// valid `temp_dir` configuration parameter if no more than one copy of a\n    /// file is required.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) -> std::io::Result<()> {\n    ///     # assert!(file.path().is_none());\n    ///     # let some_path = std::env::temp_dir().join(\"some-copy.txt\");\n    ///     file.move_copy_to(&some_path).await?;\n    ///     # assert_eq!(file.path(), Some(&*some_path));\n    ///\n    ///     Ok(())\n    /// }\n    /// # let file = TempFile::Buffered { content: \"hi\".as_bytes() };\n    /// # rocket::async_test(handle(file)).unwrap();\n    /// ```\n    pub async fn move_copy_to<P>(&mut self, path: P) -> io::Result<()>\n        where P: AsRef<Path>\n    {\n        let dest = path.as_ref();\n        self.copy_to(dest).await?;\n\n        if let TempFile::File { path, .. } = self {\n            fs::remove_file(&path).await?;\n            *path = Either::Right(dest.to_path_buf());\n        }\n\n        Ok(())\n    }\n\n    /// Open the file for reading, returning an `async` stream of the file.\n    ///\n    /// This method should be used sparingly. `TempFile` is intended to be used\n    /// when the incoming data is destined to be stored on disk. If the incoming\n    /// data is intended to be streamed elsewhere, prefer to implement a custom\n    /// form guard via [`FromFormField`] that directly streams the incoming data\n    /// to the ultimate destination.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    /// use rocket::tokio::io;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(file: TempFile<'_>) -> std::io::Result<()> {\n    ///     let mut stream = file.open().await?;\n    ///     io::copy(&mut stream, &mut io::stdout()).await?;\n    ///     Ok(())\n    /// }\n    /// # let file = TempFile::Buffered { content: \"hi\".as_bytes() };\n    /// # rocket::async_test(handle(file)).unwrap();\n    /// ```\n    pub async fn open(&self) -> io::Result<impl AsyncBufRead + '_> {\n        use tokio_util::either::Either;\n\n        match self {\n            TempFile::File { path, .. } => {\n                let path = match path {\n                    either::Either::Left(p) => p.as_ref(),\n                    either::Either::Right(p) => p.as_path(),\n                };\n\n                let reader = BufReader::new(File::open(path).await?);\n                Ok(Either::Left(reader))\n            },\n            TempFile::Buffered { content } => {\n                Ok(Either::Right(*content))\n            },\n        }\n    }\n\n    /// Returns the size, in bytes, of the file.\n    ///\n    /// This method does not perform any system calls.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// fn handler(file: TempFile<'_>) {\n    ///     let file_len = file.len();\n    /// }\n    /// ```\n    pub fn len(&self) -> u64 {\n        match self {\n            TempFile::File { len, .. } => *len,\n            TempFile::Buffered { content } => content.len() as u64,\n        }\n    }\n\n    /// Returns the path to the file if it is known.\n    ///\n    /// Once a file is persisted with [`TempFile::persist_to()`], this method is\n    /// guaranteed to return `Some`. Prior to this point, however, this method\n    /// may return `Some` or `None`, depending on whether the file is on disk or\n    /// partially buffered in memory.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) -> std::io::Result<()> {\n    ///     # assert!(file.path().is_none());\n    ///     # let some_path = std::env::temp_dir().join(\"some-path.txt\");\n    ///     file.persist_to(&some_path).await?;\n    ///     assert_eq!(file.path(), Some(&*some_path));\n    ///     # assert_eq!(std::fs::read(some_path).unwrap(), b\"hi\");\n    ///\n    ///     Ok(())\n    /// }\n    /// # let file = TempFile::Buffered { content: b\"hi\" };\n    /// # rocket::async_test(handle(file)).unwrap();\n    /// ```\n    pub fn path(&self) -> Option<&Path> {\n        match self {\n            TempFile::File { path: Either::Left(p), .. } => Some(p.as_ref()),\n            TempFile::File { path: Either::Right(p), .. } => Some(p.as_path()),\n            TempFile::Buffered { .. } => None,\n        }\n    }\n\n    /// Returns the sanitized file name as specified in the form field.\n    ///\n    /// A multipart data form field can optionally specify the name of a file. A\n    /// browser will typically send the actual name of a user's selected file in\n    /// this field, but clients are also able to specify _any_ name, including\n    /// invalid or dangerous file names. This method returns a sanitized version\n    /// of that value, if it was specified, suitable and safe for use as a\n    /// permanent file name.\n    ///\n    /// Note that you will likely want to prepend or append random or\n    /// user-specific components to the name to avoid collisions; UUIDs make for\n    /// a good \"random\" data.\n    ///\n    /// See [`FileName::as_str()`] for specifics on sanitization.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) -> std::io::Result<()> {\n    ///     # let some_dir = std::env::temp_dir();\n    ///     if let Some(name) = file.name() {\n    ///         // Because of Rocket's sanitization, this is safe.\n    ///         file.persist_to(&some_dir.join(name)).await?;\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn name(&self) -> Option<&str> {\n        self.raw_name().and_then(|f| f.as_str())\n    }\n\n    /// Returns the raw name of the file as specified in the form field.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// async fn handle(mut file: TempFile<'_>) {\n    ///     let raw_name = file.raw_name();\n    /// }\n    /// ```\n    pub fn raw_name(&self) -> Option<&FileName> {\n        match *self {\n            TempFile::File { file_name, .. } => file_name,\n            TempFile::Buffered { .. } => None\n        }\n    }\n\n    /// Returns the Content-Type of the file as specified in the form field.\n    ///\n    /// A multipart data form field can optionally specify the content-type of a\n    /// file. A browser will typically sniff the file's extension to set the\n    /// content-type. This method returns that value, if it was specified.\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::TempFile;\n    ///\n    /// #[post(\"/\", data = \"<file>\")]\n    /// fn handle(file: TempFile<'_>) {\n    ///     let content_type = file.content_type();\n    /// }\n    /// ```\n    pub fn content_type(&self) -> Option<&ContentType> {\n        match self {\n            TempFile::File { content_type, .. } => content_type.as_ref(),\n            TempFile::Buffered { .. } => None\n        }\n    }\n\n    async fn from<'a>(\n        req: &Request<'_>,\n        data: Data<'_>,\n        file_name: Option<&'a FileName>,\n        content_type: Option<ContentType>,\n    ) -> io::Result<Capped<TempFile<'a>>> {\n        let limit = content_type.as_ref()\n            .and_then(|ct| ct.extension())\n            .and_then(|ext| req.limits().find(&[\"file\", ext.as_str()]))\n            .or_else(|| req.limits().get(\"file\"))\n            .unwrap_or(Limits::FILE);\n\n        let temp_dir = req.rocket().config().temp_dir.relative();\n        let file = task::spawn_blocking(move || NamedTempFile::new_in(temp_dir));\n        let file = file.await;\n        let file = file.map_err(|_| io::Error::new(io::ErrorKind::Other, \"spawn_block panic\"))??;\n        let (file, temp_path) = file.into_parts();\n\n        let mut file = File::from_std(file);\n        let fut = data.open(limit).stream_to(tokio::io::BufWriter::new(&mut file));\n        let n = fut.await;\n        let n = n?;\n        let temp_file = TempFile::File {\n            content_type, file_name,\n            path: Either::Left(temp_path),\n            len: n.written,\n        };\n\n        Ok(Capped::new(temp_file, n))\n    }\n}\n\n#[crate::async_trait]\nimpl<'v> FromFormField<'v> for Capped<TempFile<'v>> {\n    fn from_value(field: ValueField<'v>) -> Result<Self, Errors<'v>> {\n        let n = N { written: field.value.len() as u64, complete: true  };\n        Ok(Capped::new(TempFile::Buffered { content: field.value.as_bytes() }, n))\n    }\n\n    async fn from_data(\n        f: DataField<'v, '_>\n    ) -> Result<Self, Errors<'v>> {\n        Ok(TempFile::from(f.request, f.data, f.file_name, Some(f.content_type)).await?)\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromData<'r> for Capped<TempFile<'_>> {\n    type Error = io::Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> data::Outcome<'r, Self> {\n        use yansi::Paint;\n\n        let has_form = |ty: &ContentType| ty.is_form_data() || ty.is_form();\n        if req.content_type().map_or(false, has_form) {\n            let (tf, form) = (\"TempFile<'_>\".primary(), \"Form<TempFile<'_>>\".primary());\n            warn_!(\"Request contains a form that will not be processed.\");\n            info_!(\"Bare `{}` data guard writes raw, unprocessed streams to disk.\", tf);\n            info_!(\"Did you mean to use `{}` instead?\", form);\n        }\n\n        TempFile::from(req, data, None, req.content_type().cloned()).await\n            .or_error(Status::BadRequest)\n    }\n}\n\nimpl_strict_from_form_field_from_capped!(TempFile<'v>);\nimpl_strict_from_data_from_capped!(TempFile<'_>);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "macro_rules! req_method {\n    ($import:literal, $NAME:literal, $f:ident, $method:expr) => (\n        req_method!(@\n            $import,\n            $NAME,\n            concat!(\"let req = client.\", stringify!($f), r#\"(\"/hello\");\"#),\n            $f,\n            $method\n        );\n    );\n\n    (@$import:literal, $NAME:literal, $use_it:expr, $f:ident, $method:expr) => (\n        /// Create a local `\n        #[doc = $NAME]\n        /// ` request to the URI `uri`.\n        ///\n        /// When dispatched, the request will be served by the instance of Rocket\n        /// within `self`. The request is not dispatched automatically. To actually\n        /// dispatch the request, call [`LocalRequest::dispatch()`] on the returned\n        /// request.\n        ///\n        /// # Example\n        ///\n        /// ```rust,no_run\n        #[doc = $import]\n        ///\n        /// # Client::_test(|client, _, _| {\n        /// let client: &Client = client;\n        #[doc = $use_it]\n        /// # });\n        /// ```\n        #[inline(always)]\n        pub fn $f<'c, 'u: 'c, U>(&'c self, uri: U) -> LocalRequest<'c>\n            where U: TryInto<Origin<'u>> + fmt::Display\n        {\n            self.req($method, uri)\n        }\n    )\n}\n\nmacro_rules! pub_client_impl {\n    ($import:literal $(@$prefix:tt $suffix:tt)?) =>\n{\n    /// Construct a new `Client` from an instance of `Rocket` _with_ cookie\n    /// tracking. This is typically the desired mode of operation for testing.\n    ///\n    /// # Cookie Tracking\n    ///\n    /// With cookie tracking enabled, a `Client` propagates cookie changes made\n    /// by responses to previously dispatched requests. In other words,\n    /// succeeding requests reflect changes (additions and removals) made by any\n    /// prior responses.\n    ///\n    /// Cookie tracking requires synchronization between dispatches. **As such,\n    /// cookie tracking _should not_ be enabled if a local client is being used\n    /// to serve requests on multiple threads.**\n    ///\n    /// # Errors\n    ///\n    /// If launching the `Rocket` instance would fail, excepting network errors,\n    /// the `Error` is returned.\n    ///\n    /// ```rust,no_run\n    #[doc = $import]\n    ///\n    /// let rocket = rocket::build();\n    /// let client = Client::tracked(rocket);\n    /// ```\n    #[inline(always)]\n    pub $($prefix)? fn tracked<P: Phase>(rocket: Rocket<P>) -> Result<Self, Error> {\n        Self::_new(rocket, true) $(.$suffix)?\n    }\n\n    /// Construct a new `Client` from an instance of `Rocket` _without_\n    /// cookie tracking.\n    ///\n    /// # Cookie Tracking\n    ///\n    /// Unlike the [`tracked()`](Client::tracked()) constructor, a `Client`\n    /// returned from this method _does not_ automatically propagate cookie\n    /// changes and thus requires no synchronization between dispatches.\n    ///\n    /// # Errors\n    ///\n    /// If launching the `Rocket` instance would fail, excepting network\n    /// errors, the `Error` is returned.\n    ///\n    /// ```rust,no_run\n    #[doc = $import]\n    ///\n    /// let rocket = rocket::build();\n    /// let client = Client::untracked(rocket);\n    /// ```\n    pub $($prefix)? fn untracked<P: Phase>(rocket: Rocket<P>) -> Result<Self, Error> {\n        Self::_new(rocket, false) $(.$suffix)?\n    }\n\n    /// Terminates `Client` by initiating a graceful shutdown via\n    /// [`Shutdown::notify()`] and running shutdown fairings.\n    ///\n    /// This method _must_ be called on a `Client` if graceful shutdown is\n    /// required for testing as `Drop` _does not_ signal `Shutdown` nor run\n    /// shutdown fairings. Returns the instance of `Rocket` being managed by\n    /// this client after all shutdown fairings run to completion.\n    ///\n    /// [`Shutdown::notify()`]: crate::Shutdown::notify()\n    ///\n    /// ```rust,no_run\n    #[doc = $import]\n    ///\n    /// # fn f(client: Client) {\n    /// let client: Client = client;\n    /// let rocket = client.terminate();\n    /// # }\n    /// ```\n    #[inline(always)]\n    pub $($prefix)? fn terminate(self) -> Rocket<Ignite> {\n        Self::_terminate(self) $(.$suffix)?\n    }\n\n    #[doc(hidden)]\n    pub $($prefix)? fn debug_with(routes: Vec<crate::Route>) -> Result<Self, Error> {\n        let rocket = crate::custom(crate::Config::debug_default());\n        Self::debug(rocket.mount(\"/\", routes)) $(.$suffix)?\n    }\n\n    #[doc(hidden)]\n    pub $($prefix)? fn debug(rocket: Rocket<crate::Build>) -> Result<Self, Error> {\n        use crate::config;\n\n        let figment = rocket.figment().clone()\n            .merge((config::Config::LOG_LEVEL, config::LogLevel::Debug))\n            .select(config::Config::DEBUG_PROFILE);\n\n        Self::tracked(rocket.configure(figment)) $(.$suffix)?\n    }\n\n    /// Deprecated alias to [`Client::tracked()`].\n    #[deprecated(\n        since = \"0.5.0\",\n        note = \"choose between `Client::untracked()` and `Client::tracked()`\"\n    )]\n    pub $($prefix)? fn new<P: Phase>(rocket: Rocket<P>) -> Result<Self, Error> {\n        Self::tracked(rocket) $(.$suffix)?\n    }\n\n    /// Returns a reference to the `Rocket` this client is creating requests\n    /// for.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|client, _, _| {\n    /// let client: &Client = client;\n    /// let rocket = client.rocket();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn rocket(&self) -> &Rocket<Orbit> {\n        &*self._rocket()\n    }\n\n    /// Returns a cookie jar containing all of the cookies this client is\n    /// currently tracking.\n    ///\n    /// If cookie tracking is disabled, the returned jar will always be empty.\n    /// Otherwise, it will contains all of the cookies collected from responses\n    /// to requests dispatched by this client that have not expired.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|client, _, _| {\n    /// let client: &Client = client;\n    /// let cookie = client.cookies();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn cookies(&self) -> crate::http::CookieJar<'_> {\n        let config = &self.rocket().config();\n        let jar = self._with_raw_cookies(|jar| jar.clone());\n        crate::http::CookieJar::from(jar, config)\n    }\n\n    req_method!($import, \"GET\", get, Method::Get);\n    req_method!($import, \"PUT\", put, Method::Put);\n    req_method!($import, \"POST\", post, Method::Post);\n    req_method!($import, \"DELETE\", delete, Method::Delete);\n    req_method!($import, \"OPTIONS\", options, Method::Options);\n    req_method!($import, \"HEAD\", head, Method::Head);\n    req_method!($import, \"PATCH\", patch, Method::Patch);\n\n    /// Create a local `GET` request to the URI `uri`.\n    ///\n    /// When dispatched, the request will be served by the instance of\n    /// Rocket within `self`. The request is not dispatched automatically.\n    /// To actually dispatch the request, call [`LocalRequest::dispatch()`]\n    /// on the returned request.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    #[doc = $import]\n    /// use rocket::http::Method;\n    ///\n    /// # Client::_test(|client, _, _| {\n    /// let client: &Client = client;\n    /// client.req(Method::Get, \"/hello\");\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn req<'c, 'u: 'c, U>(\n        &'c self,\n        method: Method,\n        uri: U\n    ) -> LocalRequest<'c>\n        where U: TryInto<Origin<'u>> + fmt::Display\n    {\n        self._req(method, uri)\n    }\n\n    #[cfg(test)]\n    #[allow(dead_code)]\n    fn _ensure_impls_exist() {\n        fn is_send<T: Send>() {}\n        is_send::<Self>();\n\n        fn is_debug<T: std::fmt::Debug>() {}\n        is_debug::<Self>();\n    }\n}}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "macro_rules! pub_request_impl {\n    ($import:literal $($prefix:tt $suffix:tt)?) =>\n{\n    /// Borrows the inner `Request` as seen by Rocket.\n    ///\n    /// Note that no routing has occurred and that there is no remote\n    /// address unless one has been explicitly set with\n    /// [`set_remote()`](Request::set_remote()).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let inner: &rocket::Request = request.inner();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn inner(&self) -> &Request<'c> {\n        self._request()\n    }\n\n    /// Mutably borrows the inner `Request` as seen by Rocket.\n    ///\n    /// Note that no routing has occurred and that there is no remote\n    /// address unless one has been explicitly set with\n    /// [`set_remote()`](Request::set_remote()).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let mut request: LocalRequest = request;\n    /// let inner: &mut rocket::Request = request.inner_mut();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn inner_mut(&mut self) -> &mut Request<'c> {\n        self._request_mut()\n    }\n\n    /// Add a header to this request.\n    ///\n    /// Any type that implements `Into<Header>` can be used here. Among\n    /// others, this includes [`ContentType`] and [`Accept`].\n    ///\n    /// [`ContentType`]: crate::http::ContentType\n    /// [`Accept`]: crate::http::Accept\n    ///\n    /// # Examples\n    ///\n    /// Add the Content-Type header:\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::Header;\n    /// use rocket::http::ContentType;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let req = request\n    ///     .header(ContentType::JSON)\n    ///     .header(Header::new(\"X-Custom\", \"custom-value\"));\n    /// # });\n    /// ```\n    #[inline]\n    pub fn header<H>(mut self, header: H) -> Self\n        where H: Into<crate::http::Header<'static>>\n    {\n        self._request_mut().add_header(header.into());\n        self\n    }\n\n    /// Adds a header to this request without consuming `self`.\n    ///\n    /// # Examples\n    ///\n    /// Add the Content-Type header:\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::ContentType;\n    ///\n    /// # Client::_test(|_, mut request, _| {\n    /// let mut request: LocalRequest = request;\n    /// request.add_header(ContentType::JSON);\n    /// # });\n    /// ```\n    #[inline]\n    pub fn add_header<H>(&mut self, header: H)\n        where H: Into<crate::http::Header<'static>>\n    {\n        self._request_mut().add_header(header.into());\n    }\n\n    /// Set the remote address of this request.\n    ///\n    /// # Examples\n    ///\n    /// Set the remote address to \"8.8.8.8:80\":\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let address = \"8.8.8.8:80\".parse().unwrap();\n    /// let req = request.remote(address);\n    /// # });\n    /// ```\n    #[inline]\n    pub fn remote(mut self, address: std::net::SocketAddr) -> Self {\n        self.set_remote(address);\n        self\n    }\n\n    /// Add a cookie to this request.\n    ///\n    /// # Examples\n    ///\n    /// Add `user_id` cookie:\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::Cookie;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let req = request\n    ///     .cookie((\"username\", \"sb\"))\n    ///     .cookie((\"user_id\", \"12\"));\n    /// # });\n    /// ```\n    #[inline]\n    pub fn cookie<'a, C>(mut self, cookie: C) -> Self\n        where C: Into<crate::http::Cookie<'a>>\n    {\n        self._request_mut().cookies_mut().add_original(cookie.into().into_owned());\n        self\n    }\n\n    /// Add all of the cookies in `cookies` to this request.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::Cookie;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let cookies = vec![(\"a\", \"b\"), (\"c\", \"d\")];\n    /// let req = request.cookies(cookies);\n    /// # });\n    /// ```\n    #[inline]\n    pub fn cookies<'a, C, I>(mut self, cookies: I) -> Self\n        where C: Into<crate::http::Cookie<'a>>,\n              I: IntoIterator<Item = C>\n    {\n        for cookie in cookies {\n            let cookie: crate::http::Cookie<'_> = cookie.into();\n            self._request_mut().cookies_mut().add_original(cookie.into_owned());\n        }\n\n        self\n    }\n\n    /// Add a [private cookie] to this request.\n    ///\n    /// [private cookie]: crate::http::CookieJar::add_private()\n    ///\n    /// # Examples\n    ///\n    /// Add `user_id` as a private cookie:\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::Cookie;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let req = request.private_cookie((\"user_id\", \"sb\"));\n    /// # });\n    /// ```\n    #[cfg(feature = \"secrets\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"secrets\")))]\n    #[inline]\n    pub fn private_cookie<C>(mut self, cookie: C) -> Self\n        where C: Into<crate::http::Cookie<'static>>\n    {\n        self._request_mut().cookies_mut().add_original_private(cookie.into());\n        self\n    }\n\n    /// Set mTLS client certificates to send along with the request.\n    ///\n    /// If the request already contained certificates, they are replaced with\n    /// those in `reader.`\n    ///\n    /// `reader` is expected to be PEM-formatted and contain X509 certificates.\n    /// If it contains more than one certificate, the entire chain is set on the\n    /// request. If it contains items other than certificates, the certificate\n    /// chain up to the first non-certificate item is set on the request. If\n    /// `reader` is syntactically invalid PEM, certificates are cleared on the\n    /// request.\n    ///\n    /// The type `C` can be anything that implements [`std::io::Read`]. This\n    /// includes: `&[u8]`, `File`, `&File`, `Stdin`, and so on. To read a file\n    /// in at compile-time, use [`include_bytes!()`].\n    ///\n    /// ```rust\n    /// use std::fs::File;\n    ///\n    #[doc = $import]\n    /// use rocket::fs::relative;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let path = relative!(\"../../examples/tls/private/ed25519_cert.pem\");\n    /// let req = request.identity(File::open(path).unwrap());\n    /// # });\n    /// ```\n    #[cfg(feature = \"mtls\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"mtls\")))]\n    pub fn identity<C: std::io::Read>(mut self, reader: C) -> Self {\n        use crate::http::{tls::util::load_certs, private::Certificates};\n\n        let mut reader = std::io::BufReader::new(reader);\n        let certs = load_certs(&mut reader).map(Certificates::from);\n        self._request_mut().connection.client_certificates = certs.ok();\n        self\n    }\n\n    /// Sets the body data of the request.\n    ///core/lib/src/local/request.rs\n    /// # Examples\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::ContentType;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let req = request\n    ///     .header(ContentType::Text)\n    ///     .body(\"Hello, world!\");\n    /// # });\n    /// ```\n    #[inline]\n    pub fn body<S: AsRef<[u8]>>(mut self, body: S) -> Self {\n        // TODO: For CGI, we want to be able to set the body to be stdin\n        // without actually reading everything into a vector. Can we allow\n        // that here while keeping the simplicity? Looks like it would\n        // require us to reintroduce a NetStream::Local(Box<Read>) or\n        // something like that.\n        *self._body_mut() = body.as_ref().into();\n        self\n    }\n\n    /// Sets the body to `value` serialized as JSON with `Content-Type`\n    /// [`ContentType::JSON`](crate::http::ContentType::JSON).\n    ///\n    /// If `value` fails to serialize, the body is set to empty. The\n    /// `Content-Type` header is _always_ set.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::serde::Serialize;\n    /// use rocket::http::ContentType;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Task {\n    ///     id: usize,\n    ///     complete: bool,\n    /// }\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let task = Task { id: 10, complete: false };\n    ///\n    /// let request: LocalRequest = request;\n    /// let req = request.json(&task);\n    /// assert_eq!(req.content_type(), Some(&ContentType::JSON));\n    /// # });\n    /// ```\n    #[cfg(feature = \"json\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"json\")))]\n    pub fn json<T: crate::serde::Serialize>(self, value: &T) -> Self {\n        let json = serde_json::to_vec(&value).unwrap_or_default();\n        self.header(crate::http::ContentType::JSON).body(json)\n    }\n\n    /// Sets the body to `value` serialized as MessagePack with `Content-Type`\n    /// [`ContentType::MsgPack`](crate::http::ContentType::MsgPack).\n    ///\n    /// If `value` fails to serialize, the body is set to empty. The\n    /// `Content-Type` header is _always_ set.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::serde::Serialize;\n    /// use rocket::http::ContentType;\n    ///\n    /// #[derive(Serialize)]\n    /// struct Task {\n    ///     id: usize,\n    ///     complete: bool,\n    /// }\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let task = Task { id: 10, complete: false };\n    ///\n    /// let request: LocalRequest = request;\n    /// let req = request.msgpack(&task);\n    /// assert_eq!(req.content_type(), Some(&ContentType::MsgPack));\n    /// # });\n    /// ```\n    #[cfg(feature = \"msgpack\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"msgpack\")))]\n    pub fn msgpack<T: crate::serde::Serialize>(self, value: &T) -> Self {\n        let msgpack = rmp_serde::to_vec(value).unwrap_or_default();\n        self.header(crate::http::ContentType::MsgPack).body(msgpack)\n    }\n\n    /// Set the body (data) of the request without consuming `self`.\n    ///\n    /// # Examples\n    ///\n    /// Set the body to be a JSON structure; also sets the Content-Type.\n    ///\n    /// ```rust\n    #[doc = $import]\n    /// use rocket::http::ContentType;\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let mut request = request.header(ContentType::JSON);\n    /// request.set_body(r#\"{ \"key\": \"value\", \"array\": [1, 2, 3] }\"#);\n    /// # });\n    /// ```\n    #[inline]\n    pub fn set_body<S: AsRef<[u8]>>(&mut self, body: S) {\n        *self._body_mut() = body.as_ref().into();\n    }\n\n    /// Dispatches the request, returning the response.\n    ///\n    /// This method consumes `self` and is the preferred mechanism for\n    /// dispatching.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $import]\n    ///\n    /// # Client::_test(|_, request, _| {\n    /// let request: LocalRequest = request;\n    /// let response = request.dispatch();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub $($prefix)? fn dispatch(self) -> LocalResponse<'c> {\n        self._dispatch()$(.$suffix)?\n    }\n\n    #[cfg(test)]\n    #[allow(dead_code)]\n    fn _ensure_impls_exist() {\n        fn is_clone_debug<T: Clone + std::fmt::Debug>() {}\n        is_clone_debug::<Self>();\n\n        fn is_deref_req<'a, T: std::ops::Deref<Target = Request<'a>>>() {}\n        is_deref_req::<Self>();\n\n        fn is_deref_mut_req<'a, T: std::ops::DerefMut<Target = Request<'a>>>() {}\n        is_deref_mut_req::<Self>();\n    }\n}}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "macro_rules! getter_method {\n    ($doc_prelude:literal, $desc:literal, $f:ident -> $r:ty) => (\n        getter_method!(@$doc_prelude, $f, $desc, $r,\n            concat!(\"let \", stringify!($f), \" = response.\", stringify!($f), \"();\"));\n    );\n    (@$doc_prelude:literal, $f:ident, $desc:expr, $r:ty, $use_it:expr) => (\n        /// Returns the\n        #[doc = $desc]\n        /// of `self`.\n        ///\n        /// # Example\n        ///\n        /// ```rust\n        #[doc = $doc_prelude]\n        ///\n        /// # Client::_test(|_, _, response| {\n        /// let response: LocalResponse = response;\n        #[doc = $use_it]\n        /// # });\n        /// ```\n        #[inline(always)]\n        pub fn $f(&self) -> $r {\n            self._response().$f()\n        }\n    )\n}\n\nmacro_rules! pub_response_impl {\n    ($doc_prelude:literal $($prefix:tt $suffix:tt)?) =>\n{\n    getter_method!($doc_prelude, \"HTTP status\",\n        status -> crate::http::Status);\n\n    getter_method!($doc_prelude, \"Content-Type, if a valid one is set,\",\n        content_type -> Option<crate::http::ContentType>);\n\n    getter_method!($doc_prelude, \"HTTP headers\",\n        headers -> &crate::http::HeaderMap<'_>);\n\n    /// Return a cookie jar containing the HTTP cookies in the response.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $doc_prelude]\n    ///\n    /// # Client::_test(|_, _, response| {\n    /// let response: LocalResponse = response;\n    /// let string = response.cookies();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub fn cookies(&self) -> &crate::http::CookieJar<'_> {\n        self._cookies()\n    }\n\n    getter_method!($doc_prelude, \"response body, if there is one,\",\n        body -> &crate::response::Body<'_>);\n\n    /// Consumes `self` and reads the entirety of its body into a string.\n    ///\n    /// If reading fails, the body contains invalid UTF-8 characters, or the\n    /// body is unset in the response, returns `None`. Otherwise, returns\n    /// `Some`. The string may be empty if the body is empty.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $doc_prelude]\n    ///\n    /// # Client::_test(|_, _, response| {\n    /// let response: LocalResponse = response;\n    /// let string = response.into_string();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub $($prefix)? fn into_string(self) -> Option<String> {\n        if self._response().body().is_none() {\n            return None;\n        }\n\n        self._into_string() $(.$suffix)? .ok()\n    }\n\n    /// Consumes `self` and reads the entirety of its body into a `Vec` of\n    /// bytes.\n    ///\n    /// If reading fails or the body is unset in the response, returns `None`.\n    /// Otherwise, returns `Some`. The returned vector may be empty if the body\n    /// is empty.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $doc_prelude]\n    ///\n    /// # Client::_test(|_, _, response| {\n    /// let response: LocalResponse = response;\n    /// let bytes = response.into_bytes();\n    /// # });\n    /// ```\n    #[inline(always)]\n    pub $($prefix)? fn into_bytes(self) -> Option<Vec<u8>> {\n        if self._response().body().is_none() {\n            return None;\n        }\n\n        self._into_bytes() $(.$suffix)? .ok()\n    }\n\n    /// Consumes `self` and deserializes its body as JSON without buffering in\n    /// memory.\n    ///\n    /// If deserialization fails or the body is unset in the response, returns\n    /// `None`. Otherwise, returns `Some`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $doc_prelude]\n    /// use rocket::serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Task {\n    ///     id: usize,\n    ///     complete: bool,\n    ///     text: String,\n    /// }\n    ///\n    /// # Client::_test(|_, _, response| {\n    /// let response: LocalResponse = response;\n    /// let task = response.into_json::<Task>();\n    /// # });\n    /// ```\n    #[cfg(feature = \"json\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"json\")))]\n    pub $($prefix)? fn into_json<T>(self) -> Option<T>\n        where T: Send + serde::de::DeserializeOwned + 'static\n    {\n        if self._response().body().is_none() {\n            return None;\n        }\n\n        self._into_json() $(.$suffix)?\n    }\n\n    /// Consumes `self` and deserializes its body as MessagePack without\n    /// buffering in memory.\n    ///\n    /// If deserialization fails or the body is unset in the response, returns\n    /// `None`. Otherwise, returns `Some`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    #[doc = $doc_prelude]\n    /// use rocket::serde::Deserialize;\n    ///\n    /// #[derive(Deserialize)]\n    /// struct Task {\n    ///     id: usize,\n    ///     complete: bool,\n    ///     text: String,\n    /// }\n    ///\n    /// # Client::_test(|_, _, response| {\n    /// let response: LocalResponse = response;\n    /// let task = response.into_msgpack::<Task>();\n    /// # });\n    /// ```\n    #[cfg(feature = \"msgpack\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"msgpack\")))]\n    pub $($prefix)? fn into_msgpack<T>(self) -> Option<T>\n        where T: Send + serde::de::DeserializeOwned + 'static\n    {\n        if self._response().body().is_none() {\n            return None;\n        }\n\n        self._into_msgpack() $(.$suffix)?\n    }\n\n    #[cfg(test)]\n    #[allow(dead_code)]\n    fn _ensure_impls_exist() {\n        fn is_debug<T: std::fmt::Debug>() {}\n        is_debug::<Self>();\n    }\n}}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::str::FromStr;\nuse std::path::PathBuf;\n\nuse crate::http::uri::{Segments, error::PathError, fmt::Path};\n\n/// Trait to convert a dynamic path segment string to a concrete value.\n///\n/// This trait is used by Rocket's code generation facilities to parse dynamic\n/// path segment string values into a given type. That is, when a path contains\n/// a dynamic segment `<param>` where `param` has some type `T` that implements\n/// `FromParam`, `T::from_param` will be called.\n///\n/// # Forwarding\n///\n/// If the conversion fails, the incoming request will be forwarded to the next\n/// matching route, if any. For instance, consider the following route and\n/// handler for the dynamic `\"/<id>\"` path:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// #[get(\"/<id>\")]\n/// fn hello(id: usize) -> String {\n/// # let _id = id;\n/// # /*\n///     ...\n/// # */\n/// # \"\".to_string()\n/// }\n/// # fn main() {  }\n/// ```\n///\n/// If `usize::from_param` returns an `Ok(usize)` variant, the encapsulated\n/// value is used as the `id` function parameter. If not, the request is\n/// forwarded to the next matching route. Since there are no additional matching\n/// routes, this example will result in a 404 error for requests with invalid\n/// `id` values.\n///\n/// # Catching Errors\n///\n/// Sometimes, a forward is not desired, and instead, we simply want to know\n/// that the dynamic path segment could not be parsed into some desired type\n/// `T`. In these cases, types of `Option<T>` or `Result<T, T::Error>` can be\n/// used. These types implement `FromParam` themselves. Their implementations\n/// always return successfully, so they never forward. They can be used to\n/// determine if the `FromParam` call failed and to retrieve the error value\n/// from the failed `from_param` call.\n///\n/// For instance, imagine you've asked for an `<id>` as a `usize`. To determine\n/// when the `<id>` was not a valid `usize` and retrieve the string that failed\n/// to parse, you can use a `Result<usize, &str>` type for the `<id>` parameter\n/// as follows:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// #[get(\"/<id>\")]\n/// fn hello(id: Result<usize, &str>) -> String {\n///     match id {\n///         Ok(id_num) => format!(\"usize: {}\", id_num),\n///         Err(string) => format!(\"Not a usize: {}\", string)\n///     }\n/// }\n/// # fn main() {  }\n/// ```\n///\n/// # Provided Implementations\n///\n/// Rocket implements `FromParam` for several standard library types. Their\n/// behavior is documented here.\n///\n///   *\n///       * Primitive types: **f32, f64, isize, i8, i16, i32, i64, i128,\n///         usize, u8, u16, u32, u64, u128, bool**\n///       * `IpAddr` and `SocketAddr` types: **IpAddr, Ipv4Addr, Ipv6Addr,\n///         SocketAddrV4, SocketAddrV6, SocketAddr**\n///       * `NonZero*` types: **NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64,\n///         NonZeroI128, NonZeroIsize, NonZeroU8, NonZeroU16, NonZeroU32,\n///         NonZeroU64, NonZeroU128, NonZeroUsize**\n///\n///     A value is parsed successfully if the `from_str` method from the given\n///     type returns successfully. Otherwise, the raw path segment is returned\n///     in the `Err` value.\n///\n///   * **&str, String**\n///\n///     _This implementation always returns successfully._\n///\n///     Returns the percent-decoded path segment with invalid UTF-8 byte\n///     sequences replaced by  U+FFFD.\n///\n///   * **Option&lt;T>** _where_ **T: FromParam**\n///\n///     _This implementation always returns successfully._\n///\n///     The path segment is parsed by `T`'s `FromParam` implementation. If the\n///     parse succeeds, a `Some(parsed_value)` is returned. Otherwise, a `None`\n///     is returned.\n///\n///   * **Result&lt;T, T::Error>** _where_ **T: FromParam**\n///\n///     _This implementation always returns successfully._\n///\n///     The path segment is parsed by `T`'s `FromParam` implementation. The\n///     returned `Result` value is returned.\n///\n/// # Example\n///\n/// Say you want to parse a segment of the form:\n///\n/// ```text\n/// [a-zA-Z]+:[0-9]+\n/// ```\n///\n/// into the following structure, where the string before the `:` is stored in\n/// `key` and the number after the colon is stored in `value`:\n///\n/// ```rust\n/// struct MyParam<'r> {\n///     key: &'r str,\n///     value: usize\n/// }\n/// ```\n///\n/// The following implementation accomplishes this:\n///\n/// ```rust\n/// use rocket::request::FromParam;\n/// # #[allow(dead_code)]\n/// # struct MyParam<'r> { key: &'r str, value: usize }\n///\n/// impl<'r> FromParam<'r> for MyParam<'r> {\n///     type Error = &'r str;\n///\n///     fn from_param(param: &'r str) -> Result<Self, Self::Error> {\n///         // We can convert `param` into a `str` since we'll check every\n///         // character for safety later.\n///         let (key, val_str) = match param.find(':') {\n///             Some(i) if i > 0 => (&param[..i], &param[(i + 1)..]),\n///             _ => return Err(param)\n///         };\n///\n///         if !key.chars().all(|c| c.is_ascii_alphabetic()) {\n///             return Err(param);\n///         }\n///\n///         val_str.parse()\n///             .map(|value| MyParam { key, value })\n///             .map_err(|_| param)\n///     }\n/// }\n/// ```\n///\n/// With the implementation, the `MyParam` type can be used as the target of a\n/// dynamic path segment:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # use rocket::request::FromParam;\n/// # #[allow(dead_code)]\n/// # struct MyParam<'r> { key: &'r str, value: usize }\n/// # impl<'r> FromParam<'r> for MyParam<'r> {\n/// #     type Error = &'r str;\n/// #     fn from_param(param: &'r str) -> Result<Self, Self::Error> {\n/// #         Err(param)\n/// #     }\n/// # }\n/// #\n/// #[get(\"/<key_val>\")]\n/// fn hello(key_val: MyParam) -> String {\n/// # let _kv = key_val;\n/// # /*\n///     ...\n/// # */\n/// # \"\".to_string()\n/// }\n/// # fn main() {  }\n/// ```\npub trait FromParam<'a>: Sized {\n    /// The associated error to be returned if parsing/validation fails.\n    type Error: std::fmt::Debug;\n\n    /// Parses and validates an instance of `Self` from a path parameter string\n    /// or returns an `Error` if parsing or validation fails.\n    fn from_param(param: &'a str) -> Result<Self, Self::Error>;\n}\n\nimpl<'a> FromParam<'a> for &'a str {\n    type Error = std::convert::Infallible;\n\n    #[inline(always)]\n    fn from_param(param: &'a str) -> Result<&'a str, Self::Error> {\n        Ok(param)\n    }\n}\n\nimpl<'a> FromParam<'a> for String {\n    type Error = std::convert::Infallible;\n\n    #[track_caller]\n    #[inline(always)]\n    fn from_param(param: &'a str) -> Result<String, Self::Error> {\n        #[cfg(debug_assertions)] {\n            let loc = std::panic::Location::caller();\n            warn_!(\"Note: Using `String` as a parameter type is inefficient. Use `&str` instead.\");\n            info_!(\"`String` is used a parameter guard in {}:{}.\", loc.file(), loc.line());\n        }\n\n        Ok(param.to_string())\n    }\n}\n\nmacro_rules! impl_with_fromstr {\n    ($($T:ty),+) => ($(\n        impl<'a> FromParam<'a> for $T {\n            type Error = &'a str;\n\n            #[inline(always)]\n            fn from_param(param: &'a str) -> Result<Self, Self::Error> {\n                <$T as FromStr>::from_str(param).map_err(|_| param)\n            }\n        }\n    )+)\n}\n\nuse std::num::{\n    NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n    NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n};\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6, SocketAddr};\n\nimpl_with_fromstr! {\n    i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64,\n    NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize,\n    NonZeroU8, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n    bool, IpAddr, Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6, SocketAddr\n}\n\nimpl<'a> FromParam<'a> for PathBuf {\n    type Error = PathError;\n\n    #[inline]\n    fn from_param(param: &'a str) -> Result<Self, Self::Error> {\n        use crate::http::private::Indexed;\n\n        let segments = &[Indexed::Indexed(0, param.len())];\n        Segments::new(param.into(), segments).to_path_buf(false)\n    }\n}\n\nimpl<'a, T: FromParam<'a>> FromParam<'a> for Result<T, T::Error> {\n    type Error = std::convert::Infallible;\n\n    #[inline]\n    fn from_param(param: &'a str) -> Result<Self, Self::Error> {\n        match T::from_param(param) {\n            Ok(val) => Ok(Ok(val)),\n            Err(e) => Ok(Err(e)),\n        }\n    }\n}\n\nimpl<'a, T: FromParam<'a>> FromParam<'a> for Option<T> {\n    type Error = std::convert::Infallible;\n\n    #[inline]\n    fn from_param(param: &'a str) -> Result<Self, Self::Error> {\n        match T::from_param(param) {\n            Ok(val) => Ok(Some(val)),\n            Err(_) => Ok(None)\n        }\n    }\n}\n\n/// Trait to convert _many_ dynamic path segment strings to a concrete value.\n///\n/// This is the `..` analog to [`FromParam`], and its functionality is identical\n/// to it with one exception: this trait applies to segment parameters of the\n/// form `<param..>`, where `param` is of some type `T` that implements\n/// `FromSegments`. `T::from_segments` is called to convert the matched segments\n/// (via the [`Segments`] iterator) into the implementing type.\n///\n/// # Provided Implementations\n///\n/// **`PathBuf`**\n///\n/// The `PathBuf` implementation constructs a path from the segments iterator.\n/// Each segment is percent-decoded. If a segment equals \"..\" before or after\n/// decoding, the previous segment (if any) is omitted. For security purposes,\n/// any other segments that begin with \"*\" or \".\" are ignored.  If a\n/// percent-decoded segment results in invalid UTF8, an `Err` is returned with\n/// the `Utf8Error`.\npub trait FromSegments<'r>: Sized {\n    /// The associated error to be returned when parsing fails.\n    type Error: std::fmt::Debug;\n\n    /// Parses an instance of `Self` from many dynamic path parameter strings or\n    /// returns an `Error` if one cannot be parsed.\n    fn from_segments(segments: Segments<'r, Path>) -> Result<Self, Self::Error>;\n}\n\nimpl<'r> FromSegments<'r> for Segments<'r, Path> {\n    type Error = std::convert::Infallible;\n\n    #[inline(always)]\n    fn from_segments(segments: Self) -> Result<Self, Self::Error> {\n        Ok(segments)\n    }\n}\n\n/// Creates a `PathBuf` from a `Segments` iterator. The returned `PathBuf` is\n/// percent-decoded. If a segment is equal to \"..\", the previous segment (if\n/// any) is skipped.\n///\n/// For security purposes, if a segment meets any of the following conditions,\n/// an `Err` is returned indicating the condition met:\n///\n///   * Decoded segment starts with any of: `.` (except `..`), `*`\n///   * Decoded segment ends with any of: `:`, `>`, `<`\n///   * Decoded segment contains any of: `/`\n///   * On Windows, decoded segment contains any of: `\\`\n///   * Percent-encoding results in invalid UTF8.\n///\n/// As a result of these conditions, a `PathBuf` derived via `FromSegments` is\n/// safe to interpolate within, or use as a suffix of, a path without additional\n/// checks.\nimpl FromSegments<'_> for PathBuf {\n    type Error = PathError;\n\n    fn from_segments(segments: Segments<'_, Path>) -> Result<Self, Self::Error> {\n        segments.to_path_buf(false)\n    }\n}\n\nimpl<'r, T: FromSegments<'r>> FromSegments<'r> for Result<T, T::Error> {\n    type Error = std::convert::Infallible;\n\n    #[inline]\n    fn from_segments(segments: Segments<'r, Path>) -> Result<Result<T, T::Error>, Self::Error> {\n        match T::from_segments(segments) {\n            Ok(val) => Ok(Ok(val)),\n            Err(e) => Ok(Err(e)),\n        }\n    }\n}\n\nimpl<'r, T: FromSegments<'r>> FromSegments<'r> for Option<T> {\n    type Error = std::convert::Infallible;\n\n    #[inline]\n    fn from_segments(segments: Segments<'r, Path>) -> Result<Option<T>, Self::Error> {\n        match T::from_segments(segments) {\n            Ok(val) => Ok(Some(val)),\n            Err(_) => Ok(None)\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::convert::Infallible;\nuse std::fmt::Debug;\nuse std::net::{IpAddr, SocketAddr};\n\nuse crate::{Request, Route};\nuse crate::outcome::{self, Outcome::*};\n\nuse crate::http::uri::{Host, Origin};\nuse crate::http::{Status, ContentType, Accept, Method, CookieJar};\n\n/// Type alias for the `Outcome` of a `FromRequest` conversion.\npub type Outcome<S, E> = outcome::Outcome<S, (Status, E), Status>;\n\n/// Trait implemented by request guards to derive a value from incoming\n/// requests.\n///\n/// # Request Guards\n///\n/// A request guard is a type that represents an arbitrary validation policy.\n/// The validation policy is implemented through `FromRequest`. In other words,\n/// every type that implements `FromRequest` is a request guard.\n///\n/// Request guards appear as inputs to handlers. An arbitrary number of request\n/// guards can appear as arguments in a route handler. Rocket will automatically\n/// invoke the `FromRequest` implementation for request guards before calling\n/// the handler. Rocket only dispatches requests to a handler when all of its\n/// guards pass.\n///\n/// ## Async Trait\n///\n/// [`FromRequest`] is an _async_ trait. Implementations of `FromRequest` must\n/// be decorated with an attribute of `#[rocket::async_trait]`:\n///\n/// ```rust\n/// use rocket::request::{self, Request, FromRequest};\n/// # struct MyType;\n/// # type MyError = String;\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for MyType {\n///     type Error = MyError;\n///\n///     async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n///         /* .. */\n///         # unimplemented!()\n///     }\n/// }\n/// ```\n///\n/// ## Example\n///\n/// The following dummy handler makes use of three request guards, `A`, `B`, and\n/// `C`. An input type can be identified as a request guard if it is not named\n/// in the route attribute. This is why, for instance, `param` is not a request\n/// guard.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # use rocket::http::Method;\n/// # type A = Method; type B = Method; type C = Method; type T = ();\n/// #[get(\"/<param>\")]\n/// fn index(param: isize, a: A, b: B, c: C) -> T { /* ... */ }\n/// # fn main() {}\n/// ```\n///\n/// Request guards always fire in left-to-right declaration order. In the\n/// example above, the order is `a` followed by `b` followed by `c`. Errors are\n/// short-circuiting; if one guard errors, the remaining are not attempted.\n///\n/// # Outcomes\n///\n/// The returned [`Outcome`] of a `from_request` call determines how the\n/// incoming request will be processed.\n///\n/// * **Success**(S)\n///\n///   If the `Outcome` is [`Success`], then the `Success` value will be used as\n///   the value for the corresponding parameter.  As long as all other guards\n///   succeed, the request will be handled.\n///\n/// * **Error**(Status, E)\n///\n///   If the `Outcome` is [`Error`], the request will fail with the given\n///   status code and error. The designated error [`Catcher`](crate::Catcher)\n///   will be used to respond to the request. Note that users can request types\n///   of `Result<S, E>` and `Option<S>` to catch `Error`s and retrieve the\n///   error value.\n///\n/// * **Forward**(Status)\n///\n///   If the `Outcome` is [`Forward`], the request will be forwarded to the next\n///   matching route until either one succeeds or there are no further matching\n///   routes to attempt. In the latter case, the request will be sent to the\n///   [`Catcher`](crate::Catcher) for the designated `Status`. Note that users\n///   can request an `Option<S>` to catch `Forward`s.\n///\n/// # Provided Implementations\n///\n/// Rocket implements `FromRequest` for several built-in types. Their behavior\n/// is documented here.\n///\n///   * **Method**\n///\n///     Extracts the [`Method`] from the incoming request.\n///\n///     _This implementation always returns successfully._\n///\n///   * **&Origin**\n///\n///     Extracts the [`Origin`] URI from the incoming request.\n///\n///     _This implementation always returns successfully._\n///\n///   * **&Host**\n///\n///     Extracts the [`Host`] from the incoming request, if it exists. See\n///     [`Request::host()`] for details. If it does not exist, the request is\n///     forwarded with a 500 Internal Server Error status.\n///\n///   * **&Route**\n///\n///     Extracts the [`Route`] from the request if one is available. When used\n///     as a request guard in a route handler, this will always succeed. Outside\n///     of a route handler, a route may not be available, and the request is\n///     forwarded with a 500 Internal Server Error status.\n///\n///     For more information on when an `&Route` is available, see\n///     [`Request::route()`].\n///\n///   * **&CookieJar**\n///\n///     Returns a borrow to the [`CookieJar`] in the incoming request. Note that\n///     `CookieJar` implements internal mutability, so a handle to a `CookieJar`\n///     allows you to get _and_ set cookies in the request.\n///\n///     _This implementation always returns successfully._\n///\n///   * **&[`Config`]**\n///\n///     Extracts the application [`Config`].\n///\n///     _This implementation always returns successfully._\n///\n///   * **&ContentType**\n///\n///     Extracts the [`ContentType`] header from the incoming request via\n///     [`Request::content_type()`]. If the request didn't specify a\n///     Content-Type, the request is forwarded with a 500 Internal Server Error\n///     status.\n///\n///   * **&Accept**\n///\n///     Extracts the [`Accept`] header from the incoming request via\n///     [`Request::accept()`]. If the request didn't specify an `Accept`, the\n///     request is forwarded with a 500 Internal Server Error status.\n///\n///   * ***IpAddr**\n///\n///     Extracts the client ip address of the incoming request as an [`IpAddr`]\n///     via [`Request::client_ip()`]. If the client's IP address is not known,\n///     the request is forwarded with a 500 Internal Server Error status.\n///\n///   * **SocketAddr**\n///\n///     Extracts the remote address of the incoming request as a [`SocketAddr`]\n///     via [`Request::remote()`]. If the remote address is not known, the\n///     request is forwarded with a 500 Internal Server Error status.\n///\n///   * **Option&lt;T>** _where_ **T: FromRequest**\n///\n///     The type `T` is derived from the incoming request using `T`'s\n///     `FromRequest` implementation. If the derivation is a `Success`, the\n///     derived value is returned in `Some`. Otherwise, a `None` is returned.\n///\n///     _This implementation always returns successfully._\n///\n///   * **Result&lt;T, T::Error>** _where_ **T: FromRequest**\n///\n///     The type `T` is derived from the incoming request using `T`'s\n///     `FromRequest` implementation. If derivation is a `Success`, the value is\n///     returned in `Ok`. If the derivation is an `Error`, the error value is\n///     returned in `Err`. If the derivation is a `Forward`, the request is\n///     forwarded with the same status code as the original forward.\n///\n/// [`Config`]: crate::config::Config\n///\n/// # Example\n///\n/// Imagine you're running an authenticated API service that requires that some\n/// requests be sent along with a valid API key in a header field. You want to\n/// ensure that the handlers corresponding to these requests don't get called\n/// unless there is an API key in the request and the key is valid. The\n/// following example implements this using an `ApiKey` type and a `FromRequest`\n/// implementation for that type. The `ApiKey` type is then used in the\n/// `sensitive` handler.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// #\n/// use rocket::http::Status;\n/// use rocket::request::{self, Outcome, Request, FromRequest};\n///\n/// struct ApiKey<'r>(&'r str);\n///\n/// #[derive(Debug)]\n/// enum ApiKeyError {\n///     Missing,\n///     Invalid,\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for ApiKey<'r> {\n///     type Error = ApiKeyError;\n///\n///     async fn from_request(req: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n///         /// Returns true if `key` is a valid API key string.\n///         fn is_valid(key: &str) -> bool {\n///             key == \"valid_api_key\"\n///         }\n///\n///         match req.headers().get_one(\"x-api-key\") {\n///             None => Outcome::Error((Status::BadRequest, ApiKeyError::Missing)),\n///             Some(key) if is_valid(key) => Outcome::Success(ApiKey(key)),\n///             Some(_) => Outcome::Error((Status::BadRequest, ApiKeyError::Invalid)),\n///         }\n///     }\n/// }\n///\n/// #[get(\"/sensitive\")]\n/// fn sensitive(key: ApiKey<'_>) -> &'static str {\n///     \"Sensitive data.\"\n/// }\n/// ```\n///\n/// # Request-Local State\n///\n/// Request guards that perform expensive operations, such as those that query a\n/// database or an external service, should use the [request-local state] cache\n/// to store results if they might be invoked multiple times during the routing\n/// of a single request.\n///\n/// For example, consider a pair of `User` and `Admin` guards and a pair of\n/// routes (`admin_dashboard` and `user_dashboard`):\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # #[cfg(feature = \"secrets\")] mod wrapper {\n/// # use rocket::outcome::{IntoOutcome, try_outcome};\n/// # use rocket::request::{self, Outcome, FromRequest, Request};\n/// # use rocket::http::Status;\n/// # struct User { id: String, is_admin: bool }\n/// # struct Database;\n/// # impl Database {\n/// #     fn get_user(&self, id: String) -> Result<User, ()> {\n/// #         Ok(User { id, is_admin: false })\n/// #     }\n/// # }\n/// # #[rocket::async_trait]\n/// # impl<'r> FromRequest<'r> for Database {\n/// #     type Error = ();\n/// #     async fn from_request(request: &'r Request<'_>) -> Outcome<Database, ()> {\n/// #         Outcome::Success(Database)\n/// #     }\n/// # }\n/// #\n/// # struct Admin { user: User }\n/// #\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for User {\n///     type Error = ();\n///\n///     async fn from_request(request: &'r Request<'_>) -> Outcome<User, ()> {\n///         let db = try_outcome!(request.guard::<Database>().await);\n///         request.cookies()\n///             .get_private(\"user_id\")\n///             .and_then(|cookie| cookie.value().parse().ok())\n///             .and_then(|id| db.get_user(id).ok())\n///             .or_forward(Status::Unauthorized)\n///     }\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for Admin {\n///     type Error = ();\n///\n///     async fn from_request(request: &'r Request<'_>) -> Outcome<Admin, ()> {\n///         // This will unconditionally query the database!\n///         let user = try_outcome!(request.guard::<User>().await);\n///         if user.is_admin {\n///             Outcome::Success(Admin { user })\n///         } else {\n///             Outcome::Forward(Status::Unauthorized)\n///         }\n///     }\n/// }\n///\n/// #[get(\"/dashboard\")]\n/// fn admin_dashboard(admin: Admin) { }\n///\n/// #[get(\"/dashboard\", rank = 2)]\n/// fn user_dashboard(user: User) { }\n/// # } // end of cfg wrapper\n/// ```\n///\n/// When a non-admin user is logged in, the database will be queried twice: once\n/// via the `Admin` guard invoking the `User` guard, and a second time via the\n/// `User` guard directly. For cases like these, request-local state should be\n/// used, as illustrated below:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # #[cfg(feature = \"secrets\")] mod wrapper {\n/// # use rocket::outcome::{IntoOutcome, try_outcome};\n/// # use rocket::request::{self, Outcome, FromRequest, Request};\n/// # use rocket::http::Status;\n/// # struct User { id: String, is_admin: bool }\n/// # struct Database;\n/// # impl Database {\n/// #     fn get_user(&self, id: String) -> Result<User, ()> {\n/// #         Ok(User { id, is_admin: false })\n/// #     }\n/// # }\n/// # #[rocket::async_trait]\n/// # impl<'r> FromRequest<'r> for Database {\n/// #     type Error = ();\n/// #     async fn from_request(request: &'r Request<'_>) -> Outcome<Database, ()> {\n/// #         Outcome::Success(Database)\n/// #     }\n/// # }\n/// #\n/// # struct Admin<'a> { user: &'a User }\n/// #\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for &'r User {\n///     type Error = std::convert::Infallible;\n///\n///     async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n///         // This closure will execute at most once per request, regardless of\n///         // the number of times the `User` guard is executed.\n///         let user_result = request.local_cache_async(async {\n///             let db = request.guard::<Database>().await.succeeded()?;\n///             request.cookies()\n///                 .get_private(\"user_id\")\n///                 .and_then(|cookie| cookie.value().parse().ok())\n///                 .and_then(|id| db.get_user(id).ok())\n///         }).await;\n///\n///         user_result.as_ref().or_forward(Status::Unauthorized)\n///     }\n/// }\n///\n/// #[rocket::async_trait]\n/// impl<'r> FromRequest<'r> for Admin<'r> {\n///     type Error = std::convert::Infallible;\n///\n///     async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error> {\n///         let user = try_outcome!(request.guard::<&User>().await);\n///         if user.is_admin {\n///             Outcome::Success(Admin { user })\n///         } else {\n///             Outcome::Forward(Status::Unauthorized)\n///         }\n///     }\n/// }\n/// # } // end of cfg wrapper\n/// ```\n///\n/// Notice that these request guards provide access to *borrowed* data (`&'a\n/// User` and `Admin<'a>`) as the data is now owned by the request's cache.\n///\n/// [request-local state]: https://rocket.rs/v0.5/guide/state/#request-local-state\n#[crate::async_trait]\npub trait FromRequest<'r>: Sized {\n    /// The associated error to be returned if derivation fails.\n    type Error: Debug;\n\n    /// Derives an instance of `Self` from the incoming request metadata.\n    ///\n    /// If the derivation is successful, an outcome of `Success` is returned. If\n    /// the derivation fails in an unrecoverable fashion, `Error` is returned.\n    /// `Forward` is returned to indicate that the request should be forwarded\n    /// to other matching routes, if any.\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Self::Error>;\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for Method {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        Success(request.method())\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Origin<'r> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        Success(request.uri())\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Host<'r> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.host() {\n            Some(host) => Success(host),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Route {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.route() {\n            Some(route) => Success(route),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r CookieJar<'r> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        Success(request.cookies())\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r Accept {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.accept() {\n            Some(accept) => Success(accept),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for &'r ContentType {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.content_type() {\n            Some(content_type) => Success(content_type),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for IpAddr {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.client_ip() {\n            Some(addr) => Success(addr),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for SocketAddr {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match request.remote() {\n            Some(addr) => Success(addr),\n            None => Forward(Status::InternalServerError)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromRequest<'r>> FromRequest<'r> for Result<T, T::Error> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match T::from_request(request).await {\n            Success(val) => Success(Ok(val)),\n            Error((_, e)) => Success(Err(e)),\n            Forward(status) => Forward(status),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromRequest<'r>> FromRequest<'r> for Option<T> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        match T::from_request(request).await {\n            Success(val) => Success(Some(val)),\n            Error(_) | Forward(_) => Success(None),\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: FromRequest<'r>> FromRequest<'r> for Outcome<T, T::Error> {\n    type Error = Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> Outcome<Self, Infallible> {\n        Success(T::from_request(request).await)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::ops::RangeFrom;\nuse std::{future::Future, borrow::Cow, sync::Arc};\nuse std::net::{IpAddr, SocketAddr};\n\nuse yansi::Paint;\nuse state::{TypeMap, InitCell};\nuse futures::future::BoxFuture;\nuse atomic::{Atomic, Ordering};\n\nuse crate::{Rocket, Route, Orbit};\nuse crate::request::{FromParam, FromSegments, FromRequest, Outcome};\nuse crate::form::{self, ValueField, FromForm};\nuse crate::data::Limits;\n\nuse crate::http::{hyper, Method, Header, HeaderMap};\nuse crate::http::{ContentType, Accept, MediaType, CookieJar, Cookie};\nuse crate::http::uncased::UncasedStr;\nuse crate::http::private::Certificates;\nuse crate::http::uri::{fmt::Path, Origin, Segments, Host, Authority};\n\n/// The type of an incoming web request.\n///\n/// This should be used sparingly in Rocket applications. In particular, it\n/// should likely only be used when writing [`FromRequest`] implementations. It\n/// contains all of the information for a given web request except for the body\n/// data. This includes the HTTP method, URI, cookies, headers, and more.\npub struct Request<'r> {\n    method: Atomic<Method>,\n    uri: Origin<'r>,\n    headers: HeaderMap<'r>,\n    pub(crate) connection: ConnectionMeta,\n    pub(crate) state: RequestState<'r>,\n}\n\n/// Information derived from an incoming connection, if any.\n#[derive(Clone)]\npub(crate) struct ConnectionMeta {\n    pub remote: Option<SocketAddr>,\n    #[cfg_attr(not(feature = \"mtls\"), allow(dead_code))]\n    pub client_certificates: Option<Certificates>,\n}\n\n/// Information derived from the request.\npub(crate) struct RequestState<'r> {\n    pub rocket: &'r Rocket<Orbit>,\n    pub route: Atomic<Option<&'r Route>>,\n    pub cookies: CookieJar<'r>,\n    pub accept: InitCell<Option<Accept>>,\n    pub content_type: InitCell<Option<ContentType>>,\n    pub cache: Arc<TypeMap![Send + Sync]>,\n    pub host: Option<Host<'r>>,\n}\n\nimpl Request<'_> {\n    pub(crate) fn clone(&self) -> Self {\n        Request {\n            method: Atomic::new(self.method()),\n            uri: self.uri.clone(),\n            headers: self.headers.clone(),\n            connection: self.connection.clone(),\n            state: self.state.clone(),\n        }\n    }\n}\n\nimpl RequestState<'_> {\n    fn clone(&self) -> Self {\n        RequestState {\n            rocket: self.rocket,\n            route: Atomic::new(self.route.load(Ordering::Acquire)),\n            cookies: self.cookies.clone(),\n            accept: self.accept.clone(),\n            content_type: self.content_type.clone(),\n            cache: self.cache.clone(),\n            host: self.host.clone(),\n        }\n    }\n}\n\nimpl<'r> Request<'r> {\n    /// Create a new `Request` with the given `method` and `uri`.\n    #[inline(always)]\n    pub(crate) fn new<'s: 'r>(\n        rocket: &'r Rocket<Orbit>,\n        method: Method,\n        uri: Origin<'s>\n    ) -> Request<'r> {\n        Request {\n            uri,\n            method: Atomic::new(method),\n            headers: HeaderMap::new(),\n            connection: ConnectionMeta {\n                remote: None,\n                client_certificates: None,\n            },\n            state: RequestState {\n                rocket,\n                route: Atomic::new(None),\n                cookies: CookieJar::new(rocket.config()),\n                accept: InitCell::new(),\n                content_type: InitCell::new(),\n                cache: Arc::new(<TypeMap![Send + Sync]>::new()),\n                host: None,\n            }\n        }\n    }\n\n    /// Retrieve the method from `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::Method;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// # let post = |uri| c.post(uri);\n    /// assert_eq!(get(\"/\").method(), Method::Get);\n    /// assert_eq!(post(\"/\").method(), Method::Post);\n    /// ```\n    #[inline(always)]\n    pub fn method(&self) -> Method {\n        self.method.load(Ordering::Acquire)\n    }\n\n    /// Set the method of `self` to `method`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::Method;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert_eq!(request.method(), Method::Get);\n    ///\n    /// request.set_method(Method::Post);\n    /// assert_eq!(request.method(), Method::Post);\n    /// ```\n    #[inline(always)]\n    pub fn set_method(&mut self, method: Method) {\n        self._set_method(method);\n    }\n\n    /// Borrow the [`Origin`] URI from `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert_eq!(get(\"/hello/rocketeer\").uri().path(), \"/hello/rocketeer\");\n    /// assert_eq!(get(\"/hello\").uri().query(), None);\n    /// ```\n    #[inline(always)]\n    pub fn uri(&self) -> &Origin<'r> {\n        &self.uri\n    }\n\n    /// Set the URI in `self` to `uri`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::uri::Origin;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// let uri = Origin::parse(\"/hello/Sergio?type=greeting\").unwrap();\n    /// request.set_uri(uri);\n    /// assert_eq!(request.uri().path(), \"/hello/Sergio\");\n    /// assert_eq!(request.uri().query().unwrap(), \"type=greeting\");\n    ///\n    /// let new_uri = request.uri().map_path(|p| format!(\"/foo{}\", p)).unwrap();\n    /// request.set_uri(new_uri);\n    /// assert_eq!(request.uri().path(), \"/foo/hello/Sergio\");\n    /// assert_eq!(request.uri().query().unwrap(), \"type=greeting\");\n    /// ```\n    #[inline(always)]\n    pub fn set_uri(&mut self, uri: Origin<'r>) {\n        self.uri = uri;\n    }\n\n    /// Returns the [`Host`] identified in the request, if any.\n    ///\n    /// If the request is made via HTTP/1.1 (or earlier), this method returns\n    /// the value in the `HOST` header without the deprecated `user_info`\n    /// component. Otherwise, this method returns the contents of the\n    /// `:authority` pseudo-header request field.\n    ///\n    /// Note that this method _only_ reflects the `HOST` header in the _initial_\n    /// request and not any changes made thereafter. To change the value\n    /// returned by this method, use [`Request::set_host()`].\n    ///\n    /// #  DANGER \n    ///\n    /// Using the user-controlled `host` to construct URLs is a security hazard!\n    /// _Never_ do so without first validating the host against a whitelist. For\n    /// this reason, Rocket disallows constructing host-prefixed URIs with\n    /// [`uri!`]. _Always_ use [`uri!`] to construct URIs.\n    ///\n    /// [`uri!`]: crate::uri!\n    ///\n    /// # Example\n    ///\n    /// Retrieve the raw host, unusable to construct safe URIs:\n    ///\n    /// ```rust\n    /// use rocket::http::uri::Host;\n    /// # use rocket::uri;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert_eq!(request.host(), None);\n    ///\n    /// request.set_host(Host::from(uri!(\"rocket.rs\")));\n    /// let host = request.host().unwrap();\n    /// assert_eq!(host.domain(), \"rocket.rs\");\n    /// assert_eq!(host.port(), None);\n    ///\n    /// request.set_host(Host::from(uri!(\"rocket.rs:2392\")));\n    /// let host = request.host().unwrap();\n    /// assert_eq!(host.domain(), \"rocket.rs\");\n    /// assert_eq!(host.port(), Some(2392));\n    /// ```\n    ///\n    /// Retrieve the raw host, check it against a whitelist, and construct a\n    /// URI:\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// # type Token = String;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    /// use rocket::http::uri::Host;\n    ///\n    /// // A sensitive URI we want to prefix with safe hosts.\n    /// #[get(\"/token?<secret>\")]\n    /// fn token(secret: Token) { /* .. */ }\n    ///\n    /// // Whitelist of known hosts. In a real setting, you might retrieve this\n    /// // list from config at ignite-time using tools like `AdHoc::config()`.\n    /// const WHITELIST: [Host<'static>; 3] = [\n    ///     Host::new(uri!(\"rocket.rs\")),\n    ///     Host::new(uri!(\"rocket.rs:443\")),\n    ///     Host::new(uri!(\"guide.rocket.rs:443\")),\n    /// ];\n    ///\n    /// // A request with a host of \"rocket.rs\". Note the case-insensitivity.\n    /// request.set_host(Host::from(uri!(\"ROCKET.rs\")));\n    /// let prefix = request.host().and_then(|h| h.to_absolute(\"https\", &WHITELIST));\n    ///\n    /// // `rocket.rs` is in the whitelist, so we'll get back a `Some`.\n    /// assert!(prefix.is_some());\n    /// if let Some(prefix) = prefix {\n    ///     // We can use this prefix to safely construct URIs.\n    ///     let uri = uri!(prefix, token(\"some-secret-token\"));\n    ///     assert_eq!(uri, \"https://ROCKET.rs/token?secret=some-secret-token\");\n    /// }\n    ///\n    /// // A request with a host of \"attacker-controlled.com\".\n    /// request.set_host(Host::from(uri!(\"attacker-controlled.com\")));\n    /// let prefix = request.host().and_then(|h| h.to_absolute(\"https\", &WHITELIST));\n    ///\n    /// // `attacker-controlled.come` is _not_ on the whitelist.\n    /// assert!(prefix.is_none());\n    /// assert!(request.host().is_some());\n    /// ```\n    #[inline(always)]\n    pub fn host(&self) -> Option<&Host<'r>> {\n        self.state.host.as_ref()\n    }\n\n    /// Sets the host of `self` to `host`.\n    ///\n    /// # Example\n    ///\n    /// Set the host to `rocket.rs:443`.\n    ///\n    /// ```rust\n    /// use rocket::http::uri::Host;\n    /// # use rocket::uri;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert_eq!(request.host(), None);\n    ///\n    /// request.set_host(Host::from(uri!(\"rocket.rs:443\")));\n    /// let host = request.host().unwrap();\n    /// assert_eq!(host.domain(), \"rocket.rs\");\n    /// assert_eq!(host.port(), Some(443));\n    /// ```\n    #[inline(always)]\n    pub fn set_host(&mut self, host: Host<'r>) {\n        self.state.host = Some(host);\n    }\n\n    /// Returns the raw address of the remote connection that initiated this\n    /// request if the address is known. If the address is not known, `None` is\n    /// returned.\n    ///\n    /// Because it is common for proxies to forward connections for clients, the\n    /// remote address may contain information about the proxy instead of the\n    /// client. For this reason, proxies typically set a \"X-Real-IP\" header\n    /// [`ip_header`](crate::Config::ip_header) with the client's true IP. To\n    /// extract this IP from the request, use the [`real_ip()`] or\n    /// [`client_ip()`] methods.\n    ///\n    /// [`real_ip()`]: #method.real_ip\n    /// [`client_ip()`]: #method.client_ip\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert_eq!(request.remote(), None);\n    ///\n    /// let localhost = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 8000).into();\n    /// request.set_remote(localhost);\n    /// assert_eq!(request.remote(), Some(localhost));\n    /// ```\n    #[inline(always)]\n    pub fn remote(&self) -> Option<SocketAddr> {\n        self.connection.remote\n    }\n\n    /// Sets the remote address of `self` to `address`.\n    ///\n    /// # Example\n    ///\n    /// Set the remote address to be 127.0.0.1:8000:\n    ///\n    /// ```rust\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert_eq!(request.remote(), None);\n    ///\n    /// let localhost = SocketAddrV4::new(Ipv4Addr::LOCALHOST, 8000).into();\n    /// request.set_remote(localhost);\n    /// assert_eq!(request.remote(), Some(localhost));\n    /// ```\n    #[inline(always)]\n    pub fn set_remote(&mut self, address: SocketAddr) {\n        self.connection.remote = Some(address);\n    }\n\n    /// Returns the IP address of the configured\n    /// [`ip_header`](crate::Config::ip_header) of the request if such a header\n    /// is configured, exists and contains a valid IP address.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::net::Ipv4Addr;\n    /// use rocket::http::Header;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let req = c.get(\"/\");\n    /// assert_eq!(req.real_ip(), None);\n    ///\n    /// // `ip_header` defaults to `X-Real-IP`.\n    /// let req = req.header(Header::new(\"X-Real-IP\", \"127.0.0.1\"));\n    /// assert_eq!(req.real_ip(), Some(Ipv4Addr::LOCALHOST.into()));\n    /// ```\n    pub fn real_ip(&self) -> Option<IpAddr> {\n        let ip_header = self.rocket().config.ip_header.as_ref()?.as_str();\n        self.headers()\n            .get_one(ip_header)\n            .and_then(|ip| {\n                ip.parse()\n                    .map_err(|_| warn_!(\"'{}' header is malformed: {}\", ip_header, ip))\n                    .ok()\n            })\n    }\n\n    /// Attempts to return the client's IP address by first inspecting the\n    /// [`ip_header`](crate::Config::ip_header) and then using the remote\n    /// connection's IP address. Note that the built-in `IpAddr` request guard\n    /// can be used to retrieve the same information in a handler:\n    ///\n    /// ```rust\n    /// # use rocket::get;\n    /// use std::net::IpAddr;\n    ///\n    /// #[get(\"/\")]\n    /// fn get_ip(client_ip: IpAddr) { /* ... */ }\n    ///\n    /// #[get(\"/\")]\n    /// fn try_get_ip(client_ip: Option<IpAddr>) { /* ... */ }\n    /// ````\n    ///\n    /// If the `ip_header` exists and contains a valid IP address, that address\n    /// is returned. Otherwise, if the address of the remote connection is\n    /// known, that address is returned. Otherwise, `None` is returned.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::http::Header;\n    /// # use std::net::{SocketAddr, IpAddr, Ipv4Addr};\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// // starting without an \"X-Real-IP\" header or remote address\n    /// assert!(request.client_ip().is_none());\n    ///\n    /// // add a remote address; this is done by Rocket automatically\n    /// request.set_remote(\"127.0.0.1:8000\".parse().unwrap());\n    /// assert_eq!(request.client_ip(), Some(\"127.0.0.1\".parse().unwrap()));\n    ///\n    /// // now with an X-Real-IP header, the default value for `ip_header`.\n    /// request.add_header(Header::new(\"X-Real-IP\", \"8.8.8.8\"));\n    /// assert_eq!(request.client_ip(), Some(\"8.8.8.8\".parse().unwrap()));\n    /// ```\n    #[inline]\n    pub fn client_ip(&self) -> Option<IpAddr> {\n        self.real_ip().or_else(|| self.remote().map(|r| r.ip()))\n    }\n\n    /// Returns a wrapped borrow to the cookies in `self`.\n    ///\n    /// [`CookieJar`] implements internal mutability, so this method allows you\n    /// to get _and_ add/remove cookies in `self`.\n    ///\n    /// # Example\n    ///\n    /// Add a new cookie to a request's cookies:\n    ///\n    /// ```rust\n    /// use rocket::http::Cookie;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    /// # let req = request.inner();\n    /// req.cookies().add((\"key\", \"val\"));\n    /// req.cookies().add((\"ans\", format!(\"life: {}\", 38 + 4)));\n    ///\n    /// assert_eq!(req.cookies().get_pending(\"key\").unwrap().value(), \"val\");\n    /// assert_eq!(req.cookies().get_pending(\"ans\").unwrap().value(), \"life: 42\");\n    /// ```\n    #[inline(always)]\n    pub fn cookies(&self) -> &CookieJar<'r> {\n        &self.state.cookies\n    }\n\n    /// Returns a [`HeaderMap`] of all of the headers in `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::{Accept, ContentType};\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert!(get(\"/\").headers().is_empty());\n    ///\n    /// let req = get(\"/\").header(Accept::HTML).header(ContentType::HTML);\n    /// assert_eq!(req.headers().len(), 2);\n    /// ```\n    #[inline(always)]\n    pub fn headers(&self) -> &HeaderMap<'r> {\n        &self.headers\n    }\n\n    /// Add `header` to `self`'s headers. The type of `header` can be any type\n    /// that implements the `Into<Header>` trait. This includes common types\n    /// such as [`ContentType`] and [`Accept`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::ContentType;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert!(request.headers().is_empty());\n    ///\n    /// request.add_header(ContentType::HTML);\n    /// assert!(request.headers().contains(\"Content-Type\"));\n    /// assert_eq!(request.headers().len(), 1);\n    /// ```\n    #[inline]\n    pub fn add_header<'h: 'r, H: Into<Header<'h>>>(&mut self, header: H) {\n        let header = header.into();\n        self.bust_header_cache(header.name(), false);\n        self.headers.add(header);\n    }\n\n    /// Replaces the value of the header with name `header.name` with\n    /// `header.value`. If no such header exists, `header` is added as a header\n    /// to `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::ContentType;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let mut req = c.get(\"/\");\n    /// # let request = req.inner_mut();\n    ///\n    /// assert!(request.headers().is_empty());\n    ///\n    /// request.add_header(ContentType::Any);\n    /// assert_eq!(request.headers().get_one(\"Content-Type\"), Some(\"*/*\"));\n    /// assert_eq!(request.content_type(), Some(&ContentType::Any));\n    ///\n    /// request.replace_header(ContentType::PNG);\n    /// assert_eq!(request.headers().get_one(\"Content-Type\"), Some(\"image/png\"));\n    /// assert_eq!(request.content_type(), Some(&ContentType::PNG));\n    /// ```\n    #[inline]\n    pub fn replace_header<'h: 'r, H: Into<Header<'h>>>(&mut self, header: H) {\n        let header = header.into();\n        self.bust_header_cache(header.name(), true);\n        self.headers.replace(header);\n    }\n\n    /// Returns the Content-Type header of `self`. If the header is not present,\n    /// returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::ContentType;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert_eq!(get(\"/\").content_type(), None);\n    ///\n    /// let req = get(\"/\").header(ContentType::JSON);\n    /// assert_eq!(req.content_type(), Some(&ContentType::JSON));\n    /// ```\n    #[inline]\n    pub fn content_type(&self) -> Option<&ContentType> {\n        self.state.content_type.get_or_init(|| {\n            self.headers().get_one(\"Content-Type\").and_then(|v| v.parse().ok())\n        }).as_ref()\n    }\n\n    /// Returns the Accept header of `self`. If the header is not present,\n    /// returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::Accept;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert_eq!(get(\"/\").accept(), None);\n    /// assert_eq!(get(\"/\").header(Accept::JSON).accept(), Some(&Accept::JSON));\n    /// ```\n    #[inline]\n    pub fn accept(&self) -> Option<&Accept> {\n        self.state.accept.get_or_init(|| {\n            self.headers().get_one(\"Accept\").and_then(|v| v.parse().ok())\n        }).as_ref()\n    }\n\n    /// Returns the media type \"format\" of the request.\n    ///\n    /// The \"format\" of a request is either the Content-Type, if the request\n    /// methods indicates support for a payload, or the preferred media type in\n    /// the Accept header otherwise. If the method indicates no payload and no\n    /// Accept header is specified, a media type of `Any` is returned.\n    ///\n    /// The media type returned from this method is used to match against the\n    /// `format` route attribute.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::http::{Accept, ContentType, MediaType};\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// # let post = |uri| c.post(uri);\n    ///\n    /// // Non-payload-bearing: format is accept header.\n    /// let req = get(\"/\").header(Accept::HTML);\n    /// assert_eq!(req.format(), Some(&MediaType::HTML));\n    ///\n    /// let req = get(\"/\").header(ContentType::JSON).header(Accept::HTML);\n    /// assert_eq!(req.format(), Some(&MediaType::HTML));\n    ///\n    /// // Payload: format is content-type header.\n    /// let req = post(\"/\").header(ContentType::HTML);\n    /// assert_eq!(req.format(), Some(&MediaType::HTML));\n    ///\n    /// let req = post(\"/\").header(ContentType::JSON).header(Accept::HTML);\n    /// assert_eq!(req.format(), Some(&MediaType::JSON));\n    ///\n    /// // Non-payload-bearing method and no accept header: `Any`.\n    /// assert_eq!(get(\"/\").format(), Some(&MediaType::Any));\n    /// ```\n    pub fn format(&self) -> Option<&MediaType> {\n        static ANY: MediaType = MediaType::Any;\n        if self.method().supports_payload() {\n            self.content_type().map(|ct| ct.media_type())\n        } else {\n            // FIXME: Should we be using `accept_first` or `preferred`? Or\n            // should we be checking neither and instead pass things through\n            // where the client accepts the thing at all?\n            self.accept()\n                .map(|accept| accept.preferred().media_type())\n                .or(Some(&ANY))\n        }\n    }\n\n    /// Returns the [`Rocket`] instance that is handling this request.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    /// # type Pool = usize;\n    /// // Retrieve the application config via `Rocket::config()`.\n    /// let config = request.rocket().config();\n    ///\n    /// // Retrieve managed state via `Rocket::state()`.\n    /// let state = request.rocket().state::<Pool>();\n    ///\n    /// // Get a list of all of the registered routes and catchers.\n    /// let routes = request.rocket().routes();\n    /// let catchers = request.rocket().catchers();\n    /// ```\n    #[inline(always)]\n    pub fn rocket(&self) -> &'r Rocket<Orbit> {\n        &self.state.rocket\n    }\n\n    /// Returns the configured application data limits.\n    ///\n    /// This is convenience function equivalent to:\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    /// &request.rocket().config().limits\n    /// # ;\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::data::ToByteUnit;\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    ///\n    /// // This is the default `form` limit.\n    /// assert_eq!(request.limits().get(\"form\"), Some(32.kibibytes()));\n    ///\n    /// // Retrieve the limit for files with extension `.pdf`; etails to 1MiB.\n    /// assert_eq!(request.limits().get(\"file/pdf\"), Some(1.mebibytes()));\n    /// ```\n    #[inline(always)]\n    pub fn limits(&self) -> &'r Limits {\n        &self.rocket().config().limits\n    }\n\n    /// Get the presently matched route, if any.\n    ///\n    /// This method returns `Some` any time a handler or its guards are being\n    /// invoked. This method returns `None` _before_ routing has commenced; this\n    /// includes during request fairing callbacks.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    /// let route = request.route();\n    /// ```\n    #[inline(always)]\n    pub fn route(&self) -> Option<&'r Route> {\n        self.state.route.load(Ordering::Acquire)\n    }\n\n    /// Invokes the request guard implementation for `T`, returning its outcome.\n    ///\n    /// # Example\n    ///\n    /// Assuming a `User` request guard exists, invoke it:\n    ///\n    /// ```rust\n    /// # type User = rocket::http::Method;\n    /// # rocket::async_test(async move {\n    /// # let c = rocket::local::asynchronous::Client::debug_with(vec![]).await.unwrap();\n    /// # let request = c.get(\"/\");\n    /// let outcome = request.guard::<User>().await;\n    /// # })\n    /// ```\n    #[inline(always)]\n    pub fn guard<'z, 'a, T>(&'a self) -> BoxFuture<'z, Outcome<T, T::Error>>\n        where T: FromRequest<'a> + 'z, 'a: 'z, 'r: 'z\n    {\n        T::from_request(self)\n    }\n\n    /// Retrieves the cached value for type `T` from the request-local cached\n    /// state of `self`. If no such value has previously been cached for this\n    /// request, `f` is called to produce the value which is subsequently\n    /// returned.\n    ///\n    /// Different values of the same type _cannot_ be cached without using a\n    /// proxy, wrapper type. To avoid the need to write these manually, or for\n    /// libraries wishing to store values of public types, use the\n    /// [`local_cache!`](crate::request::local_cache) or\n    /// [`local_cache_once!`](crate::request::local_cache_once) macros to\n    /// generate a locally anonymous wrapper type, store, and retrieve the\n    /// wrapped value from request-local cache.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let request = c.get(\"/\");\n    /// // The first store into local cache for a given type wins.\n    /// let value = request.local_cache(|| \"hello\");\n    /// assert_eq!(*request.local_cache(|| \"hello\"), \"hello\");\n    ///\n    /// // The following return the cached, previously stored value for the type.\n    /// assert_eq!(*request.local_cache(|| \"goodbye\"), \"hello\");\n    /// ```\n    #[inline]\n    pub fn local_cache<T, F>(&self, f: F) -> &T\n        where F: FnOnce() -> T,\n              T: Send + Sync + 'static\n    {\n        self.state.cache.try_get()\n            .unwrap_or_else(|| {\n                self.state.cache.set(f());\n                self.state.cache.get()\n            })\n    }\n\n    /// Retrieves the cached value for type `T` from the request-local cached\n    /// state of `self`. If no such value has previously been cached for this\n    /// request, `fut` is `await`ed to produce the value which is subsequently\n    /// returned.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::Request;\n    /// # type User = ();\n    /// async fn current_user<'r>(request: &Request<'r>) -> User {\n    ///     // validate request for a given user, load from database, etc\n    /// }\n    ///\n    /// # rocket::async_test(async move {\n    /// # let c = rocket::local::asynchronous::Client::debug_with(vec![]).await.unwrap();\n    /// # let request = c.get(\"/\");\n    /// let current_user = request.local_cache_async(async {\n    ///     current_user(&request).await\n    /// }).await;\n    /// # })\n    /// ```\n    #[inline]\n    pub async fn local_cache_async<'a, T, F>(&'a self, fut: F) -> &'a T\n        where F: Future<Output = T>,\n              T: Send + Sync + 'static\n    {\n        match self.state.cache.try_get() {\n            Some(s) => s,\n            None => {\n                self.state.cache.set(fut.await);\n                self.state.cache.get()\n            }\n        }\n    }\n\n    /// Retrieves and parses into `T` the 0-indexed `n`th non-empty segment from\n    /// the _routed_ request, that is, the `n`th segment _after_ the mount\n    /// point. If the request has not been routed, then this is simply the `n`th\n    /// non-empty request URI segment.\n    ///\n    /// Returns `None` if `n` is greater than the number of non-empty segments.\n    /// Returns `Some(Err(T::Error))` if the parameter type `T` failed to be\n    /// parsed from the `n`th dynamic parameter.\n    ///\n    /// This method exists only to be used by manual routing. To retrieve\n    /// parameters from a request, use Rocket's code generation facilities.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert_eq!(get(\"/a/b/c\").param(0), Some(Ok(\"a\")));\n    /// assert_eq!(get(\"/a/b/c\").param(1), Some(Ok(\"b\")));\n    /// assert_eq!(get(\"/a/b/c\").param(2), Some(Ok(\"c\")));\n    /// assert_eq!(get(\"/a/b/c\").param::<&str>(3), None);\n    ///\n    /// assert_eq!(get(\"/1/b/3\").param(0), Some(Ok(1)));\n    /// assert!(get(\"/1/b/3\").param::<usize>(1).unwrap().is_err());\n    /// assert_eq!(get(\"/1/b/3\").param(2), Some(Ok(3)));\n    ///\n    /// assert_eq!(get(\"/\").param::<&str>(0), None);\n    /// ```\n    #[inline]\n    pub fn param<'a, T>(&'a self, n: usize) -> Option<Result<T, T::Error>>\n        where T: FromParam<'a>\n    {\n        self.routed_segment(n).map(T::from_param)\n    }\n\n    /// Retrieves and parses into `T` all of the path segments in the request\n    /// URI beginning and including the 0-indexed `n`th non-empty segment\n    /// _after_ the mount point.,that is, the `n`th segment _after_ the mount\n    /// point. If the request has not been routed, then this is simply the `n`th\n    /// non-empty request URI segment.\n    ///\n    /// `T` must implement [`FromSegments`], which is used to parse the\n    /// segments. If there are no non-empty segments, the `Segments` iterator\n    /// will be empty.\n    ///\n    /// This method exists only to be used by manual routing. To retrieve\n    /// segments from a request, use Rocket's code generation facilities.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::path::PathBuf;\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// assert_eq!(get(\"/\").segments(0..), Ok(PathBuf::new()));\n    /// assert_eq!(get(\"/\").segments(2..), Ok(PathBuf::new()));\n    ///\n    /// // Empty segments are skipped.\n    /// assert_eq!(get(\"///\").segments(2..), Ok(PathBuf::new()));\n    /// assert_eq!(get(\"/a/b/c\").segments(0..), Ok(PathBuf::from(\"a/b/c\")));\n    /// assert_eq!(get(\"/a/b/c\").segments(1..), Ok(PathBuf::from(\"b/c\")));\n    /// assert_eq!(get(\"/a/b/c\").segments(2..), Ok(PathBuf::from(\"c\")));\n    /// assert_eq!(get(\"/a/b/c\").segments(3..), Ok(PathBuf::new()));\n    /// assert_eq!(get(\"/a/b/c\").segments(4..), Ok(PathBuf::new()));\n    /// ```\n    #[inline]\n    pub fn segments<'a, T>(&'a self, n: RangeFrom<usize>) -> Result<T, T::Error>\n        where T: FromSegments<'a>\n    {\n        T::from_segments(self.routed_segments(n))\n    }\n\n    /// Retrieves and parses into `T` the query value with field name `name`.\n    /// `T` must implement [`FromForm`], which is used to parse the query's\n    /// value. Key matching is performed case-sensitively.\n    ///\n    /// # Warning\n    ///\n    /// This method exists _only_ to be used by manual routing and should\n    /// _never_ be used in a regular Rocket application. It is much more\n    /// expensive to use this method than to retrieve query parameters via\n    /// Rocket's codegen. To retrieve query values from a request, _always_\n    /// prefer to use Rocket's code generation facilities.\n    ///\n    /// # Error\n    ///\n    /// If a query segment with name `name` isn't present, returns `None`. If\n    /// parsing the value fails, returns `Some(Err(_))`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::FromForm;\n    ///\n    /// #[derive(Debug, PartialEq, FromForm)]\n    /// struct Dog<'r> {\n    ///     name: &'r str,\n    ///     age: usize\n    /// }\n    ///\n    /// # let c = rocket::local::blocking::Client::debug_with(vec![]).unwrap();\n    /// # let get = |uri| c.get(uri);\n    /// let req = get(\"/?a=apple&z=zebra&a=aardvark\");\n    /// assert_eq!(req.query_value::<&str>(\"a\").unwrap(), Ok(\"apple\"));\n    /// assert_eq!(req.query_value::<&str>(\"z\").unwrap(), Ok(\"zebra\"));\n    /// assert_eq!(req.query_value::<&str>(\"b\"), None);\n    ///\n    /// let a_seq = req.query_value::<Vec<&str>>(\"a\");\n    /// assert_eq!(a_seq.unwrap().unwrap(), [\"apple\", \"aardvark\"]);\n    ///\n    /// let req = get(\"/?dog.name=Max+Fido&dog.age=3\");\n    /// let dog = req.query_value::<Dog>(\"dog\");\n    /// assert_eq!(dog.unwrap().unwrap(), Dog { name: \"Max Fido\", age: 3 });\n    /// ```\n    #[inline]\n    pub fn query_value<'a, T>(&'a self, name: &str) -> Option<form::Result<'a, T>>\n        where T: FromForm<'a>\n    {\n        if self.query_fields().find(|f| f.name == name).is_none() {\n            return None;\n        }\n\n        let mut ctxt = T::init(form::Options::Lenient);\n\n        self.query_fields()\n            .filter(|f| f.name == name)\n            .for_each(|f| T::push_value(&mut ctxt, f.shift()));\n\n        Some(T::finalize(ctxt))\n    }\n}\n\n// All of these methods only exist for internal, including codegen, purposes.\n// They _are not_ part of the stable API. Please, don't use these.\n#[doc(hidden)]\nimpl<'r> Request<'r> {\n    /// Resets the cached value (if any) for the header with name `name`.\n    fn bust_header_cache(&mut self, name: &UncasedStr, replace: bool) {\n        if name == \"Content-Type\" {\n            if self.content_type().is_none() || replace {\n                self.state.content_type = InitCell::new();\n            }\n        } else if name == \"Accept\" {\n            if self.accept().is_none() || replace {\n                self.state.accept = InitCell::new();\n            }\n        }\n    }\n\n    /// Get the `n`th path segment, 0-indexed, after the mount point for the\n    /// currently matched route, as a string, if it exists. Used by codegen.\n    #[inline]\n    pub fn routed_segment(&self, n: usize) -> Option<&str> {\n        self.routed_segments(0..).get(n)\n    }\n\n    /// Get the segments beginning at the `n`th, 0-indexed, after the mount\n    /// point for the currently matched route, if they exist. Used by codegen.\n    #[inline]\n    pub fn routed_segments(&self, n: RangeFrom<usize>) -> Segments<'_, Path> {\n        let mount_segments = self.route()\n            .map(|r| r.uri.metadata.base_segs.len())\n            .unwrap_or(0);\n\n        self.uri().path().segments().skip(mount_segments + n.start)\n    }\n\n    // Retrieves the pre-parsed query items. Used by matching and codegen.\n    #[inline]\n    pub fn query_fields(&self) -> impl Iterator<Item = ValueField<'_>> {\n        self.uri().query()\n            .map(|q| q.segments().map(ValueField::from))\n            .into_iter()\n            .flatten()\n    }\n\n    /// Set `self`'s parameters given that the route used to reach this request\n    /// was `route`. Use during routing when attempting a given route.\n    #[inline(always)]\n    pub(crate) fn set_route(&self, route: &'r Route) {\n        self.state.route.store(Some(route), Ordering::Release)\n    }\n\n    /// Set the method of `self`, even when `self` is a shared reference. Used\n    /// during routing to override methods for re-routing.\n    #[inline(always)]\n    pub(crate) fn _set_method(&self, method: Method) {\n        self.method.store(method, Ordering::Release)\n    }\n\n    pub(crate) fn cookies_mut(&mut self) -> &mut CookieJar<'r> {\n        &mut self.state.cookies\n    }\n\n    /// Convert from Hyper types into a Rocket Request.\n    pub(crate) fn from_hyp(\n        rocket: &'r Rocket<Orbit>,\n        hyper: &'r hyper::request::Parts,\n        connection: Option<ConnectionMeta>,\n    ) -> Result<Request<'r>, BadRequest<'r>> {\n        // Keep track of parsing errors; emit a `BadRequest` if any exist.\n        let mut errors = vec![];\n\n        // Ensure that the method is known. TODO: Allow made-up methods?\n        let method = Method::from_hyp(&hyper.method)\n            .unwrap_or_else(|| {\n                errors.push(Kind::BadMethod(&hyper.method));\n                Method::Get\n            });\n\n        // TODO: Keep around not just the path/query, but the rest, if there?\n        let uri = hyper.uri.path_and_query()\n            .map(|uri| {\n                // In debug, make sure we agree with Hyper about URI validity.\n                // If we disagree, log a warning but continue anyway; if this is\n                // a security issue with Hyper, there isn't much we can do.\n                #[cfg(debug_assertions)]\n                if Origin::parse(uri.as_str()).is_err() {\n                    warn!(\"Hyper/Rocket URI validity discord: {:?}\", uri.as_str());\n                    info_!(\"Hyper believes the URI is valid while Rocket disagrees.\");\n                    info_!(\"This is likely a Hyper bug with potential security implications.\");\n                    warn_!(\"Please report this warning to Rocket's GitHub issue tracker.\");\n                }\n\n                Origin::new(uri.path(), uri.query().map(Cow::Borrowed))\n            })\n            .unwrap_or_else(|| {\n                errors.push(Kind::InvalidUri(&hyper.uri));\n                Origin::ROOT\n            });\n\n        // Construct the request object; fill in metadata and headers next.\n        let mut request = Request::new(rocket, method, uri);\n\n        // Set the passed in connection metadata.\n        if let Some(connection) = connection {\n            request.connection = connection;\n        }\n\n        // Determine + set host. On HTTP < 2, use the `HOST` header. Otherwise,\n        // use the `:authority` pseudo-header which hyper makes part of the URI.\n        request.state.host = if hyper.version < hyper::Version::HTTP_2 {\n            hyper.headers.get(\"host\").and_then(|h| Host::parse_bytes(h.as_bytes()).ok())\n        } else {\n            hyper.uri.host().map(|h| Host::new(Authority::new(None, h, hyper.uri.port_u16())))\n        };\n\n        // Set the request cookies, if they exist.\n        for header in hyper.headers.get_all(\"Cookie\") {\n            let raw_str = match std::str::from_utf8(header.as_bytes()) {\n                Ok(string) => string,\n                Err(_) => continue\n            };\n\n            for cookie_str in raw_str.split(';').map(|s| s.trim()) {\n                if let Ok(cookie) = Cookie::parse_encoded(cookie_str) {\n                    request.state.cookies.add_original(cookie.into_owned());\n                }\n            }\n        }\n\n        // Set the rest of the headers. This is rather unfortunate and slow.\n        for (name, value) in hyper.headers.iter() {\n            // FIXME: This is rather unfortunate. Header values needn't be UTF8.\n            let value = match std::str::from_utf8(value.as_bytes()) {\n                Ok(value) => value,\n                Err(_) => {\n                    warn!(\"Header '{}' contains invalid UTF-8\", name);\n                    warn_!(\"Rocket only supports UTF-8 header values. Dropping header.\");\n                    continue;\n                }\n            };\n\n            request.add_header(Header::new(name.as_str(), value));\n        }\n\n        if errors.is_empty() {\n            Ok(request)\n        } else {\n            Err(BadRequest { request, errors })\n        }\n    }\n}\n\n#[derive(Debug)]\npub(crate) struct BadRequest<'r> {\n    pub request: Request<'r>,\n    pub errors: Vec<Kind<'r>>,\n}\n\n#[derive(Debug)]\npub(crate) enum Kind<'r> {\n    InvalidUri(&'r hyper::Uri),\n    BadMethod(&'r hyper::Method),\n}\n\nimpl fmt::Display for Kind<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Kind::InvalidUri(u) => write!(f, \"invalid origin URI: {}\", u),\n            Kind::BadMethod(m) => write!(f, \"invalid or unrecognized method: {}\", m),\n        }\n    }\n}\n\nimpl fmt::Debug for Request<'_> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"Request\")\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"headers\", &self.headers())\n            .field(\"remote\", &self.remote())\n            .field(\"cookies\", &self.cookies())\n            .finish()\n    }\n}\n\nimpl fmt::Display for Request<'_> {\n    /// Pretty prints a Request. Primarily used by Rocket's logging.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{} {}\", self.method().green(), self.uri.blue())?;\n\n        // Print the requests media type when the route specifies a format.\n        if let Some(mime) = self.format() {\n            if !mime.is_any() {\n                write!(f, \" {}/{}\", mime.top().yellow().linger(), mime.sub().resetting())?;\n            }\n        }\n\n        Ok(())\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::collections::HashMap;\n\nuse crate::Request;\nuse crate::local::blocking::Client;\nuse crate::http::hyper;\n\nmacro_rules! assert_headers {\n    ($($key:expr => [$($value:expr),+]),+) => ({\n        // Create a new Hyper request. Add all of the passed in headers.\n        let mut req = hyper::Request::get(\"/test\").body(()).unwrap();\n        $($(req.headers_mut().append($key, hyper::HeaderValue::from_str($value).unwrap());)+)+\n\n        // Build up what we expect the headers to actually be.\n        let mut expected = HashMap::new();\n        $(expected.entry($key).or_insert(vec![]).append(&mut vec![$($value),+]);)+\n\n        // Create a valid `Rocket` and convert the hyper req to a Rocket one.\n        let client = Client::debug_with(vec![]).unwrap();\n        let hyper = req.into_parts().0;\n        let req = Request::from_hyp(client.rocket(), &hyper, None).unwrap();\n\n        // Dispatch the request and check that the headers match.\n        let actual_headers = req.headers();\n        for (key, values) in expected.iter() {\n            let actual: Vec<_> = actual_headers.get(key).collect();\n            assert_eq!(*values, actual);\n        }\n    })\n}\n\n#[test]\nfn test_multiple_headers_from_hyp() {\n    assert_headers!(\"friends\" => [\"alice\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob, carol\"]);\n    assert_headers!(\"friends\" => [\"alice, david\", \"bob, carol\", \"eric, frank\"]);\n    assert_headers!(\"friends\" => [\"alice\"], \"enemies\" => [\"victor\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob\"], \"enemies\" => [\"david\", \"emily\"]);\n}\n\n#[test]\nfn test_multiple_headers_merge_into_one_from_hyp() {\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"]);\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"], \"friend\" => [\"carol\"]);\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"], \"enemy\" => [\"carol\"]);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{io, fmt};\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\n\nuse tokio::io::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt, ReadBuf};\n\n/// The body of a [`Response`].\n///\n/// A `Body` is never created directly, but instead, through the following\n/// methods on `Response` and `Builder`:\n///\n///   * [`Builder::sized_body()`]\n///   * [`Response::set_sized_body()`]\n///   * [`Builder::streamed_body()`]\n///   * [`Response::set_streamed_body()`]\n///\n/// [`Response`]: crate::Response\n/// [`Builder`]: crate::response::Builder\n/// [`Response::set_sized_body()`]: crate::Response::set_sized_body\n/// [`Response::set_streamed_body()`]: crate::Response::set_streamed_body\n/// [`Builder::sized_body()`]: crate::response::Builder::sized_body\n/// [`Builder::streamed_body()`]: crate::response::Builder::streamed_body\n///\n/// An unset body in a `Response` begins as a [`Body::default()`], a `None`\n/// body with a preset size of `0`.\n///\n/// # Sizing\n///\n/// A response body may be sized or unsized (\"streamed\"). A \"sized\" body is\n/// transferred with a `Content-Length` equal to its size while an \"unsized\"\n/// body is chunk-encoded. The body data is streamed in _all_ cases and is never\n/// buffered in memory beyond a minimal amount for efficient transmission.\n///\n/// ## Sized\n///\n/// A sized body may have a _preset_ size ([`Body::preset_size()`]) or may have\n/// its size computed on the fly by seeking ([`Body::size()`]). As such, sized\n/// bodies must implement [`AsyncSeek`]. If a body does not have a preset size\n/// and the fails to be computed dynamically, a sized body is treated as an\n/// unsized body when written out to the network.\n///\n/// ## Unsized\n///\n/// An unsized body's data is streamed as it arrives. In other words, as soon as\n/// the body's [`AsyncRead`] implementation returns bytes, the bytes are written\n/// to the network. Individual unsized bodies may use an internal buffer to\n/// curtail writes to the network.\n///\n/// The maximum number of bytes written to the network at once is controlled via\n/// the [`Body::max_chunk_size()`] parameter which can be set via\n/// [`Response::set_max_chunk_size()`] and [`Builder::max_chunk_size()`].\n///\n/// [`Response::set_max_chunk_size()`]: crate::Response::set_max_chunk_size\n/// [`Builder::max_chunk_size()`]: crate::response::Builder::max_chunk_size\n///\n/// # Reading\n///\n/// The contents of a body, decoded, can be read through [`Body::to_bytes()`],\n/// [`Body::to_string()`], or directly though `Body`'s [`AsyncRead`]\n/// implementation.\n#[derive(Debug)]\npub struct Body<'r> {\n    /// The size of the body, if it is known.\n    size: Option<usize>,\n    /// The body itself.\n    inner: Inner<'r>,\n    /// The maximum chunk size.\n    max_chunk: usize,\n}\n\n/// A \"trait alias\" of sorts so we can use `AsyncRead + AsyncSeek` in `dyn`.\npub trait AsyncReadSeek: AsyncRead + AsyncSeek { }\n\n/// Implemented for all `AsyncRead + AsyncSeek`, of course.\nimpl<T: AsyncRead + AsyncSeek> AsyncReadSeek for T {  }\n\n/// A pinned `AsyncRead + AsyncSeek` body type.\ntype SizedBody<'r> = Pin<Box<dyn AsyncReadSeek + Send + 'r>>;\n\n/// A pinned `AsyncRead` (not `AsyncSeek`) body type.\ntype UnsizedBody<'r> = Pin<Box<dyn AsyncRead + Send + 'r>>;\n\nenum Inner<'r> {\n    /// A body that can be seeked to determine it's size.\n    Seekable(SizedBody<'r>),\n    /// A body that has no known size.\n    Unsized(UnsizedBody<'r>),\n    /// A body that \"exists\" but only for metadata calculations.\n    Phantom(SizedBody<'r>),\n    /// An empty body: no body at all.\n    None,\n}\n\nimpl Default for Body<'_> {\n    fn default() -> Self {\n        Body {\n            size: Some(0),\n            inner: Inner::None,\n            max_chunk: Body::DEFAULT_MAX_CHUNK,\n        }\n    }\n}\n\nimpl<'r> Body<'r> {\n    /// The default max size, in bytes, of chunks for streamed responses.\n    ///\n    /// The present value is `4096`.\n    pub const DEFAULT_MAX_CHUNK: usize = 4096;\n\n    pub(crate) fn with_sized<T>(body: T, preset_size: Option<usize>) -> Self\n        where T: AsyncReadSeek + Send + 'r\n    {\n        Body {\n            size: preset_size,\n            inner: Inner::Seekable(Box::pin(body)),\n            max_chunk: Body::DEFAULT_MAX_CHUNK,\n        }\n    }\n\n    pub(crate) fn with_unsized<T>(body: T) -> Self\n        where T: AsyncRead + Send + 'r\n    {\n        Body {\n            size: None,\n            inner: Inner::Unsized(Box::pin(body)),\n            max_chunk: Body::DEFAULT_MAX_CHUNK,\n        }\n    }\n\n    pub(crate) fn set_max_chunk_size(&mut self, max_chunk: usize) {\n        self.max_chunk = max_chunk;\n    }\n\n    pub(crate) fn strip(&mut self) {\n        let body = std::mem::take(self);\n        *self = match body.inner {\n            Inner::Seekable(b) | Inner::Phantom(b) => Body {\n                size: body.size,\n                inner: Inner::Phantom(b),\n                max_chunk: body.max_chunk,\n            },\n            Inner::Unsized(_) | Inner::None => Body::default()\n        };\n    }\n\n    /// Returns `true` if the body is `None` or unset, the default.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::Response;\n    ///\n    /// let r = Response::build().finalize();\n    /// assert!(r.body().is_none());\n    /// ```\n    #[inline(always)]\n    pub fn is_none(&self) -> bool {\n        matches!(self.inner, Inner::None)\n    }\n\n    /// Returns `true` if the body is _not_ `None`, anything other than the\n    /// default.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::response::Response;\n    ///\n    /// let body = \"Brewing the best coffee!\";\n    /// let r = Response::build()\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// assert!(r.body().is_some());\n    /// ```\n    #[inline(always)]\n    pub fn is_some(&self) -> bool {\n        !self.is_none()\n    }\n\n    /// A body's preset size, which may have been computed by a previous call to\n    /// [`Body::size()`].\n    ///\n    /// Unsized bodies _always_ return `None`, while sized bodies return `Some`\n    /// if the body size was supplied directly on creation or a call to\n    /// [`Body::size()`] successfully computed the size and `None` otherwise.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::response::Response;\n    ///\n    /// # rocket::async_test(async {\n    /// let body = \"Brewing the best coffee!\";\n    /// let r = Response::build()\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// // This will _always_ return `Some`.\n    /// assert_eq!(r.body().preset_size(), Some(body.len()));\n    ///\n    /// let r = Response::build()\n    ///     .streamed_body(Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// // This will _never_ return `Some`.\n    /// assert_eq!(r.body().preset_size(), None);\n    ///\n    /// let mut r = Response::build()\n    ///     .sized_body(None, Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// // This returns `Some` only after a call to `size()`.\n    /// assert_eq!(r.body().preset_size(), None);\n    /// assert_eq!(r.body_mut().size().await, Some(body.len()));\n    /// assert_eq!(r.body().preset_size(), Some(body.len()));\n    /// # });\n    /// ```\n    pub fn preset_size(&self) -> Option<usize> {\n        self.size\n    }\n\n    /// Returns the maximum chunk size for chunked transfers.\n    ///\n    /// If none is explicitly set, defaults to [`Body::DEFAULT_MAX_CHUNK`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::response::{Response, Body};\n    ///\n    /// let body = \"Brewing the best coffee!\";\n    /// let r = Response::build()\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// assert_eq!(r.body().max_chunk_size(), Body::DEFAULT_MAX_CHUNK);\n    ///\n    /// let r = Response::build()\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .max_chunk_size(1024)\n    ///     .finalize();\n    ///\n    /// assert_eq!(r.body().max_chunk_size(), 1024);\n    /// ```\n    pub fn max_chunk_size(&self) -> usize {\n        self.max_chunk\n    }\n\n    /// Attempts to compute the body's size and returns it if the body is sized.\n    ///\n    /// If the size was preset (see [`Body::preset_size()`]), the value is\n    /// returned immediately as `Some`. If the body is unsized or computing the\n    /// size fails, returns `None`. Otherwise, the size is computed by seeking,\n    /// and the `preset_size` is updated to reflect the known value.\n    ///\n    /// **Note:** the number of bytes read from the reader and/or written to the\n    /// network may differ from the value returned by this method. Some examples\n    /// include:\n    ///\n    ///   * bodies in response to `HEAD` requests are never read or written\n    ///   * the client may close the connection before the body is read fully\n    ///   * reading the body may fail midway\n    ///   * a preset size may differ from the actual body size\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::response::Response;\n    ///\n    /// # rocket::async_test(async {\n    /// let body = \"Hello, Rocketeers!\";\n    /// let mut r = Response::build()\n    ///     .sized_body(None, Cursor::new(body))\n    ///     .finalize();\n    ///\n    /// assert_eq!(r.body().preset_size(), None);\n    /// assert_eq!(r.body_mut().size().await, Some(body.len()));\n    /// assert_eq!(r.body().preset_size(), Some(body.len()));\n    /// # });\n    /// ```\n    pub async fn size(&mut self) -> Option<usize> {\n        if let Some(size) = self.size {\n            return Some(size);\n        }\n\n        if let Inner::Seekable(ref mut body) | Inner::Phantom(ref mut body) = self.inner {\n            let pos = body.seek(io::SeekFrom::Current(0)).await.ok()?;\n            let end = body.seek(io::SeekFrom::End(0)).await.ok()?;\n            body.seek(io::SeekFrom::Start(pos)).await.ok()?;\n\n            let size = end as usize - pos as usize;\n            self.size = Some(size);\n            return Some(size);\n        }\n\n        None\n    }\n\n    /// Moves the body out of `self` and returns it, leaving a\n    /// [`Body::default()`] in its place.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::response::Response;\n    ///\n    /// let mut r = Response::build()\n    ///     .sized_body(None, Cursor::new(\"Hi\"))\n    ///     .finalize();\n    ///\n    /// assert!(r.body().is_some());\n    ///\n    /// let body = r.body_mut().take();\n    /// assert!(body.is_some());\n    /// assert!(r.body().is_none());\n    /// ```\n    #[inline(always)]\n    pub fn take(&mut self) -> Self {\n        std::mem::take(self)\n    }\n\n    /// Reads all of `self` into a vector of bytes, consuming the contents.\n    ///\n    /// If reading fails, returns `Err`. Otherwise, returns `Ok`. Calling this\n    /// method may partially or fully consume the body's content. As such,\n    /// subsequent calls to `to_bytes()` will likely return different result.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::response::Response;\n    ///\n    /// # let ok: io::Result<()> = rocket::async_test(async {\n    /// let mut r = Response::build()\n    ///     .streamed_body(io::Cursor::new(&[1, 2, 3, 11, 13, 17]))\n    ///     .finalize();\n    ///\n    /// assert_eq!(r.body_mut().to_bytes().await?, &[1, 2, 3, 11, 13, 17]);\n    /// # Ok(())\n    /// # });\n    /// # assert!(ok.is_ok());\n    /// ```\n    pub async fn to_bytes(&mut self) -> io::Result<Vec<u8>> {\n        let mut vec = Vec::new();\n        let n = match self.read_to_end(&mut vec).await {\n            Ok(n) => n,\n            Err(e) => {\n                error_!(\"Error reading body: {:?}\", e);\n                return Err(e);\n            }\n        };\n\n        if let Some(ref mut size) = self.size {\n            *size = size.checked_sub(n).unwrap_or(0);\n        }\n\n        Ok(vec)\n    }\n\n    /// Reads all of `self` into a string, consuming the contents.\n    ///\n    /// If reading fails, or the body contains invalid UTF-8 characters, returns\n    /// `Err`. Otherwise, returns `Ok`. Calling this method may partially or\n    /// fully consume the body's content. As such, subsequent calls to\n    /// `to_string()` will likely return different result.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::response::Response;\n    ///\n    /// # let ok: io::Result<()> = rocket::async_test(async {\n    /// let mut r = Response::build()\n    ///     .streamed_body(io::Cursor::new(\"Hello, Rocketeers!\"))\n    ///     .finalize();\n    ///\n    /// assert_eq!(r.body_mut().to_string().await?, \"Hello, Rocketeers!\");\n    /// # Ok(())\n    /// # });\n    /// # assert!(ok.is_ok());\n    /// ```\n    pub async fn to_string(&mut self) -> io::Result<String> {\n        String::from_utf8(self.to_bytes().await?).map_err(|e| {\n            error_!(\"Body is invalid UTF-8: {}\", e);\n            io::Error::new(io::ErrorKind::InvalidData, e)\n        })\n    }\n}\n\nimpl AsyncRead for Body<'_> {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        let reader = match self.inner {\n            Inner::Seekable(ref mut b) => b as &mut (dyn AsyncRead + Unpin),\n            Inner::Unsized(ref mut b) => b as &mut (dyn AsyncRead + Unpin),\n            Inner::Phantom(_) | Inner::None => return Poll::Ready(Ok(())),\n        };\n\n        Pin::new(reader).poll_read(cx, buf)\n    }\n}\n\nimpl fmt::Debug for Inner<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Inner::Seekable(_) => \"seekable\".fmt(f),\n            Inner::Unsized(_) => \"unsized\".fmt(f),\n            Inner::Phantom(_) => \"phantom\".fmt(f),\n            Inner::None => \"none\".fmt(f),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Contains types that set the Content-Type of a response.\n//!\n//! # Usage\n//!\n//! Each type in this module is a `Responder` that wraps an existing\n//! `Responder`, overwriting the `Content-Type` of the response but otherwise\n//! delegating the response to the wrapped responder. As a convenience,\n//! `(ContentType, R)` where `R: Responder` is _also_ a `Responder` that\n//! overrides the `Content-Type` to the value in `.0`:\n//!\n//! ```rust\n//! # use rocket::get;\n//! use rocket::http::ContentType;\n//!\n//! #[get(\"/\")]\n//! fn index() -> (ContentType, &'static str) {\n//!     (ContentType::HTML, \"Is this HTML? <p>Sure, why not!</p>\")\n//! }\n//! ```\n//!\n//! # Example\n//!\n//! The following snippet creates a `RawHtml` response from a string. Normally,\n//! raw strings set their response Content-Type to `text/plain`. By using the\n//! `RawHtml` content response, the Content-Type will be set to `text/html`\n//! instead:\n//!\n//! ```rust\n//! use rocket::response::content;\n//!\n//! let response = content::RawHtml(\"<h1>Hello, world!</h1>\");\n//! ```\n\nuse crate::request::Request;\nuse crate::response::{self, Response, Responder};\nuse crate::http::ContentType;\n\nmacro_rules! ctrs {\n    ($($name:ident: $ct:ident, $name_str:expr, $ct_str:expr),+) => {\n        $(\n            #[doc=\"Override the `Content-Type` of the response to <b>\"]\n            #[doc=$name_str]\n            #[doc=\"</b>, or <i>\"]\n            #[doc=$ct_str]\n            #[doc=\"</i>.\"]\n            ///\n            /// Delegates the remainder of the response to the wrapped responder.\n            ///\n            /// **Note:** Unlike types like [`Json`](crate::serde::json::Json)\n            /// and [`MsgPack`](crate::serde::msgpack::MsgPack), this type _does\n            /// not_ serialize data in any way. You should _always_ use those\n            /// types to respond with serializable data. Additionally, you\n            /// should _always_ use [`NamedFile`](crate::fs::NamedFile), which\n            /// automatically sets a `Content-Type`, to respond with file data.\n            #[derive(Debug, Clone, PartialEq)]\n            pub struct $name<R>(pub R);\n\n            /// Sets the Content-Type of the response then delegates the\n            /// remainder of the response to the wrapped responder.\n            impl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for $name<R> {\n                fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n                    (ContentType::$ct, self.0).respond_to(req)\n                }\n            }\n        )+\n    }\n}\n\nctrs! {\n    // FIXME: Add a note that this is _not_ `serde::Json`.\n    RawJson: JSON, \"JSON\", \"application/json\",\n    RawXml: XML, \"XML\", \"text/xml\",\n    RawMsgPack: MsgPack, \"MessagePack\", \"application/msgpack\",\n    RawHtml: HTML, \"HTML\", \"text/html\",\n    RawText: Text, \"plain text\", \"text/plain\",\n    RawCss: CSS, \"CSS\", \"text/css\",\n    RawJavaScript: JavaScript, \"JavaScript\", \"application/javascript\"\n}\n\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for (ContentType, R) {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        Response::build()\n            .merge(self.1.respond_to(req)?)\n            .header(self.0)\n            .ok()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::request::Request;\nuse crate::response::{self, Responder};\nuse crate::http::Status;\n\nuse yansi::Paint;\n\n/// Debug prints the internal value before forwarding to the 500 error catcher.\n///\n/// This value exists primarily to allow handler return types that would not\n/// otherwise implement [`Responder`]. It is typically used in conjunction with\n/// `Result<T, E>` where `E` implements `Debug` but not `Responder`.\n///\n/// Note that because of it's common use as an error value, `std::io::Error`\n/// _does_ implement `Responder`. As a result, a `std::io::Result<T>` can be\n/// returned directly without the need for `Debug`:\n///\n/// ```rust\n/// use std::io;\n///\n/// # use rocket::get;\n/// use rocket::fs::NamedFile;\n///\n/// #[get(\"/\")]\n/// async fn index() -> io::Result<NamedFile> {\n///     NamedFile::open(\"index.html\").await\n/// }\n/// ```\n///\n/// # Example\n///\n/// Because of the generic `From<E>` implementation for `Debug<E>`, conversions\n/// from `Result<T, E>` to `Result<T, Debug<E>>` through `?` occur\n/// automatically:\n///\n/// ```rust\n/// use std::string::FromUtf8Error;\n///\n/// # use rocket::get;\n/// use rocket::response::Debug;\n///\n/// #[get(\"/\")]\n/// fn rand_str() -> Result<String, Debug<FromUtf8Error>> {\n///     # /*\n///     let bytes: Vec<u8> = random_bytes();\n///     # */\n///     # let bytes: Vec<u8> = vec![];\n///     Ok(String::from_utf8(bytes)?)\n/// }\n/// ```\n///\n/// It is also possible to map the error directly to `Debug` via\n/// [`Result::map_err()`]:\n///\n/// ```rust\n/// use std::string::FromUtf8Error;\n///\n/// # use rocket::get;\n/// use rocket::response::Debug;\n///\n/// #[get(\"/\")]\n/// fn rand_str() -> Result<String, Debug<FromUtf8Error>> {\n///     # /*\n///     let bytes: Vec<u8> = random_bytes();\n///     # */\n///     # let bytes: Vec<u8> = vec![];\n///     String::from_utf8(bytes).map_err(Debug)\n/// }\n/// ```\n#[derive(Debug)]\npub struct Debug<E>(pub E);\n\nimpl<E> From<E> for Debug<E> {\n    #[inline(always)]\n    fn from(e: E) -> Self {\n        Debug(e)\n    }\n}\n\nimpl<'r, E: std::fmt::Debug> Responder<'r, 'static> for Debug<E> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        warn_!(\"Debug: {:?}\", self.0.primary());\n        warn_!(\"Debug always responds with {}.\", Status::InternalServerError.primary());\n        Err(Status::InternalServerError)\n    }\n}\n\n/// Prints a warning with the error and forwards to the `500` error catcher.\nimpl<'r> Responder<'r, 'static> for std::io::Error {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        warn_!(\"I/O Error: {:?}\", self.primary());\n        Err(Status::InternalServerError)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use time::Duration;\nuse serde::ser::{Serialize, Serializer, SerializeStruct};\n\nuse crate::outcome::IntoOutcome;\nuse crate::response::{self, Responder};\nuse crate::request::{self, Request, FromRequest};\nuse crate::http::{Status, Cookie, CookieJar};\nuse std::sync::atomic::{AtomicBool, Ordering};\n\n// The name of the actual flash cookie.\nconst FLASH_COOKIE_NAME: &str = \"_flash\";\n\n// Character to use as a delimiter after the cookie's name's length.\nconst FLASH_COOKIE_DELIM: char = ':';\n\n/// Sets a \"flash\" cookie that will be removed when it is accessed. The\n/// analogous request type is [`FlashMessage`].\n///\n/// This type makes it easy to send messages across requests. It is typically\n/// used for \"status\" messages after redirects. For instance, if a user attempts\n/// to visit a page he/she does not have access to, you may want to redirect the\n/// user to a safe place and show a message indicating what happened on the\n/// redirected page. The message should only persist for a single request. This\n/// can be accomplished with this type.\n///\n/// # Usage\n///\n/// Each `Flash` message consists of a `kind` and `message`. A generic\n/// constructor ([new](#method.new)) can be used to construct a message of any\n/// kind, while the [warning](#method.warning), [success](#method.success), and\n/// [error](#method.error) constructors create messages with the corresponding\n/// kinds.\n///\n/// Messages can be retrieved on the request side via the [`FlashMessage`] type\n/// and the [kind](#method.kind) and [message](#method.message) methods.\n///\n/// # Response\n///\n/// The `Responder` implementation for `Flash` sets the message cookie and then\n/// uses the passed in responder `res` to complete the response. In other words,\n/// it simply sets a cookie and delegates the rest of the response handling to\n/// the wrapped responder.\n///\n/// # Example\n///\n/// The following routes illustrate the use of a `Flash` message on both the\n/// request and response sides.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::response::{Flash, Redirect};\n/// use rocket::request::FlashMessage;\n///\n/// #[post(\"/login/<name>\")]\n/// fn login(name: &str) -> Result<&'static str, Flash<Redirect>> {\n///     if name == \"special_user\" {\n///         Ok(\"Hello, special user!\")\n///     } else {\n///         Err(Flash::error(Redirect::to(uri!(index)), \"Invalid username.\"))\n///     }\n/// }\n///\n/// #[get(\"/\")]\n/// fn index(flash: Option<FlashMessage<'_>>) -> String {\n///     flash.map(|flash| format!(\"{}: {}\", flash.kind(), flash.message()))\n///          .unwrap_or_else(|| \"Welcome!\".to_string())\n/// }\n/// ```\n///\n/// On the response side (in `login`), a `Flash` error message is set if some\n/// fictional authentication failed, and the user is redirected to `\"/\"`. On the\n/// request side (in `index`), the handler emits the flash message if there is\n/// one and otherwise emits a standard welcome message. Note that if the user\n/// were to refresh the index page after viewing a flash message, the user would\n/// receive the standard welcome message.\n#[derive(Debug)]\npub struct Flash<R> {\n    kind: String,\n    message: String,\n    consumed: AtomicBool,\n    inner: R,\n}\n\n/// Type alias to retrieve [`Flash`] messages from a request.\n///\n/// # Flash Cookie\n///\n/// A `FlashMessage` holds the parsed contents of the flash cookie. As long as\n/// there is a flash cookie present (set by the `Flash` `Responder`), a\n/// `FlashMessage` request guard will succeed.\n///\n/// The flash cookie is cleared if either the [`kind()`] or [`message()`] method is\n/// called. If neither method is called, the flash cookie is not cleared.\n///\n/// [`kind()`]: Flash::kind()\n/// [`message()`]: Flash::message()\npub type FlashMessage<'a> = crate::response::Flash<&'a CookieJar<'a>>;\n\nimpl<R> Flash<R> {\n    /// Constructs a new `Flash` message with the given `kind`, `message`, and\n    /// underlying `responder`.\n    ///\n    /// # Examples\n    ///\n    /// Construct a \"suggestion\" message with contents \"Try this out!\" that\n    /// redirects to \"/\".\n    ///\n    /// ```rust\n    /// use rocket::response::{Redirect, Flash};\n    ///\n    /// # #[allow(unused_variables)]\n    /// let message = Flash::new(Redirect::to(\"/\"), \"suggestion\", \"Try this out!\");\n    /// ```\n    pub fn new<K: Into<String>, M: Into<String>>(res: R, kind: K, message: M) -> Flash<R> {\n        Flash {\n            kind: kind.into(),\n            message: message.into(),\n            consumed: AtomicBool::default(),\n            inner: res,\n        }\n    }\n\n    /// Constructs a \"success\" `Flash` message with the given `responder` and\n    /// `message`.\n    ///\n    /// # Examples\n    ///\n    /// Construct a \"success\" message with contents \"It worked!\" that redirects\n    /// to \"/\".\n    ///\n    /// ```rust\n    /// use rocket::response::{Redirect, Flash};\n    ///\n    /// # #[allow(unused_variables)]\n    /// let message = Flash::success(Redirect::to(\"/\"), \"It worked!\");\n    /// ```\n    pub fn success<S: Into<String>>(responder: R, message: S) -> Flash<R> {\n        Flash::new(responder, \"success\", message.into())\n    }\n\n    /// Constructs a \"warning\" `Flash` message with the given `responder` and\n    /// `message`.\n    ///\n    /// # Examples\n    ///\n    /// Construct a \"warning\" message with contents \"Watch out!\" that redirects\n    /// to \"/\".\n    ///\n    /// ```rust\n    /// use rocket::response::{Redirect, Flash};\n    ///\n    /// # #[allow(unused_variables)]\n    /// let message = Flash::warning(Redirect::to(\"/\"), \"Watch out!\");\n    /// ```\n    pub fn warning<S: Into<String>>(responder: R, message: S) -> Flash<R> {\n        Flash::new(responder, \"warning\", message.into())\n    }\n\n    /// Constructs an \"error\" `Flash` message with the given `responder` and\n    /// `message`.\n    ///\n    /// # Examples\n    ///\n    /// Construct an \"error\" message with contents \"Whoops!\" that redirects\n    /// to \"/\".\n    ///\n    /// ```rust\n    /// use rocket::response::{Redirect, Flash};\n    ///\n    /// # #[allow(unused_variables)]\n    /// let message = Flash::error(Redirect::to(\"/\"), \"Whoops!\");\n    /// ```\n    pub fn error<S: Into<String>>(responder: R, message: S) -> Flash<R> {\n        Flash::new(responder, \"error\", message.into())\n    }\n\n    fn cookie(&self) -> Cookie<'static> {\n        let content = format!(\"{}{}{}{}\",\n            self.kind.len(), FLASH_COOKIE_DELIM, self.kind, self.message);\n\n        Cookie::build((FLASH_COOKIE_NAME, content))\n            .max_age(Duration::minutes(5))\n            .build()\n    }\n}\n\n/// Sets the message cookie and then uses the wrapped responder to complete the\n/// response. In other words, simply sets a cookie and delegates the rest of the\n/// response handling to the wrapped responder. As a result, the `Outcome` of\n/// the response is the `Outcome` of the wrapped `Responder`.\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for Flash<R> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        req.cookies().add(self.cookie());\n        self.inner.respond_to(req)\n    }\n}\n\nimpl<'r> FlashMessage<'r> {\n    /// Constructs a new message with the given name and message for the given\n    /// request.\n    fn named<S: Into<String>>(kind: S, message: S, req: &'r Request<'_>) -> Self {\n        Flash {\n            kind: kind.into(),\n            message: message.into(),\n            consumed: AtomicBool::new(false),\n            inner: req.cookies(),\n        }\n    }\n\n    // Clears the request cookie if it hasn't already been cleared.\n    fn clear_cookie_if_needed(&self) {\n        // Remove the cookie if it hasn't already been removed.\n        if !self.consumed.swap(true, Ordering::Relaxed) {\n            self.inner.remove(FLASH_COOKIE_NAME);\n        }\n    }\n\n    /// Returns a tuple of `(kind, message)`, consuming `self`.\n    pub fn into_inner(self) -> (String, String) {\n        self.clear_cookie_if_needed();\n        (self.kind, self.message)\n    }\n\n    /// Returns the `kind` of this message.\n    pub fn kind(&self) -> &str {\n        self.clear_cookie_if_needed();\n        &self.kind\n    }\n\n    /// Returns the `message` contents of this message.\n    pub fn message(&self) -> &str {\n        self.clear_cookie_if_needed();\n        &self.message\n    }\n}\n\n/// Retrieves a flash message from a flash cookie. If there is no flash cookie,\n/// or if the flash cookie is malformed, an empty `Err` is returned.\n///\n/// The suggested use is through an `Option` and the `FlashMessage` type alias\n/// in `request`: `Option<FlashMessage>`.\n#[crate::async_trait]\nimpl<'r> FromRequest<'r> for FlashMessage<'r> {\n    type Error = ();\n\n    async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n        trace_!(\"Flash: attempting to retrieve message.\");\n        req.cookies().get(FLASH_COOKIE_NAME).ok_or(()).and_then(|cookie| {\n            trace_!(\"Flash: retrieving message: {:?}\", cookie);\n\n            // Parse the flash message.\n            let content = cookie.value();\n            let (len_str, kv) = match content.find(FLASH_COOKIE_DELIM) {\n                Some(i) => (&content[..i], &content[(i + 1)..]),\n                None => return Err(()),\n            };\n\n            match len_str.parse::<usize>() {\n                Ok(i) if i <= kv.len() => Ok(Flash::named(&kv[..i], &kv[i..], req)),\n                _ => Err(())\n            }\n        }).or_error(Status::BadRequest)\n    }\n}\n\nimpl Serialize for FlashMessage<'_> {\n    fn serialize<S: Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {\n        let mut flash = ser.serialize_struct(\"Flash\", 2)?;\n        flash.serialize_field(\"kind\", self.kind())?;\n        flash.serialize_field(\"message\", self.message())?;\n        flash.end()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types and traits to build and send responses.\n//!\n//! The return type of a Rocket handler can be any type that implements the\n//! [`Responder`] trait, which means that the type knows how to generate a\n//! [`Response`]. Among other things, this module contains several such types.\n//!\n//! # Composing\n//!\n//! Many of the built-in `Responder` types _chain_ responses: they take in\n//! another `Responder` and add, remove, or change information in the response.\n//! In other words, many `Responder` types are built to compose well. As a\n//! result, you'll often have types of the form `A<B<C>>` consisting of three\n//! `Responder`s `A`, `B`, and `C`. This is normal and encouraged as the type\n//! names typically illustrate the intended response.\n\nmod responder;\nmod redirect;\nmod response;\nmod debug;\nmod body;\n\npub(crate) mod flash;\n\npub mod content;\npub mod status;\npub mod stream;\n\n#[doc(hidden)]\npub use rocket_codegen::Responder;\n\npub use self::response::{Response, Builder};\npub use self::body::Body;\npub use self::responder::Responder;\npub use self::redirect::Redirect;\npub use self::flash::Flash;\npub use self::debug::Debug;\n\n/// Type alias for the `Result` of a [`Responder::respond_to()`] call.\npub type Result<'r> = std::result::Result<Response<'r>, crate::http::Status>;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::request::Request;\nuse crate::response::{self, Response, Responder};\nuse crate::http::uri::Reference;\nuse crate::http::Status;\n\n/// An empty redirect response to a given URL.\n///\n/// This type simplifies returning a redirect response to the client.\n///\n/// # Usage\n///\n/// All constructors accept a generic type of `T: TryInto<Reference<'static>>`.\n/// Among the candidate types are:\n///\n///   * `String`, `&'static str`\n///   * [`Origin`](crate::http::uri::Origin)\n///   * [`Authority`](crate::http::uri::Authority)\n///   * [`Absolute`](crate::http::uri::Absolute)\n///   * [`Reference`](crate::http::uri::Reference)\n///\n/// Any non-`'static` strings must first be allocated using `.to_string()` or\n/// similar before being passed to a `Redirect` constructor. When redirecting to\n/// a route, or any URI containing a route, _always_ use [`uri!`] to construct a\n/// valid URI:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::response::Redirect;\n///\n/// #[get(\"/hello/<name>/<age>\")]\n/// fn hello(name: String, age: u8) -> String {\n///     format!(\"Hello, {} year old named {}!\", age, name)\n/// }\n///\n/// #[get(\"/hi/<name>/<age>\")]\n/// fn hi(name: String, age: u8) -> Redirect {\n///     Redirect::to(uri!(hello(name, age)))\n/// }\n///\n/// #[get(\"/bye/<name>/<age>\")]\n/// fn bye(name: String, age: u8) -> Redirect {\n///     Redirect::to(uri!(\"https://rocket.rs/bye\", hello(name, age), \"?bye#now\"))\n/// }\n/// ```\n///\n/// [`Origin`]: crate::http::uri::Origin\n/// [`uri!`]: ../macro.uri.html\n#[derive(Debug)]\npub struct Redirect(Status, Option<Reference<'static>>);\n\nimpl Redirect {\n    /// Construct a temporary \"see other\" (303) redirect response. This is the\n    /// typical response when redirecting a user to another page. This type of\n    /// redirect indicates that the client should look elsewhere, but always via\n    /// a `GET` request, for a given resource.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::response::Redirect;\n    ///\n    /// let redirect = Redirect::to(uri!(\"/foo/bar\"));\n    /// let redirect = Redirect::to(uri!(\"https://domain.com#foo\"));\n    /// ```\n    pub fn to<U: TryInto<Reference<'static>>>(uri: U) -> Redirect {\n        Redirect(Status::SeeOther, uri.try_into().ok())\n    }\n\n    /// Construct a \"temporary\" (307) redirect response. This response instructs\n    /// the client to reissue the current request to a different URL,\n    /// maintaining the contents of the request identically. This means that,\n    /// for example, a `POST` request will be resent, contents included, to the\n    /// requested URL.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::response::Redirect;\n    ///\n    /// let redirect = Redirect::temporary(uri!(\"some/other/path\"));\n    /// let redirect = Redirect::temporary(uri!(\"https://rocket.rs?foo\"));\n    /// let redirect = Redirect::temporary(format!(\"some-{}-thing\", \"crazy\"));\n    /// ```\n    pub fn temporary<U: TryInto<Reference<'static>>>(uri: U) -> Redirect {\n        Redirect(Status::TemporaryRedirect, uri.try_into().ok())\n    }\n\n   /// Construct a \"permanent\" (308) redirect response. This redirect must only\n   /// be used for permanent redirects as it is cached by clients. This\n   /// response instructs the client to reissue requests for the current URL to\n   /// a different URL, now and in the future, maintaining the contents of the\n   /// request identically. This means that, for example, a `POST` request will\n   /// be resent, contents included, to the requested URL.\n   ///\n   /// # Examples\n   ///\n   /// ```rust\n   /// # #[macro_use] extern crate rocket;\n   /// use rocket::response::Redirect;\n   ///\n   /// let redirect = Redirect::permanent(uri!(\"/other_url\"));\n   /// let redirect = Redirect::permanent(format!(\"some-{}-thing\", \"crazy\"));\n   /// ```\n   pub fn permanent<U: TryInto<Reference<'static>>>(uri: U) -> Redirect {\n       Redirect(Status::PermanentRedirect, uri.try_into().ok())\n   }\n\n   /// Construct a temporary \"found\" (302) redirect response. This response\n   /// instructs the client to reissue the current request to a different URL,\n   /// ideally maintaining the contents of the request identically.\n   /// Unfortunately, different clients may respond differently to this type of\n   /// redirect, so `303` or `307` redirects, which disambiguate, are\n   /// preferred.\n   ///\n   /// # Examples\n   ///\n   /// ```rust\n   /// # #[macro_use] extern crate rocket;\n   /// use rocket::response::Redirect;\n   ///\n   /// let redirect = Redirect::found(uri!(\"/other_url\"));\n   /// let redirect = Redirect::found(format!(\"some-{}-thing\", \"crazy\"));\n   /// ```\n   pub fn found<U: TryInto<Reference<'static>>>(uri: U) -> Redirect {\n       Redirect(Status::Found, uri.try_into().ok())\n   }\n\n   /// Construct a permanent \"moved\" (301) redirect response. This response\n   /// should only be used for permanent redirects as it can be cached by\n   /// browsers. Because different clients may respond differently to this type\n   /// of redirect, a `308` redirect, which disambiguates, is preferred.\n   ///\n   /// # Examples\n   ///\n   /// ```rust\n   /// # #[macro_use] extern crate rocket;\n   /// use rocket::response::Redirect;\n   ///\n   /// let redirect = Redirect::moved(uri!(\"here\"));\n   /// let redirect = Redirect::moved(format!(\"some-{}-thing\", \"crazy\"));\n   /// ```\n   pub fn moved<U: TryInto<Reference<'static>>>(uri: U) -> Redirect {\n       Redirect(Status::MovedPermanently, uri.try_into().ok())\n   }\n}\n\n/// Constructs a response with the appropriate status code and the given URL in\n/// the `Location` header field. The body of the response is empty. If the URI\n/// value used to create the `Responder` is an invalid URI, an error of\n/// `Status::InternalServerError` is returned.\nimpl<'r> Responder<'r, 'static> for Redirect {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        if let Some(uri) = self.1 {\n            Response::build()\n                .status(self.0)\n                .raw_header(\"Location\", uri.to_string())\n                .ok()\n        } else {\n            error!(\"Invalid URI used for redirect.\");\n            Err(Status::InternalServerError)\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fs::File;\nuse std::io::Cursor;\nuse std::sync::Arc;\n\nuse crate::http::{Status, ContentType, StatusClass};\nuse crate::response::{self, Response};\nuse crate::request::Request;\n\n/// Trait implemented by types that generate responses for clients.\n///\n/// Any type that implements `Responder` can be used as the return type of a\n/// handler:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type T = ();\n/// #\n/// // This works for any `T` that implements `Responder`.\n/// #[get(\"/\")]\n/// fn index() -> T { /* ... */ }\n/// ```\n///\n/// # Deriving\n///\n/// This trait can, and largely _should_, be automatically derived. The derive\n/// can handle all simple cases and most complex cases, too. When deriving\n/// `Responder`, the first field of the annotated structure (or of each variant\n/// if an `enum`) is used to generate a response while the remaining fields are\n/// used as response headers:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # #[cfg(feature = \"json\")] mod _main {\n/// # type Template = String;\n/// use rocket::http::ContentType;\n/// use rocket::serde::{Serialize, json::Json};\n///\n/// #[derive(Responder)]\n/// enum Error<T> {\n///     #[response(status = 400)]\n///     Unauthorized(Json<T>),\n///     #[response(status = 404)]\n///     NotFound(Template, ContentType),\n/// }\n/// # }\n/// ```\n///\n/// For full details on deriving `Responder`, see the [`Responder` derive].\n///\n/// [`Responder` derive]: derive@crate::Responder\n///\n/// # Provided Implementations\n///\n/// Rocket implements `Responder` for several standard library types. Their\n/// behavior is documented here. Note that the `Result` implementation is\n/// overloaded, allowing for two `Responder`s to be used at once, depending on\n/// the variant.\n///\n///   * **&str**\n///\n///     Sets the `Content-Type` to `text/plain`. The string is used as the body\n///     of the response, which is fixed size and not streamed. To stream a raw\n///     string, use `Stream::from(Cursor::new(string))`.\n///\n///   * **String**\n///\n///     Sets the `Content-Type` to `text/plain`. The string is used as the body\n///     of the response, which is fixed size and not streamed. To stream a\n///     string, use `Stream::from(Cursor::new(string))`.\n///\n///   * **&\\[u8\\]**\n///\n///     Sets the `Content-Type` to `application/octet-stream`. The slice\n///     is used as the body of the response, which is fixed size and not\n///     streamed. To stream a slice of bytes, use\n///     `Stream::from(Cursor::new(data))`.\n///\n///   * **Vec&lt;u8>**\n///\n///     Sets the `Content-Type` to `application/octet-stream`. The vector's data\n///     is used as the body of the response, which is fixed size and not\n///     streamed. To stream a vector of bytes, use\n///     `Stream::from(Cursor::new(vec))`.\n///\n///   * **File**\n///\n///     Responds with a streamed body containing the data in the `File`. No\n///     `Content-Type` is set. To automatically have a `Content-Type` set based\n///     on the file's extension, use [`NamedFile`](crate::fs::NamedFile).\n///\n///   * **()**\n///\n///     Responds with an empty body. No `Content-Type` is set.\n///\n///   * **Option&lt;T>**\n///\n///     If the `Option` is `Some`, the wrapped responder is used to respond to\n///     the client. Otherwise, an `Err` with status **404 Not Found** is\n///     returned and a warning is printed to the console.\n///\n///   * **Result&lt;T, E>**\n///\n///     If the `Result` is `Ok`, the wrapped `Ok` responder is used to respond\n///     to the client. If the `Result` is `Err`, the wrapped `Err` responder is\n///     used to respond to the client.\n///\n/// # Return Value\n///\n/// A `Responder` returns a `Result<Response, Status>`.\n///\n///   * An `Ok(Response)` indicates success. The `Response` will be written out\n///     to the client.\n///\n///   * An `Err(Status)` indicates an error. The error catcher for `Status` will\n///     be invoked to generate a response.\n///\n/// # Implementation Tips\n///\n/// This section describes a few best practices to take into account when\n/// implementing `Responder`.\n///\n/// 1. Avoid Manual Implementations\n///\n///    The [`Responder` derive] is a powerful mechanism that eliminates the need\n///    to implement `Responder` in almost all cases. We encourage you to explore\n///    using the derive _before_ attempting to implement `Responder` directly.\n///    It allows you to leverage existing `Responder` implementations through\n///    composition, decreasing the opportunity for mistakes or performance\n///    degradation.\n///\n/// 2. Joining and Merging\n///\n///    When chaining/wrapping other `Responder`s, start with\n///    [`Response::build_from()`] and/or use the [`merge()`](Response::merge())\n///    or [`join()`](Response::join()) methods on the `Response` or\n///    `ResponseBuilder` struct. Ensure that you document merging or joining\n///    behavior appropriately.\n///\n/// 3. Inspecting Requests\n///\n///    While tempting, a `Responder` that varies its functionality based on the\n///    incoming request sacrifices its functionality being understood based\n///    purely on its type. By implication, gleaning the functionality of a\n///    _handler_ from its type signature also becomes more difficult. You should\n///    avoid varying responses based on the `Request` value as much as possible.\n///\n/// 4. Perform `async` I/O in Constructors\n///\n///    The `Responder` trait is not an `async` trait. This is not an oversight.\n///    Instead of performing `async` operations in what would be the\n///    `respond_to` method, perform them in a constructor for the responder. As\n///    an example, see [`NamedFile::open()`](crate::fs::NamedFile::open()),\n///    which performs the requisite I/O for `NamedFile`'s responder.\n///\n/// ## Lifetimes\n///\n/// `Responder` has two lifetimes: `Responder<'r, 'o: 'r>`.\n///\n///   * `'r` bounds the reference to the `&'r Request`.\n///\n///   * `'o` bounds the returned `Response<'o>` to values that live at least as\n///     long as the request.\n///\n///     This includes borrows from the `Request` itself (where `'o` would be\n///     `'r` as in `impl<'r> Responder<'r, 'r>`) as well as `'static` data\n///     (where `'o` would be `'static` as in `impl<'r> Responder<'r, 'static>`).\n///\n/// In practice, you are likely choosing between four signatures:\n///\n/// ```rust\n/// # use rocket::request::Request;\n/// # use rocket::response::{self, Responder};\n/// # struct A;\n/// // If the response contains no borrowed data.\n/// impl<'r> Responder<'r, 'static> for A {\n///     fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n///         todo!()\n///     }\n/// }\n///\n/// # struct B<'r>(&'r str);\n/// // If the response borrows from the request.\n/// impl<'r> Responder<'r, 'r> for B<'r> {\n///     fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n///         todo!()\n///     }\n/// }\n///\n/// # struct C;\n/// // If the response is or wraps a borrow that may outlive the request.\n/// impl<'r, 'o: 'r> Responder<'r, 'o> for &'o C {\n///     fn respond_to(self, _: &'r Request<'_>) -> response::Result<'o> {\n///         todo!()\n///     }\n/// }\n///\n/// # struct D<R>(R);\n/// // If the response wraps an existing responder.\n/// impl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for D<R> {\n///     fn respond_to(self, _: &'r Request<'_>) -> response::Result<'o> {\n///         todo!()\n///     }\n/// }\n/// ```\n///\n/// # Example\n///\n/// Say that you have a custom type, `Person`:\n///\n/// ```rust\n/// struct Person {\n///     name: String,\n///     age: u16\n/// }\n/// ```\n///\n/// You'd like to use `Person` as a `Responder` so that you can return a\n/// `Person` directly from a handler:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type Person = String;\n/// #[get(\"/person/<id>\")]\n/// fn person(id: usize) -> Option<Person> {\n///     # /*\n///     Person::from_id(id)\n///     # */ None\n/// }\n/// # fn main() {}\n/// ```\n///\n/// You want the `Person` responder to set two header fields: `X-Person-Name`\n/// and `X-Person-Age` as well as supply a custom representation of the object\n/// (`Content-Type: application/x-person`) in the body of the response. The\n/// following `Responder` implementation accomplishes this:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// #\n/// # #[derive(Debug)]\n/// # struct Person { name: String, age: u16 }\n/// #\n/// use std::io::Cursor;\n///\n/// use rocket::request::Request;\n/// use rocket::response::{self, Response, Responder};\n/// use rocket::http::ContentType;\n///\n/// impl<'r> Responder<'r, 'static> for Person {\n///     fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n///         let string = format!(\"{}:{}\", self.name, self.age);\n///         Response::build_from(string.respond_to(req)?)\n///             .raw_header(\"X-Person-Name\", self.name)\n///             .raw_header(\"X-Person-Age\", self.age.to_string())\n///             .header(ContentType::new(\"application\", \"x-person\"))\n///             .ok()\n///     }\n/// }\n/// #\n/// # #[get(\"/person\")]\n/// # fn person() -> Person { Person { name: \"a\".to_string(), age: 20 } }\n/// # fn main() {  }\n/// ```\n///\n/// Note that the implementation could have instead been derived if structured\n/// in a slightly different manner:\n///\n/// ```rust\n/// use rocket::http::Header;\n/// use rocket::response::Responder;\n///\n/// #[derive(Responder)]\n/// #[response(content_type = \"application/x-person\")]\n/// struct Person {\n///     text: String,\n///     name: Header<'static>,\n///     age: Header<'static>,\n/// }\n///\n/// impl Person {\n///     fn new(name: &str, age: usize) -> Person {\n///         Person {\n///             text: format!(\"{}:{}\", name, age),\n///             name: Header::new(\"X-Person-Name\", name.to_string()),\n///             age: Header::new(\"X-Person-Age\", age.to_string())\n///         }\n///     }\n/// }\n/// #\n/// # #[rocket::get(\"/person\")]\n/// # fn person() -> Person { Person::new(\"Bob\", 29) }\n/// ```\npub trait Responder<'r, 'o: 'r> {\n    /// Returns `Ok` if a `Response` could be generated successfully. Otherwise,\n    /// returns an `Err` with a failing `Status`.\n    ///\n    /// The `request` parameter is the `Request` that this `Responder` is\n    /// responding to.\n    ///\n    /// When using Rocket's code generation, if an `Ok(Response)` is returned,\n    /// the response will be written out to the client. If an `Err(Status)` is\n    /// returned, the error catcher for the given status is retrieved and called\n    /// to generate a final error response, which is then written out to the\n    /// client.\n    fn respond_to(self, request: &'r Request<'_>) -> response::Result<'o>;\n}\n\n/// Returns a response with Content-Type `text/plain` and a fixed-size body\n/// containing the string `self`. Always returns `Ok`.\nimpl<'r, 'o: 'r> Responder<'r, 'o> for &'o str {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'o> {\n        Response::build()\n            .header(ContentType::Plain)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `text/plain` and a fixed-size body\n/// containing the string `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for String {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Plain)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n#[repr(transparent)]\nstruct DerefRef<T>(T);\n\nimpl<T: std::ops::Deref> AsRef<[u8]> for DerefRef<T> where T::Target: AsRef<[u8]> {\n    fn as_ref(&self) -> &[u8] {\n        self.0.deref().as_ref()\n    }\n}\n\n/// Returns a response with Content-Type `text/plain` and a fixed-size body\n/// containing the string `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for Arc<str> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Plain)\n            .sized_body(self.len(), Cursor::new(DerefRef(self)))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `text/plain` and a fixed-size body\n/// containing the string `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for Box<str> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Plain)\n            .sized_body(self.len(), Cursor::new(DerefRef(self)))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `application/octet-stream` and a\n/// fixed-size body containing the data in `self`. Always returns `Ok`.\nimpl<'r, 'o: 'r> Responder<'r, 'o> for &'o [u8] {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'o> {\n        Response::build()\n            .header(ContentType::Binary)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `application/octet-stream` and a\n/// fixed-size body containing the data in `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for Vec<u8> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Binary)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `application/octet-stream` and a\n/// fixed-size body containing the data in `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for Arc<[u8]> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Binary)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n/// Returns a response with Content-Type `application/octet-stream` and a\n/// fixed-size body containing the data in `self`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for Box<[u8]> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build()\n            .header(ContentType::Binary)\n            .sized_body(self.len(), Cursor::new(self))\n            .ok()\n    }\n}\n\n/// Returns the response generated by the inner `T`. Note that this explicitly\n/// does not support `Box<dyn Responder>`.\n///\n/// ```rust,compile_fail\n/// #[macro_use] extern crate rocket;\n///\n/// use rocket::response::Responder;\n///\n/// #[get(\"/\")]\n/// fn f() -> Box<dyn Responder<'static,'static>> {\n///     Box::new(())\n/// }\n/// ```\n///\n/// However, this `impl` allows boxing sized responders:\n///\n/// ```rust\n/// #[macro_use] extern crate rocket;\n///\n/// #[derive(Responder)]\n/// enum Content {\n///     Redirect(Box<rocket::response::Redirect>),\n///     Text(String),\n/// }\n///\n/// #[get(\"/\")]\n/// fn f() -> Option<Box<String>> {\n///     None\n/// }\n///\n/// #[get(\"/\")]\n/// fn g() -> Content {\n///     Content::Text(\"hello\".to_string())\n/// }\n/// ```\nimpl<'r, 'o: 'r, T: Responder<'r, 'o> + Sized> Responder<'r, 'o> for Box<T> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        let inner = *self;\n        inner.respond_to(req)\n    }\n}\n\n/// Returns a response with a sized body for the file. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for File {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        tokio::fs::File::from(self).respond_to(req)\n    }\n}\n\n/// Returns a response with a sized body for the file. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for tokio::fs::File {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build().sized_body(None, self).ok()\n    }\n}\n\n/// Returns an empty, default `Response`. Always returns `Ok`.\nimpl<'r> Responder<'r, 'static> for () {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Ok(Response::new())\n    }\n}\n\n/// Responds with the inner `Responder` in `Cow`.\nimpl<'r, 'o: 'r, R: ?Sized + ToOwned> Responder<'r, 'o> for std::borrow::Cow<'o, R>\n    where &'o R: Responder<'r, 'o> + 'o, <R as ToOwned>::Owned: Responder<'r, 'o> + 'r\n{\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        match self {\n            std::borrow::Cow::Borrowed(b) => b.respond_to(req),\n            std::borrow::Cow::Owned(o) => o.respond_to(req),\n        }\n    }\n}\n\n/// If `self` is `Some`, responds with the wrapped `Responder`. Otherwise prints\n/// a warning message and returns an `Err` of `Status::NotFound`.\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for Option<R> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        match self {\n            Some(r) => r.respond_to(req),\n            None => {\n                warn_!(\"Response was `None`.\");\n                Err(Status::NotFound)\n            },\n        }\n    }\n}\n\n/// Responds with the wrapped `Responder` in `self`, whether it is `Ok` or\n/// `Err`.\nimpl<'r, 'o: 'r, 't: 'o, 'e: 'o, T, E> Responder<'r, 'o> for Result<T, E>\n    where T: Responder<'r, 't>, E: Responder<'r, 'e>\n{\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        match self {\n            Ok(responder) => responder.respond_to(req),\n            Err(responder) => responder.respond_to(req),\n        }\n    }\n}\n\n/// Responds with the wrapped `Responder` in `self`, whether it is `Left` or\n/// `Right`.\nimpl<'r, 'o: 'r, 't: 'o, 'e: 'o, T, E> Responder<'r, 'o> for crate::Either<T, E>\n    where T: Responder<'r, 't>, E: Responder<'r, 'e>\n{\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        match self {\n            crate::Either::Left(r) => r.respond_to(req),\n            crate::Either::Right(r) => r.respond_to(req),\n        }\n    }\n}\n\n/// The response generated by `Status` depends on the status code itself. The\n/// table below summarizes the functionality:\n///\n/// | Status Code Range | Response                              |\n/// |-------------------|---------------------------------------|\n/// | [400, 599]        | Forwards to catcher for given status. |\n/// | 100, [200, 205]   | Empty with status of `self`.          |\n/// | All others.       | Invalid. Errors to `500` catcher.     |\n///\n/// In short, a client or server error status codes will forward to the\n/// corresponding error catcher, a successful status code less than `206` or\n/// `100` responds with any empty body and the given status code, and all other\n/// status code emit an error message and forward to the `500` (internal server\n/// error) catcher.\nimpl<'r> Responder<'r, 'static> for Status {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        match self.class() {\n            StatusClass::ClientError | StatusClass::ServerError => Err(self),\n            StatusClass::Success if self.code < 206 => {\n                Response::build().status(self).ok()\n            }\n            StatusClass::Informational if self.code == 100 => {\n                Response::build().status(self).ok()\n            }\n            _ => {\n                error_!(\"Invalid status used as responder: {}.\", self);\n                Err(Status::InternalServerError)\n            }\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{fmt, str};\nuse std::borrow::Cow;\nuse std::collections::HashMap;\nuse std::pin::Pin;\n\nuse tokio::io::{AsyncRead, AsyncSeek};\n\nuse crate::http::{Header, HeaderMap, Status, ContentType, Cookie};\nuse crate::http::uncased::{Uncased, AsUncased};\nuse crate::data::IoHandler;\nuse crate::response::Body;\n\n/// Builder for the [`Response`] type.\n///\n/// Building a [`Response`] can be a low-level ordeal; this structure presents a\n/// higher-level API that simplifies building `Response`s.\n///\n/// # Usage\n///\n/// `Builder` follows the builder pattern and is usually obtained by calling\n/// [`Response::build()`] on `Response`. Almost all methods take the current\n/// builder as a mutable reference and return the same mutable reference with\n/// field(s) modified in the `Response` being built. These method calls can be\n/// chained: `build.a().b()`.\n///\n/// To finish building and retrieve the built `Response`, use the\n/// [`finalize()`](#method.finalize) or [`ok()`](#method.ok) methods.\n///\n/// ## Headers\n///\n/// When building a `Response`, headers can either be _replaced_ or _adjoined_;\n/// the default behavior (using `header(..)`) is to _replace_. When a header is\n/// _replaced_, any existing values for headers with the same name are removed,\n/// and the new value is set. If no header exists, the header is simply added.\n/// On the other hand, when a header is _adjoined_, all existing values will\n/// remain, and the `value` of the adjoined header will be added to the set of\n/// existing values, if any. Adjoining maintains order: headers adjoined first\n/// will appear first in the `Response`.\n///\n/// ## Joining and Merging\n///\n/// It is often necessary to combine multiple `Response`s in some way. The\n/// [merge](#method.merge) and [join](#method.join) methods facilitate this. The\n/// `merge` method replaces all of the fields in `self` with those present in\n/// `other`. The `join` method sets any fields not set in `self` to the value in\n/// `other`. See their documentation for more details.\n/// ## Example\n///\n/// The following example builds a `Response` with:\n///\n///   * **Status**: `418 I'm a teapot`\n///   * **Content-Type** header: `text/plain; charset=utf-8`\n///   * **X-Teapot-Make** header: `Rocket`\n///   * **X-Teapot-Model** headers: `Utopia`, `Series 1`\n///   * **Body**: fixed-size string `\"Brewing the best coffee!\"`\n///\n/// ```rust\n/// use std::io::Cursor;\n/// use rocket::response::Response;\n/// use rocket::http::{Status, ContentType};\n///\n/// let body = \"Brewing the best coffee!\";\n/// let response = Response::build()\n///     .status(Status::ImATeapot)\n///     .header(ContentType::Plain)\n///     .raw_header(\"X-Teapot-Make\", \"Rocket\")\n///     .raw_header(\"X-Teapot-Model\", \"Utopia\")\n///     .raw_header_adjoin(\"X-Teapot-Model\", \"Series 1\")\n///     .sized_body(body.len(), Cursor::new(body))\n///     .finalize();\n/// ```\npub struct Builder<'r> {\n    response: Response<'r>,\n}\n\nimpl<'r> Builder<'r> {\n    /// Creates a new `Builder` that will build on top of the `base`\n    /// `Response`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::{Builder, Response};\n    ///\n    /// # #[allow(unused_variables)]\n    /// let builder = Builder::new(Response::new());\n    /// ```\n    #[inline(always)]\n    pub fn new(base: Response<'r>) -> Builder<'r> {\n        Builder {\n            response: base,\n        }\n    }\n\n    /// Sets the status of the `Response` being built to `status`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Status;\n    ///\n    /// let response = Response::build()\n    ///     .status(Status::NotFound)\n    ///     .finalize();\n    /// ```\n    #[inline(always)]\n    pub fn status(&mut self, status: Status) -> &mut Builder<'r> {\n        self.response.set_status(status);\n        self\n    }\n\n    /// Adds `header` to the `Response`, replacing any header with the same name\n    /// that already exists in the response. If multiple headers with\n    /// the same name exist, they are all removed, and only the new header and\n    /// value will remain.\n    ///\n    /// The type of `header` can be any type that implements `Into<Header>`.\n    /// This includes `Header` itself, [`ContentType`](crate::http::ContentType) and\n    /// [hyper::header types](crate::http::hyper::header).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::ContentType;\n    ///\n    /// let response = Response::build()\n    ///     .header(ContentType::JSON)\n    ///     .header(ContentType::HTML)\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.headers().get(\"Content-Type\").count(), 1);\n    /// ```\n    #[inline(always)]\n    pub fn header<'h: 'r, H>(&mut self, header: H) -> &mut Builder<'r>\n        where H: Into<Header<'h>>\n    {\n        self.response.set_header(header);\n        self\n    }\n\n    /// Adds `header` to the `Response` by adjoining the header with any\n    /// existing headers with the same name that already exist in the\n    /// `Response`. This allows for multiple headers with the same name and\n    /// potentially different values to be present in the `Response`.\n    ///\n    /// The type of `header` can be any type that implements `Into<Header>`.\n    /// This includes `Header` itself, [`ContentType`](crate::http::ContentType) and\n    /// [hyper::header types](crate::http::hyper::header).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Header;\n    /// use rocket::http::hyper::header::ACCEPT;\n    ///\n    /// let response = Response::build()\n    ///     .header_adjoin(Header::new(ACCEPT.as_str(), \"application/json\"))\n    ///     .header_adjoin(Header::new(ACCEPT.as_str(), \"text/plain\"))\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.headers().get(\"Accept\").count(), 2);\n    /// ```\n    #[inline(always)]\n    pub fn header_adjoin<'h: 'r, H>(&mut self, header: H) -> &mut Builder<'r>\n        where H: Into<Header<'h>>\n    {\n        self.response.adjoin_header(header);\n        self\n    }\n\n    /// Adds a custom header to the `Response` with the given name and value,\n    /// replacing any header with the same name that already exists in the\n    /// response. If multiple headers with the same name exist, they are all\n    /// removed, and only the new header and value will remain.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    ///\n    /// let response = Response::build()\n    ///     .raw_header(\"X-Custom\", \"first\")\n    ///     .raw_header(\"X-Custom\", \"second\")\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.headers().get(\"X-Custom\").count(), 1);\n    /// ```\n    #[inline(always)]\n    pub fn raw_header<'a, 'b, N, V>(&mut self, name: N, value: V) -> &mut Builder<'r>\n        where N: Into<Cow<'a, str>>, V: Into<Cow<'b, str>>, 'a: 'r, 'b: 'r\n    {\n        self.response.set_raw_header(name, value);\n        self\n    }\n\n    /// Adds custom header to the `Response` with the given name and value,\n    /// adjoining the header with any existing headers with the same name that\n    /// already exist in the `Response`. This allows for multiple headers with\n    /// the same name and potentially different values to be present in the\n    /// `Response`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    ///\n    /// let response = Response::build()\n    ///     .raw_header_adjoin(\"X-Custom\", \"first\")\n    ///     .raw_header_adjoin(\"X-Custom\", \"second\")\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.headers().get(\"X-Custom\").count(), 2);\n    /// ```\n    #[inline(always)]\n    pub fn raw_header_adjoin<'a, 'b, N, V>(&mut self, name: N, value: V) -> &mut Builder<'r>\n        where N: Into<Cow<'a, str>>, V: Into<Cow<'b, str>>, 'a: 'r, 'b: 'r\n    {\n        self.response.adjoin_raw_header(name, value);\n        self\n    }\n\n    /// Sets the body of the `Response` to be the fixed-sized `body` with size\n    /// `size`, which may be `None`. If `size` is `None`, the body's size will\n    /// be computed with calls to `seek` when the response is written out.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::Response;\n    ///\n    /// let body = \"Hello, world!\";\n    /// let response = Response::build()\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .finalize();\n    /// ```\n    pub fn sized_body<B, S>(&mut self, size: S, body: B) -> &mut Builder<'r>\n        where B: AsyncRead + AsyncSeek + Send + 'r,\n              S: Into<Option<usize>>\n    {\n        self.response.set_sized_body(size, body);\n        self\n    }\n\n    /// Sets the body of the `Response` to be the streamed `body`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::Response;\n    ///\n    /// let response = Response::build()\n    ///     .streamed_body(Cursor::new(\"Hello, world!\"))\n    ///     .finalize();\n    /// ```\n    #[inline(always)]\n    pub fn streamed_body<B>(&mut self, body: B) -> &mut Builder<'r>\n        where B: AsyncRead + Send + 'r\n    {\n        self.response.set_streamed_body(body);\n        self\n    }\n\n    /// Registers `handler` as the I/O handler for upgrade protocol `protocol`.\n    ///\n    /// This is equivalent to [`Response::add_upgrade()`].\n    ///\n    /// **NOTE**: Responses registering I/O handlers for upgraded protocols\n    /// **should not** set the response status to `101 Switching Protocols`, nor set the\n    /// `Connection` or `Upgrade` headers. Rocket automatically sets these\n    /// headers as needed. See [`Response`#upgrading] for details.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::pin::Pin;\n    ///\n    /// use rocket::Response;\n    /// use rocket::data::{IoHandler, IoStream};\n    /// use rocket::tokio::io;\n    ///\n    /// struct EchoHandler;\n    ///\n    /// #[rocket::async_trait]\n    /// impl IoHandler for EchoHandler {\n    ///     async fn io(self: Pin<Box<Self>>, io: IoStream) -> io::Result<()> {\n    ///         let (mut reader, mut writer) = io::split(io);\n    ///         io::copy(&mut reader, &mut writer).await?;\n    ///         Ok(())\n    ///     }\n    /// }\n    ///\n    /// let response = Response::build()\n    ///     .upgrade(\"raw-echo\", EchoHandler)\n    ///     .streamed_body(std::io::Cursor::new(\"We didn't upgrade!\"))\n    ///     .finalize();\n    /// ```\n    #[inline(always)]\n    pub fn upgrade<P, H>(&mut self, protocol: P, handler: H) -> &mut Builder<'r>\n        where P: Into<Uncased<'r>>, H: IoHandler + 'r\n    {\n        self.response.add_upgrade(protocol.into(), handler);\n        self\n    }\n\n    /// Sets the max chunk size of a body, if any, to `size`.\n    ///\n    /// See [`Response::set_max_chunk_size()`] for notes.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::Response;\n    ///\n    /// let response = Response::build()\n    ///     .streamed_body(Cursor::new(\"Hello, world!\"))\n    ///     .max_chunk_size(3072)\n    ///     .finalize();\n    /// ```\n    #[inline(always)]\n    pub fn max_chunk_size(&mut self, size: usize) -> &mut Builder<'r> {\n        self.response.set_max_chunk_size(size);\n        self\n    }\n\n    /// Merges the `other` `Response` into `self` by setting any fields in\n    /// `self` to the corresponding value in `other` if they are set in `other`.\n    /// Fields in `self` are unchanged if they are not set in `other`. If a\n    /// header is set in both `self` and `other`, the values in `other` are\n    /// kept. Headers set only in `self` remain.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::{Status, ContentType};\n    ///\n    /// let base = Response::build()\n    ///     .status(Status::NotFound)\n    ///     .header(ContentType::HTML)\n    ///     .raw_header(\"X-Custom\", \"value 1\")\n    ///     .finalize();\n    ///\n    /// let response = Response::build()\n    ///     .status(Status::ImATeapot)\n    ///     .raw_header(\"X-Custom\", \"value 2\")\n    ///     .raw_header_adjoin(\"X-Custom\", \"value 3\")\n    ///     .merge(base)\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.status(), Status::NotFound);\n    ///\n    /// let ctype: Vec<_> = response.headers().get(\"Content-Type\").collect();\n    /// assert_eq!(ctype, vec![ContentType::HTML.to_string()]);\n    ///\n    /// let custom_values: Vec<_> = response.headers().get(\"X-Custom\").collect();\n    /// assert_eq!(custom_values, vec![\"value 1\"]);\n    /// ```\n    #[inline(always)]\n    pub fn merge(&mut self, other: Response<'r>) -> &mut Builder<'r> {\n        self.response.merge(other);\n        self\n    }\n\n    /// Joins the `other` `Response` into `self` by setting any fields in `self`\n    /// to the corresponding value in `other` if they are set in `self`. Fields\n    /// in `self` are unchanged if they are already set. If a header is set in\n    /// both `self` and `other`, the values are adjoined, with the values in\n    /// `self` coming first. Headers only in `self` or `other` are set in\n    /// `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::{Status, ContentType};\n    ///\n    /// let other = Response::build()\n    ///     .status(Status::NotFound)\n    ///     .header(ContentType::HTML)\n    ///     .raw_header(\"X-Custom\", \"value 1\")\n    ///     .finalize();\n    ///\n    /// let response = Response::build()\n    ///     .status(Status::ImATeapot)\n    ///     .raw_header(\"X-Custom\", \"value 2\")\n    ///     .raw_header_adjoin(\"X-Custom\", \"value 3\")\n    ///     .join(other)\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.status(), Status::ImATeapot);\n    ///\n    /// let ctype: Vec<_> = response.headers().get(\"Content-Type\").collect();\n    /// assert_eq!(ctype, vec![ContentType::HTML.to_string()]);\n    ///\n    /// let custom_values: Vec<_> = response.headers().get(\"X-Custom\").collect();\n    /// assert_eq!(custom_values, vec![\"value 2\", \"value 3\", \"value 1\"]);\n    /// ```\n    #[inline(always)]\n    pub fn join(&mut self, other: Response<'r>) -> &mut Builder<'r> {\n        self.response.join(other);\n        self\n    }\n\n    /// Return the `Response` structure that was being built by this builder.\n    /// After calling this method, `self` is cleared and must be rebuilt as if\n    /// from `new()`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    ///\n    /// use rocket::Response;\n    /// use rocket::http::Status;\n    ///\n    /// let body = \"Brewing the best coffee!\";\n    /// let response = Response::build()\n    ///     .status(Status::ImATeapot)\n    ///     .sized_body(body.len(), Cursor::new(body))\n    ///     .raw_header(\"X-Custom\", \"value 2\")\n    ///     .finalize();\n    /// ```\n    pub fn finalize(&mut self) -> Response<'r> {\n        std::mem::replace(&mut self.response, Response::new())\n    }\n\n    /// Retrieve the built `Response` wrapped in `Ok`. After calling this\n    /// method, `self` is cleared and must be rebuilt as if from `new()`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    ///\n    /// let response: Result<Response, ()> = Response::build()\n    ///     // build the response\n    ///     .ok();\n    ///\n    /// assert!(response.is_ok());\n    /// ```\n    #[inline(always)]\n    pub fn ok<E>(&mut self) -> Result<Response<'r>, E> {\n        Ok(self.finalize())\n    }\n}\n\n/// A response, as returned by types implementing\n/// [`Responder`](crate::response::Responder).\n///\n/// See [`Builder`] for docs on how a `Response` is typically created and the\n/// [module docs](crate::response) for notes on composing responses\n///\n/// ## Upgrading\n///\n/// A response may optionally register [`IoHandler`]s for upgraded requests via\n/// [`Response::add_upgrade()`] or the corresponding builder method\n/// [`Builder::upgrade()`]. If the incoming request 1) requests an upgrade via a\n/// `Connection: Upgrade` header _and_ 2) includes a protocol in its `Upgrade`\n/// header that is registered by the returned `Response`, the connection will be\n/// upgraded. An upgrade response is sent to the client, and the registered\n/// `IoHandler` for the client's preferred protocol is invoked with an\n/// [`IoStream`](crate::data::IoStream) representing a raw byte stream to the\n/// client. Note that protocol names are treated case-insensitively during\n/// matching.\n///\n/// If a connection is upgraded, Rocket automatically set the following in the\n/// upgrade response:\n///   * The response status to `101 Switching Protocols`.\n///   * The `Connection: Upgrade` header.\n///   * The `Upgrade` header's value to the selected protocol.\n///\n/// As such, a response **should never** set a `101` status nor the `Connection`\n/// or `Upgrade` headers: Rocket handles this automatically. Instead, it should\n/// set a status and headers to use in case the connection is not upgraded,\n/// either due to an error or because the client did not request an upgrade.\n///\n/// If a connection _is not_ upgraded due to an error, even though there was a\n/// matching, registered protocol, the `IoHandler` is not invoked, and the\n/// original response is sent to the client without alteration.\n#[derive(Default)]\npub struct Response<'r> {\n    status: Option<Status>,\n    headers: HeaderMap<'r>,\n    body: Body<'r>,\n    upgrade: HashMap<Uncased<'r>, Pin<Box<dyn IoHandler + 'r>>>,\n}\n\nimpl<'r> Response<'r> {\n    /// Creates a new, empty `Response` without a status, body, or headers.\n    /// Because all HTTP responses must have a status, if a default `Response`\n    /// is written to the client without a status, the status defaults to `200\n    /// Ok`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Status;\n    ///\n    /// let mut response = Response::new();\n    ///\n    /// assert_eq!(response.status(), Status::Ok);\n    /// assert_eq!(response.headers().len(), 0);\n    /// assert!(response.body().is_none());\n    /// ```\n    #[inline(always)]\n    pub fn new() -> Response<'r> {\n        Response::default()\n    }\n\n    /// Returns a `Builder` with a base of `Response::new()`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    ///\n    /// # #[allow(unused_variables)]\n    /// let builder = Response::build();\n    /// ```\n    #[inline(always)]\n    pub fn build() -> Builder<'r> {\n        Response::build_from(Response::new())\n    }\n\n    /// Returns a `Builder` with a base of `other`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #![allow(unused_variables)]\n    /// use rocket::Response;\n    ///\n    /// let other = Response::new();\n    /// let builder = Response::build_from(other);\n    /// ```\n    #[inline(always)]\n    pub fn build_from(other: Response<'r>) -> Builder<'r> {\n        Builder::new(other)\n    }\n\n    /// Returns the status of `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Status;\n    ///\n    /// let mut response = Response::new();\n    /// assert_eq!(response.status(), Status::Ok);\n    ///\n    /// response.set_status(Status::NotFound);\n    /// assert_eq!(response.status(), Status::NotFound);\n    /// ```\n    #[inline(always)]\n    pub fn status(&self) -> Status {\n        self.status.unwrap_or(Status::Ok)\n    }\n\n    /// Sets the status of `self` to `status`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Status;\n    ///\n    /// let mut response = Response::new();\n    /// response.set_status(Status::ImATeapot);\n    /// assert_eq!(response.status(), Status::ImATeapot);\n    /// ```\n    #[inline(always)]\n    pub fn set_status(&mut self, status: Status) {\n        self.status = Some(status);\n    }\n\n    /// Returns the Content-Type header of `self`. If the header is not present\n    /// or is malformed, returns `None`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::ContentType;\n    ///\n    /// let mut response = Response::new();\n    /// response.set_header(ContentType::HTML);\n    /// assert_eq!(response.content_type(), Some(ContentType::HTML));\n    /// ```\n    #[inline(always)]\n    pub fn content_type(&self) -> Option<ContentType> {\n        self.headers().get_one(\"Content-Type\").and_then(|v| v.parse().ok())\n    }\n\n    /// Returns an iterator over the cookies in `self` as identified by the\n    /// `Set-Cookie` header. Malformed cookies are skipped.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Cookie;\n    ///\n    /// let mut response = Response::new();\n    /// response.set_header(Cookie::new(\"hello\", \"world!\"));\n    /// let cookies: Vec<_> = response.cookies().collect();\n    /// assert_eq!(cookies, vec![Cookie::new(\"hello\", \"world!\")]);\n    /// ```\n    pub fn cookies(&self) -> impl Iterator<Item = Cookie<'_>> {\n        self.headers()\n            .get(\"Set-Cookie\")\n            .filter_map(|header| Cookie::parse_encoded(header).ok())\n    }\n\n    /// Returns a [`HeaderMap`] of all of the headers in `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Header;\n    ///\n    /// let mut response = Response::new();\n    /// response.adjoin_raw_header(\"X-Custom\", \"1\");\n    /// response.adjoin_raw_header(\"X-Custom\", \"2\");\n    ///\n    /// let mut custom_headers = response.headers().iter();\n    /// assert_eq!(custom_headers.next(), Some(Header::new(\"X-Custom\", \"1\")));\n    /// assert_eq!(custom_headers.next(), Some(Header::new(\"X-Custom\", \"2\")));\n    /// assert_eq!(custom_headers.next(), None);\n    /// ```\n    #[inline(always)]\n    pub fn headers(&self) -> &HeaderMap<'r> {\n        &self.headers\n    }\n\n    /// Sets the header `header` in `self`. Any existing headers with the name\n    /// `header.name` will be lost, and only `header` will remain. The type of\n    /// `header` can be any type that implements `Into<Header>`. This includes\n    /// `Header` itself, [`ContentType`](crate::http::ContentType) and\n    /// [`hyper::header` types](crate::http::hyper::header).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::ContentType;\n    ///\n    /// let mut response = Response::new();\n    ///\n    /// response.set_header(ContentType::HTML);\n    /// assert_eq!(response.headers().iter().next(), Some(ContentType::HTML.into()));\n    /// assert_eq!(response.headers().len(), 1);\n    ///\n    /// response.set_header(ContentType::JSON);\n    /// assert_eq!(response.headers().iter().next(), Some(ContentType::JSON.into()));\n    /// assert_eq!(response.headers().len(), 1);\n    /// ```\n    #[inline(always)]\n    pub fn set_header<'h: 'r, H: Into<Header<'h>>>(&mut self, header: H) -> bool {\n        self.headers.replace(header)\n    }\n\n    /// Sets the custom header with name `name` and value `value` in `self`. Any\n    /// existing headers with the same `name` will be lost, and the new custom\n    /// header will remain. This method should be used sparingly; prefer to use\n    /// [set_header](#method.set_header) instead.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Header;\n    ///\n    /// let mut response = Response::new();\n    ///\n    /// response.set_raw_header(\"X-Custom\", \"1\");\n    /// assert_eq!(response.headers().get_one(\"X-Custom\"), Some(\"1\"));\n    /// assert_eq!(response.headers().len(), 1);\n    ///\n    /// response.set_raw_header(\"X-Custom\", \"2\");\n    /// assert_eq!(response.headers().get_one(\"X-Custom\"), Some(\"2\"));\n    /// assert_eq!(response.headers().len(), 1);\n    /// ```\n    #[inline(always)]\n    pub fn set_raw_header<'a: 'r, 'b: 'r, N, V>(&mut self, name: N, value: V) -> bool\n        where N: Into<Cow<'a, str>>, V: Into<Cow<'b, str>>\n    {\n        self.set_header(Header::new(name, value))\n    }\n\n    /// Adds the header `header` to `self`. If `self` contains headers with the\n    /// name `header.name`, another header with the same name and value\n    /// `header.value` is added. The type of `header` can be any type that\n    /// implements `Into<Header>`. This includes `Header` itself,\n    /// [`ContentType`](crate::http::ContentType) and [`hyper::header`\n    /// types](crate::http::hyper::header).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Header;\n    /// use rocket::http::hyper::header::ACCEPT;\n    ///\n    /// let mut response = Response::new();\n    /// response.adjoin_header(Header::new(ACCEPT.as_str(), \"application/json\"));\n    /// response.adjoin_header(Header::new(ACCEPT.as_str(), \"text/plain\"));\n    ///\n    /// let mut accept_headers = response.headers().iter();\n    /// assert_eq!(accept_headers.next(), Some(Header::new(ACCEPT.as_str(), \"application/json\")));\n    /// assert_eq!(accept_headers.next(), Some(Header::new(ACCEPT.as_str(), \"text/plain\")));\n    /// assert_eq!(accept_headers.next(), None);\n    /// ```\n    #[inline(always)]\n    pub fn adjoin_header<'h: 'r, H: Into<Header<'h>>>(&mut self, header: H) {\n        self.headers.add(header)\n    }\n\n    /// Adds a custom header with name `name` and value `value` to `self`. If\n    /// `self` already contains headers with the name `name`, another header\n    /// with the same `name` and `value` is added. The type of `header` can be\n    /// any type implements `Into<Header>`. This includes `Header` itself,\n    /// [`ContentType`](crate::http::ContentType) and [`hyper::header`\n    /// types](crate::http::hyper::header).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::Header;\n    ///\n    /// let mut response = Response::new();\n    /// response.adjoin_raw_header(\"X-Custom\", \"one\");\n    /// response.adjoin_raw_header(\"X-Custom\", \"two\");\n    ///\n    /// let mut custom_headers = response.headers().iter();\n    /// assert_eq!(custom_headers.next(), Some(Header::new(\"X-Custom\", \"one\")));\n    /// assert_eq!(custom_headers.next(), Some(Header::new(\"X-Custom\", \"two\")));\n    /// assert_eq!(custom_headers.next(), None);\n    /// ```\n    #[inline(always)]\n    pub fn adjoin_raw_header<'a: 'r, 'b: 'r, N, V>(&mut self, name: N, value: V)\n        where N: Into<Cow<'a, str>>, V: Into<Cow<'b, str>>\n    {\n        self.adjoin_header(Header::new(name, value));\n    }\n\n    /// Removes all headers with the name `name`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    ///\n    /// let mut response = Response::new();\n    ///\n    /// response.adjoin_raw_header(\"X-Custom\", \"one\");\n    /// response.adjoin_raw_header(\"X-Custom\", \"two\");\n    /// response.adjoin_raw_header(\"X-Other\", \"hi\");\n    /// assert_eq!(response.headers().len(), 3);\n    ///\n    /// response.remove_header(\"X-Custom\");\n    /// assert_eq!(response.headers().len(), 1);\n    /// ```\n    #[inline(always)]\n    pub fn remove_header(&mut self, name: &str) {\n        self.headers.remove(name);\n    }\n\n    /// Returns an immutable borrow of the body of `self`, if there is one.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::Response;\n    ///\n    /// # rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// assert!(response.body().is_none());\n    ///\n    /// let string = \"Hello, world!\";\n    /// response.set_sized_body(string.len(), Cursor::new(string));\n    /// assert!(response.body().is_some());\n    /// # })\n    /// ```\n    #[inline(always)]\n    pub fn body(&self) -> &Body<'r> {\n        &self.body\n    }\n\n    /// Returns `Ok(Some(_))` if `self` contains a suitable handler for any of\n    /// the comma-separated protocols any of the strings in `I`. Returns\n    /// `Ok(None)` if `self` doesn't support any kind of upgrade. Returns\n    /// `Err(_)` if `protocols` is non-empty but no match was found in `self`.\n    pub(crate) fn take_upgrade<I: Iterator<Item = &'r str>>(\n        &mut self,\n        protocols: I\n    ) -> Result<Option<(Uncased<'r>, Pin<Box<dyn IoHandler + 'r>>)>, ()> {\n        if self.upgrade.is_empty() {\n            return Ok(None);\n        }\n\n        let mut protocols = protocols.peekable();\n        let have_protocols = protocols.peek().is_some();\n        let found = protocols\n            .flat_map(|v| v.split(',').map(str::trim))\n            .find_map(|p| self.upgrade.remove_entry(p.as_uncased()));\n\n        match found {\n            Some(handler) => Ok(Some(handler)),\n            None if have_protocols => Err(()),\n            None => Ok(None)\n        }\n    }\n\n    /// Returns the [`IoHandler`] for the protocol `proto`.\n    ///\n    /// Returns `Some` if such a handler was registered via\n    /// [`Response::add_upgrade()`] or the corresponding builder method\n    /// [`upgrade()`](Builder::upgrade()). Otherwise returns `None`.\n    ///\n    /// ```rust\n    /// use std::pin::Pin;\n    ///\n    /// use rocket::Response;\n    /// use rocket::data::{IoHandler, IoStream};\n    /// use rocket::tokio::io;\n    ///\n    /// struct EchoHandler;\n    ///\n    /// #[rocket::async_trait]\n    /// impl IoHandler for EchoHandler {\n    ///     async fn io(self: Pin<Box<Self>>, io: IoStream) -> io::Result<()> {\n    ///         let (mut reader, mut writer) = io::split(io);\n    ///         io::copy(&mut reader, &mut writer).await?;\n    ///         Ok(())\n    ///     }\n    /// }\n    ///\n    /// # rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// assert!(response.upgrade(\"raw-echo\").is_none());\n    ///\n    /// response.add_upgrade(\"raw-echo\", EchoHandler);\n    /// assert!(response.upgrade(\"raw-echo\").is_some());\n    /// # })\n    /// ```\n    pub fn upgrade(&mut self, proto: &str) -> Option<Pin<&mut (dyn IoHandler + 'r)>> {\n        self.upgrade.get_mut(proto.as_uncased()).map(|h| h.as_mut())\n    }\n\n    /// Returns a mutable borrow of the body of `self`, if there is one. A\n    /// mutable borrow allows for reading the body.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    /// use rocket::Response;\n    ///\n    /// # rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// assert!(response.body().is_none());\n    ///\n    /// let string = \"Hello, world!\";\n    /// response.set_sized_body(string.len(), Cursor::new(string));\n    /// let string = response.body_mut().to_string().await;\n    /// assert_eq!(string.unwrap(), \"Hello, world!\");\n    /// # })\n    /// ```\n    #[inline(always)]\n    pub fn body_mut(&mut self) -> &mut Body<'r> {\n        &mut self.body\n    }\n\n    // Makes the `AsyncRead`er in the body empty but leaves the size of the body\n    // if it exists. Meant to be used during HEAD handling.\n    #[inline(always)]\n    pub(crate) fn strip_body(&mut self) {\n        self.body.strip();\n    }\n\n    /// Sets the body of `self` to be the fixed-sized `body` with size\n    /// `size`, which may be `None`. If `size` is `None`, the body's size will\n    /// be computing with calls to `seek` just before being written out in a\n    /// response.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::io;\n    /// use rocket::Response;\n    ///\n    /// # let o: io::Result<()> = rocket::async_test(async {\n    /// let string = \"Hello, world!\";\n    ///\n    /// let mut response = Response::new();\n    /// response.set_sized_body(string.len(), io::Cursor::new(string));\n    /// assert_eq!(response.body_mut().to_string().await?, \"Hello, world!\");\n    /// # Ok(())\n    /// # });\n    /// # assert!(o.is_ok());\n    /// ```\n    pub fn set_sized_body<B, S>(&mut self, size: S, body: B)\n        where B: AsyncRead + AsyncSeek + Send + 'r,\n              S: Into<Option<usize>>\n    {\n        self.body = Body::with_sized(body, size.into());\n    }\n\n    /// Sets the body of `self` to `body`, which will be streamed.\n    ///\n    /// The max chunk size is configured via [`Response::set_max_chunk_size()`]\n    /// and defaults to [`Body::DEFAULT_MAX_CHUNK`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use std::io;\n    /// use tokio::io::{repeat, AsyncReadExt};\n    /// use rocket::Response;\n    ///\n    /// # let o: io::Result<()> = rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// response.set_streamed_body(repeat(97).take(5));\n    /// assert_eq!(response.body_mut().to_string().await?, \"aaaaa\");\n    /// # Ok(())\n    /// # });\n    /// # assert!(o.is_ok());\n    /// ```\n    #[inline(always)]\n    pub fn set_streamed_body<B>(&mut self, body: B)\n        where B: AsyncRead + Send + 'r\n    {\n        self.body = Body::with_unsized(body);\n    }\n\n    /// Registers `handler` as the I/O handler for upgrade protocol `protocol`.\n    ///\n    /// Responses registering I/O handlers for upgraded protocols **should not**\n    /// set the response status to `101`, nor set the `Connection` or `Upgrade`\n    /// headers. Rocket automatically sets these headers as needed. See\n    /// [`Response`#upgrading] for details.\n    ///\n    /// If a handler was previously registered for `protocol`, this `handler`\n    /// replaces it. If the connection is upgraded to `protocol`, the last\n    /// `handler` registered for the protocol is used to handle the connection.\n    /// See [`IoHandler`] for details on implementing an I/O handler. For\n    /// details on connection upgrading, see [`Response`#upgrading].\n    ///\n    /// [`Response`#upgrading]: Response#upgrading\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use std::pin::Pin;\n    ///\n    /// use rocket::Response;\n    /// use rocket::data::{IoHandler, IoStream};\n    /// use rocket::tokio::io;\n    ///\n    /// struct EchoHandler;\n    ///\n    /// #[rocket::async_trait]\n    /// impl IoHandler for EchoHandler {\n    ///     async fn io(self: Pin<Box<Self>>, io: IoStream) -> io::Result<()> {\n    ///         let (mut reader, mut writer) = io::split(io);\n    ///         io::copy(&mut reader, &mut writer).await?;\n    ///         Ok(())\n    ///     }\n    /// }\n    ///\n    /// # rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// assert!(response.upgrade(\"raw-echo\").is_none());\n    ///\n    /// response.add_upgrade(\"raw-echo\", EchoHandler);\n    /// assert!(response.upgrade(\"raw-echo\").is_some());\n    /// # })\n    /// ```\n    pub fn add_upgrade<N, H>(&mut self, protocol: N, handler: H)\n        where N: Into<Uncased<'r>>, H: IoHandler + 'r\n    {\n        self.upgrade.insert(protocol.into(), Box::pin(handler));\n    }\n\n    /// Sets the body's maximum chunk size to `size` bytes.\n    ///\n    /// The default max chunk size is [`Body::DEFAULT_MAX_CHUNK`]. The max chunk\n    /// size is a property of the body and is thus reset whenever a body is set\n    /// via [`Response::set_streamed_body()`], [`Response::set_sized_body()`],\n    /// or the corresponding builder methods.\n    ///\n    /// This setting does not typically need to be changed. Configuring a high\n    /// value can result in high memory usage. Similarly, configuring a low\n    /// value can result in excessive network writes. When unsure, leave the\n    /// value unchanged.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use tokio::io::{repeat, AsyncReadExt};\n    /// use rocket::Response;\n    ///\n    /// # let o: Option<()> = rocket::async_test(async {\n    /// let mut response = Response::new();\n    /// response.set_streamed_body(repeat(97).take(5));\n    /// response.set_max_chunk_size(3072);\n    /// # Some(())\n    /// # });\n    /// # assert!(o.is_some());\n    #[inline(always)]\n    pub fn set_max_chunk_size(&mut self, size: usize) {\n        self.body_mut().set_max_chunk_size(size);\n    }\n\n    /// Replaces this response's status and body with that of `other`, if they\n    /// exist in `other`. Any headers that exist in `other` replace the ones in\n    /// `self`. Any in `self` that aren't in `other` remain in `self`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::{Status, ContentType};\n    ///\n    /// let base = Response::build()\n    ///     .status(Status::NotFound)\n    ///     .header(ContentType::HTML)\n    ///     .raw_header(\"X-Custom\", \"value 1\")\n    ///     .finalize();\n    ///\n    /// let response = Response::build()\n    ///     .status(Status::ImATeapot)\n    ///     .raw_header(\"X-Custom\", \"value 2\")\n    ///     .raw_header_adjoin(\"X-Custom\", \"value 3\")\n    ///     .merge(base)\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.status(), Status::NotFound);\n    ///\n    /// let ctype: Vec<_> = response.headers().get(\"Content-Type\").collect();\n    /// assert_eq!(ctype, vec![ContentType::HTML.to_string()]);\n    ///\n    /// let custom_values: Vec<_> = response.headers().get(\"X-Custom\").collect();\n    /// assert_eq!(custom_values, vec![\"value 1\"]);\n    /// ```\n    pub fn merge(&mut self, other: Response<'r>) {\n        if let Some(status) = other.status {\n            self.status = Some(status);\n        }\n\n        if other.body().is_some() {\n            self.body = other.body;\n        }\n\n        for (name, values) in other.headers.into_iter_raw() {\n            self.headers.replace_all(name.into_cow(), values);\n        }\n    }\n\n    /// Sets `self`'s status and body to that of `other` if they are not already\n    /// set in `self`. Any headers present in both `other` and `self` are\n    /// adjoined.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Response;\n    /// use rocket::http::{Status, ContentType};\n    ///\n    /// let other = Response::build()\n    ///     .status(Status::NotFound)\n    ///     .header(ContentType::HTML)\n    ///     .raw_header(\"X-Custom\", \"value 1\")\n    ///     .finalize();\n    ///\n    /// let response = Response::build()\n    ///     .status(Status::ImATeapot)\n    ///     .raw_header(\"X-Custom\", \"value 2\")\n    ///     .raw_header_adjoin(\"X-Custom\", \"value 3\")\n    ///     .join(other)\n    ///     .finalize();\n    ///\n    /// assert_eq!(response.status(), Status::ImATeapot);\n    ///\n    /// let ctype: Vec<_> = response.headers().get(\"Content-Type\").collect();\n    /// assert_eq!(ctype, vec![ContentType::HTML.to_string()]);\n    ///\n    /// let custom_values: Vec<_> = response.headers().get(\"X-Custom\").collect();\n    /// assert_eq!(custom_values, vec![\"value 2\", \"value 3\", \"value 1\"]);\n    /// ```\n    pub fn join(&mut self, other: Response<'r>) {\n        if self.status.is_none() {\n            self.status = other.status;\n        }\n\n        if self.body.is_none() {\n            self.body = other.body;\n        }\n\n        for (name, mut values) in other.headers.into_iter_raw() {\n            self.headers.add_all(name.into_cow(), &mut values);\n        }\n    }\n}\n\nimpl fmt::Debug for Response<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        writeln!(f, \"{}\", self.status())?;\n\n        for header in self.headers().iter() {\n            writeln!(f, \"{}\", header)?;\n        }\n\n        self.body.fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Contains types that set the status code and corresponding headers of a\n//! response.\n//!\n//! # Responding\n//!\n//! Types in this module designed to make it easier to construct correct\n//! responses with a given status code. Each type takes in the minimum number of\n//! parameters required to construct a correct response. Some types take in\n//! responders; when they do, the responder finalizes the response by writing\n//! out additional headers and, importantly, the body of the response.\n//!\n//! The [`Custom`] type allows responding with _any_ `Status` but _does not_\n//! ensure that all of the required headers are present. As a convenience,\n//! `(Status, R)` where `R: Responder` is _also_ a `Responder`, identical to\n//! `Custom`.\n//!\n//! ```rust\n//! # extern crate rocket;\n//! # use rocket::get;\n//! use rocket::http::Status;\n//!\n//! #[get(\"/\")]\n//! fn index() -> (Status, &'static str) {\n//!     (Status::NotFound, \"Hey, there's no index!\")\n//! }\n//! ```\n\nuse std::hash::{Hash, Hasher};\nuse std::collections::hash_map::DefaultHasher;\nuse std::borrow::Cow;\n\nuse crate::request::Request;\nuse crate::response::{self, Responder, Response};\nuse crate::http::Status;\n\n/// Sets the status of the response to 201 Created.\n///\n/// Sets the `Location` header and optionally the `ETag` header in the response.\n/// The body of the response, which identifies the created resource, can be set\n/// via the builder methods [`Created::body()`] and [`Created::tagged_body()`].\n/// While both builder methods set the responder, the [`Created::tagged_body()`]\n/// additionally computes a hash for the responder which is used as the value of\n/// the `ETag` header when responding.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::response::status;\n///\n/// let response = status::Created::new(\"http://myservice.com/resource.json\")\n///     .tagged_body(\"{ 'resource': 'Hello, world!' }\");\n/// ```\n#[derive(Debug, Clone, PartialEq)]\npub struct Created<R>(Cow<'static, str>, Option<R>, Option<u64>);\n\nimpl<'r, R> Created<R> {\n    /// Constructs a `Created` response with a `location` and no body.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::{get, routes, local::blocking::Client};\n    /// use rocket::response::status;\n    ///\n    /// #[get(\"/\")]\n    /// fn create() -> status::Created<&'static str> {\n    ///     status::Created::new(\"http://myservice.com/resource.json\")\n    /// }\n    ///\n    /// # let client = Client::debug_with(routes![create]).unwrap();\n    /// let response = client.get(\"/\").dispatch();\n    ///\n    /// let loc = response.headers().get_one(\"Location\");\n    /// assert_eq!(loc, Some(\"http://myservice.com/resource.json\"));\n    /// assert!(response.body().is_none());\n    /// ```\n    pub fn new<L: Into<Cow<'static, str>>>(location: L) -> Self {\n        Created(location.into(), None, None)\n    }\n\n    /// Adds `responder` as the body of `self`.\n    ///\n    /// Unlike [`tagged_body()`](self::Created::tagged_body()), this method\n    /// _does not_ result in an `ETag` header being set in the response.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::{get, routes, local::blocking::Client};\n    /// use rocket::response::status;\n    ///\n    /// #[get(\"/\")]\n    /// fn create() -> status::Created<&'static str> {\n    ///     status::Created::new(\"http://myservice.com/resource.json\")\n    ///         .body(\"{ 'resource': 'Hello, world!' }\")\n    /// }\n    ///\n    /// # let client = Client::debug_with(routes![create]).unwrap();\n    /// let response = client.get(\"/\").dispatch();\n    ///\n    /// let loc = response.headers().get_one(\"Location\");\n    /// assert_eq!(loc, Some(\"http://myservice.com/resource.json\"));\n    ///\n    /// let etag = response.headers().get_one(\"ETag\");\n    /// assert_eq!(etag, None);\n    ///\n    /// let body = response.into_string();\n    /// assert_eq!(body.unwrap(), \"{ 'resource': 'Hello, world!' }\");\n    /// ```\n    pub fn body(mut self, responder: R) -> Self {\n        self.1 = Some(responder);\n        self\n    }\n\n    /// Adds `responder` as the body of `self`. Computes a hash of the\n    /// `responder` to be used as the value of the `ETag` header.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::{get, routes, local::blocking::Client};\n    /// use rocket::response::status;\n    ///\n    /// #[get(\"/\")]\n    /// fn create() -> status::Created<&'static str> {\n    ///     status::Created::new(\"http://myservice.com/resource.json\")\n    ///         .tagged_body(\"{ 'resource': 'Hello, world!' }\")\n    /// }\n    ///\n    /// # let client = Client::debug_with(routes![create]).unwrap();\n    /// let response = client.get(\"/\").dispatch();\n    ///\n    /// let loc = response.headers().get_one(\"Location\");\n    /// assert_eq!(loc, Some(\"http://myservice.com/resource.json\"));\n    ///\n    /// let etag = response.headers().get_one(\"ETag\");\n    /// assert_eq!(etag, Some(r#\"\"13046220615156895040\"\"#));\n    ///\n    /// let body = response.into_string();\n    /// assert_eq!(body.unwrap(), \"{ 'resource': 'Hello, world!' }\");\n    /// ```\n    pub fn tagged_body(mut self, responder: R) -> Self where R: Hash {\n        let mut hasher = &mut DefaultHasher::default();\n        responder.hash(&mut hasher);\n        let hash = hasher.finish();\n        self.1 = Some(responder);\n        self.2 = Some(hash);\n        self\n    }\n}\n\n/// Sets the status code of the response to 201 Created. Sets the `Location`\n/// header to the parameter in the [`Created::new()`] constructor.\n///\n/// The optional responder, set via [`Created::body()`] or\n/// [`Created::tagged_body()`] finalizes the response if it exists. The wrapped\n/// responder should write the body of the response so that it contains\n/// information about the created resource. If no responder is provided, the\n/// response body will be empty.\n///\n/// In addition to setting the status code, `Location` header, and finalizing\n/// the response with the `Responder`, the `ETag` header is set conditionally if\n/// a hashable `Responder` is provided via [`Created::tagged_body()`]. The `ETag`\n/// header is set to a hash value of the responder.\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for Created<R> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        let mut response = Response::build();\n        if let Some(responder) = self.1 {\n            response.merge(responder.respond_to(req)?);\n        }\n\n        if let Some(hash) = self.2 {\n            response.raw_header(\"ETag\", format!(r#\"\"{}\"\"#, hash));\n        }\n\n        response.status(Status::Created)\n            .raw_header(\"Location\", self.0)\n            .ok()\n    }\n}\n\n/// Sets the status of the response to 204 No Content.\n///\n/// The response body will be empty.\n///\n/// # Example\n///\n/// A 204 No Content response:\n///\n/// ```rust\n/// # use rocket::get;\n/// use rocket::response::status;\n///\n/// #[get(\"/\")]\n/// fn foo() -> status::NoContent {\n///     status::NoContent\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq)]\npub struct NoContent;\n\n/// Sets the status code of the response to 204 No Content.\nimpl<'r> Responder<'r, 'static> for NoContent {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'static> {\n        Response::build().status(Status::NoContent).ok()\n    }\n}\n\n/// Creates a response with a status code and underlying responder.\n///\n/// Note that this is equivalent to `(Status, R)`.\n///\n/// # Example\n///\n/// ```rust\n/// # use rocket::get;\n/// use rocket::response::status;\n/// use rocket::http::Status;\n///\n/// #[get(\"/\")]\n/// fn handler() -> status::Custom<&'static str> {\n///     status::Custom(Status::ImATeapot, \"Hi!\")\n/// }\n///\n/// // This is equivalent to the above.\n/// #[get(\"/\")]\n/// fn handler2() -> (Status, &'static str) {\n///     (Status::ImATeapot, \"Hi!\")\n/// }\n/// ```\n#[derive(Debug, Clone, PartialEq)]\npub struct Custom<R>(pub Status, pub R);\n\n/// Sets the status code of the response and then delegates the remainder of the\n/// response to the wrapped responder.\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for Custom<R> {\n    #[inline]\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n        Response::build_from(self.1.respond_to(req)?)\n            .status(self.0)\n            .ok()\n    }\n}\n\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for (Status, R) {\n    #[inline(always)]\n    fn respond_to(self, request: &'r Request<'_>) -> response::Result<'o> {\n        Custom(self.0, self.1).respond_to(request)\n    }\n}\n\nmacro_rules! status_response {\n    ($T:ident $kind:expr) => {\n        /// Sets the status of the response to\n        #[doc = concat!($kind, concat!(\" ([`Status::\", stringify!($T), \"`]).\"))]\n        ///\n        /// The remainder of the response is delegated to `self.0`.\n        /// # Examples\n        ///\n        /// A\n        #[doc = $kind]\n        /// response without a body:\n        ///\n        /// ```rust\n        /// # use rocket::get;\n        /// use rocket::response::status;\n        ///\n        /// #[get(\"/\")]\n        #[doc = concat!(\"fn handler() -> status::\", stringify!($T), \"<()> {\")]\n        #[doc = concat!(\"    status::\", stringify!($T), \"(())\")]\n        /// }\n        /// ```\n        ///\n        /// A\n        #[doc = $kind]\n        /// response _with_ a body:\n        ///\n        /// ```rust\n        /// # use rocket::get;\n        /// use rocket::response::status;\n        ///\n        /// #[get(\"/\")]\n        #[doc = concat!(\"fn handler() -> status::\", stringify!($T), \"<&'static str> {\")]\n        #[doc = concat!(\"    status::\", stringify!($T), \"(\\\"body\\\")\")]\n        /// }\n        /// ```\n        #[derive(Debug, Clone, PartialEq)]\n        pub struct $T<R>(pub R);\n\n        impl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for $T<R> {\n            #[inline(always)]\n            fn respond_to(self, req: &'r Request<'_>) -> response::Result<'o> {\n                Custom(Status::$T, self.0).respond_to(req)\n            }\n        }\n    }\n}\n\nstatus_response!(Accepted \"202 Accepted\");\nstatus_response!(BadRequest \"400 Bad Request\");\nstatus_response!(Unauthorized \"401 Unauthorized\");\nstatus_response!(Forbidden \"403 Forbidden\");\nstatus_response!(NotFound \"404 NotFound\");\nstatus_response!(Conflict \"409 Conflict\");\n\n// The following are unimplemented.\n// 206 Partial Content (variant), 203 Non-Authoritative Information (headers)."}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::{Request, Data};\nuse crate::response::{Response, Responder};\nuse crate::http::Status;\n\n/// Type alias for the return type of a [`Route`](crate::Route)'s\n/// [`Handler::handle()`].\npub type Outcome<'r> = crate::outcome::Outcome<Response<'r>, Status, (Data<'r>, Status)>;\n\n/// Type alias for the return type of a _raw_ [`Route`](crate::Route)'s\n/// [`Handler`].\npub type BoxFuture<'r, T = Outcome<'r>> = futures::future::BoxFuture<'r, T>;\n\n/// Trait implemented by [`Route`](crate::Route) request handlers.\n///\n/// In general, you will never need to implement `Handler` manually or be\n/// concerned about the `Handler` trait; Rocket's code generation handles\n/// everything for you. You only need to learn about this trait if you want to\n/// provide an external, library-based mechanism to handle requests where\n/// request handling depends on input from the user. In other words, if you want\n/// to write a plugin for Rocket that looks mostly like a static route but need\n/// user provided state to make a request handling decision, you should consider\n/// implementing a custom `Handler`.\n///\n/// ## Async Trait\n///\n/// This is an _async_ trait. Implementations must be decorated\n/// [`#[rocket::async_trait]`](crate::async_trait).\n///\n/// # Example\n///\n/// Say you'd like to write a handler that changes its functionality based on an\n/// enum value that the user provides:\n///\n/// ```rust\n/// #[derive(Copy, Clone)]\n/// enum Kind {\n///     Simple,\n///     Intermediate,\n///     Complex,\n/// }\n/// ```\n///\n/// Such a handler might be written and used as follows:\n///\n/// ```rust,no_run\n/// # #[derive(Copy, Clone)] enum Kind { Simple, Intermediate, Complex, }\n/// use rocket::{Request, Data};\n/// use rocket::route::{Handler, Route, Outcome};\n/// use rocket::http::Method;\n///\n/// #[derive(Clone)]\n/// struct CustomHandler(Kind);\n///\n/// #[rocket::async_trait]\n/// impl Handler for CustomHandler {\n///     async fn handle<'r>(&self, req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r> {\n///         match self.0 {\n///             Kind::Simple => Outcome::from(req, \"simple\"),\n///             Kind::Intermediate => Outcome::from(req, \"intermediate\"),\n///             Kind::Complex => Outcome::from(req, \"complex\"),\n///         }\n///     }\n/// }\n///\n/// impl Into<Vec<Route>> for CustomHandler {\n///     fn into(self) -> Vec<Route> {\n///         vec![Route::new(Method::Get, \"/\", self)]\n///     }\n/// }\n///\n/// #[rocket::launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", CustomHandler(Kind::Simple))\n/// }\n/// ```\n///\n/// Note the following:\n///\n///   1. `CustomHandler` implements `Clone`. This is required so that\n///      `CustomHandler` implements `Cloneable` automatically. The `Cloneable`\n///      trait serves no other purpose but to ensure that every `Handler` can be\n///      cloned, allowing `Route`s to be cloned.\n///   2. `CustomHandler` implements `Into<Vec<Route>>`, allowing an instance to\n///      be used directly as the second parameter to `rocket.mount()`.\n///   3. Unlike static-function-based handlers, this custom handler can make use\n///      of any internal state.\n///\n/// # Alternatives\n///\n/// The previous example could have been implemented using a combination of\n/// managed state and a static route, as follows:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// #\n/// # #[derive(Copy, Clone)]\n/// # enum Kind {\n/// #     Simple,\n/// #     Intermediate,\n/// #     Complex,\n/// # }\n/// #\n/// use rocket::State;\n///\n/// #[get(\"/\")]\n/// fn custom_handler(state: &State<Kind>) -> &'static str {\n///     match state.inner() {\n///         Kind::Simple => \"simple\",\n///         Kind::Intermediate => \"intermediate\",\n///         Kind::Complex => \"complex\",\n///     }\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build()\n///         .mount(\"/\", routes![custom_handler])\n///         .manage(Kind::Simple)\n/// }\n/// ```\n///\n/// Pros:\n///\n///   * The handler is easier to implement since Rocket's code generation\n///     ensures type-safety at all levels.\n///\n/// Cons:\n///\n///   * Only one `Kind` can be stored in managed state. As such, only one\n///     variant of the custom handler can be used.\n///   * The user must remember to manually call `rocket.manage(state)`.\n///\n/// Use this alternative when a single configuration is desired and your custom\n/// handler is private to your application. For all other cases, a custom\n/// `Handler` implementation is preferred.\n#[crate::async_trait]\npub trait Handler: Cloneable + Send + Sync + 'static {\n    /// Called by Rocket when a `Request` with its associated `Data` should be\n    /// handled by this handler.\n    ///\n    /// The variant of `Outcome` returned by the returned `Future` determines\n    /// what Rocket does next. If the return value is a `Success(Response)`, the\n    /// wrapped `Response` is used to respond to the client. If the return value\n    /// is an `Error(Status)`, the error catcher for `Status` is invoked to\n    /// generate a response. Otherwise, if the return value is `Forward(Data)`,\n    /// the next matching route is attempted. If there are no other matching\n    /// routes, the `404` error catcher is invoked.\n    async fn handle<'r>(&self, request: &'r Request<'_>, data: Data<'r>) -> Outcome<'r>;\n}\n\n// We write this manually to avoid double-boxing.\nimpl<F: Clone + Sync + Send + 'static> Handler for F\n    where for<'x> F: Fn(&'x Request<'_>, Data<'x>) -> BoxFuture<'x>,\n{\n    #[inline(always)]\n    fn handle<'r, 'life0, 'life1, 'async_trait>(\n        &'life0 self,\n        req: &'r Request<'life1>,\n        data: Data<'r>,\n    ) -> BoxFuture<'r>\n        where 'r: 'async_trait,\n              'life0: 'async_trait,\n              'life1: 'async_trait,\n              Self: 'async_trait,\n    {\n        self(req, data)\n    }\n}\n\n// FIXME!\nimpl<'r, 'o: 'r> Outcome<'o> {\n    /// Return the `Outcome` of response to `req` from `responder`.\n    ///\n    /// If the responder returns `Ok`, an outcome of `Success` is returned with\n    /// the response. If the responder returns `Err`, an outcome of `Error` is\n    /// returned with the status code.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::{Request, Data, route};\n    ///\n    /// fn str_responder<'r>(req: &'r Request, _: Data<'r>) -> route::Outcome<'r> {\n    ///     route::Outcome::from(req, \"Hello, world!\")\n    /// }\n    /// ```\n    #[inline]\n    pub fn from<R: Responder<'r, 'o>>(req: &'r Request<'_>, responder: R) -> Outcome<'r> {\n        match responder.respond_to(req) {\n            Ok(response) => Outcome::Success(response),\n            Err(status) => Outcome::Error(status)\n        }\n    }\n\n    /// Return the `Outcome` of response to `req` from `responder`.\n    ///\n    /// If the responder returns `Ok`, an outcome of `Success` is returned with\n    /// the response. If the responder returns `Err`, an outcome of `Error` is\n    /// returned with the status code.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::{Request, Data, route};\n    ///\n    /// fn str_responder<'r>(req: &'r Request, _: Data<'r>) -> route::Outcome<'r> {\n    ///     route::Outcome::from(req, \"Hello, world!\")\n    /// }\n    /// ```\n    #[inline]\n    pub fn try_from<R, E>(req: &'r Request<'_>, result: Result<R, E>) -> Outcome<'r>\n        where R: Responder<'r, 'o>, E: std::fmt::Debug\n    {\n        let responder = result.map_err(crate::response::Debug);\n        match responder.respond_to(req) {\n            Ok(response) => Outcome::Success(response),\n            Err(status) => Outcome::Error(status)\n        }\n    }\n\n    /// Return an `Outcome` of `Error` with the status code `code`. This is\n    /// equivalent to `Outcome::Error(code)`.\n    ///\n    /// This method exists to be used during manual routing.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::{Request, Data, route};\n    /// use rocket::http::Status;\n    ///\n    /// fn bad_req_route<'r>(_: &'r Request, _: Data<'r>) -> route::Outcome<'r> {\n    ///     route::Outcome::error(Status::BadRequest)\n    /// }\n    /// ```\n    #[inline(always)]\n    pub fn error(code: Status) -> Outcome<'r> {\n        Outcome::Error(code)\n    }\n\n    /// Return an `Outcome` of `Forward` with the data `data` and status\n    /// `status`. This is equivalent to `Outcome::Forward((data, status))`.\n    ///\n    /// This method exists to be used during manual routing.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::{Request, Data, route};\n    /// use rocket::http::Status;\n    ///\n    /// fn always_forward<'r>(_: &'r Request, data: Data<'r>) -> route::Outcome<'r> {\n    ///     route::Outcome::forward(data, Status::InternalServerError)\n    /// }\n    /// ```\n    #[inline(always)]\n    pub fn forward(data: Data<'r>, status: Status) -> Outcome<'r> {\n        Outcome::Forward((data, status))\n    }\n}\n\n// INTERNAL: A handler to use when one is needed temporarily.\n#[doc(hidden)]\npub fn dummy_handler<'r>(r: &'r Request<'_>, _: Data<'r>) -> BoxFuture<'r> {\n    Outcome::from(r, ()).pin()\n}\n\nmod private {\n    pub trait Sealed {}\n    impl<T: super::Handler + Clone> Sealed for T {}\n}\n\n/// Helper trait to make a [`Route`](crate::Route)'s `Box<dyn Handler>`\n/// `Clone`.\n///\n/// This trait cannot be implemented directly. Instead, implement `Clone` and\n/// [`Handler`]; all types that implement `Clone` and `Handler` automatically\n/// implement `Cloneable`.\npub trait Cloneable: private::Sealed {\n    #[doc(hidden)]\n    fn clone_handler(&self) -> Box<dyn Handler>;\n}\n\nimpl<T: Handler + Clone> Cloneable for T {\n    fn clone_handler(&self) -> Box<dyn Handler> {\n        Box::new(self.clone())\n    }\n}\n\nimpl Clone for Box<dyn Handler> {\n    fn clone(&self) -> Box<dyn Handler> {\n        self.clone_handler()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types and traits for routes and their request handlers and return types.\n\nmod route;\nmod handler;\nmod uri;\nmod segment;\n\npub use route::*;\npub use handler::*;\npub use uri::*;\n\npub(crate) use segment::Segment;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::convert::From;\nuse std::borrow::Cow;\n\nuse yansi::Paint;\n\nuse crate::http::{uri, Method, MediaType};\nuse crate::route::{Handler, RouteUri, BoxFuture};\nuse crate::sentinel::Sentry;\n\n/// A request handling route.\n///\n/// A route consists of exactly the information in its fields. While a `Route`\n/// can be instantiated directly, doing so should be a rare or nonexistent\n/// event. Instead, a Rocket application should use Rocket's\n/// [`#[route]`](macro@crate::route) series of attributes to generate a `Route`.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # use std::path::PathBuf;\n/// #[get(\"/route/<path..>?query\", rank = 2, format = \"json\")]\n/// fn route_name(path: PathBuf) { /* handler procedure */ }\n///\n/// use rocket::http::{Method, MediaType};\n///\n/// let route = routes![route_name].remove(0);\n/// assert_eq!(route.name.unwrap(), \"route_name\");\n/// assert_eq!(route.method, Method::Get);\n/// assert_eq!(route.uri, \"/route/<path..>?query\");\n/// assert_eq!(route.rank, 2);\n/// assert_eq!(route.format.unwrap(), MediaType::JSON);\n/// ```\n///\n/// Note that the `rank` and `format` attribute parameters are optional. See\n/// [`#[route]`](macro@crate::route) for details on macro usage. Note also that\n/// a route's mounted _base_ becomes part of its URI; see [`RouteUri`] for\n/// details.\n///\n/// # Routing\n///\n/// A request _matches_ a route _iff_:\n///\n///   * The route's method matches that of the incoming request.\n///   * The route's format (if any) matches that of the incoming request.\n///     - If route specifies a format, it only matches requests for that format.\n///     - If route doesn't specify a format, it matches requests for any format.\n///     - A route's `format` matches against the `Accept` header in the request\n///       when the route's method [`supports_payload()`] and `Content-Type`\n///       header otherwise.\n///     - Non-specific `Accept` header components (`*`) match anything.\n///   * All static components in the route's path match the corresponding\n///     components in the same position in the incoming request.\n///   * All static components in the route's query string are also in the\n///     request query string, though in any position. If there is no query\n///     in the route, requests with and without queries match.\n///\n/// Rocket routes requests to matching routes.\n///\n/// [`supports_payload()`]: Method::supports_payload()\n///\n/// # Collisions\n///\n/// Two routes are said to _collide_ if there exists a request that matches both\n/// routes. Colliding routes present a routing ambiguity and are thus disallowed\n/// by Rocket. Because routes can be constructed dynamically, collision checking\n/// is done at [`ignite`](crate::Rocket::ignite()) time, after it becomes\n/// statically impossible to add any more routes to an instance of `Rocket`.\n///\n/// Note that because query parsing is always lenient -- extra and missing query\n/// parameters are allowed -- queries do not directly impact whether two routes\n/// collide.\n///\n/// ## Resolving Collisions\n///\n/// Collisions are resolved through _ranking_. Routes with lower ranks have\n/// higher precedence during routing than routes with higher ranks. Thus, routes\n/// are attempted in ascending rank order. If a higher precedence route returns\n/// an `Outcome` of `Forward`, the next highest precedence route is attempted,\n/// and so on, until a route returns `Success` or `Error`, or there are no\n/// more routes to try. When all routes have been attempted, Rocket issues a\n/// `404` error, handled by the appropriate [`Catcher`](crate::Catcher).\n///\n/// ## Default Ranking\n///\n/// Most collisions are automatically resolved by Rocket's _default rank_. The\n/// default rank prefers static components over dynamic components in both paths\n/// and queries: the _more_ static a route's path and query are, the lower its\n/// rank and thus the higher its precedence.\n///\n/// There are three \"colors\" to paths and queries:\n///   1. `static` - all components are static\n///   2. `partial` - at least one, but not all, components are dynamic\n///   3. `wild` - all components are dynamic\n///\n/// Static paths carry more weight than static queries. The same is true for\n/// partial and wild paths. This results in the following default ranking\n/// table:\n///\n/// | path    | query   | rank |\n/// |---------|---------|------|\n/// | static  | static  | -12  |\n/// | static  | partial | -11  |\n/// | static  | wild    | -10  |\n/// | static  | none    | -9   |\n/// | partial | static  | -8   |\n/// | partial | partial | -7   |\n/// | partial | wild    | -6   |\n/// | partial | none    | -5   |\n/// | wild    | static  | -4   |\n/// | wild    | partial | -3   |\n/// | wild    | wild    | -2   |\n/// | wild    | none    | -1   |\n///\n/// Recall that _lower_ ranks have _higher_ precedence.\n///\n/// ### Example\n///\n/// ```rust\n/// use rocket::Route;\n/// use rocket::http::Method;\n///\n/// macro_rules! assert_rank {\n///     ($($uri:expr => $rank:expr,)*) => {$(\n///         let route = Route::new(Method::Get, $uri, rocket::route::dummy_handler);\n///         assert_eq!(route.rank, $rank);\n///     )*}\n/// }\n///\n/// assert_rank! {\n///     \"/?foo\" => -12,                 // static path, static query\n///     \"/foo/bar?a=b&bob\" => -12,      // static path, static query\n///     \"/?a=b&bob\" => -12,             // static path, static query\n///\n///     \"/?a&<zoo..>\" => -11,           // static path, partial query\n///     \"/foo?a&<zoo..>\" => -11,        // static path, partial query\n///     \"/?a&<zoo>\" => -11,             // static path, partial query\n///\n///     \"/?<zoo..>\" => -10,             // static path, wild query\n///     \"/foo?<zoo..>\" => -10,          // static path, wild query\n///     \"/foo?<a>&<b>\" => -10,          // static path, wild query\n///\n///     \"/\" => -9,                      // static path, no query\n///     \"/foo/bar\" => -9,               // static path, no query\n///\n///     \"/a/<b>?foo\" => -8,             // partial path, static query\n///     \"/a/<b..>?foo\" => -8,           // partial path, static query\n///     \"/<a>/b?foo\" => -8,             // partial path, static query\n///\n///     \"/a/<b>?<b>&c\" => -7,           // partial path, partial query\n///     \"/a/<b..>?a&<c..>\" => -7,       // partial path, partial query\n///\n///     \"/a/<b>?<c..>\" => -6,           // partial path, wild query\n///     \"/a/<b..>?<c>&<d>\" => -6,       // partial path, wild query\n///     \"/a/<b..>?<c>\" => -6,           // partial path, wild query\n///\n///     \"/a/<b>\" => -5,                 // partial path, no query\n///     \"/<a>/b\" => -5,                 // partial path, no query\n///     \"/a/<b..>\" => -5,               // partial path, no query\n///\n///     \"/<b>/<c>?foo&bar\" => -4,       // wild path, static query\n///     \"/<a>/<b..>?foo\" => -4,         // wild path, static query\n///     \"/<b..>?cat\" => -4,             // wild path, static query\n///\n///     \"/<b>/<c>?<foo>&bar\" => -3,     // wild path, partial query\n///     \"/<a>/<b..>?a&<b..>\" => -3,     // wild path, partial query\n///     \"/<b..>?cat&<dog>\" => -3,       // wild path, partial query\n///\n///     \"/<b>/<c>?<foo>\" => -2,         // wild path, wild query\n///     \"/<a>/<b..>?<b..>\" => -2,       // wild path, wild query\n///     \"/<b..>?<c>&<dog>\" => -2,       // wild path, wild query\n///\n///     \"/<b>/<c>\" => -1,               // wild path, no query\n///     \"/<a>/<b..>\" => -1,             // wild path, no query\n///     \"/<b..>\" => -1,                 // wild path, no query\n/// }\n/// ```\n#[derive(Clone)]\npub struct Route {\n    /// The name of this route, if one was given.\n    pub name: Option<Cow<'static, str>>,\n    /// The method this route matches against.\n    pub method: Method,\n    /// The function that should be called when the route matches.\n    pub handler: Box<dyn Handler>,\n    /// The route URI.\n    pub uri: RouteUri<'static>,\n    /// The rank of this route. Lower ranks have higher priorities.\n    pub rank: isize,\n    /// The media type this route matches against, if any.\n    pub format: Option<MediaType>,\n    /// The discovered sentinels.\n    pub(crate) sentinels: Vec<Sentry>,\n}\n\nimpl Route {\n    /// Creates a new route with the given method, path, and handler with a base\n    /// of `/` and a computed [default rank](#default-ranking).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `path` is not a valid Rocket route URI.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// // this is a rank 1 route matching requests to `GET /`\n    /// let index = Route::new(Method::Get, \"/\", handler);\n    /// assert_eq!(index.rank, -9);\n    /// assert_eq!(index.method, Method::Get);\n    /// assert_eq!(index.uri, \"/\");\n    /// ```\n    #[track_caller]\n    pub fn new<H: Handler>(method: Method, uri: &str, handler: H) -> Route {\n        Route::ranked(None, method, uri, handler)\n    }\n\n    /// Creates a new route with the given rank, method, path, and handler with\n    /// a base of `/`. If `rank` is `None`, the computed [default\n    /// rank](#default-ranking) is used.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `path` is not a valid Rocket route URI.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let foo = Route::ranked(1, Method::Post, \"/foo?bar\", handler);\n    /// assert_eq!(foo.rank, 1);\n    /// assert_eq!(foo.method, Method::Post);\n    /// assert_eq!(foo.uri, \"/foo?bar\");\n    ///\n    /// let foo = Route::ranked(None, Method::Post, \"/foo?bar\", handler);\n    /// assert_eq!(foo.rank, -12);\n    /// assert_eq!(foo.method, Method::Post);\n    /// assert_eq!(foo.uri, \"/foo?bar\");\n    /// ```\n    #[track_caller]\n    pub fn ranked<H, R>(rank: R, method: Method, uri: &str, handler: H) -> Route\n        where H: Handler + 'static, R: Into<Option<isize>>,\n    {\n        let uri = RouteUri::new(\"/\", uri);\n        let rank = rank.into().unwrap_or_else(|| uri.default_rank());\n        Route {\n            name: None,\n            format: None,\n            sentinels: Vec::new(),\n            handler: Box::new(handler),\n            rank, uri, method,\n        }\n    }\n\n    /// Maps the `base` of this route using `mapper`, returning a new `Route`\n    /// with the returned base.\n    ///\n    /// `mapper` is called with the current base. The returned `String` is used\n    /// as the new base if it is a valid URI. If the returned base URI contains\n    /// a query, it is ignored. Returns an error if the base produced by\n    /// `mapper` is not a valid origin URI.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::{Method, uri::Origin};\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar\", handler);\n    /// assert_eq!(index.uri.base(), \"/\");\n    /// assert_eq!(index.uri.unmounted_origin.path(), \"/foo/bar\");\n    /// assert_eq!(index.uri.path(), \"/foo/bar\");\n    ///\n    /// let index = index.map_base(|base| format!(\"{}{}\", \"/boo\", base)).unwrap();\n    /// assert_eq!(index.uri.base(), \"/boo\");\n    /// assert_eq!(index.uri.unmounted_origin.path(), \"/foo/bar\");\n    /// assert_eq!(index.uri.path(), \"/boo/foo/bar\");\n    /// ```\n    pub fn map_base<'a, F>(mut self, mapper: F) -> Result<Self, uri::Error<'static>>\n        where F: FnOnce(uri::Origin<'a>) -> String\n    {\n        let base = mapper(self.uri.base);\n        self.uri = RouteUri::try_new(&base, &self.uri.unmounted_origin.to_string())?;\n        Ok(self)\n    }\n}\n\nimpl fmt::Display for Route {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(ref n) = self.name {\n            write!(f, \"{}{}{} \", \"(\".cyan(), n.primary(), \")\".cyan())?;\n        }\n\n        write!(f, \"{} \", self.method.green())?;\n        if self.uri.base() != \"/\" {\n            write!(f, \"{}\", self.uri.base().blue().underline())?;\n        }\n\n        write!(f, \"{}\", self.uri.unmounted_origin.blue())?;\n\n        if self.rank > 1 {\n            write!(f, \" [{}]\", self.rank.primary().bold())?;\n        }\n\n        if let Some(ref format) = self.format {\n            write!(f, \" {}\", format.yellow())?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl fmt::Debug for Route {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Route\")\n            .field(\"name\", &self.name)\n            .field(\"method\", &self.method)\n            .field(\"uri\", &self.uri)\n            .field(\"rank\", &self.rank)\n            .field(\"format\", &self.format)\n            .finish()\n    }\n}\n\n/// Information generated by the `route` attribute during codegen.\n#[doc(hidden)]\npub struct StaticInfo {\n    /// The route's name, i.e, the name of the function.\n    pub name: &'static str,\n    /// The route's method.\n    pub method: Method,\n    /// The route's URi, without the base mount point.\n    pub uri: &'static str,\n    /// The route's format, if any.\n    pub format: Option<MediaType>,\n    /// The route's handler, i.e, the annotated function.\n    pub handler: for<'r> fn(&'r crate::Request<'_>, crate::Data<'r>) -> BoxFuture<'r>,\n    /// The route's rank, if any.\n    pub rank: Option<isize>,\n    /// Route-derived sentinels, if any.\n    /// This isn't `&'static [SentryInfo]` because `type_name()` isn't `const`.\n    pub sentinels: Vec<Sentry>,\n}\n\n#[doc(hidden)]\nimpl From<StaticInfo> for Route {\n    fn from(info: StaticInfo) -> Route {\n        // This should never panic since `info.path` is statically checked.\n        let uri = RouteUri::new(\"/\", info.uri);\n\n        Route {\n            name: Some(info.name.into()),\n            method: info.method,\n            handler: Box::new(info.handler),\n            rank: info.rank.unwrap_or_else(|| uri.default_rank()),\n            format: info.format,\n            sentinels: info.sentinels.into_iter().collect(),\n            uri,\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::http::RawStr;\n\n#[derive(Debug, Clone)]\npub struct Segment {\n    pub value: String,\n    pub dynamic: bool,\n    pub trailing: bool,\n}\n\nimpl Segment {\n    pub fn from(segment: &RawStr) -> Self {\n        let mut value = segment;\n        let mut dynamic = false;\n        let mut trailing = false;\n\n        if segment.starts_with('<') && segment.ends_with('>') {\n            dynamic = true;\n            value = &segment[1..(segment.len() - 1)];\n\n            if value.ends_with(\"..\") {\n                trailing = true;\n                value = &value[..(value.len() - 2)];\n            }\n        }\n\n        Segment { value: value.to_string(), dynamic, trailing }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::borrow::Cow;\n\nuse crate::http::uri::{self, Origin};\nuse crate::http::ext::IntoOwned;\nuse crate::form::ValueField;\nuse crate::route::Segment;\n\n/// A route URI which is matched against requests.\n///\n/// A route URI is composed of two components:\n///\n///   * `base`\n///\n///     Otherwise known as the route's \"mount point\", the `base` is a static\n///     [`Origin`] that prefixes the route URI. All route URIs have a `base`.\n///     When routes are created manually with [`Route::new()`], the base\n///     defaults to `/`. When mounted via [`Rocket::mount()`], the base is\n///     explicitly specified as the first argument.\n///\n///     ```rust\n///     use rocket::Route;\n///     use rocket::http::Method;\n///     # use rocket::route::dummy_handler as handler;\n///\n///     let route = Route::new(Method::Get, \"/foo/<bar>\", handler);\n///     assert_eq!(route.uri.base(), \"/\");\n///\n///     let rocket = rocket::build().mount(\"/base\", vec![route]);\n///     let routes: Vec<_> = rocket.routes().collect();\n///     assert_eq!(routes[0].uri.base(), \"/base\");\n///     ```\n///\n///   * `origin`\n///\n///     Otherwise known as the \"route URI\", the `origin` is an [`Origin`] with\n///     potentially dynamic (`<dyn>` or `<dyn..>`) segments. It is prefixed with\n///     the `base`. This is the URI which is matched against incoming requests\n///     for routing.\n///\n///     ```rust\n///     use rocket::Route;\n///     use rocket::http::Method;\n///     # use rocket::route::dummy_handler as handler;\n///\n///     let route = Route::new(Method::Get, \"/foo/<bar>\", handler);\n///     assert_eq!(route.uri, \"/foo/<bar>\");\n///\n///     let rocket = rocket::build().mount(\"/base\", vec![route]);\n///     let routes: Vec<_> = rocket.routes().collect();\n///     assert_eq!(routes[0].uri, \"/base/foo/<bar>\");\n///     ```\n///\n/// [`Rocket::mount()`]: crate::Rocket::mount()\n/// [`Route::new()`]: crate::Route::new()\n#[derive(Clone)]\npub struct RouteUri<'a> {\n    /// The source string for this URI.\n    source: Cow<'a, str>,\n    /// The mount point.\n    pub base: Origin<'a>,\n    /// The URI _without_ the `base` mount point.\n    pub unmounted_origin: Origin<'a>,\n    /// The URI _with_ the base mount point. This is the canonical route URI.\n    pub origin: Origin<'a>,\n    /// Cached metadata about this URI.\n    pub(crate) metadata: Metadata,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub(crate) enum Color {\n    /// Fully static: no dynamic components.\n    Static = 3,\n    /// Partially static/dynamic: some, but not all, dynamic components.\n    Partial = 2,\n    /// Fully dynamic: no static components.\n    Wild = 1,\n}\n\n#[derive(Debug, Clone)]\npub(crate) struct Metadata {\n    /// Segments in the base.\n    pub base_segs: Vec<Segment>,\n    /// Segments in the path, including base.\n    pub path_segs: Vec<Segment>,\n    /// `(name, value)` of the query segments that are static.\n    pub static_query_fields: Vec<(String, String)>,\n    /// The \"color\" of the route path.\n    pub path_color: Color,\n    /// The \"color\" of the route query, if there is query.\n    pub query_color: Option<Color>,\n    /// Whether the path has a `<trailing..>` parameter.\n    pub trailing_path: bool,\n}\n\ntype Result<T, E = uri::Error<'static>> = std::result::Result<T, E>;\n\nimpl<'a> RouteUri<'a> {\n    /// Create a new `RouteUri`.\n    ///\n    /// This is a fallible variant of [`RouteUri::new`] which returns an `Err`\n    /// if `base` or `uri` cannot be parsed as [`Origin`]s.\n    pub(crate) fn try_new(base: &str, uri: &str) -> Result<RouteUri<'static>> {\n        let mut base = Origin::parse(base)\n            .map_err(|e| e.into_owned())?\n            .into_normalized()\n            .into_owned();\n\n        base.clear_query();\n\n        let unmounted_origin = Origin::parse_route(uri)\n            .map_err(|e| e.into_owned())?\n            .into_normalized()\n            .into_owned();\n\n        let origin = Origin::parse_route(&format!(\"{}/{}\", base, unmounted_origin))\n            .map_err(|e| e.into_owned())?\n            .into_normalized()\n            .into_owned();\n\n        let source = origin.to_string().into();\n        let metadata = Metadata::from(&base, &origin);\n\n        Ok(RouteUri { source, base, unmounted_origin, origin, metadata })\n    }\n\n    /// Create a new `RouteUri`.\n    ///\n    /// Panics if  `base` or `uri` cannot be parsed as `Origin`s.\n    #[track_caller]\n    pub(crate) fn new(base: &str, uri: &str) -> RouteUri<'static> {\n        Self::try_new(base, uri).expect(\"Expected valid URIs\")\n    }\n\n    /// The path of the base mount point of this route URI as an `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar?a=1\", handler);\n    /// assert_eq!(index.uri.base(), \"/\");\n    /// let index = index.map_base(|base| format!(\"{}{}\", \"/boo\", base)).unwrap();\n    /// assert_eq!(index.uri.base(), \"/boo\");\n    /// ```\n    #[inline(always)]\n    pub fn base(&self) -> &str {\n        self.base.path().as_str()\n    }\n\n    /// The path part of this route URI as an `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar?a=1\", handler);\n    /// assert_eq!(index.uri.path(), \"/foo/bar\");\n    /// let index = index.map_base(|base| format!(\"{}{}\", \"/boo\", base)).unwrap();\n    /// assert_eq!(index.uri.path(), \"/boo/foo/bar\");\n    /// ```\n    #[inline(always)]\n    pub fn path(&self) -> &str {\n        self.origin.path().as_str()\n    }\n\n    /// The query part of this route URI, if there is one.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar\", handler);\n    /// assert!(index.uri.query().is_none());\n    ///\n    /// // Normalization clears the empty '?'.\n    /// let index = Route::new(Method::Get, \"/foo/bar?\", handler);\n    /// assert!(index.uri.query().is_none());\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar?a=1\", handler);\n    /// assert_eq!(index.uri.query().unwrap(), \"a=1\");\n    ///\n    /// let index = index.map_base(|base| format!(\"{}{}\", \"/boo\", base)).unwrap();\n    /// assert_eq!(index.uri.query().unwrap(), \"a=1\");\n    /// ```\n    #[inline(always)]\n    pub fn query(&self) -> Option<&str> {\n        self.origin.query().map(|q| q.as_str())\n    }\n\n    /// The full URI as an `&str`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::Route;\n    /// use rocket::http::Method;\n    /// # use rocket::route::dummy_handler as handler;\n    ///\n    /// let index = Route::new(Method::Get, \"/foo/bar?a=1\", handler);\n    /// assert_eq!(index.uri.as_str(), \"/foo/bar?a=1\");\n    /// let index = index.map_base(|base| format!(\"{}{}\", \"/boo\", base)).unwrap();\n    /// assert_eq!(index.uri.as_str(), \"/boo/foo/bar?a=1\");\n    /// ```\n    #[inline(always)]\n    pub fn as_str(&self) -> &str {\n        &self.source\n    }\n\n    /// Get the default rank of a route with this URI.\n    ///\n    /// The route's default rank is determined based on the presence or absence\n    /// of static and dynamic paths and queries. See the documentation for\n    /// [`Route::new`][`crate::Route::new`] for a table summarizing the exact default ranks.\n    ///\n    /// | path    | query   | rank |\n    /// |---------|---------|------|\n    /// | static  | static  | -12  |\n    /// | static  | partial | -11  |\n    /// | static  | wild    | -10  |\n    /// | static  | none    | -9   |\n    /// | partial | static  | -8   |\n    /// | partial | partial | -7   |\n    /// | partial | wild    | -6   |\n    /// | partial | none    | -5   |\n    /// | wild    | static  | -4   |\n    /// | wild    | partial | -3   |\n    /// | wild    | wild    | -2   |\n    /// | wild    | none    | -1   |\n    pub(crate) fn default_rank(&self) -> isize {\n        let raw_path_weight = self.metadata.path_color as u8;\n        let raw_query_weight = self.metadata.query_color.map_or(0, |c| c as u8);\n        let raw_weight = (raw_path_weight << 2) | raw_query_weight;\n\n        // We subtract `3` because `raw_path` is never `0`: 0b0100 = 4 - 3 = 1.\n        -((raw_weight as isize) - 3)\n    }\n}\n\nimpl Metadata {\n    fn from(base: &Origin<'_>, origin: &Origin<'_>) -> Self {\n        let base_segs = base.path().raw_segments()\n            .map(Segment::from)\n            .collect::<Vec<_>>();\n\n        let path_segs = origin.path().raw_segments()\n            .map(Segment::from)\n            .collect::<Vec<_>>();\n\n        let query_segs = origin.query()\n            .map(|q| q.raw_segments().map(Segment::from).collect::<Vec<_>>())\n            .unwrap_or_default();\n\n        let static_query_fields = query_segs.iter().filter(|s| !s.dynamic)\n            .map(|s| ValueField::parse(&s.value))\n            .map(|f| (f.name.source().to_string(), f.value.to_string()))\n            .collect();\n\n        let static_path = path_segs.iter().all(|s| !s.dynamic);\n        let wild_path = !path_segs.is_empty() && path_segs.iter().all(|s| s.dynamic);\n        let path_color = match (static_path, wild_path) {\n            (true, _) => Color::Static,\n            (_, true) => Color::Wild,\n            (_, _) => Color::Partial\n        };\n\n        let query_color = (!query_segs.is_empty()).then(|| {\n            let static_query = query_segs.iter().all(|s| !s.dynamic);\n            let wild_query = query_segs.iter().all(|s| s.dynamic);\n            match (static_query, wild_query) {\n                (true, _) => Color::Static,\n                (_, true) => Color::Wild,\n                (_, _) => Color::Partial\n            }\n        });\n\n        let trailing_path = path_segs.last().map_or(false, |p| p.trailing);\n\n        Metadata {\n            base_segs, path_segs, static_query_fields, path_color, query_color,\n            trailing_path,\n        }\n    }\n}\n\nimpl<'a> std::ops::Deref for RouteUri<'a> {\n    type Target = Origin<'a>;\n\n    fn deref(&self) -> &Self::Target {\n        &self.origin\n    }\n}\n\nimpl fmt::Display for RouteUri<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.origin.fmt(f)\n    }\n}\n\nimpl fmt::Debug for RouteUri<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RouteUri\")\n            .field(\"base\", &self.base)\n            .field(\"unmounted_origin\", &self.unmounted_origin)\n            .field(\"origin\", &self.origin)\n            .field(\"metadata\", &self.metadata)\n            .finish()\n    }\n}\n\nimpl<'a, 'b> PartialEq<Origin<'b>> for RouteUri<'a> {\n    fn eq(&self, other: &Origin<'b>) -> bool { &self.origin == other }\n}\n\nimpl PartialEq<str> for RouteUri<'_> {\n    fn eq(&self, other: &str) -> bool { self.as_str() == other }\n}\n\nimpl PartialEq<&str> for RouteUri<'_> {\n    fn eq(&self, other: &&str) -> bool { self.as_str() == *other }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Rocket's router.\n\nmod router;\nmod collider;\n\npub(crate) use router::*;\npub(crate) use collider::*;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Automatic JSON (de)serialization support.\n//!\n//! See [`Json`] for details.\n//!\n//! # Enabling\n//!\n//! This module is only available when the `json` feature is enabled. Enable it\n//! in `Cargo.toml` as follows:\n//!\n//! ```toml\n//! [dependencies.rocket]\n//! version = \"0.5.1\"\n//! features = [\"json\"]\n//! ```\n//!\n//! # Testing\n//!\n//! The [`LocalRequest`] and [`LocalResponse`] types provide [`json()`] and\n//! [`into_json()`] methods to create a request with serialized JSON and\n//! deserialize a response as JSON, respectively.\n//!\n//! [`LocalRequest`]: crate::local::blocking::LocalRequest\n//! [`LocalResponse`]: crate::local::blocking::LocalResponse\n//! [`json()`]: crate::local::blocking::LocalRequest::json()\n//! [`into_json()`]: crate::local::blocking::LocalResponse::into_json()\n\nuse std::{io, fmt, error};\nuse std::ops::{Deref, DerefMut};\n\nuse crate::request::{Request, local_cache};\nuse crate::data::{Limits, Data, FromData, Outcome};\nuse crate::response::{self, Responder, content};\nuse crate::form::prelude as form;\nuse crate::http::uri::fmt::{UriDisplay, FromUriParam, Query, Formatter as UriFormatter};\nuse crate::http::Status;\n\nuse serde::{Serialize, Deserialize};\n\n#[doc(hidden)]\npub use serde_json;\n\n/// The JSON guard: easily consume and return JSON.\n///\n/// ## Sending JSON\n///\n/// To respond with serialized JSON data, return a `Json<T>` type, where `T`\n/// implements [`Serialize`] from [`serde`]. The content type of the response is\n/// set to `application/json` automatically.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::json::Json;\n///\n/// #[get(\"/users/<id>\")]\n/// fn user(id: usize) -> Json<User> {\n///     let user_from_id = User::from(id);\n///     /* ... */\n///     Json(user_from_id)\n/// }\n/// ```\n///\n/// ## Receiving JSON\n///\n/// `Json` is both a data guard and a form guard.\n///\n/// ### Data Guard\n///\n/// To deserialize request body data as JSON , add a `data` route argument with\n/// a target type of `Json<T>`, where `T` is some type you'd like to parse from\n/// JSON. `T` must implement [`serde::Deserialize`].\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::json::Json;\n///\n/// #[post(\"/user\", format = \"json\", data = \"<user>\")]\n/// fn new_user(user: Json<User>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// You don't _need_ to use `format = \"json\"`, but it _may_ be what you want.\n/// Using `format = json` means that any request that doesn't specify\n/// \"application/json\" as its `Content-Type` header value will not be routed to\n/// the handler.\n///\n/// ### Form Guard\n///\n/// `Json<T>`, as a form guard, accepts value and data fields and parses the\n/// data as a `T`. Simple use `Json<T>`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type Metadata = usize;\n/// use rocket::form::{Form, FromForm};\n/// use rocket::serde::json::Json;\n///\n/// #[derive(FromForm)]\n/// struct User<'r> {\n///     name: &'r str,\n///     metadata: Json<Metadata>\n/// }\n///\n/// #[post(\"/user\", data = \"<form>\")]\n/// fn new_user(form: Form<User<'_>>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// ### Incoming Data Limits\n///\n/// The default size limit for incoming JSON data is 1MiB. Setting a limit\n/// protects your application from denial of service (DoS) attacks and from\n/// resource exhaustion through high memory consumption. The limit can be\n/// increased by setting the `limits.json` configuration parameter. For\n/// instance, to increase the JSON limit to 5MiB for all environments, you may\n/// add the following to your `Rocket.toml`:\n///\n/// ```toml\n/// [global.limits]\n/// json = 5242880\n/// ```\n#[repr(transparent)]\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct Json<T>(pub T);\n\n/// Error returned by the [`Json`] guard when JSON deserialization fails.\n#[derive(Debug)]\npub enum Error<'a> {\n    /// An I/O error occurred while reading the incoming request data.\n    Io(io::Error),\n\n    /// The client's data was received successfully but failed to parse as valid\n    /// JSON or as the requested type. The `&str` value in `.0` is the raw data\n    /// received from the user, while the `Error` in `.1` is the deserialization\n    /// error from `serde`.\n    Parse(&'a str, serde_json::error::Error),\n}\n\nimpl<'a> fmt::Display for Error<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Io(err) => write!(f, \"i/o error: {}\", err),\n            Self::Parse(_, err) => write!(f, \"parse error: {}\", err),\n        }\n    }\n}\n\nimpl<'a> error::Error for Error<'a> {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        match self {\n            Self::Io(err) => Some(err),\n            Self::Parse(_, err) => Some(err),\n        }\n    }\n}\n\nimpl<T> Json<T> {\n    /// Consumes the JSON wrapper and returns the wrapped item.\n    ///\n    /// # Example\n    /// ```rust\n    /// # use rocket::serde::json::Json;\n    /// let string = \"Hello\".to_string();\n    /// let my_json = Json(string);\n    /// assert_eq!(my_json.into_inner(), \"Hello\".to_string());\n    /// ```\n    #[inline(always)]\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\nimpl<'r, T: Deserialize<'r>> Json<T> {\n    fn from_str(s: &'r str) -> Result<Self, Error<'r>> {\n        serde_json::from_str(s).map(Json).map_err(|e| Error::Parse(s, e))\n    }\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Result<Self, Error<'r>> {\n        let limit = req.limits().get(\"json\").unwrap_or(Limits::JSON);\n        let string = match data.open(limit).into_string().await {\n            Ok(s) if s.is_complete() => s.into_inner(),\n            Ok(_) => {\n                let eof = io::ErrorKind::UnexpectedEof;\n                return Err(Error::Io(io::Error::new(eof, \"data limit exceeded\")));\n            },\n            Err(e) => return Err(Error::Io(e)),\n        };\n\n        Self::from_str(local_cache!(req, string))\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: Deserialize<'r>> FromData<'r> for Json<T> {\n    type Error = Error<'r>;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        match Self::from_data(req, data).await {\n            Ok(value) => Outcome::Success(value),\n            Err(Error::Io(e)) if e.kind() == io::ErrorKind::UnexpectedEof => {\n                Outcome::Error((Status::PayloadTooLarge, Error::Io(e)))\n            },\n            Err(Error::Parse(s, e)) if e.classify() == serde_json::error::Category::Data => {\n                Outcome::Error((Status::UnprocessableEntity, Error::Parse(s, e)))\n            },\n            Err(e) => Outcome::Error((Status::BadRequest, e)),\n\n        }\n    }\n}\n\n/// Serializes the wrapped value into JSON. Returns a response with Content-Type\n/// JSON and a fixed-size body with the serialized value. If serialization\n/// fails, an `Err` of `Status::InternalServerError` is returned.\nimpl<'r, T: Serialize> Responder<'r, 'static> for Json<T> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        let string = serde_json::to_string(&self.0)\n            .map_err(|e| {\n                error_!(\"JSON failed to serialize: {:?}\", e);\n                Status::InternalServerError\n            })?;\n\n        content::RawJson(string).respond_to(req)\n    }\n}\n\nimpl<T: Serialize> UriDisplay<Query> for Json<T> {\n    fn fmt(&self, f: &mut UriFormatter<'_, Query>) -> fmt::Result {\n        let string = to_string(&self.0).map_err(|_| fmt::Error)?;\n        f.write_value(&string)\n    }\n}\n\nmacro_rules! impl_from_uri_param_from_inner_type {\n    ($($lt:lifetime)?, $T:ty) => (\n        impl<$($lt,)? T: Serialize> FromUriParam<Query, $T> for Json<T> {\n            type Target = Json<$T>;\n\n            #[inline(always)]\n            fn from_uri_param(param: $T) -> Self::Target {\n                Json(param)\n            }\n        }\n    )\n}\n\nimpl_from_uri_param_from_inner_type!(, T);\nimpl_from_uri_param_from_inner_type!('a, &'a T);\nimpl_from_uri_param_from_inner_type!('a, &'a mut T);\n\ncrate::http::impl_from_uri_param_identity!([Query] (T: Serialize) Json<T>);\n\nimpl<T> From<T> for Json<T> {\n    fn from(value: T) -> Self {\n        Json(value)\n    }\n}\n\nimpl<T> Deref for Json<T> {\n    type Target = T;\n\n    #[inline(always)]\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for Json<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.0\n    }\n}\n\nimpl From<Error<'_>> for form::Error<'_> {\n    fn from(e: Error<'_>) -> Self {\n        match e {\n            Error::Io(e) => e.into(),\n            Error::Parse(_, e) => form::Error::custom(e)\n        }\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: Deserialize<'v> + Send> form::FromFormField<'v> for Json<T> {\n    fn from_value(field: form::ValueField<'v>) -> Result<Self, form::Errors<'v>> {\n        Ok(Self::from_str(field.value)?)\n    }\n\n    async fn from_data(f: form::DataField<'v, '_>) -> Result<Self, form::Errors<'v>> {\n        Ok(Self::from_data(f.request, f.data).await?)\n    }\n}\n\n/// Serializes the value into JSON. Returns a response with Content-Type JSON\n/// and a fixed-size body with the serialized value.\nimpl<'r> Responder<'r, 'static> for Value {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        content::RawJson(self.to_string()).respond_to(req)\n    }\n}\n\ncrate::export! {\n    /// A macro to create ad-hoc JSON serializable values using JSON syntax.\n    ///\n    /// The return type of a `json!` invocation is [`Value`](Value). A value\n    /// created with this macro can be returned from a handler as follows:\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::serde::json::{json, Value};\n    ///\n    /// #[get(\"/json\")]\n    /// fn get_json() -> Value {\n    ///     json!({\n    ///         \"key\": \"value\",\n    ///         \"array\": [1, 2, 3, 4]\n    ///     })\n    /// }\n    /// ```\n    ///\n    /// The [`Responder`](crate::response::Responder) implementation for\n    /// `Value` serializes the value into a JSON string and sets it as the body\n    /// of the response with a `Content-Type` of `application/json`.\n    ///\n    /// # Examples\n    ///\n    /// Create a simple JSON object with two keys: `\"username\"` and `\"id\"`:\n    ///\n    /// ```rust\n    /// use rocket::serde::json::json;\n    ///\n    /// let value = json!({\n    ///     \"username\": \"mjordan\",\n    ///     \"id\": 23\n    /// });\n    /// ```\n    ///\n    /// Create a more complex object with a nested object and array:\n    ///\n    /// ```rust\n    /// # use rocket::serde::json::json;\n    /// let value = json!({\n    ///     \"code\": 200,\n    ///     \"success\": true,\n    ///     \"payload\": {\n    ///         \"features\": [\"serde\", \"json\"],\n    ///         \"ids\": [12, 121],\n    ///     },\n    /// });\n    /// ```\n    ///\n    /// Variables or expressions can be interpolated into the JSON literal. Any type\n    /// interpolated into an array element or object value must implement serde's\n    /// `Serialize` trait, while any type interpolated into a object key must\n    /// implement `Into<String>`.\n    ///\n    /// ```rust\n    /// # use rocket::serde::json::json;\n    /// let code = 200;\n    /// let features = vec![\"serde\", \"json\"];\n    ///\n    /// let value = json!({\n    ///    \"code\": code,\n    ///    \"success\": code == 200,\n    ///    \"payload\": {\n    ///        features[0]: features[1]\n    ///    }\n    /// });\n    /// ```\n    ///\n    /// Trailing commas are allowed inside both arrays and objects.\n    ///\n    /// ```rust\n    /// # use rocket::serde::json::json;\n    /// let value = json!([\n    ///     \"notice\",\n    ///     \"the\",\n    ///     \"trailing\",\n    ///     \"comma -->\",\n    /// ]);\n    /// ```\n    macro_rules! json {\n        ($($json:tt)+) => ($crate::serde::json::serde_json::json!($($json)*));\n    }\n}\n\n/// An arbitrary JSON value as returned by [`json!`].\n///\n/// # `Responder`\n///\n/// `Value` is a `Responder` that serializes the represented value into a JSON\n/// string and sets the string as the body of a fixed-sized response with a\n/// `Content-Type` of `application/json`.\n///\n/// # Usage\n///\n/// A value of this type is returned by [`json!`]. The macro and this type are\n/// typically used to construct JSON values in an ad-hoc fashion during request\n/// handling. This looks something like:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use rocket::serde::json::{json, Value};\n///\n/// #[get(\"/json\")]\n/// fn get_json() -> Value {\n///     json!({\n///         \"id\": 83,\n///         \"values\": [1, 2, 3, 4]\n///     })\n/// }\n/// ```\n#[doc(inline)]\npub use serde_json::Value;\n\n/// Deserialize an instance of type `T` from bytes of JSON text.\n///\n/// **_Always_ use [`Json`] to deserialize JSON request data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, json};\n///\n/// #[derive(Debug, PartialEq, Deserialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = br#\"\n///     {\n///         \"framework\": \"Rocket\",\n///         \"stars\": 5\n///     }\n/// \"#;\n///\n/// let data: Data = json::from_slice(bytes).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\n#[inline(always)]\npub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, serde_json::error::Error>\n    where T: Deserialize<'a>,\n{\n    serde_json::from_slice(slice)\n}\n\n/// Deserialize an instance of type `T` from a string of JSON text.\n///\n/// **_Always_ use [`Json`] to deserialize JSON request data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, json};\n///\n/// #[derive(Debug, PartialEq, Deserialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let string = r#\"\n///     {\n///         \"framework\": \"Rocket\",\n///         \"stars\": 5\n///     }\n/// \"#;\n///\n/// let data: Data = json::from_str(string).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\n#[inline(always)]\npub fn from_str<'a, T>(string: &'a str) -> Result<T, serde_json::error::Error>\n    where T: Deserialize<'a>,\n{\n    serde_json::from_str(string)\n}\n\n/// Serialize a `T` into a JSON string with compact representation.\n///\n/// **_Always_ use [`Json`] to serialize JSON response data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, json};\n///\n/// #[derive(Debug, PartialEq, Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let data = Data {\n///     framework: \"Rocket\",\n///     stars: 5,\n/// };\n///\n/// let string = json::to_string(&data).unwrap();\n/// let data: Data = json::from_str(&string).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails or if `T`\n/// contains a map with non-string keys.\n#[inline(always)]\npub fn to_string<T>(value: &T) -> Result<String, serde_json::error::Error>\n    where T: Serialize\n{\n    serde_json::to_string(value)\n}\n\n/// Serialize a `T` into a JSON string with \"pretty\" formatted representation.\n///\n/// **_Always_ use [`Json`] to serialize JSON response data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, json};\n///\n/// #[derive(Debug, PartialEq, Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let data = Data {\n///     framework: \"Rocket\",\n///     stars: 5,\n/// };\n///\n/// let string = json::to_pretty_string(&data).unwrap();\n/// # let compact = json::to_string(&data).unwrap();\n/// # assert_ne!(compact, string);\n/// let data: Data = json::from_str(&string).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails or if `T`\n/// contains a map with non-string keys.\n#[inline(always)]\npub fn to_pretty_string<T>(value: &T) -> Result<String, serde_json::error::Error>\n    where T: Serialize\n{\n    serde_json::to_string_pretty(value)\n}\n\n/// Interpret a [`Value`] as an instance of type `T`.\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, json};\n///\n/// #[derive(Debug, PartialEq, Deserialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data {\n///     framework: String ,\n///     stars: usize,\n/// }\n///\n/// let value = json::json!({\n///     \"framework\": \"Rocket\",\n///     \"stars\": 5\n/// });\n///\n/// let data: Data = json::from_value(value).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\".into(), stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// This conversion can fail if the structure of the input does not match the\n/// structure expected by `T`, for example if `T` is a struct type but the input\n/// contains something other than a JSON map. It can also fail if the structure\n/// is correct but `T`'s implementation of `Deserialize` decides that something\n/// is wrong with the data, for example required struct fields are missing from\n/// the JSON map or some number is too big to fit in the expected primitive\n/// type.\n#[inline(always)]\npub fn from_value<T>(value: Value) -> Result<T, serde_json::error::Error>\n    where T: crate::serde::DeserializeOwned\n{\n    serde_json::from_value(value)\n}\n\n/// Convert a `T` into a [`Value`], an opaque value representing JSON data.\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, json};\n///\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data {\n///     framework: String ,\n///     stars: usize,\n/// }\n///\n/// let value = json::json!({\n///     \"framework\": \"Rocket\",\n///     \"stars\": 5\n/// });\n///\n/// let data: Data = json::from_value(value.clone()).unwrap();\n/// let data_value = json::to_value(data).unwrap();\n/// assert_eq!(value, data_value);\n/// ```\n///\n/// # Errors\n///\n/// This conversion fails if `T`s implementation of `Serialize` decides to fail\n/// or if `T` contains a map with non-string keys.\n#[inline(always)]\npub fn to_value<T>(item: T) -> Result<Value, serde_json::error::Error>\n    where T: Serialize\n{\n    serde_json::to_value(item)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Serialization and deserialization support.\n//!\n//! * JSON support is provided by the [`Json`](json::Json) type.\n//! * MessagePack support is provided by the [`MsgPack`](msgpack::MsgPack) type.\n//! * UUID support is provided by the [`UUID`](uuid) type.\n//!\n//! Types implement one or all of [`FromParam`](crate::request::FromParam),\n//! [`FromForm`](crate::form::FromForm), [`FromData`](crate::data::FromData),\n//! and [`Responder`](crate::response::Responder).\n//!\n//! ## Deriving `Serialize`, `Deserialize`\n//!\n//! For convenience, Rocket re-exports `serde`'s `Serialize` and `Deserialize`\n//! traits and derive macros from this module. However, due to Rust's limited\n//! support for derive macro re-exports, using the re-exported derive macros\n//! requires annotating structures with `#[serde(crate = \"rocket::serde\")]`:\n//!\n//! ```rust\n//! use rocket::serde::{Serialize, Deserialize};\n//!\n//! #[derive(Serialize, Deserialize)]\n//! #[serde(crate = \"rocket::serde\")]\n//! struct MyStruct {\n//!     foo: String,\n//! }\n//! ```\n//!\n//! If you'd like to avoid this extra annotation, you must depend on `serde`\n//! directly via your crate's `Cargo.toml`:\n//!\n//! ```toml\n//! [dependencies]\n//! serde = { version = \"1.0\", features = [\"derive\"] }\n//! ```\n\n#[doc(inline)]\npub use serde::ser::{Serialize, Serializer};\n\n#[doc(inline)]\npub use serde::de::{Deserialize, DeserializeOwned, Deserializer};\n\n#[doc(hidden)]\npub use serde::*;\n\n#[cfg(feature = \"json\")]\n#[cfg_attr(nightly, doc(cfg(feature = \"json\")))]\npub mod json;\n\n#[cfg(feature = \"msgpack\")]\n#[cfg_attr(nightly, doc(cfg(feature = \"msgpack\")))]\npub mod msgpack;\n\n#[cfg(feature = \"uuid\")]\n#[cfg_attr(nightly, doc(cfg(feature = \"uuid\")))]\npub mod uuid;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Automatic MessagePack (de)serialization support.\n//!\n//! See [`MsgPack`] for further details.\n//!\n//! # Enabling\n//!\n//! This module is only available when the `msgpack` feature is enabled. Enable\n//! it in `Cargo.toml` as follows:\n//!\n//! ```toml\n//! [dependencies.rocket]\n//! version = \"0.5.1\"\n//! features = [\"msgpack\"]\n//! ```\n//!\n//! # Testing\n//!\n//! The [`LocalRequest`] and [`LocalResponse`] types provide [`msgpack()`] and\n//! [`into_msgpack()`] methods to create a request with serialized MessagePack\n//! and deserialize a response as MessagePack, respectively.\n//!\n//! [`LocalRequest`]: crate::local::blocking::LocalRequest\n//! [`LocalResponse`]: crate::local::blocking::LocalResponse\n//! [`msgpack()`]: crate::local::blocking::LocalRequest::msgpack()\n//! [`into_msgpack()`]: crate::local::blocking::LocalResponse::into_msgpack()\n\nuse std::io;\nuse std::ops::{Deref, DerefMut};\n\nuse crate::request::{Request, local_cache};\nuse crate::data::{Limits, Data, FromData, Outcome};\nuse crate::response::{self, Responder, content};\nuse crate::http::Status;\nuse crate::form::prelude as form;\n// use crate::http::uri::fmt;\n\nuse serde::{Serialize, Deserialize};\n\n#[doc(inline)]\npub use rmp_serde::decode::Error;\n\n/// The MessagePack guard: easily consume and return MessagePack.\n///\n/// ## Sending MessagePack\n///\n/// To respond with serialized MessagePack data, return a `MsgPack<T>` type,\n/// where `T` implements [`Serialize`] from [`serde`]. The content type of the\n/// response is set to `application/msgpack` automatically.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[get(\"/users/<id>\")]\n/// fn user(id: usize) -> MsgPack<User> {\n///     let user_from_id = User::from(id);\n///     /* ... */\n///     MsgPack(user_from_id)\n/// }\n/// ```\n///\n/// ## Receiving MessagePack\n///\n/// `MsgPack` is both a data guard and a form guard.\n///\n/// ### Data Guard\n///\n/// To deserialize request body data as MessagePack, add a `data` route\n/// argument with a target type of `MsgPack<T>`, where `T` is some type you'd\n/// like to parse from JSON. `T` must implement [`serde::Deserialize`].\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[post(\"/users\", format = \"msgpack\", data = \"<user>\")]\n/// fn new_user(user: MsgPack<User>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// You don't _need_ to use `format = \"msgpack\"`, but it _may_ be what you want.\n/// Using `format = msgpack` means that any request that doesn't specify\n/// \"application/msgpack\" as its first `Content-Type:` header parameter will not\n/// be routed to this handler.\n///\n/// ### Form Guard\n///\n/// `MsgPack<T>`, as a form guard, accepts value and data fields and parses the\n/// data as a `T`. Simple use `MsgPack<T>`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type Metadata = usize;\n/// use rocket::form::{Form, FromForm};\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[derive(FromForm)]\n/// struct User<'r> {\n///     name: &'r str,\n///     metadata: MsgPack<Metadata>\n/// }\n///\n/// #[post(\"/users\", data = \"<form>\")]\n/// fn new_user(form: Form<User<'_>>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// ### Incoming Data Limits\n///\n/// The default size limit for incoming MessagePack data is 1MiB. Setting a\n/// limit protects your application from denial of service (DOS) attacks and\n/// from resource exhaustion through high memory consumption. The limit can be\n/// increased by setting the `limits.msgpack` configuration parameter. For\n/// instance, to increase the MessagePack limit to 5MiB for all environments,\n/// you may add the following to your `Rocket.toml`:\n///\n/// ```toml\n/// [global.limits]\n/// msgpack = 5242880\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct MsgPack<T>(pub T);\n\nimpl<T> MsgPack<T> {\n    /// Consumes the `MsgPack` wrapper and returns the wrapped item.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::serde::msgpack::MsgPack;\n    /// let string = \"Hello\".to_string();\n    /// let my_msgpack = MsgPack(string);\n    /// assert_eq!(my_msgpack.into_inner(), \"Hello\".to_string());\n    /// ```\n    #[inline(always)]\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\nimpl<'r, T: Deserialize<'r>> MsgPack<T> {\n    fn from_bytes(buf: &'r [u8]) -> Result<Self, Error> {\n        rmp_serde::from_slice(buf).map(MsgPack)\n    }\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Result<Self, Error> {\n        let limit = req.limits().get(\"msgpack\").unwrap_or(Limits::MESSAGE_PACK);\n        let bytes = match data.open(limit).into_bytes().await {\n            Ok(buf) if buf.is_complete() => buf.into_inner(),\n            Ok(_) => {\n                let eof = io::ErrorKind::UnexpectedEof;\n                return Err(Error::InvalidDataRead(io::Error::new(eof, \"data limit exceeded\")));\n            },\n            Err(e) => return Err(Error::InvalidDataRead(e)),\n        };\n\n        Self::from_bytes(local_cache!(req, bytes))\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: Deserialize<'r>> FromData<'r> for MsgPack<T> {\n    type Error = Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        match Self::from_data(req, data).await {\n            Ok(value) => Outcome::Success(value),\n            Err(Error::InvalidDataRead(e)) if e.kind() == io::ErrorKind::UnexpectedEof => {\n                Outcome::Error((Status::PayloadTooLarge, Error::InvalidDataRead(e)))\n            },\n            | Err(e@Error::TypeMismatch(_))\n            | Err(e@Error::OutOfRange)\n            | Err(e@Error::LengthMismatch(_))\n            => {\n                Outcome::Error((Status::UnprocessableEntity, e))\n            },\n            Err(e) => Outcome::Error((Status::BadRequest, e)),\n        }\n    }\n}\n\n/// Serializes the wrapped value into MessagePack. Returns a response with\n/// Content-Type `MsgPack` and a fixed-size body with the serialization. If\n/// serialization fails, an `Err` of `Status::InternalServerError` is returned.\nimpl<'r, T: Serialize> Responder<'r, 'static> for MsgPack<T> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        let buf = rmp_serde::to_vec(&self.0)\n            .map_err(|e| {\n                error_!(\"MsgPack failed to serialize: {:?}\", e);\n                Status::InternalServerError\n            })?;\n\n        content::RawMsgPack(buf).respond_to(req)\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: Deserialize<'v> + Send> form::FromFormField<'v> for MsgPack<T> {\n    // TODO: To implement `from_value`, we need to the raw string so we can\n    // decode it into bytes as opposed to a string as it won't be UTF-8.\n\n    async fn from_data(f: form::DataField<'v, '_>) -> Result<Self, form::Errors<'v>> {\n        Self::from_data(f.request, f.data).await.map_err(|e| {\n            match e {\n                Error::InvalidMarkerRead(e) | Error::InvalidDataRead(e) => e.into(),\n                Error::Utf8Error(e) => e.into(),\n                _ => form::Error::custom(e).into(),\n            }\n        })\n    }\n}\n\n// impl<T: Serialize> fmt::UriDisplay<fmt::Query> for MsgPack<T> {\n//     fn fmt(&self, f: &mut fmt::Formatter<'_, fmt::Query>) -> std::fmt::Result {\n//         let bytes = to_vec(&self.0).map_err(|_| std::fmt::Error)?;\n//         let encoded = crate::http::RawStr::percent_encode_bytes(&bytes);\n//         f.write_value(encoded.as_str())\n//     }\n// }\n\nimpl<T> From<T> for MsgPack<T> {\n    fn from(value: T) -> Self {\n        MsgPack(value)\n    }\n}\n\nimpl<T> Deref for MsgPack<T> {\n    type Target = T;\n\n    #[inline(always)]\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\nimpl<T> DerefMut for MsgPack<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.0\n    }\n}\n\n/// Deserialize an instance of type `T` from MessagePack encoded bytes.\n///\n/// Deserialization is performed in a zero-copy manner whenever possible.\n///\n/// **_Always_ use [`MsgPack`] to deserialize MessagePack request data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, msgpack};\n///\n/// #[derive(Debug, PartialEq, Deserialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[\n///     130, 169, 102, 114, 97, 109, 101, 119, 111, 114, 107, 166, 82, 111,\n///     99, 107, 101, 116, 165, 115, 116, 97, 114, 115, 5\n/// ];\n///\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// Deserialization fails if `v` does not represent a valid MessagePack encoding\n/// of any instance of `T` or if `T`'s `Deserialize` implementation fails\n/// otherwise.\n#[inline(always)]\npub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T, Error>\n    where T: Deserialize<'a>,\n{\n    rmp_serde::from_slice(v)\n}\n\n/// Serialize a `T` into a MessagePack byte vector with compact representation.\n///\n/// The compact representation represents structs as arrays.\n///\n/// **_Always_ use [`MsgPack`] to serialize MessagePack response data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, msgpack};\n///\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[146, 166, 82, 111, 99, 107, 101, 116, 5];\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// let byte_vec = msgpack::to_compact_vec(&data).unwrap();\n/// assert_eq!(bytes, &byte_vec[..]);\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails.\n#[inline(always)]\npub fn to_compact_vec<T>(value: &T) -> Result<Vec<u8>, rmp_serde::encode::Error>\n    where T: Serialize + ?Sized\n{\n    rmp_serde::to_vec(value)\n}\n\n/// Serialize a `T` into a MessagePack byte vector with named representation.\n///\n/// The named representation represents structs as maps with field names.\n///\n/// **_Always_ use [`MsgPack`] to serialize MessagePack response data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, msgpack};\n///\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[\n///     130, 169, 102, 114, 97, 109, 101, 119, 111, 114, 107, 166, 82, 111,\n///     99, 107, 101, 116, 165, 115, 116, 97, 114, 115, 5\n/// ];\n///\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// let byte_vec = msgpack::to_vec(&data).unwrap();\n/// assert_eq!(bytes, &byte_vec[..]);\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails.\n#[inline(always)]\npub fn to_vec<T>(value: &T) -> Result<Vec<u8>, rmp_serde::encode::Error>\n    where T: Serialize + ?Sized\n{\n    rmp_serde::to_vec_named(value)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! UUID path/query parameter and form value parsing support.\n//!\n//! # Enabling\n//!\n//! This module is only available when the `uuid` feature is enabled. Enable it\n//! in `Cargo.toml` as follows:\n//!\n//! ```toml\n//! [dependencies.rocket]\n//! version = \"0.5.1\"\n//! features = [\"uuid\"]\n//! ```\n//!\n//! # Usage\n//!\n//! `Uuid` implements [`FromParam`] and [`FromFormField`] (i.e,\n//! [`FromForm`](crate::form::FromForm)), allowing UUID values to be accepted\n//! directly in paths, queries, and forms. You can use the `Uuid` type directly\n//! as a target of a dynamic parameter:\n//!\n//! ```rust\n//! # #[macro_use] extern crate rocket;\n//! use rocket::serde::uuid::Uuid;\n//!\n//! #[get(\"/users/<id>\")]\n//! fn user(id: Uuid) -> String {\n//!     format!(\"We found: {}\", id)\n//! }\n//! ```\n//!\n//! You can also use the `Uuid` as a form value, including in query strings:\n//!\n//! ```rust\n//! # #[macro_use] extern crate rocket;\n//! use rocket::serde::uuid::Uuid;\n//!\n//! #[get(\"/user?<id>\")]\n//! fn user(id: Uuid) -> String {\n//!     format!(\"User ID: {}\", id)\n//! }\n//! ```\n//!\n//! Additionally, `Uuid` implements `UriDisplay<P>` for all `P`. As such, route\n//! URIs including `Uuid`s can be generated in a type-safe manner:\n//!\n//! ```rust\n//! # #[macro_use] extern crate rocket;\n//! use rocket::serde::uuid::Uuid;\n//! use rocket::response::Redirect;\n//!\n//! #[get(\"/user/<id>\")]\n//! fn user(id: Uuid) -> String {\n//!     format!(\"User ID: {}\", id)\n//! }\n//!\n//! #[get(\"/user?<id>\")]\n//! fn old_user_path(id: Uuid) -> Redirect {\n//!     # let _ = Redirect::to(uri!(user(&id)));\n//!     # let _ = Redirect::to(uri!(old_user_path(id)));\n//!     # let _ = Redirect::to(uri!(old_user_path(&id)));\n//!     Redirect::to(uri!(user(id)))\n//! }\n//! ```\n//!\n//! # Extra Features\n//!\n//! The [`uuid`](https://docs.rs/uuid/1) crate exposes extra `v{n}` features\n//! for generating UUIDs which are not enabled by Rocket. To enable these\n//! features, depend on `uuid` directly. The extra functionality can be accessed\n//! via both `rocket::serde::uuid::Uuid` or the direct `uuid::Uuid`; the types\n//! are one and the same.\n//!\n//! ```toml\n//! [dependencies.uuid]\n//! version = \"1\"\n//! features = [\"v1\", \"v4\"]\n//! ```\n\nuse crate::request::FromParam;\nuse crate::form::{self, FromFormField, ValueField};\n\n/// Error returned on [`FromParam`] or [`FromFormField`] failures.\n///\npub use uuid_::Error;\n\npub use uuid_::{Uuid, Builder, Variant, Version, Bytes, uuid, fmt};\n\nimpl<'a> FromParam<'a> for Uuid {\n    type Error = Error;\n\n    /// A value is successfully parsed if `param` is a properly formatted Uuid.\n    /// Otherwise, an error is returned.\n    #[inline(always)]\n    fn from_param(param: &'a str) -> Result<Uuid, Self::Error> {\n        param.parse()\n    }\n}\n\nimpl<'v> FromFormField<'v> for Uuid {\n    #[inline]\n    fn from_value(field: ValueField<'v>) -> form::Result<'v, Self> {\n        Ok(field.value.parse().map_err(form::error::Error::custom)?)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::{Uuid, FromParam};\n\n    #[test]\n    fn test_from_param() {\n        let uuid_str = \"c1aa1e3b-9614-4895-9ebd-705255fa5bc2\";\n        let uuid = Uuid::from_param(uuid_str).unwrap();\n        assert_eq!(uuid_str, uuid.to_string());\n    }\n\n    #[test]\n    fn test_from_param_invalid() {\n        let uuid_str = \"c1aa1e3b-9614-4895-9ebd-705255fa5bc2p\";\n        assert!(Uuid::from_param(uuid_str).is_err());\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Security and privacy headers for all outgoing responses.\n//!\n//! The [`Shield`] fairing provides a typed interface for injecting HTTP\n//! security and privacy headers into all outgoing responses. It takes some\n//! inspiration from [helmetjs], a similar piece of middleware for [express].\n//!\n//! [fairing]: https://rocket.rs/v0.5/guide/fairings/\n//! [helmetjs]: https://helmetjs.github.io/\n//! [express]: https://expressjs.com\n//!\n//! # Supported Headers\n//!\n//! | HTTP Header                 | Description                            | Policy         | Default? |\n//! | --------------------------- | -------------------------------------- | -------------- | -------- |\n//! | [X-XSS-Protection]          | Prevents some reflected XSS attacks.   | [`XssFilter`]  |         |\n//! | [X-Content-Type-Options]    | Prevents client sniffing of MIME type. | [`NoSniff`]    |         |\n//! | [X-Frame-Options]           | Prevents [clickjacking].               | [`Frame`]      |         |\n//! | [Strict-Transport-Security] | Enforces strict use of HTTPS.          | [`Hsts`]       | ?        |\n//! | [Expect-CT]                 | Enables certificate transparency.      | [`ExpectCt`]   |         |\n//! | [Referrer-Policy]           | Enables referrer policy.               | [`Referrer`]   |         |\n//! | [X-DNS-Prefetch-Control]    | Controls browser DNS prefetching.      | [`Prefetch`]   |         |\n//! | [Permissions-Policy]        | Allows or block browser features.      | [`Permission`] |         |\n//!\n//! <small>? If TLS is enabled in a non-debug profile, HSTS is automatically\n//! enabled with its default policy and a warning is logged at liftoff.</small>\n//!\n//! [X-XSS-Protection]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection\n//! [X-Content-Type-Options]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options\n//! [X-Frame-Options]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n//! [Strict-Transport-Security]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\n//! [Expect-CT]:  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT\n//! [Referrer-Policy]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n//! [X-DNS-Prefetch-Control]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control\n//! [clickjacking]: https://en.wikipedia.org/wiki/Clickjacking\n//! [Permissions-Policy]: https://github.com/w3c/webappsec-permissions-policy/blob/a45df7b237e2a85e1909d7f226ca4eb4ce5095ba/permissions-policy-explainer.md\n//!\n//! [`XssFilter`]: self::XssFilter\n//! [`NoSniff`]: self::NoSniff\n//! [`Frame`]: self::Frame\n//! [`Hsts`]: self::Hsts\n//! [`ExpectCt`]: self::ExpectCt\n//! [`Referrer`]: self::Referrer\n//! [`Prefetch`]: self::Prefetch\n//!\n//! # Usage\n//!\n//! By default, [`Shield::default()`] is attached to all instances Rocket. To\n//! change the default, including removing all `Shield` headers, attach a\n//! configured instance of [`Shield`]:\n//!\n//! ```rust\n//! # #[macro_use] extern crate rocket;\n//! use rocket::shield::Shield;\n//!\n//! #[launch]\n//! fn rocket() -> _ {\n//!     // Remove all `Shield` headers.\n//!     rocket::build().attach(Shield::new())\n//! }\n//! ```\n//!\n//! Each header can be configured individually. To enable a particular header,\n//! call the chainable [`enable()`](shield::Shield::enable()) method\n//! on an instance of `Shield`, passing in the configured policy type.\n//! Similarly, to disable a header, call the chainable\n//! [`disable()`](shield::Shield::disable()) method on an instance of\n//! `Shield`:\n//!\n//! ```rust\n//! # #[macro_use] extern crate rocket;\n//! use time::Duration;\n//!\n//! use rocket::http::uri::Uri;\n//! use rocket::shield::{Shield, Referrer, Prefetch, ExpectCt, NoSniff};\n//!\n//! let report_uri = uri!(\"https://report.rocket.rs\");\n//! let shield = Shield::default()\n//!     .enable(Referrer::NoReferrer)\n//!     .enable(Prefetch::Off)\n//!     .enable(ExpectCt::ReportAndEnforce(Duration::days(30), report_uri))\n//!     .disable::<NoSniff>();\n//! ```\n//!\n//! # FAQ\n//!\n//! * **Which policies should I choose?**\n//!\n//!   See the links in the table above for individual header documentation. The\n//!   [helmetjs] docs are also a good resource, and [OWASP] has a collection of\n//!   references on these headers.\n//!\n//! * **Do I need any headers beyond what `Shield` enables by default?**\n//!\n//!   Maybe! The other headers may protect against many important\n//!   vulnerabilities. Please consult their documentation and other resources to\n//!   determine if they are needed for your project.\n//!\n//! [OWASP]: https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers\n\nmod shield;\nmod policy;\n\npub use self::shield::Shield;\npub use self::policy::*;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Module containing the [`Policy`] trait and types that implement it.\n\nuse std::fmt;\nuse std::borrow::Cow;\n\nuse indexmap::IndexMap;\nuse rocket_http::{ext::IntoCollection, private::SmallVec};\nuse time::Duration;\n\nuse crate::http::{Header, uri::Absolute, uncased::{UncasedStr, Uncased}};\n\n/// Trait implemented by security and privacy policy headers.\n///\n/// Types that implement this trait can be [`enable()`]d and [`disable()`]d on\n/// instances of [`Shield`].\n///\n/// [`Shield`]: crate::shield::Shield\n/// [`enable()`]: crate::shield::Shield::enable()\n/// [`disable()`]: crate::shield::Shield::disable()\npub trait Policy: Default + Send + Sync + 'static {\n    /// The actual name of the HTTP header.\n    ///\n    /// This name must uniquely identify the header as it is used to determine\n    /// whether two implementations of `Policy` are for the same header. Use the\n    /// real HTTP header's name.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # extern crate rocket;\n    /// # use rocket::http::Header;\n    /// use rocket::shield::Policy;\n    ///\n    /// #[derive(Default)]\n    /// struct MyPolicy;\n    ///\n    /// impl Policy for MyPolicy {\n    ///     const NAME: &'static str = \"X-My-Policy\";\n    /// #   fn header(&self) -> Header<'static> { unimplemented!() }\n    /// }\n    /// ```\n    const NAME: &'static str;\n\n    /// Returns the [`Header`](../../rocket/http/struct.Header.html) to attach\n    /// to all outgoing responses.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # extern crate rocket;\n    /// use rocket::http::Header;\n    /// use rocket::shield::Policy;\n    ///\n    /// #[derive(Default)]\n    /// struct MyPolicy;\n    ///\n    /// impl Policy for MyPolicy {\n    /// #   const NAME: &'static str = \"X-My-Policy\";\n    ///     fn header(&self) -> Header<'static> {\n    ///         Header::new(Self::NAME, \"value-to-enable\")\n    ///     }\n    /// }\n    /// ```\n    fn header(&self) -> Header<'static>;\n}\n\n/// Hack to make `Policy` Object-Safe.\npub(crate) trait SubPolicy: Send + Sync {\n    fn name(&self) -> &'static UncasedStr;\n    fn header(&self) -> Header<'static>;\n}\n\nimpl<P: Policy> SubPolicy for P {\n    fn name(&self) -> &'static UncasedStr {\n        P::NAME.into()\n    }\n\n    fn header(&self) -> Header<'static> {\n        Policy::header(self)\n    }\n}\n\nmacro_rules! impl_policy {\n    ($T:ty, $name:expr) => (\n        impl Policy for $T {\n            const NAME: &'static str = $name;\n\n            fn header(&self) -> Header<'static> {\n                self.into()\n            }\n        }\n    )\n}\n\n// Keep this in-sync with the top-level module docs.\nimpl_policy!(XssFilter, \"X-XSS-Protection\");\nimpl_policy!(NoSniff, \"X-Content-Type-Options\");\nimpl_policy!(Frame, \"X-Frame-Options\");\nimpl_policy!(Hsts, \"Strict-Transport-Security\");\nimpl_policy!(ExpectCt, \"Expect-CT\");\nimpl_policy!(Referrer, \"Referrer-Policy\");\nimpl_policy!(Prefetch, \"X-DNS-Prefetch-Control\");\nimpl_policy!(Permission, \"Permissions-Policy\");\n\n/// The [Referrer-Policy] header: controls the value set by the browser for the\n/// [Referer] header.\n///\n/// Tells the browser if it should send all or part of URL of the current page\n/// to the next site the user navigates to via the [Referer] header. This can be\n/// important for security as the URL itself might expose sensitive data, such\n/// as a hidden file path or personal identifier.\n///\n/// [Referrer-Policy]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\n/// [Referer]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer\npub enum Referrer {\n    /// Omits the `Referer` header (returned by [`Referrer::default()`]).\n    NoReferrer,\n\n    /// Omits the `Referer` header on connection downgrade i.e. following HTTP\n    /// link from HTTPS site (_Browser default_).\n    NoReferrerWhenDowngrade,\n\n    /// Only send the origin of part of the URL, e.g. the origin of\n    /// `https://foo.com/bob.html` is `https://foo.com`.\n    Origin,\n\n    /// Send full URL for same-origin requests, only send origin part when\n    /// replying to [cross-origin] requests.\n    ///\n    /// [cross-origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\n    OriginWhenCrossOrigin,\n\n    /// Send full URL for same-origin requests only.\n    SameOrigin,\n\n    /// Only send origin part of URL, only send if protocol security level\n    /// remains the same e.g. HTTPS to HTTPS.\n    StrictOrigin,\n\n    /// Send full URL for same-origin requests. For cross-origin requests, only\n    /// send origin part of URL if protocol security level remains the same e.g.\n    /// HTTPS to HTTPS.\n    StrictOriginWhenCrossOrigin,\n\n    /// Send full URL for same-origin or cross-origin requests. _This will leak\n    /// the full URL of TLS protected resources to insecure origins. Use with\n    /// caution._\n    UnsafeUrl,\n }\n\n/// Defaults to [`Referrer::NoReferrer`]. Tells the browser to omit the\n/// `Referer` header.\nimpl Default for Referrer {\n    fn default() -> Referrer {\n        Referrer::NoReferrer\n    }\n}\n\nimpl From<&Referrer> for Header<'static> {\n    fn from(referrer: &Referrer) -> Self {\n        let policy_string = match referrer {\n            Referrer::NoReferrer => \"no-referrer\",\n            Referrer::NoReferrerWhenDowngrade => \"no-referrer-when-downgrade\",\n            Referrer::Origin => \"origin\",\n            Referrer::OriginWhenCrossOrigin => \"origin-when-cross-origin\",\n            Referrer::SameOrigin => \"same-origin\",\n            Referrer::StrictOrigin => \"strict-origin\",\n            Referrer::StrictOriginWhenCrossOrigin => \"strict-origin-when-cross-origin\",\n            Referrer::UnsafeUrl => \"unsafe-url\",\n        };\n\n        Header::new(Referrer::NAME, policy_string)\n    }\n}\n\n/// The [Expect-CT] header: enables reporting and/or enforcement of [Certificate\n/// Transparency].\n///\n/// [Certificate Transparency] can detect and prevent the use of incorrectly\n/// issued malicious, or revoked TLS certificates. It solves a variety of\n/// problems with public TLS/SSL certificate management and is valuable measure\n/// for all public TLS applications.\n///\n/// If you're just [getting started] with certificate transparency, ensure that\n/// your [site is in compliance][getting started] before you enable enforcement\n/// with [`ExpectCt::Enforce`] or [`ExpectCt::ReportAndEnforce`]. Failure to do\n/// so will result in the browser refusing to communicate with your application.\n/// _You have been warned_.\n///\n/// [Expect-CT]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT\n/// [Certificate Transparency]: http://www.certificate-transparency.org/what-is-ct\n/// [getting started]: http://www.certificate-transparency.org/getting-started\npub enum ExpectCt {\n    /// Enforce certificate compliance for the next [`Duration`]. Ensure that\n    /// your certificates are in compliance before turning on enforcement.\n    /// (_Shield_ default).\n    Enforce(Duration),\n\n    /// Report to `Absolute`, but do not enforce, compliance violations for the\n    /// next [`Duration`]. Doesn't provide any protection but is a good way make\n    /// sure things are working correctly before turning on enforcement in\n    /// production.\n    Report(Duration, Absolute<'static>),\n\n    /// Enforce compliance and report violations to `Absolute` for the next\n    /// [`Duration`].\n    ReportAndEnforce(Duration, Absolute<'static>),\n}\n\n/// Defaults to [`ExpectCt::Enforce`] with a 30 day duration, enforce CT\n/// compliance, see [draft] standard for more.\n///\n/// [draft]: https://tools.ietf.org/html/draft-ietf-httpbis-expect-ct-03#page-15\nimpl Default for ExpectCt {\n    fn default() -> ExpectCt {\n        ExpectCt::Enforce(Duration::days(30))\n    }\n}\n\nimpl From<&ExpectCt> for Header<'static> {\n    fn from(expect: &ExpectCt) -> Self {\n        let policy_string =  match expect {\n            ExpectCt::Enforce(age) => format!(\"max-age={}, enforce\", age.whole_seconds()),\n            ExpectCt::Report(age, uri) => {\n                format!(r#\"max-age={}, report-uri=\"{}\"\"#, age.whole_seconds(), uri)\n            }\n            ExpectCt::ReportAndEnforce(age, uri) => {\n                format!(\"max-age={}, enforce, report-uri=\\\"{}\\\"\", age.whole_seconds(), uri)\n            }\n        };\n\n        Header::new(ExpectCt::NAME, policy_string)\n    }\n}\n\n/// The [X-Content-Type-Options] header: turns off [mime sniffing] which can\n/// prevent certain [attacks].\n///\n/// [mime sniffing]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#MIME_sniffing\n/// [X-Content-Type-Options]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options\n/// [attacks]: https://blog.mozilla.org/security/2016/08/26/mitigating-mime-confusion-attacks-in-firefox/\npub enum NoSniff {\n    /// Turns off mime sniffing.\n    Enable,\n}\n\n/// Defaults to [`NoSniff::Enable`], turns off mime sniffing.\nimpl Default for NoSniff {\n    fn default() -> NoSniff {\n        NoSniff::Enable\n    }\n}\n\nimpl From<&NoSniff> for Header<'static> {\n    fn from(_: &NoSniff) -> Self {\n        Header::new(NoSniff::NAME, \"nosniff\")\n    }\n}\n\n/// The HTTP [Strict-Transport-Security] (HSTS) header: enforces strict HTTPS\n/// usage.\n///\n/// HSTS tells the browser that the site should only be accessed using HTTPS\n/// instead of HTTP. HSTS prevents a variety of downgrading attacks and should\n/// always be used when [TLS] is enabled. `Shield` will turn HSTS on and issue a\n/// warning if you enable TLS without enabling HSTS when the application is run\n/// in non-debug profiles.\n///\n/// While HSTS is important for HTTPS security, incorrectly configured HSTS can\n/// lead to problems as you are disallowing access to non-HTTPS enabled parts of\n/// your site. [Yelp engineering] has good discussion of potential challenges\n/// that can arise and how to roll this out in a large scale setting. So, if\n/// you use TLS, use HSTS, but roll it out with care.\n///\n/// [TLS]: https://rocket.rs/guide/configuration/#configuring-tls\n/// [Strict-Transport-Security]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\n/// [Yelp engineering]: https://engineeringblog.yelp.com/2017/09/the-road-to-hsts.html\n#[derive(PartialEq, Copy, Clone)]\npub enum Hsts {\n    /// Browser should only permit this site to be accesses by HTTPS for the\n    /// next [`Duration`].\n    Enable(Duration),\n\n    /// Like [`Hsts::Enable`], but also apply to all of the site's subdomains.\n    IncludeSubDomains(Duration),\n\n    /// Send a \"preload\" HSTS header, which requests inclusion in the HSTS\n    /// preload list. This variant implies [`Hsts::IncludeSubDomains`], which\n    /// implies [`Hsts::Enable`].\n    ///\n    /// The provided `Duration` must be _at least_ 365 days. If the duration\n    /// provided is less than 365 days, the header will be written out with a\n    /// `max-age` of 365 days.\n    ///\n    /// # Details\n    ///\n    /// Google maintains an [HSTS preload service] that can be used to prevent\n    /// the browser from ever connecting to your site over an insecure\n    /// connection. Read more at [MDN]. Don't enable this before you have\n    /// registered your site and you ensure that it meets the requirements\n    /// specified by the preload service.\n    ///\n    /// [HSTS preload service]: https://hstspreload.org/\n    /// [MDN]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security#Preloading_Strict_Transport_Security\n    Preload(Duration),\n}\n\n/// Defaults to `Hsts::Enable(Duration::days(365))`.\nimpl Default for Hsts {\n    fn default() -> Hsts {\n        Hsts::Enable(Duration::days(365))\n    }\n}\n\nimpl From<&Hsts> for Header<'static> {\n    fn from(hsts: &Hsts) -> Self {\n        if hsts == &Hsts::default() {\n            static DEFAULT: Header<'static> = Header {\n                name: Uncased::from_borrowed(Hsts::NAME),\n                value: Cow::Borrowed(\"max-age=31536000\")\n            };\n\n            return DEFAULT.clone();\n        }\n\n        let policy_string = match hsts {\n            Hsts::Enable(age) => format!(\"max-age={}\", age.whole_seconds()),\n            Hsts::IncludeSubDomains(age) => {\n                format!(\"max-age={}; includeSubDomains\", age.whole_seconds())\n            }\n            Hsts::Preload(age) => {\n                // Google says it needs to be >= 365 days for preload list.\n                static YEAR: Duration = Duration::seconds(31536000);\n\n                format!(\"max-age={}; includeSubDomains; preload\", age.max(&YEAR).whole_seconds())\n            }\n        };\n\n        Header::new(Hsts::NAME, policy_string)\n    }\n}\n\n/// The [X-Frame-Options] header: helps prevent [clickjacking] attacks.\n///\n/// Controls whether the browser should allow the page to render in a `<frame>`,\n/// [`<iframe>`][iframe] or `<object>`. This can be used to prevent\n/// [clickjacking] attacks.\n///\n/// [X-Frame-Options]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n/// [clickjacking]: https://en.wikipedia.org/wiki/Clickjacking\n/// [owasp-clickjacking]: https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet\n/// [iframe]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe\npub enum Frame {\n    /// Page cannot be displayed in a frame.\n    Deny,\n\n    /// Page can only be displayed in a frame if the page trying to render it is\n    /// in the same origin. Interpretation of same-origin is [browser\n    /// dependent][X-Frame-Options].\n    ///\n    /// [X-Frame-Options]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\n    SameOrigin,\n}\n\n/// Defaults to [`Frame::SameOrigin`].\nimpl Default for Frame {\n    fn default() -> Frame {\n        Frame::SameOrigin\n    }\n}\n\nimpl From<&Frame> for Header<'static> {\n    fn from(frame: &Frame) -> Self {\n        let policy_string: &'static str = match frame {\n            Frame::Deny => \"DENY\",\n            Frame::SameOrigin => \"SAMEORIGIN\",\n        };\n\n        Header::new(Frame::NAME, policy_string)\n    }\n}\n\n/// The [X-XSS-Protection] header: filters some forms of reflected [XSS]\n/// attacks. Modern browsers do not support or enforce this header.\n///\n/// [X-XSS-Protection]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection\n/// [XSS]: https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting\npub enum XssFilter {\n    /// Disables XSS filtering.\n    Disable,\n\n    /// Enables XSS filtering. If XSS is detected, the browser will sanitize\n    /// before rendering the page (_Shield default_).\n    Enable,\n\n    /// Enables XSS filtering. If XSS is detected, the browser will not\n    /// render the page.\n    EnableBlock,\n}\n\n/// Defaults to [`XssFilter::Enable`].\nimpl Default for XssFilter {\n    fn default() -> XssFilter {\n        XssFilter::Enable\n    }\n}\n\nimpl From<&XssFilter> for Header<'static> {\n    fn from(filter: &XssFilter) -> Self {\n        let policy_string: &'static str = match filter {\n            XssFilter::Disable => \"0\",\n            XssFilter::Enable => \"1\",\n            XssFilter::EnableBlock => \"1; mode=block\",\n        };\n\n        Header::new(XssFilter::NAME, policy_string)\n    }\n}\n\n/// The [X-DNS-Prefetch-Control] header: controls browser DNS prefetching.\n///\n/// Tells the browser if it should perform domain name resolution on both links\n/// that the user may choose to follow as well as URLs for items referenced by\n/// the document including images, CSS, JavaScript, and so forth. Disabling\n/// prefetching is useful if you don't control the link on the pages, or know\n/// that you don't want to leak information to these domains.\n///\n/// [X-DNS-Prefetch-Control]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control\npub enum Prefetch {\n    /// Enables DNS prefetching. This is the browser default.\n    On,\n    /// Disables DNS prefetching. This is the shield policy default.\n    Off,\n}\n\nimpl Default for Prefetch {\n    fn default() -> Prefetch {\n        Prefetch::Off\n    }\n}\n\nimpl From<&Prefetch> for Header<'static> {\n    fn from(prefetch: &Prefetch) -> Self {\n        let policy_string = match prefetch {\n            Prefetch::On => \"on\",\n            Prefetch::Off => \"off\",\n        };\n\n        Header::new(Prefetch::NAME, policy_string)\n    }\n}\n\n/// The [Permissions-Policy] header: allow or block the use of browser features.\n///\n/// Tells the browser to allow or block the use of a browser feature in the\n/// top-level page as well as allow or block _requesting access to_ (via the\n/// `allow` `iframe` attribute) features in embedded iframes.\n///\n/// By default, the top-level page may access ~all features and any embedded\n/// iframes may request access to ~any feature. This header allows the server to\n/// control exactly _which_ (if any) origins may access or request access to\n/// browser features.\n///\n/// Features are enabled via the [`Permission::allowed()`] constructor and\n/// chainable [`allow()`](Self::allow()) build method. Features can be blocked\n/// via the [`Permission::blocked()`] and chainable [`block()`](Self::block())\n/// builder method.\n///\n/// ```rust\n    /// # #[macro_use] extern crate rocket;\n/// use rocket::shield::{Shield, Permission, Feature, Allow};\n///\n/// // In addition to defaults, block access to geolocation and USB features.\n/// // Enable camera and microphone features only for the serving origin. Enable\n/// // payment request access for the current origin and `https://rocket.rs`.\n/// let permission = Permission::default()\n///     .block(Feature::Geolocation)\n///     .block(Feature::Usb)\n///     .allow(Feature::Camera, Allow::This)\n///     .allow(Feature::Microphone, Allow::This)\n///     .allow(Feature::Payment, [Allow::This, Allow::Origin(uri!(\"https://rocket.rs\"))]);\n///\n/// rocket::build().attach(Shield::default().enable(permission));\n/// ```\n///\n/// # Default\n///\n/// The default returned via [`Permission::default()`] blocks access to the\n/// `interest-cohort` feature, otherwise known as FLoC, which disables using the\n/// current site in ad targeting tracking computations.\n///\n/// [Permissions-Policy]: https://github.com/w3c/webappsec-permissions-policy/blob/a45df7b237e2a85e1909d7f226ca4eb4ce5095ba/permissions-policy-explainer.md\n#[derive(PartialEq, Clone)]\npub struct Permission(IndexMap<Feature, Option<SmallVec<[Allow; 1]>>>);\n\nimpl Default for Permission {\n    /// The default `Permission` policy blocks access to the `interest-cohort`\n    /// feature, otherwise known as FLoC, which disables using the current site\n    /// in ad targeting tracking computations.\n    fn default() -> Self {\n        Permission::blocked(Feature::InterestCohort)\n    }\n}\n\nimpl Permission {\n    /// Constructs a new `Permission` policy with only `feature` allowed for the\n    /// set of origins in `allow` which may be a single [`Allow`], a slice\n    /// (`[Allow]` or `&[Allow]`), or a vector (`Vec<Allow>`).\n    ///\n    /// If `allow` is empty, the use of the feature is blocked unless another\n    /// call to `allow()` allows it. If `allow` contains [`Allow::Any`], the\n    /// feature is allowable for all origins. Otherwise, the feature is\n    /// allowable only for the origin specified in `allow`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if an `Absolute` URI in an `Allow::Origin` does not contain a\n    /// host part.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::shield::{Permission, Feature, Allow};\n    ///\n    /// let rocket = Allow::Origin(uri!(\"https://rocket.rs\"));\n    ///\n    /// let perm = Permission::allowed(Feature::Usb, Allow::This);\n    /// let perm = Permission::allowed(Feature::Usb, Allow::Any);\n    /// let perm = Permission::allowed(Feature::Usb, [Allow::This, rocket]);\n    /// ```\n    pub fn allowed<L>(feature: Feature, allow: L) -> Self\n        where L: IntoCollection<Allow>\n    {\n        Permission(IndexMap::new()).allow(feature, allow)\n    }\n\n    /// Constructs a new `Permission` policy with only `feature` blocked.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::{Permission, Feature};\n    ///\n    /// let perm = Permission::blocked(Feature::Usb);\n    /// let perm = Permission::blocked(Feature::Payment);\n    /// ```\n    pub fn blocked(feature: Feature) -> Self {\n        Permission(IndexMap::new()).block(feature)\n    }\n\n    /// Adds `feature` as allowable for the set of origins in `allow` which may\n    /// be a single [`Allow`], a slice (`[Allow]` or `&[Allow]`), or a vector\n    /// (`Vec<Allow>`).\n    ///\n    /// This policy supersedes any previous policy set for `feature`.\n    ///\n    /// If `allow` is empty, the use of the feature is blocked unless another\n    /// call to `allow()` allows it. If `allow` contains [`Allow::Any`], the\n    /// feature is allowable for all origins. Otherwise, the feature is\n    /// allowable only for the origin specified in `allow`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if an `Absolute` URI in an `Allow::Origin` does not contain a\n    /// host part.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::shield::{Permission, Feature, Allow};\n    ///\n    /// let rocket = Allow::Origin(uri!(\"https://rocket.rs\"));\n    /// let perm = Permission::allowed(Feature::Usb, Allow::This)\n    ///     .allow(Feature::Payment, [rocket, Allow::This]);\n    /// ```\n    pub fn allow<L>(mut self, feature: Feature, allow: L) -> Self\n        where L: IntoCollection<Allow>\n    {\n        let mut allow = allow.into_collection();\n\n        if allow.contains(&Allow::Any) {\n            allow = Allow::Any.into_collection();\n        }\n\n        for allow in &allow {\n            if let Allow::Origin(absolute) = allow {\n                let auth = absolute.authority();\n                if auth.is_none() || matches!(auth, Some(a) if a.host().is_empty()) {\n                    panic!(\"...\")\n                }\n            }\n        }\n\n        self.0.insert(feature, Some(allow));\n        self\n    }\n\n    /// Blocks `feature`. This policy supersedes any previous policy set for\n    /// `feature`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::{Permission, Feature};\n    ///\n    /// let perm = Permission::default()\n    ///     .block(Feature::Usb)\n    ///     .block(Feature::Payment);\n    /// ```\n    pub fn block(mut self, feature: Feature) -> Self {\n        self.0.insert(feature, None);\n        self\n    }\n\n    /// Returns the allow list (so far) for `feature` if feature is allowed.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::{Permission, Feature, Allow};\n    ///\n    /// let perm = Permission::default();\n    /// assert!(perm.get(Feature::Usb).is_none());\n    ///\n    /// let perm = perm.allow(Feature::Usb, Allow::Any);\n    /// assert_eq!(perm.get(Feature::Usb).unwrap(), &[Allow::Any]);\n    /// ```\n    pub fn get(&self, feature: Feature) -> Option<&[Allow]> {\n        self.0.get(&feature)?.as_deref()\n    }\n\n    /// Returns an iterator over the pairs of features and their allow lists,\n    /// `None` if the feature is blocked.\n    ///\n    /// Features are returned in the order in which they were first added.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::shield::{Permission, Feature, Allow};\n    ///\n    /// let foo = uri!(\"https://foo.com:1234\");\n    /// let perm = Permission::blocked(Feature::Camera)\n    ///     .allow(Feature::Gyroscope, [Allow::This, Allow::Origin(foo.clone())])\n    ///     .block(Feature::Payment)\n    ///     .allow(Feature::Camera, Allow::Any);\n    ///\n    /// let perms: Vec<_> = perm.iter().collect();\n    /// assert_eq!(perms.len(), 3);\n    /// assert_eq!(perms, vec![\n    ///     (Feature::Camera, Some(&[Allow::Any][..])),\n    ///     (Feature::Gyroscope, Some(&[Allow::This, Allow::Origin(foo)][..])),\n    ///     (Feature::Payment, None),\n    /// ]);\n    /// ```\n    pub fn iter(&self) -> impl Iterator<Item = (Feature, Option<&[Allow]>)> {\n        self.0.iter().map(|(feature, list)| (*feature, list.as_deref()))\n    }\n}\n\nimpl From<&Permission> for Header<'static> {\n    fn from(perm: &Permission) -> Self {\n        if perm == &Permission::default() {\n            static DEFAULT: Header<'static> = Header {\n                name: Uncased::from_borrowed(Permission::NAME),\n                value: Cow::Borrowed(\"interest-cohort=()\")\n            };\n\n            return DEFAULT.clone();\n        }\n\n        let value = perm.0.iter()\n            .map(|(feature, allow)| {\n                let list = allow.as_ref()\n                    .into_iter()\n                    .flatten()\n                    .map(|origin| origin.rendered())\n                    .collect::<Vec<_>>()\n                    .join(\" \");\n\n                format!(\"{}=({})\", feature, list)\n            })\n            .collect::<Vec<_>>()\n            .join(\", \");\n\n        Header::new(Permission::NAME, value)\n    }\n}\n\n/// Specifies the origin(s) allowed to access a browser [`Feature`] via\n/// [`Permission`].\n#[derive(Debug, PartialEq, Clone)]\npub enum Allow {\n    /// Allow this specific origin. The feature is allowed only for this\n    /// specific origin.\n    ///\n    /// The `user_info`, `path`, and `query` parts of the URI, if any, are\n    /// ignored.\n    Origin(Absolute<'static>),\n    /// Any origin at all.\n    ///\n    /// The feature will be allowed in all browsing contexts regardless of their\n    /// origin.\n    Any,\n    /// The current origin.\n    ///\n    /// The feature will be allowed in the immediately returned document and in\n    /// all nested browsing contexts (iframes) in the same origin.\n    This,\n}\n\nimpl Allow {\n    fn rendered(&self) -> Cow<'static, str> {\n        match self {\n            Allow::Origin(uri) => {\n                let mut string = String::with_capacity(32);\n                string.push('\"');\n                string.push_str(uri.scheme());\n\n                // This should never fail when rendering a header for `Shield`\n                // due to `panic` in `.allow()`.\n                if let Some(auth) = uri.authority() {\n                    use std::fmt::Write;\n\n                    let _ = write!(string, \"://{}\", auth.host());\n                    if let Some(port) = auth.port() {\n                        let _ = write!(string, \":{}\", port);\n                    }\n                }\n\n                string.push('\"');\n                string.into()\n            }\n            Allow::Any => \"*\".into(),\n            Allow::This => \"self\".into(),\n        }\n    }\n}\n\n/// A browser feature that can be enabled or blocked via [`Permission`].\n#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n#[non_exhaustive]\npub enum Feature {\n    // Standardized.\n\n    /// The \"accelerometer\" feature.\n    Accelerometer,\n    /// The \"ambient-light-sensor\" feature.\n    AmbientLightSensor,\n    /// The \"autoplay\" feature.\n    Autoplay,\n    /// The \"battery\" feature.\n    Battery,\n    /// The \"camera\" feature.\n    Camera,\n    /// The \"cross-origin-isolated\" feature.\n    CrossOriginIsolated,\n    /// The \"display-capture\" feature.\n    Displaycapture,\n    /// The \"document-domain\" feature.\n    DocumentDomain,\n    /// The \"encrypted-media\" feature.\n    EncryptedMedia,\n    /// The \"execution-while-not-rendered\" feature.\n    ExecutionWhileNotRendered,\n    /// The \"execution-while-out-of-viewport\" feature.\n    ExecutionWhileOutOfviewport,\n    /// The \"fullscreen\" feature.\n    Fullscreen,\n    /// The \"geolocation\" feature.\n    Geolocation,\n    /// The \"gyroscope\" feature.\n    Gyroscope,\n    /// The \"magnetometer\" feature.\n    Magnetometer,\n    /// The \"microphone\" feature.\n    Microphone,\n    /// The \"midi\" feature.\n    Midi,\n    /// The \"navigation-override\" feature.\n    NavigationOverride,\n    /// The \"payment\" feature.\n    Payment,\n    /// The \"picture-in-picture\" feature.\n    PictureInPicture,\n    /// The \"publickey-credentials-get\" feature.\n    PublickeyCredentialsGet,\n    /// The \"screen-wake-lock\" feature.\n    ScreenWakeLock,\n    /// The \"sync-xhr\" feature.\n    SyncXhr,\n    /// The \"usb\" feature.\n    Usb,\n    /// The \"web-share\" feature.\n    WebShare,\n    /// The \"xr-spatial-tracking\" feature.\n    XrSpatialTracking,\n\n    // Proposed.\n\n    /// The \"clipboard-read\" feature.\n    ClipboardRead,\n    /// The \"clipboard-write\" feature.\n    ClipboardWrite,\n    /// The \"gamepad\" feature.\n    Gamepad,\n    /// The \"speaker-selection\" feature.\n    SpeakerSelection,\n    /// The \"interest-cohort\" feature.\n    InterestCohort,\n\n    // Experimental.\n\n    /// The \"conversion-measurement\" feature.\n    ConversionMeasurement,\n    /// The \"focus-without-user-activation\" feature.\n    FocusWithoutUserActivation,\n    /// The \"hid\" feature.\n    Hid,\n    /// The \"idle-detection\" feature.\n    IdleDetection,\n    /// The \"serial\" feature.\n    Serial,\n    /// The \"sync-script\" feature.\n    SyncScript,\n    /// The \"trust-token-redemption\" feature.\n    TrustTokenRedemption,\n    /// The \"vertical-scroll\" feature.\n    VerticalScroll,\n}\n\nimpl Feature {\n    /// Returns the feature string as it appears in the header.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::Feature;\n    ///\n    /// assert_eq!(Feature::Camera.as_str(), \"camera\");\n    /// assert_eq!(Feature::SyncScript.as_str(), \"sync-script\");\n    /// ```\n    pub const fn as_str(self) -> &'static str {\n        use Feature::*;\n\n        match self {\n            Accelerometer => \"accelerometer\",\n            AmbientLightSensor => \"ambient-light-sensor\",\n            Autoplay => \"autoplay\",\n            Battery => \"battery\",\n            Camera => \"camera\",\n            CrossOriginIsolated => \"cross-origin-isolated\",\n            Displaycapture => \"display-capture\",\n            DocumentDomain => \"document-domain\",\n            EncryptedMedia => \"encrypted-media\",\n            ExecutionWhileNotRendered => \"execution-while-not-rendered\",\n            ExecutionWhileOutOfviewport => \"execution-while-out-of-viewport\",\n            Fullscreen => \"fullscreen\",\n            Geolocation => \"geolocation\",\n            Gyroscope => \"gyroscope\",\n            Magnetometer => \"magnetometer\",\n            Microphone => \"microphone\",\n            Midi => \"midi\",\n            NavigationOverride => \"navigation-override\",\n            Payment => \"payment\",\n            PictureInPicture => \"picture-in-picture\",\n            PublickeyCredentialsGet => \"publickey-credentials-get\",\n            ScreenWakeLock => \"screen-wake-lock\",\n            SyncXhr => \"sync-xhr\",\n            Usb => \"usb\",\n            WebShare => \"web-share\",\n            XrSpatialTracking => \"xr-spatial-tracking\",\n\n            ClipboardRead => \"clipboard-read\",\n            ClipboardWrite => \"clipboard-write\",\n            Gamepad => \"gamepad\",\n            SpeakerSelection => \"speaker-selection\",\n            InterestCohort => \"interest-cohort\",\n\n            ConversionMeasurement => \"conversion-measurement\",\n            FocusWithoutUserActivation => \"focus-without-user-activation\",\n            Hid => \"hid\",\n            IdleDetection => \"idle-detection\",\n            Serial => \"serial\",\n            SyncScript => \"sync-script\",\n            TrustTokenRedemption => \"trust-token-redemption\",\n            VerticalScroll => \"vertical-scroll\",\n        }\n    }\n}\n\nimpl fmt::Display for Feature {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.as_str().fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::collections::HashMap;\nuse std::sync::atomic::{AtomicBool, Ordering};\n\nuse state::InitCell;\nuse yansi::Paint;\n\nuse crate::{Rocket, Request, Response, Orbit, Config};\nuse crate::fairing::{Fairing, Info, Kind};\nuse crate::http::{Header, uncased::UncasedStr};\nuse crate::log::PaintExt;\nuse crate::shield::*;\n\n/// A [`Fairing`] that injects browser security and privacy headers into all\n/// outgoing responses.\n///\n/// # Usage\n///\n/// To use `Shield`, first construct an instance of it. To use the default\n/// set of headers, construct with [`Shield::default()`](#method.default).\n/// For an instance with no preset headers, use [`Shield::new()`]. To\n/// enable an additional header, use [`enable()`](Shield::enable()), and to\n/// disable a header, use [`disable()`](Shield::disable()):\n///\n/// ```rust\n/// use rocket::shield::Shield;\n/// use rocket::shield::{XssFilter, ExpectCt};\n///\n/// // A `Shield` with the default headers:\n/// let shield = Shield::default();\n///\n/// // A `Shield` with the default headers minus `XssFilter`:\n/// let shield = Shield::default().disable::<XssFilter>();\n///\n/// // A `Shield` with the default headers plus `ExpectCt`.\n/// let shield = Shield::default().enable(ExpectCt::default());\n///\n/// // A `Shield` with only `XssFilter` and `ExpectCt`.\n/// let shield = Shield::default()\n///     .enable(XssFilter::default())\n///     .enable(ExpectCt::default());\n/// ```\n///\n/// Then, attach the instance of `Shield` to your application's instance of\n/// `Rocket`:\n///\n/// ```rust\n/// # extern crate rocket;\n/// # use rocket::shield::Shield;\n/// # let shield = Shield::default();\n/// rocket::build()\n///     // ...\n///     .attach(shield)\n/// # ;\n/// ```\n///\n/// The fairing will inject all enabled headers into all outgoing responses\n/// _unless_ the response already contains a header with the same name. If it\n/// does contain the header, a warning is emitted, and the header is not\n/// overwritten.\n///\n/// # TLS and HSTS\n///\n/// If TLS is configured and enabled when the application is launched in a\n/// non-debug profile, HSTS is automatically enabled with its default policy and\n/// a warning is logged.\n///\n/// To get rid of this warning, explicitly [`Shield::enable()`] an [`Hsts`]\n/// policy.\npub struct Shield {\n    /// Enabled policies where the key is the header name.\n    policies: HashMap<&'static UncasedStr, Box<dyn SubPolicy>>,\n    /// Whether to enforce HSTS even though the user didn't enable it.\n    force_hsts: AtomicBool,\n    /// Headers pre-rendered at liftoff from the configured policies.\n    rendered: InitCell<Vec<Header<'static>>>,\n}\n\nimpl Default for Shield {\n    /// Returns a new `Shield` instance. See the [table] for a description\n    /// of the policies used by default.\n    ///\n    /// [table]: ./#supported-headers\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # extern crate rocket;\n    /// use rocket::shield::Shield;\n    ///\n    /// let shield = Shield::default();\n    /// ```\n    fn default() -> Self {\n        Shield::new()\n            .enable(NoSniff::default())\n            .enable(Frame::default())\n            .enable(Permission::default())\n    }\n}\n\nimpl Shield {\n    /// Returns an instance of `Shield` with no headers enabled.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::Shield;\n    ///\n    /// let shield = Shield::new();\n    /// ```\n    pub fn new() -> Self {\n        Shield {\n            policies: HashMap::new(),\n            force_hsts: AtomicBool::new(false),\n            rendered: InitCell::new(),\n        }\n    }\n\n    /// Enables the policy header `policy`.\n    ///\n    /// If the policy was previously enabled, the configuration is replaced\n    /// with that of `policy`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::Shield;\n    /// use rocket::shield::NoSniff;\n    ///\n    /// let shield = Shield::new().enable(NoSniff::default());\n    /// ```\n    pub fn enable<P: Policy>(mut self, policy: P) -> Self {\n        self.rendered = InitCell::new();\n        self.policies.insert(P::NAME.into(), Box::new(policy));\n        self\n    }\n\n    /// Disables the policy header `policy`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::Shield;\n    /// use rocket::shield::NoSniff;\n    ///\n    /// let shield = Shield::default().disable::<NoSniff>();\n    /// ```\n    pub fn disable<P: Policy>(mut self) -> Self {\n        self.rendered = InitCell::new();\n        self.policies.remove(UncasedStr::new(P::NAME));\n        self\n    }\n\n    /// Returns `true` if the policy `P` is enabled.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::shield::Shield;\n    /// use rocket::shield::{Permission, NoSniff, Frame};\n    /// use rocket::shield::{Prefetch, ExpectCt, Referrer};\n    ///\n    /// let shield = Shield::default();\n    ///\n    /// assert!(shield.is_enabled::<NoSniff>());\n    /// assert!(shield.is_enabled::<Frame>());\n    /// assert!(shield.is_enabled::<Permission>());\n    ///\n    /// assert!(!shield.is_enabled::<Prefetch>());\n    /// assert!(!shield.is_enabled::<ExpectCt>());\n    /// assert!(!shield.is_enabled::<Referrer>());\n    /// ```\n    pub fn is_enabled<P: Policy>(&self) -> bool {\n        self.policies.contains_key(UncasedStr::new(P::NAME))\n    }\n\n    fn headers(&self) -> &[Header<'static>] {\n        self.rendered.get_or_init(|| {\n            let mut headers: Vec<_> = self.policies.values()\n                .map(|p| p.header())\n                .collect();\n\n            if self.force_hsts.load(Ordering::Acquire) {\n                headers.push(Policy::header(&Hsts::default()));\n            }\n\n            headers\n        })\n    }\n}\n\n#[crate::async_trait]\nimpl Fairing for Shield {\n    fn info(&self) -> Info {\n        Info {\n            name: \"Shield\",\n            kind: Kind::Liftoff | Kind::Response | Kind::Singleton,\n        }\n    }\n\n    async fn on_liftoff(&self, rocket: &Rocket<Orbit>) {\n        let force_hsts = rocket.config().tls_enabled()\n            && rocket.figment().profile() != Config::DEBUG_PROFILE\n            && !self.is_enabled::<Hsts>();\n\n        if force_hsts {\n            self.force_hsts.store(true, Ordering::Release);\n        }\n\n        if !self.headers().is_empty() {\n            info!(\"{}{}:\", \" \".emoji(), \"Shield\".magenta());\n\n            for header in self.headers() {\n                info_!(\"{}: {}\", header.name(), header.value().primary());\n            }\n\n            if force_hsts {\n                warn_!(\"Detected TLS-enabled liftoff without enabling HSTS.\");\n                warn_!(\"Shield has enabled a default HSTS policy.\");\n                info_!(\"To remove this warning, configure an HSTS policy.\");\n            }\n        }\n    }\n\n    async fn on_response<'r>(&self, _: &'r Request<'_>, response: &mut Response<'r>) {\n        // Set all of the headers in `self.policies` in `response` as long as\n        // the header is not already in the response.\n        for header in self.headers() {\n            if response.headers().contains(header.name()) {\n                warn!(\"Shield: response contains a '{}' header.\", header.name());\n                warn_!(\"Refusing to overwrite existing header.\");\n                continue\n            }\n\n            response.set_header(header.clone());\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::borrow::Cow;\n\nuse crate::form::name::*;\n\n/// A potentially owned [`Name`].\n///\n/// Constructible from a [`NameView`], [`Name`], `&str`, or `String`, a\n/// `NameBuf` acts much like a [`Name`] but can be converted into an owned\n/// version via [`IntoOwned`](crate::http::ext::IntoOwned).\n///\n/// ```rust\n/// use rocket::form::name::NameBuf;\n/// use rocket::http::ext::IntoOwned;\n///\n/// let alloc = String::from(\"a.b.c\");\n/// let name = NameBuf::from(alloc.as_str());\n/// let owned: NameBuf<'static> = name.into_owned();\n/// ```\n#[derive(Clone)]\npub struct NameBuf<'v> {\n    left: &'v Name,\n    right: Cow<'v, str>,\n}\n\nimpl<'v> NameBuf<'v> {\n    #[inline]\n    fn split(&self) -> (&Name, &Name) {\n        (self.left, Name::new(&self.right))\n    }\n\n    /// Returns an iterator over the keys of `self`, including empty keys.\n    ///\n    /// See [`Name`] for a description of \"keys\".\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameBuf;\n    ///\n    /// let name = NameBuf::from(\"apple.b[foo:bar]zoo.[barb].bat\");\n    /// let keys: Vec<_> = name.keys().map(|k| k.as_str()).collect();\n    /// assert_eq!(keys, &[\"apple\", \"b\", \"foo:bar\", \"zoo\", \"\", \"barb\", \"bat\"]);\n    /// ```\n    #[inline]\n    pub fn keys(&self) -> impl Iterator<Item = &Key> {\n        let (left, right) = self.split();\n        left.keys().chain(right.keys())\n    }\n\n    /// Returns `true` if `self` is empty.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameBuf;\n    ///\n    /// let name = NameBuf::from(\"apple.b[foo:bar]zoo.[barb].bat\");\n    /// assert!(!name.is_empty());\n    ///\n    /// let name = NameBuf::from(\"\");\n    /// assert!(name.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        let (left, right) = self.split();\n        left.is_empty() && right.is_empty()\n    }\n}\n\nimpl crate::http::ext::IntoOwned for NameBuf<'_> {\n    type Owned = NameBuf<'static>;\n\n    fn into_owned(self) -> Self::Owned {\n        let right = match (self.left, self.right) {\n            (l, Cow::Owned(r)) if l.is_empty() => Cow::Owned(r),\n            (l, r) if l.is_empty() => r.to_string().into(),\n            (l, r) if r.is_empty() => l.to_string().into(),\n            (l, r) => format!(\"{}.{}\", l, r).into(),\n        };\n\n        NameBuf { left: \"\".into(), right }\n    }\n}\n\nimpl serde::Serialize for NameBuf<'_> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n        where S: serde::Serializer\n    {\n        serializer.serialize_str(&self.to_string())\n    }\n}\n\nimpl<'v> From<NameView<'v>> for NameBuf<'v> {\n    fn from(nv: NameView<'v>) -> Self {\n        NameBuf { left: nv.as_name(), right: Cow::Borrowed(\"\") }\n    }\n}\n\nimpl<'v> From<&'v Name> for NameBuf<'v> {\n    fn from(name: &'v Name) -> Self {\n        NameBuf { left: name, right: Cow::Borrowed(\"\") }\n    }\n}\n\nimpl<'v> From<&'v str> for NameBuf<'v> {\n    fn from(name: &'v str) -> Self {\n        NameBuf::from((None, Cow::Borrowed(name)))\n    }\n}\n\nimpl<'v> From<String> for NameBuf<'v> {\n    fn from(name: String) -> Self {\n        NameBuf::from((None, Cow::Owned(name)))\n    }\n}\n\n#[doc(hidden)]\nimpl<'v> From<(Option<&'v Name>, Cow<'v, str>)> for NameBuf<'v> {\n    fn from((prefix, right): (Option<&'v Name>, Cow<'v, str>)) -> Self {\n        match prefix {\n            Some(left) => NameBuf { left, right },\n            None => NameBuf { left: \"\".into(), right }\n        }\n    }\n}\n\n#[doc(hidden)]\nimpl<'v> From<(Option<&'v Name>, String)> for NameBuf<'v> {\n    fn from((prefix, right): (Option<&'v Name>, String)) -> Self {\n        match prefix {\n            Some(left) => NameBuf { left, right: right.into() },\n            None => NameBuf { left: \"\".into(), right: right.into() }\n        }\n    }\n}\n\n#[doc(hidden)]\nimpl<'v> From<(Option<&'v Name>, &'v str)> for NameBuf<'v> {\n    fn from((prefix, suffix): (Option<&'v Name>, &'v str)) -> Self {\n        NameBuf::from((prefix, Cow::Borrowed(suffix)))\n    }\n}\n\n#[doc(hidden)]\nimpl<'v> From<(&'v Name, &'v str)> for NameBuf<'v> {\n    fn from((prefix, suffix): (&'v Name, &'v str)) -> Self {\n        NameBuf::from((Some(prefix), Cow::Borrowed(suffix)))\n    }\n}\n\nimpl std::fmt::Debug for NameBuf<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"\\\"\")?;\n\n        let (left, right) = self.split();\n        if !left.is_empty() { write!(f, \"{}\", left.escape_debug())? }\n        if !right.is_empty() {\n            if !left.is_empty() { f.write_str(\".\")?; }\n            write!(f, \"{}\", right.escape_debug())?;\n        }\n\n        write!(f, \"\\\"\")\n    }\n}\n\nimpl std::fmt::Display for NameBuf<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let (left, right) = self.split();\n        if !left.is_empty() { left.fmt(f)?; }\n        if !right.is_empty() {\n            if !left.is_empty() { f.write_str(\".\")?; }\n            right.fmt(f)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl PartialEq for NameBuf<'_> {\n    fn eq(&self, other: &Self) -> bool {\n        self.keys().eq(other.keys())\n    }\n}\n\nimpl<N: AsRef<Name> + ?Sized> PartialEq<N> for NameBuf<'_> {\n    fn eq(&self, other: &N) -> bool {\n        self.keys().eq(other.as_ref().keys())\n    }\n}\n\nimpl PartialEq<NameBuf<'_>> for Name {\n    fn eq(&self, other: &NameBuf<'_>) -> bool {\n        self.keys().eq(other.keys())\n    }\n}\n\nimpl PartialEq<NameBuf<'_>> for str {\n    fn eq(&self, other: &NameBuf<'_>) -> bool {\n        Name::new(self) == other\n    }\n}\n\nimpl PartialEq<NameBuf<'_>> for &str {\n    fn eq(&self, other: &NameBuf<'_>) -> bool {\n        Name::new(self) == other\n    }\n}\n\nimpl Eq for NameBuf<'_> { }\n\nimpl std::hash::Hash for NameBuf<'_> {\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        self.keys().for_each(|k| k.hash(state))\n    }\n}\n\nimpl indexmap::Equivalent<Name> for NameBuf<'_> {\n    fn equivalent(&self, key: &Name) -> bool {\n        self.keys().eq(key.keys())\n    }\n}\n\nimpl indexmap::Equivalent<NameBuf<'_>> for Name {\n    fn equivalent(&self, key: &NameBuf<'_>) -> bool {\n        self.keys().eq(key.keys())\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::Deref;\n\nuse ref_cast::RefCast;\n\nuse crate::http::RawStr;\n\n/// A field name key composed of indices.\n///\n/// A form field name key is composed of _indices_, delimited by `:`. The\n/// graphic below illustrates this composition for a single field in\n/// `$name=$value` format:\n///\n/// ```text\n///       food.bart[bar:foo:baz]=some-value\n/// name  |--------------------|\n/// key   |--| |--| |---------|\n/// index |--| |--| |-| |-| |-|\n/// ```\n///\n/// A `Key` is a wrapper around a given key string with methods to easily access\n/// its indices.\n///\n/// # Serialization\n///\n/// A value of this type is serialized exactly as an `&str` consisting of the\n/// entire key.\n#[repr(transparent)]\n#[derive(RefCast, Debug, PartialEq, Eq, Hash)]\npub struct Key(str);\n\nimpl Key {\n    /// Wraps a string as a `Key`. This is cost-free.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Key;\n    ///\n    /// let key = Key::new(\"a:b:c\");\n    /// assert_eq!(key.as_str(), \"a:b:c\");\n    /// ```\n    pub fn new<S: AsRef<str> + ?Sized>(string: &S) -> &Key {\n        Key::ref_cast(string.as_ref())\n    }\n\n    /// Returns an iterator over the indices of `self`, including empty indices.\n    ///\n    /// See the [top-level docs](Self) for a description of \"indices\".\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Key;\n    ///\n    /// let key = Key::new(\"foo:bar::baz:a.b.c\");\n    /// let indices: Vec<_> = key.indices().collect();\n    /// assert_eq!(indices, &[\"foo\", \"bar\", \"\", \"baz\", \"a.b.c\"]);\n    /// ```\n    pub fn indices(&self) -> impl Iterator<Item = &str> {\n        self.split(':')\n    }\n\n    /// Borrows the underlying string.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Key;\n    ///\n    /// let key = Key::new(\"a:b:c\");\n    /// assert_eq!(key.as_str(), \"a:b:c\");\n    /// ```\n    pub fn as_str(&self) -> &str {\n        &*self\n    }\n}\n\nimpl Deref for Key {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl serde::Serialize for Key {\n    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n        where S: serde::Serializer\n    {\n        self.0.serialize(ser)\n    }\n}\n\nimpl<'de: 'a, 'a> serde::Deserialize<'de> for &'a Key {\n    fn deserialize<D>(de: D) -> Result<Self, D::Error>\n        where D: serde::Deserializer<'de>\n    {\n        <&'a str as serde::Deserialize<'de>>::deserialize(de).map(Key::new)\n    }\n}\n\nimpl<I: core::slice::SliceIndex<str, Output=str>> core::ops::Index<I> for Key {\n    type Output = Key;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        self.0[index].into()\n    }\n}\n\nimpl PartialEq<str> for Key {\n    fn eq(&self, other: &str) -> bool {\n        self == Key::new(other)\n    }\n}\n\nimpl PartialEq<Key> for str {\n    fn eq(&self, other: &Key) -> bool {\n        Key::new(self) == other\n    }\n}\n\nimpl<'a, S: AsRef<str> + ?Sized> From<&'a S> for &'a Key {\n    #[inline]\n    fn from(string: &'a S) -> Self {\n        Key::new(string)\n    }\n}\n\nimpl AsRef<Key> for str {\n    fn as_ref(&self) -> &Key {\n        Key::new(self)\n    }\n}\n\nimpl AsRef<Key> for RawStr {\n    fn as_ref(&self) -> &Key {\n        Key::new(self)\n    }\n}\n\nimpl std::fmt::Display for Key {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Types for field names, name keys, and key indices.\n\nmod name;\nmod view;\nmod key;\nmod buf;\n\npub use name::Name;\npub use view::NameView;\npub use key::Key;\npub use buf::NameBuf;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::ops::Deref;\n\nuse ref_cast::RefCast;\n\nuse crate::http::RawStr;\nuse crate::form::name::*;\n\n/// A field name composed of keys.\n///\n/// A form field name is composed of _keys_, delimited by `.` or `[]`. Keys, in\n/// turn, are composed of _indices_, delimited by `:`. The graphic below\n/// illustrates this composition for a single field in `$name=$value` format:\n///\n/// ```text\n///       food.bart[bar:foo].blam[0_0][1000]=some-value\n/// name  |--------------------------------|\n/// key   |--| |--| |-----|  |--| |-|  |--|\n/// index |--| |--| |-| |-|  |--| |-|  |--|\n/// ```\n///\n/// A `Name` is a wrapper around the field name string with methods to easily\n/// access its sub-components.\n///\n/// # Serialization\n///\n/// A value of this type is serialized exactly as an `&str` consisting of the\n/// entire field name.\n#[repr(transparent)]\n#[derive(RefCast)]\npub struct Name(str);\n\nimpl Name {\n    /// Wraps a string as a `Name`. This is cost-free.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Name;\n    ///\n    /// let name = Name::new(\"a.b.c\");\n    /// assert_eq!(name.as_str(), \"a.b.c\");\n    /// ```\n    pub fn new<S: AsRef<str> + ?Sized>(string: &S) -> &Name {\n        Name::ref_cast(string.as_ref())\n    }\n\n    /// Returns an iterator over the keys of `self`, including empty keys.\n    ///\n    /// See the [top-level docs](Self) for a description of \"keys\".\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Name;\n    ///\n    /// let name = Name::new(\"apple.b[foo:bar]zoo.[barb].bat\");\n    /// let keys: Vec<_> = name.keys().map(|k| k.as_str()).collect();\n    /// assert_eq!(keys, &[\"apple\", \"b\", \"foo:bar\", \"zoo\", \"\", \"barb\", \"bat\"]);\n    /// ```\n    pub fn keys(&self) -> impl Iterator<Item = &Key> {\n        struct Keys<'v>(NameView<'v>);\n\n        impl<'v> Iterator for Keys<'v> {\n            type Item = &'v Key;\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if self.0.exhausted() {\n                    return None;\n                }\n\n                let key = self.0.key_lossy();\n                self.0.shift();\n                Some(key)\n            }\n        }\n\n        Keys(NameView::new(self))\n    }\n\n    /// Returns an iterator over overlapping name prefixes of `self`, each\n    /// succeeding prefix containing one more key than the previous.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Name;\n    ///\n    /// let name = Name::new(\"apple.b[foo:bar]\");\n    /// let prefixes: Vec<_> = name.prefixes().map(|p| p.as_str()).collect();\n    /// assert_eq!(prefixes, &[\"apple\", \"apple.b\", \"apple.b[foo:bar]\"]);\n    ///\n    /// let name = Name::new(\"a.b.[foo]\");\n    /// let prefixes: Vec<_> = name.prefixes().map(|p| p.as_str()).collect();\n    /// assert_eq!(prefixes, &[\"a\", \"a.b\", \"a.b.\", \"a.b.[foo]\"]);\n    /// ```\n    pub fn prefixes(&self) -> impl Iterator<Item = &Name> {\n        struct Prefixes<'v>(NameView<'v>);\n\n        impl<'v> Iterator for Prefixes<'v> {\n            type Item = &'v Name;\n\n            fn next(&mut self) -> Option<Self::Item> {\n                if self.0.exhausted() {\n                    return None;\n                }\n\n                let name = self.0.as_name();\n                self.0.shift();\n                Some(name)\n            }\n        }\n\n        Prefixes(NameView::new(self))\n    }\n\n    /// Borrows the underlying string.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::Name;\n    ///\n    /// let name = Name::new(\"a.b.c\");\n    /// assert_eq!(name.as_str(), \"a.b.c\");\n    /// ```\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n}\n\nimpl serde::Serialize for Name {\n    fn serialize<S>(&self, ser: S) -> Result<S::Ok, S::Error>\n        where S: serde::Serializer\n    {\n        self.0.serialize(ser)\n    }\n}\n\nimpl<'de: 'a, 'a> serde::Deserialize<'de> for &'a Name {\n    fn deserialize<D>(de: D) -> Result<Self, D::Error>\n        where D: serde::Deserializer<'de>\n    {\n        <&'a str as serde::Deserialize<'de>>::deserialize(de).map(Name::new)\n    }\n}\n\nimpl<'a, S: AsRef<str> + ?Sized> From<&'a S> for &'a Name {\n    #[inline]\n    fn from(string: &'a S) -> Self {\n        Name::new(string)\n    }\n}\n\nimpl Deref for Name {\n    type Target = str;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<I: core::slice::SliceIndex<str, Output=str>> core::ops::Index<I> for Name {\n    type Output = Name;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        self.0[index].into()\n    }\n}\n\nimpl PartialEq for Name {\n    fn eq(&self, other: &Self) -> bool {\n        self.keys().eq(other.keys())\n    }\n}\n\nimpl PartialEq<str> for Name {\n    fn eq(&self, other: &str) -> bool {\n        self == Name::new(other)\n    }\n}\n\nimpl PartialEq<Name> for str {\n    fn eq(&self, other: &Name) -> bool {\n        Name::new(self) == other\n    }\n}\n\nimpl PartialEq<&str> for Name {\n    fn eq(&self, other: &&str) -> bool {\n        self == Name::new(other)\n    }\n}\n\nimpl PartialEq<Name> for &str {\n    fn eq(&self, other: &Name) -> bool {\n        Name::new(self) == other\n    }\n}\n\nimpl AsRef<Name> for str {\n    fn as_ref(&self) -> &Name {\n        Name::new(self)\n    }\n}\n\nimpl AsRef<Name> for RawStr {\n    fn as_ref(&self) -> &Name {\n        Name::new(self)\n    }\n}\n\nimpl AsRef<Name> for Name {\n    fn as_ref(&self) -> &Name {\n        self\n    }\n}\n\nimpl Eq for Name { }\n\nimpl std::hash::Hash for Name {\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        self.keys().for_each(|k| k.hash(state))\n    }\n}\n\nimpl std::fmt::Display for Name {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl std::fmt::Debug for Name {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::form::name::*;\n\n/// A sliding-prefix view into a [`Name`].\n///\n/// A [`NameView`] maintains a sliding key view into a [`Name`]. The current key\n/// ([`key()`]) can be [`shift()`ed](NameView::shift()) one key to the right.\n/// The `Name` prefix including the current key can be extracted via\n/// [`as_name()`] and the prefix _not_ including the current key via\n/// [`parent()`].\n///\n/// [`key()`]: NameView::key()\n/// [`as_name()`]: NameView::as_name()\n/// [`parent()`]: NameView::parent()\n///\n/// This is best illustrated via an example:\n///\n/// ```rust\n/// use rocket::form::name::NameView;\n///\n/// // The view begins at the first key. Illustrated: `(a).b[c:d]` where\n/// // parenthesis enclose the current key.\n/// let mut view = NameView::new(\"a.b[c:d]\");\n/// assert_eq!(view.key().unwrap(), \"a\");\n/// assert_eq!(view.as_name(), \"a\");\n/// assert_eq!(view.parent(), None);\n///\n/// // Shifted once to the right views the second key: `a.(b)[c:d]`.\n/// view.shift();\n/// assert_eq!(view.key().unwrap(), \"b\");\n/// assert_eq!(view.as_name(), \"a.b\");\n/// assert_eq!(view.parent().unwrap(), \"a\");\n///\n/// // Shifting again now has predictable results: `a.b[(c:d)]`.\n/// view.shift();\n/// assert_eq!(view.key().unwrap(), \"c:d\");\n/// assert_eq!(view.as_name(), \"a.b[c:d]\");\n/// assert_eq!(view.parent().unwrap(), \"a.b\");\n///\n/// // Shifting past the end means we have no further keys.\n/// view.shift();\n/// assert_eq!(view.key(), None);\n/// assert_eq!(view.key_lossy(), \"\");\n/// assert_eq!(view.as_name(), \"a.b[c:d]\");\n/// assert_eq!(view.parent().unwrap(), \"a.b[c:d]\");\n///\n/// view.shift();\n/// assert_eq!(view.key(), None);\n/// assert_eq!(view.as_name(), \"a.b[c:d]\");\n/// assert_eq!(view.parent().unwrap(), \"a.b[c:d]\");\n/// ```\n///\n/// # Equality\n///\n/// `PartialEq`, `Eq`, and `Hash` all operate on the name prefix including the\n/// current key. Only key values are compared; delimiters are insignificant.\n/// Again, illustrated via examples:\n///\n/// ```rust\n/// use rocket::form::name::NameView;\n///\n/// let mut view = NameView::new(\"a.b[c:d]\");\n/// assert_eq!(view, \"a\");\n///\n/// // Shifted once to the right views the second key: `a.(b)[c:d]`.\n/// view.shift();\n/// assert_eq!(view.key().unwrap(), \"b\");\n/// assert_eq!(view.as_name(), \"a.b\");\n/// assert_eq!(view, \"a.b\");\n/// assert_eq!(view, \"a[b]\");\n///\n/// // Shifting again now has predictable results: `a.b[(c:d)]`.\n/// view.shift();\n/// assert_eq!(view, \"a.b[c:d]\");\n/// assert_eq!(view, \"a.b.c:d\");\n/// assert_eq!(view, \"a[b].c:d\");\n/// assert_eq!(view, \"a[b]c:d\");\n/// ```\n#[derive(Copy, Clone)]\npub struct NameView<'v> {\n    name: &'v Name,\n    start: usize,\n    end: usize,\n}\n\nimpl<'v> NameView<'v> {\n    /// Initializes a new `NameView` at the first key of `name`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a.b[c:d]\");\n    /// assert_eq!(view.key().unwrap(), \"a\");\n    /// assert_eq!(view.as_name(), \"a\");\n    /// assert_eq!(view.parent(), None);\n    /// ```\n    pub fn new<N: Into<&'v Name>>(name: N) -> Self {\n        let mut view = NameView { name: name.into(), start: 0, end: 0 };\n        view.shift();\n        view\n    }\n\n    /// Shifts the current key once to the right.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a.b[c:d][d.e]\");\n    /// assert_eq!(view.key().unwrap(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key().unwrap(), \"b\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key().unwrap(), \"c:d\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key().unwrap(), \"d.e\");\n    /// ```\n    ///\n    /// Malformed strings can have interesting results:\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[c.d\");\n    /// assert_eq!(view.key_lossy(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"c.d\");\n    ///\n    /// let mut view = NameView::new(\"a[c[.d]\");\n    /// assert_eq!(view.key_lossy(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"c[.d\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key(), None);\n    ///\n    /// let mut view = NameView::new(\"foo[c[.d]]\");\n    /// assert_eq!(view.key_lossy(), \"foo\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"c[.d\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"]\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key(), None);\n    /// ```\n    pub fn shift(&mut self) {\n        const START_DELIMS: &[char] = &['.', '['];\n\n        let string = &self.name[self.end..];\n        let bytes = string.as_bytes();\n        let shift = match bytes.get(0) {\n            None | Some(b'=') => 0,\n            Some(b'[') => match memchr::memchr(b']', bytes) {\n                Some(j) => j + 1,\n                None => bytes.len(),\n            },\n            Some(b'.') => match string[1..].find(START_DELIMS) {\n                Some(j) => j + 1,\n                None => bytes.len(),\n            },\n            _ => match string.find(START_DELIMS) {\n                Some(j) => j,\n                None => bytes.len()\n            }\n        };\n\n        debug_assert!(self.end + shift <= self.name.len());\n        *self = NameView {\n            name: self.name,\n            start: self.end,\n            end: self.end + shift,\n        };\n    }\n\n    /// Returns the key currently viewed by `self` if it is non-empty.\n    ///\n    /// ```text\n    ///                 food.bart[bar:foo].blam[0_0][][1000]=some-value\n    /// name            |----------------------------------|\n    /// non-empty key   |--| |--| |-----|  |--| |-|     |--|\n    /// empty key                                  |-|\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[b]\");\n    /// assert_eq!(view.key().unwrap(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key().unwrap(), \"b\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key(), None);\n    /// # view.shift(); assert_eq!(view.key(), None);\n    /// # view.shift(); assert_eq!(view.key(), None);\n    /// ```\n    pub fn key(&self) -> Option<&'v Key> {\n        let lossy_key = self.key_lossy();\n        if lossy_key.is_empty() {\n            return None;\n        }\n\n        Some(lossy_key)\n    }\n\n    /// Returns the key currently viewed by `self`, even if it is non-empty.\n    ///\n    /// ```text\n    ///                 food.bart[bar:foo].blam[0_0][][1000]=some-value\n    /// name            |----------------------------------|\n    /// non-empty key   |--| |--| |-----|  |--| |-|     |--|\n    /// empty key                                  |-|\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[b]\");\n    /// assert_eq!(view.key_lossy(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"b\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.key_lossy(), \"\");\n    /// # view.shift(); assert_eq!(view.key_lossy(), \"\");\n    /// # view.shift(); assert_eq!(view.key_lossy(), \"\");\n    /// ```\n    pub fn key_lossy(&self) -> &'v Key {\n        let view = &self.name[self.start..self.end];\n        let key = match view.as_bytes().get(0) {\n            Some(b'.') => &view[1..],\n            Some(b'[') if view.ends_with(']') => &view[1..view.len() - 1],\n            Some(b'[') if self.is_at_last() => &view[1..],\n            _ => view\n        };\n\n        key.as_str().into()\n    }\n\n    /// Returns the `Name` _up to and including_ the current key.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[b]\");\n    /// assert_eq!(view.as_name(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.as_name(), \"a[b]\");\n    /// # view.shift(); assert_eq!(view.as_name(), \"a[b]\");\n    /// # view.shift(); assert_eq!(view.as_name(), \"a[b]\");\n    /// ```\n    pub fn as_name(&self) -> &'v Name {\n        &self.name[..self.end]\n    }\n\n    /// Returns the `Name` _prior to_ the current key.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[b]\");\n    /// assert_eq!(view.parent(), None);\n    ///\n    /// view.shift();\n    /// assert_eq!(view.parent().unwrap(), \"a\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.parent().unwrap(), \"a[b]\");\n    /// # view.shift(); assert_eq!(view.parent().unwrap(), \"a[b]\");\n    /// # view.shift(); assert_eq!(view.parent().unwrap(), \"a[b]\");\n    /// ```\n    pub fn parent(&self) -> Option<&'v Name> {\n        if self.start > 0 {\n            Some(&self.name[..self.start])\n        } else {\n            None\n        }\n    }\n\n    /// Returns the underlying `Name`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::form::name::NameView;\n    ///\n    /// let mut view = NameView::new(\"a[b]\");\n    /// assert_eq!(view.source(), \"a[b]\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.source(), \"a[b]\");\n    ///\n    /// view.shift();\n    /// assert_eq!(view.source(), \"a[b]\");\n    ///\n    /// # view.shift(); assert_eq!(view.source(), \"a[b]\");\n    /// # view.shift(); assert_eq!(view.source(), \"a[b]\");\n    /// ```\n    pub fn source(&self) -> &'v Name {\n        self.name\n    }\n\n    // This is the last key. The next `shift()` will exhaust `self`.\n    fn is_at_last(&self) -> bool {\n        self.end == self.name.len()\n    }\n\n    // There are no more keys. A `shift` will do nothing.\n    pub(crate) fn exhausted(&self) -> bool {\n        self.start == self.name.len()\n    }\n}\n\nimpl std::fmt::Debug for NameView<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.as_name().fmt(f)\n    }\n}\n\nimpl std::fmt::Display for NameView<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.as_name().fmt(f)\n    }\n}\n\nimpl<'a, 'b> PartialEq<NameView<'b>> for NameView<'a> {\n    fn eq(&self, other: &NameView<'b>) -> bool {\n        self.as_name() == other.as_name()\n    }\n}\n\nimpl<B: PartialEq<Name>> PartialEq<B> for NameView<'_> {\n    fn eq(&self, other: &B) -> bool {\n        other == self.as_name()\n    }\n}\n\nimpl Eq for NameView<'_> {  }\n\nimpl std::hash::Hash for NameView<'_> {\n    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n        self.as_name().hash(state)\n    }\n}\n\nimpl std::borrow::Borrow<Name> for NameView<'_> {\n    fn borrow(&self) -> &Name {\n        self.as_name()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse parking_lot::RwLock;\n\nuse crate::{Rocket, Phase, Orbit, Ignite, Error};\nuse crate::local::asynchronous::{LocalRequest, LocalResponse};\nuse crate::http::{Method, uri::Origin, private::cookie};\n\n/// An `async` client to construct and dispatch local requests.\n///\n/// For details, see [the top-level documentation](../index.html#client).\n/// For the `blocking` version, see\n/// [`blocking::Client`](crate::local::blocking::Client).\n///\n/// ## Multithreaded Tracking Synchronization Pitfalls\n///\n/// Unlike its [`blocking`](crate::local::blocking) variant, this `async`\n/// `Client` implements `Sync`. However, using it in a multithreaded environment\n/// while tracking cookies can result in surprising, non-deterministic behavior.\n/// This is because while cookie modifications are serialized, the ordering\n/// depends on the ordering of request dispatch.\n///\n/// If possible, refrain from sharing a single instance of a tracking `Client`\n/// across multiple threads. Instead, prefer to create a unique instance of\n/// `Client` per thread. If this is not possible, ensure that you are not\n/// depending on the ordering of cookie modifications or have arranged for\n/// request dispatch to occur in a deterministic manner.\n///\n/// Alternatively, use an untracked client, which does not suffer from these\n/// pitfalls.\n///\n/// ## Example\n///\n/// The following snippet creates a `Client` from a `Rocket` instance and\n/// dispatches a local `POST /` request with a body of `Hello, world!`.\n///\n/// ```rust,no_run\n/// use rocket::local::asynchronous::Client;\n///\n/// # rocket::async_test(async {\n/// let rocket = rocket::build();\n/// let client = Client::tracked(rocket).await.expect(\"valid rocket\");\n/// let response = client.post(\"/\")\n///     .body(\"Hello, world!\")\n///     .dispatch()\n///     .await;\n/// # });\n/// ```\npub struct Client {\n    rocket: Rocket<Orbit>,\n    cookies: RwLock<cookie::CookieJar>,\n    pub(in super) tracked: bool,\n}\n\nimpl Client {\n    pub(crate) async fn _new<P: Phase>(\n        rocket: Rocket<P>,\n        tracked: bool\n    ) -> Result<Client, Error> {\n        let rocket = rocket.local_launch().await?;\n        let cookies = RwLock::new(cookie::CookieJar::new());\n        Ok(Client { rocket, cookies, tracked })\n    }\n\n    // WARNING: This is unstable! Do not use this method outside of Rocket!\n    // This is used by the `Client` doctests.\n    #[doc(hidden)]\n    pub fn _test<T, F>(f: F) -> T\n        where F: FnOnce(&Self, LocalRequest<'_>, LocalResponse<'_>) -> T + Send\n    {\n        crate::async_test(async {\n            let client = Client::debug(crate::build()).await.unwrap();\n            let request = client.get(\"/\");\n            let response = request.clone().dispatch().await;\n            f(&client, request, response)\n        })\n    }\n\n    #[inline(always)]\n    pub(crate) fn _rocket(&self) -> &Rocket<Orbit> {\n        &self.rocket\n    }\n\n    #[inline(always)]\n    pub(crate) fn _with_raw_cookies<F, T>(&self, f: F) -> T\n        where F: FnOnce(&cookie::CookieJar) -> T\n    {\n        f(&*self.cookies.read())\n    }\n\n    #[inline(always)]\n    pub(crate) fn _with_raw_cookies_mut<F, T>(&self, f: F) -> T\n        where F: FnOnce(&mut cookie::CookieJar) -> T\n    {\n        f(&mut *self.cookies.write())\n    }\n\n    #[inline(always)]\n    fn _req<'c, 'u: 'c, U>(&'c self, method: Method, uri: U) -> LocalRequest<'c>\n        where U: TryInto<Origin<'u>> + fmt::Display\n    {\n        LocalRequest::new(self, method, uri)\n    }\n\n    pub(crate) async fn _terminate(self) -> Rocket<Ignite> {\n        let rocket = self.rocket;\n        rocket.shutdown().notify();\n        rocket.fairings.handle_shutdown(&rocket).await;\n        rocket.into_ignite()\n    }\n\n    // Generates the public API methods, which call the private methods above.\n    pub_client_impl!(\"use rocket::local::asynchronous::Client;\" @async await);\n}\n\nimpl std::fmt::Debug for Client {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._rocket().fmt(f)\n    }\n}\n\n#[cfg(test)]\nmod test {\n    #[test]\n    fn test_local_client_impl_send_sync() {\n        fn assert_sync_send<T: Sync + Send>() {}\n        assert_sync_send::<super::Client>();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Asynchronous local dispatching of requests.\n//!\n//! This module contains the `asynchronous` variant of the `local` API: it can\n//! be used with `#[rocket::async_test]` or another asynchronous test harness.\n//! For the blocking variant, see [`blocking`](super::blocking).\n//!\n//! See the [top-level documentation](super) for more usage details.\n\nmod client;\nmod request;\nmod response;\n\npub use client::*;\npub use request::*;\npub use response::*;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse crate::{Request, Data};\nuse crate::http::{Status, Method};\nuse crate::http::uri::Origin;\n\nuse super::{Client, LocalResponse};\n\n/// An `async` local request as returned by [`Client`](super::Client).\n///\n/// For details, see [the top-level documentation](../index.html#localrequest).\n///\n/// ## Example\n///\n/// The following snippet uses the available builder methods to construct and\n/// dispatch a `POST` request to `/` with a JSON body:\n///\n/// ```rust,no_run\n/// use rocket::local::asynchronous::{Client, LocalRequest};\n/// use rocket::http::{ContentType, Cookie};\n///\n/// # rocket::async_test(async {\n/// let client = Client::tracked(rocket::build()).await.expect(\"valid rocket\");\n/// let req = client.post(\"/\")\n///     .header(ContentType::JSON)\n///     .remote(\"127.0.0.1:8000\".parse().unwrap())\n///     .cookie((\"name\", \"value\"))\n///     .body(r#\"{ \"value\": 42 }\"#);\n///\n/// let response = req.dispatch().await;\n/// # });\n/// ```\npub struct LocalRequest<'c> {\n    pub(in super) client: &'c Client,\n    pub(in super) request: Request<'c>,\n    data: Vec<u8>,\n    // The `Origin` on the right is INVALID! It should _not_ be used!\n    uri: Result<Origin<'c>, Origin<'static>>,\n}\n\nimpl<'c> LocalRequest<'c> {\n    pub(crate) fn new<'u: 'c, U>(client: &'c Client, method: Method, uri: U) -> Self\n        where U: TryInto<Origin<'u>> + fmt::Display\n    {\n        // Try to parse `uri` into an `Origin`, storing whether it's good.\n        let uri_str = uri.to_string();\n        let try_origin = uri.try_into().map_err(|_| Origin::path_only(uri_str));\n\n        // Create a request. We'll handle bad URIs later, in `_dispatch`.\n        let origin = try_origin.clone().unwrap_or_else(|bad| bad);\n        let mut request = Request::new(client.rocket(), method, origin);\n\n        // Add any cookies we know about.\n        if client.tracked {\n            client._with_raw_cookies(|jar| {\n                for cookie in jar.iter() {\n                    request.cookies_mut().add_original(cookie.clone());\n                }\n            })\n        }\n\n        LocalRequest { client, request, uri: try_origin, data: vec![] }\n    }\n\n    pub(crate) fn _request(&self) -> &Request<'c> {\n        &self.request\n    }\n\n    pub(crate) fn _request_mut(&mut self) -> &mut Request<'c> {\n        &mut self.request\n    }\n\n    pub(crate) fn _body_mut(&mut self) -> &mut Vec<u8> {\n        &mut self.data\n    }\n\n    // Performs the actual dispatch.\n    async fn _dispatch(mut self) -> LocalResponse<'c> {\n        // First, revalidate the URI, returning an error response (generated\n        // from an error catcher) immediately if it's invalid. If it's valid,\n        // then `request` already contains a correct URI.\n        let rocket = self.client.rocket();\n        if let Err(ref invalid) = self.uri {\n            // The user may have changed the URI in the request in which case we\n            // _shouldn't_ error. Check that now and error only if not.\n            if self.inner().uri() == invalid {\n                error!(\"invalid request URI: {:?}\", invalid.path());\n                return LocalResponse::new(self.request, move |req| {\n                    rocket.handle_error(Status::BadRequest, req)\n                }).await\n            }\n        }\n\n        // Actually dispatch the request.\n        let mut data = Data::local(self.data);\n        let token = rocket.preprocess_request(&mut self.request, &mut data).await;\n        let response = LocalResponse::new(self.request, move |req| {\n            rocket.dispatch(token, req, data)\n        }).await;\n\n        // If the client is tracking cookies, updates the internal cookie jar\n        // with the changes reflected by `response`.\n        if self.client.tracked {\n            self.client._with_raw_cookies_mut(|jar| {\n                let current_time = time::OffsetDateTime::now_utc();\n                for cookie in response.cookies().iter() {\n                    if let Some(expires) = cookie.expires_datetime() {\n                        if expires <= current_time {\n                            jar.force_remove(cookie.name());\n                            continue;\n                        }\n                    }\n\n                    jar.add_original(cookie.clone());\n                }\n            })\n        }\n\n        response\n    }\n\n    pub_request_impl!(\"# use rocket::local::asynchronous::Client;\\n\\\n        use rocket::local::asynchronous::LocalRequest;\" async await);\n}\n\nimpl<'c> Clone for LocalRequest<'c> {\n    fn clone(&self) -> Self {\n        LocalRequest {\n            client: self.client,\n            request: self.request.clone(),\n            data: self.data.clone(),\n            uri: self.uri.clone(),\n        }\n    }\n}\n\nimpl std::fmt::Debug for LocalRequest<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._request().fmt(f)\n    }\n}\n\nimpl<'c> std::ops::Deref for LocalRequest<'c> {\n    type Target = Request<'c>;\n\n    fn deref(&self) -> &Self::Target {\n        self.inner()\n    }\n}\n\nimpl<'c> std::ops::DerefMut for LocalRequest<'c> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.inner_mut()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::io;\nuse std::future::Future;\nuse std::{pin::Pin, task::{Context, Poll}};\n\nuse tokio::io::{AsyncRead, ReadBuf};\n\nuse crate::http::CookieJar;\nuse crate::{Request, Response};\n\n/// An `async` response from a dispatched [`LocalRequest`](super::LocalRequest).\n///\n/// This `LocalResponse` implements [`tokio::io::AsyncRead`]. As such, if\n/// [`into_string()`](LocalResponse::into_string()) and\n/// [`into_bytes()`](LocalResponse::into_bytes()) do not suffice, the response's\n/// body can be read directly:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use std::io;\n///\n/// use rocket::local::asynchronous::Client;\n/// use rocket::tokio::io::AsyncReadExt;\n/// use rocket::http::Status;\n///\n/// #[get(\"/\")]\n/// fn hello_world() -> &'static str {\n///     \"Hello, world!\"\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", routes![hello_world])\n///     #    .configure(rocket::Config::debug_default())\n/// }\n///\n/// # async fn read_body_manually() -> io::Result<()> {\n/// // Dispatch a `GET /` request.\n/// let client = Client::tracked(rocket()).await.expect(\"valid rocket\");\n/// let mut response = client.get(\"/\").dispatch().await;\n///\n/// // Check metadata validity.\n/// assert_eq!(response.status(), Status::Ok);\n/// assert_eq!(response.body().preset_size(), Some(13));\n///\n/// // Read 10 bytes of the body. Note: in reality, we'd use `into_string()`.\n/// let mut buffer = [0; 10];\n/// response.read(&mut buffer).await?;\n/// assert_eq!(buffer, \"Hello, wor\".as_bytes());\n/// # Ok(())\n/// # }\n/// # rocket::async_test(read_body_manually()).expect(\"read okay\");\n/// ```\n///\n/// For more, see [the top-level documentation](../index.html#localresponse).\npub struct LocalResponse<'c> {\n    _request: Box<Request<'c>>,\n    response: Response<'c>,\n    cookies: CookieJar<'c>,\n}\n\nimpl<'c> LocalResponse<'c> {\n    pub(crate) fn new<F, O>(req: Request<'c>, f: F) -> impl Future<Output = LocalResponse<'c>>\n        where F: FnOnce(&'c Request<'c>) -> O + Send,\n              O: Future<Output = Response<'c>> + Send\n    {\n        // `LocalResponse` is a self-referential structure. In particular,\n        // `inner` can refer to `_request` and its contents. As such, we must\n        //   1) Ensure `Request` has a stable address.\n        //\n        //      This is done by `Box`ing the `Request`, using only the stable\n        //      address thereafter.\n        //\n        //   2) Ensure no refs to `Request` or its contents leak with a lifetime\n        //      extending beyond that of `&self`.\n        //\n        //      We have no methods that return an `&Request`. However, we must\n        //      also ensure that `Response` doesn't leak any such references. To\n        //      do so, we don't expose the `Response` directly in any way;\n        //      otherwise, methods like `.headers()` could, in conjunction with\n        //      particular crafted `Responder`s, potentially be used to obtain a\n        //      reference to contents of `Request`. All methods, instead, return\n        //      references bounded by `self`. This is easily verified by noting\n        //      that 1) `LocalResponse` fields are private, and 2) all `impl`s\n        //      of `LocalResponse` aside from this method abstract the lifetime\n        //      away as `'_`, ensuring it is not used for any output value.\n        let boxed_req = Box::new(req);\n        let request: &'c Request<'c> = unsafe { &*(&*boxed_req as *const _) };\n\n        async move {\n            let response: Response<'c> = f(request).await;\n            let mut cookies = CookieJar::new(request.rocket().config());\n            for cookie in response.cookies() {\n                cookies.add_original(cookie.into_owned());\n            }\n\n            LocalResponse { cookies, _request: boxed_req, response, }\n        }\n    }\n}\n\nimpl LocalResponse<'_> {\n    pub(crate) fn _response(&self) -> &Response<'_> {\n        &self.response\n    }\n\n    pub(crate) fn _cookies(&self) -> &CookieJar<'_> {\n        &self.cookies\n    }\n\n    pub(crate) async fn _into_string(mut self) -> io::Result<String> {\n        self.response.body_mut().to_string().await\n    }\n\n    pub(crate) async fn _into_bytes(mut self) -> io::Result<Vec<u8>> {\n        self.response.body_mut().to_bytes().await\n    }\n\n    #[cfg(feature = \"json\")]\n    async fn _into_json<T: Send + 'static>(self) -> Option<T>\n        where T: serde::de::DeserializeOwned\n    {\n        self.blocking_read(|r| serde_json::from_reader(r)).await?.ok()\n    }\n\n    #[cfg(feature = \"msgpack\")]\n    async fn _into_msgpack<T: Send + 'static>(self) -> Option<T>\n        where T: serde::de::DeserializeOwned\n    {\n        self.blocking_read(|r| rmp_serde::from_read(r)).await?.ok()\n    }\n\n    #[cfg(any(feature = \"json\", feature = \"msgpack\"))]\n    async fn blocking_read<T, F>(mut self, f: F) -> Option<T>\n        where T: Send + 'static,\n              F: FnOnce(&mut dyn io::Read) -> T + Send + 'static\n    {\n        use tokio::sync::mpsc;\n        use tokio::io::AsyncReadExt;\n\n        struct ChanReader {\n            last: Option<io::Cursor<Vec<u8>>>,\n            rx: mpsc::Receiver<io::Result<Vec<u8>>>,\n        }\n\n        impl std::io::Read for ChanReader {\n            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n                loop {\n                    if let Some(ref mut cursor) = self.last {\n                        if cursor.position() < cursor.get_ref().len() as u64 {\n                            return std::io::Read::read(cursor, buf);\n                        }\n                    }\n\n                    if let Some(buf) = self.rx.blocking_recv() {\n                        self.last = Some(io::Cursor::new(buf?));\n                    } else {\n                        return Ok(0);\n                    }\n                }\n            }\n        }\n\n        let (tx, rx) = mpsc::channel(2);\n        let reader = tokio::task::spawn_blocking(move || {\n            let mut reader = ChanReader { last: None, rx };\n            f(&mut reader)\n        });\n\n        loop {\n            // TODO: Try to fill as much as the buffer before send it off?\n            let mut buf = Vec::with_capacity(1024);\n            match self.read_buf(&mut buf).await {\n                Ok(n) if n == 0 => break,\n                Ok(_) => tx.send(Ok(buf)).await.ok()?,\n                Err(e) => {\n                    tx.send(Err(e)).await.ok()?;\n                    break;\n                }\n            }\n        }\n\n        // NOTE: We _must_ drop tx now to prevent a deadlock!\n        drop(tx);\n\n        reader.await.ok()\n    }\n\n    // Generates the public API methods, which call the private methods above.\n    pub_response_impl!(\"# use rocket::local::asynchronous::Client;\\n\\\n        use rocket::local::asynchronous::LocalResponse;\" async await);\n}\n\nimpl AsyncRead for LocalResponse<'_> {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        Pin::new(self.response.body_mut()).poll_read(cx, buf)\n    }\n}\n\nimpl std::fmt::Debug for LocalResponse<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._response().fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\nuse std::cell::RefCell;\n\nuse crate::{Rocket, Phase, Orbit, Ignite, Error};\nuse crate::local::{asynchronous, blocking::{LocalRequest, LocalResponse}};\nuse crate::http::{Method, uri::Origin};\n\n/// A `blocking` client to construct and dispatch local requests.\n///\n/// For details, see [the top-level documentation](../index.html#client). For\n/// the `async` version, see [`asynchronous::Client`].\n///\n/// ## Example\n///\n/// The following snippet creates a `Client` from a `Rocket` instance and\n/// dispatches a local `POST /` request with a body of `Hello, world!`.\n///\n/// ```rust,no_run\n/// use rocket::local::blocking::Client;\n///\n/// let rocket = rocket::build();\n/// let client = Client::tracked(rocket).expect(\"valid rocket\");\n/// let response = client.post(\"/\")\n///     .body(\"Hello, world!\")\n///     .dispatch();\n/// ```\npub struct Client {\n    pub(crate) inner: Option<asynchronous::Client>,\n    runtime: RefCell<tokio::runtime::Runtime>,\n}\n\nimpl Client {\n    fn _new<P: Phase>(rocket: Rocket<P>, tracked: bool) -> Result<Client, Error> {\n        let runtime = tokio::runtime::Builder::new_multi_thread()\n            .thread_name(\"rocket-local-client-worker-thread\")\n            .worker_threads(1)\n            .enable_all()\n            .build()\n            .expect(\"create tokio runtime\");\n\n        // Initialize the Rocket instance\n        let inner = Some(runtime.block_on(asynchronous::Client::_new(rocket, tracked))?);\n        Ok(Self { inner, runtime: RefCell::new(runtime) })\n    }\n\n    // WARNING: This is unstable! Do not use this method outside of Rocket!\n    #[doc(hidden)]\n    pub fn _test<T, F>(f: F) -> T\n        where F: FnOnce(&Self, LocalRequest<'_>, LocalResponse<'_>) -> T + Send\n    {\n        let client = Client::debug(crate::build()).unwrap();\n        let request = client.get(\"/\");\n        let response = request.clone().dispatch();\n        f(&client, request, response)\n    }\n\n    #[inline(always)]\n    pub(crate) fn inner(&self) -> &asynchronous::Client {\n        self.inner.as_ref().expect(\"internal invariant broken: self.inner is Some\")\n    }\n\n    #[inline(always)]\n    pub(crate) fn block_on<F, R>(&self, fut: F) -> R\n        where F: std::future::Future<Output=R>,\n    {\n        self.runtime.borrow_mut().block_on(fut)\n    }\n\n    #[inline(always)]\n    fn _rocket(&self) -> &Rocket<Orbit> {\n        self.inner()._rocket()\n    }\n\n    #[inline(always)]\n    pub(crate) fn _with_raw_cookies<F, T>(&self, f: F) -> T\n        where F: FnOnce(&crate::http::private::cookie::CookieJar) -> T\n    {\n        self.inner()._with_raw_cookies(f)\n    }\n\n    pub(crate) fn _terminate(mut self) -> Rocket<Ignite> {\n        let runtime = tokio::runtime::Builder::new_current_thread().build().unwrap();\n        let runtime = self.runtime.replace(runtime);\n        let inner = self.inner.take().expect(\"invariant broken: self.inner is Some\");\n        let rocket = runtime.block_on(inner._terminate());\n        runtime.shutdown_timeout(std::time::Duration::from_secs(1));\n        rocket\n    }\n\n    #[inline(always)]\n    fn _req<'c, 'u: 'c, U>(&'c self, method: Method, uri: U) -> LocalRequest<'c>\n        where U: TryInto<Origin<'u>> + fmt::Display\n    {\n        LocalRequest::new(self, method, uri)\n    }\n\n    // Generates the public API methods, which call the private methods above.\n    pub_client_impl!(\"use rocket::local::blocking::Client;\");\n}\n\nimpl std::fmt::Debug for Client {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._rocket().fmt(f)\n    }\n}\n\nimpl Drop for Client {\n    fn drop(&mut self) {\n        if let Some(client) = self.inner.take() {\n            self.block_on(async { drop(client) });\n        }\n    }\n}\n\n#[cfg(doctest)]\nmod doctest {\n    /// ```compile_fail\n    /// use rocket::local::blocking::Client;\n    ///\n    /// fn not_sync<T: Sync>() {};\n    /// not_sync::<Client>();\n    /// ```\n    #[allow(dead_code)]\n    fn test_not_sync() {}\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Blocking local dispatching of requests.\n//!\n//! This module contains the `blocking` variant of the `local` API: it can be\n//! used in Rust's synchronous `#[test]` harness. This is accomplished by\n//! starting and running an internal asynchronous Runtime as needed. For the\n//! asynchronous variant, see [`asynchronous`](super::asynchronous).\n//!\n//! See the [top-level documentation](super) for more usage details.\n\nmod client;\nmod request;\nmod response;\n\npub use self::client::*;\npub use self::request::*;\npub use self::response::*;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt;\n\nuse crate::{Request, http::Method, local::asynchronous};\nuse crate::http::uri::Origin;\n\nuse super::{Client, LocalResponse};\n\n/// A `blocking` local request as returned by [`Client`](super::Client).\n///\n/// For details, see [the top-level documentation](../index.html#localrequest).\n///\n/// ## Example\n///\n/// The following snippet uses the available builder methods to construct and\n/// dispatch a `POST` request to `/` with a JSON body:\n///\n/// ```rust,no_run\n/// use rocket::local::blocking::{Client, LocalRequest};\n/// use rocket::http::{ContentType, Cookie};\n///\n/// let client = Client::tracked(rocket::build()).expect(\"valid rocket\");\n/// let req = client.post(\"/\")\n///     .header(ContentType::JSON)\n///     .remote(\"127.0.0.1:8000\".parse().unwrap())\n///     .cookie((\"name\", \"value\"))\n///     .body(r#\"{ \"value\": 42 }\"#);\n///\n/// let response = req.dispatch();\n/// ```\n#[derive(Clone)]\npub struct LocalRequest<'c> {\n    inner: asynchronous::LocalRequest<'c>,\n    client: &'c Client,\n}\n\nimpl<'c> LocalRequest<'c> {\n    #[inline]\n    pub(crate) fn new<'u: 'c, U>(client: &'c Client, method: Method, uri: U) -> Self\n        where U: TryInto<Origin<'u>> + fmt::Display\n    {\n        let inner = asynchronous::LocalRequest::new(client.inner(), method, uri);\n        Self { inner, client }\n    }\n\n    #[inline]\n    fn _request(&self) -> &Request<'c> {\n        self.inner._request()\n    }\n\n    #[inline]\n    fn _request_mut(&mut self) -> &mut Request<'c> {\n        self.inner._request_mut()\n    }\n\n    fn _body_mut(&mut self) -> &mut Vec<u8> {\n        self.inner._body_mut()\n    }\n\n    fn _dispatch(self) -> LocalResponse<'c> {\n        let inner = self.client.block_on(self.inner.dispatch());\n        LocalResponse { inner, client: self.client }\n    }\n\n    pub_request_impl!(\"# use rocket::local::blocking::Client;\\n\\\n        use rocket::local::blocking::LocalRequest;\");\n}\n\nimpl std::fmt::Debug for LocalRequest<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._request().fmt(f)\n    }\n}\n\nimpl<'c> std::ops::Deref for LocalRequest<'c> {\n    type Target = Request<'c>;\n\n    fn deref(&self) -> &Self::Target {\n        self.inner()\n    }\n}\n\nimpl<'c> std::ops::DerefMut for LocalRequest<'c> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        self.inner_mut()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::io;\nuse tokio::io::AsyncReadExt;\n\nuse crate::{Response, local::asynchronous, http::CookieJar};\n\nuse super::Client;\n\n/// A `blocking` response from a dispatched [`LocalRequest`](super::LocalRequest).\n///\n/// This `LocalResponse` implements [`io::Read`]. As such, if\n/// [`into_string()`](LocalResponse::into_string()) and\n/// [`into_bytes()`](LocalResponse::into_bytes()) do not suffice, the response's\n/// body can be read directly:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// use std::io::{self, Read};\n///\n/// use rocket::local::blocking::Client;\n/// use rocket::http::Status;\n///\n/// #[get(\"/\")]\n/// fn hello_world() -> &'static str {\n///     \"Hello, world!\"\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", routes![hello_world])\n///     #    .configure(rocket::Config::debug_default())\n/// }\n///\n/// # fn read_body_manually() -> io::Result<()> {\n/// // Dispatch a `GET /` request.\n/// let client = Client::tracked(rocket()).expect(\"valid rocket\");\n/// let mut response = client.get(\"/\").dispatch();\n///\n/// // Check metadata validity.\n/// assert_eq!(response.status(), Status::Ok);\n/// assert_eq!(response.body().preset_size(), Some(13));\n///\n/// // Read 10 bytes of the body. Note: in reality, we'd use `into_string()`.\n/// let mut buffer = [0; 10];\n/// response.read(&mut buffer)?;\n/// assert_eq!(buffer, \"Hello, wor\".as_bytes());\n/// # Ok(())\n/// # }\n/// # read_body_manually().expect(\"read okay\");\n/// ```\n///\n/// For more, see [the top-level documentation](../index.html#localresponse).\npub struct LocalResponse<'c> {\n    pub(in super) inner: asynchronous::LocalResponse<'c>,\n    pub(in super) client: &'c Client,\n}\n\nimpl LocalResponse<'_> {\n    fn _response(&self) -> &Response<'_> {\n        &self.inner._response()\n    }\n\n    pub(crate) fn _cookies(&self) -> &CookieJar<'_> {\n        self.inner._cookies()\n    }\n\n    fn _into_string(self) -> io::Result<String> {\n        self.client.block_on(self.inner._into_string())\n    }\n\n    fn _into_bytes(self) -> io::Result<Vec<u8>> {\n        self.client.block_on(self.inner._into_bytes())\n    }\n\n    #[cfg(feature = \"json\")]\n    fn _into_json<T: Send + 'static>(self) -> Option<T>\n        where T: serde::de::DeserializeOwned\n    {\n        serde_json::from_reader(self).ok()\n    }\n\n    #[cfg(feature = \"msgpack\")]\n    fn _into_msgpack<T: Send + 'static>(self) -> Option<T>\n        where T: serde::de::DeserializeOwned\n    {\n        rmp_serde::from_read(self).ok()\n    }\n\n    // Generates the public API methods, which call the private methods above.\n    pub_response_impl!(\"# use rocket::local::blocking::Client;\\n\\\n        use rocket::local::blocking::LocalResponse;\");\n}\n\nimpl io::Read for LocalResponse<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        self.client.block_on(self.inner.read(buf))\n    }\n}\n\nimpl std::fmt::Debug for LocalResponse<'_> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self._response().fmt(f)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use futures::stream::{Stream, StreamExt};\n\nuse crate::request::Request;\nuse crate::response::{self, Response, Responder};\nuse crate::http::ContentType;\nuse crate::response::stream::ReaderStream;\n\n/// A potentially infinite stream of bytes: any `T: AsRef<[u8]>`.\n///\n/// A `ByteStream` can be constructed from any [`Stream`] of items of type `T`\n/// where `T: AsRef<[u8]>`. This includes `Vec<u8>`, `&[u8]`, `&str`, `&RawStr`,\n/// and more. The stream can be constructed directly, via `ByteStream(..)` or\n/// [`ByteStream::from()`], or through generator syntax via [`ByteStream!`].\n///\n/// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n///\n/// # Responder\n///\n/// `ByteStream` is a (potentially infinite) responder. The response\n/// `Content-Type` is set to [`Binary`](ContentType::Binary). The body is\n/// [unsized](crate::response::Body#unsized), and values are sent as soon as\n/// they are yielded by the internal iterator.\n///\n/// # Example\n///\n/// Use [`ByteStream!`] to yield 10 3-byte vectors, one every second, of the\n/// form `vec![i, i + 1, i + 2]` for `i` from `0` to `10` exclusive:\n///\n/// ```rust\n/// # use rocket::*;\n/// use rocket::response::stream::ByteStream;\n/// use rocket::futures::stream::{repeat, StreamExt};\n/// use rocket::tokio::time::{self, Duration};\n///\n/// #[get(\"/bytes\")]\n/// fn bytes() -> ByteStream![&'static [u8]] {\n///     ByteStream(repeat(&[1, 2, 3][..]))\n/// }\n///\n/// #[get(\"/byte/stream\")]\n/// fn stream() -> ByteStream![Vec<u8>] {\n///     ByteStream! {\n///         let mut interval = time::interval(Duration::from_secs(1));\n///         for i in 0..10u8 {\n///             yield vec![i, i + 1, i + 2];\n///             interval.tick().await;\n///         }\n///     }\n/// }\n/// ```\n///\n/// The syntax of `ByteStream!` as an expression is identical to that of\n/// [`stream!`](crate::response::stream::stream).\n#[derive(Debug, Clone)]\npub struct ByteStream<S>(pub S);\n\nimpl<S> From<S> for ByteStream<S> {\n    /// Creates a `ByteStream` from any `S: Stream`.\n    fn from(stream: S) -> Self {\n        ByteStream(stream)\n    }\n}\n\nimpl<'r, S: Stream> Responder<'r, 'r> for ByteStream<S>\n    where S: Send + 'r, S::Item: AsRef<[u8]> + Send + Unpin + 'r\n{\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n        Response::build()\n            .header(ContentType::Binary)\n            .streamed_body(ReaderStream::from(self.0.map(std::io::Cursor::new)))\n            .ok()\n    }\n}\n\ncrate::export! {\n    /// Type and stream expression macro for [`struct@ByteStream`].\n    ///\n    /// See [`stream!`](crate::response::stream::stream) for the syntax\n    /// supported by this macro.\n    ///\n    /// See [`struct@ByteStream`] and the [module level\n    /// docs](crate::response::stream#typed-streams) for usage details.\n    macro_rules! ByteStream {\n        ($($s:tt)*) => ($crate::_typed_stream!(ByteStream, $($s)*));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Potentially infinite async [`Stream`] response types.\n//!\n//! A [`Stream<Item = T>`] is the async analog of an `Iterator<Item = T>`: it\n//! generates a sequence of values asynchronously, otherwise known as an async\n//! _generator_. Types in this module allow for returning responses that are\n//! streams.\n//!\n//! [`Stream<Item = T>`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n//! [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n//!\n//! # Raw Streams\n//!\n//! Rust does not yet natively support syntax for creating arbitrary generators,\n//! and as such, for creating streams. To ameliorate this, Rocket exports\n//! [`stream!`], which retrofit generator syntax, allowing raw `impl Stream`s to\n//! be defined using `yield` and `for await` syntax:\n//!\n//! ```rust\n//! use rocket::futures::stream::Stream;\n//! use rocket::response::stream::stream;\n//!\n//! fn make_stream() -> impl Stream<Item = u8> {\n//!     stream! {\n//!         for i in 0..3 {\n//!             yield i;\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! See [`stream!`] for full usage details.\n//!\n//! # Typed Streams\n//!\n//! A raw stream is not a `Responder`, so it cannot be directly returned from a\n//! route handler. Instead, one of three _typed_ streams may be used. Each typed\n//! stream places type bounds on the `Item` of the stream, allowing for\n//! `Responder` implementation on the stream itself.\n//!\n//! Each typed stream exists both as a type and as a macro. They are:\n//!\n//!   * [`struct@ReaderStream`] ([`ReaderStream!`]) - streams of `T: AsyncRead`\n//!   * [`struct@ByteStream`] ([`ByteStream!`]) - streams of `T: AsRef<[u8]>`\n//!   * [`struct@TextStream`] ([`TextStream!`]) - streams of `T: AsRef<str>`\n//!   * [`struct@EventStream`] ([`EventStream!`]) - Server-Sent [`Event`] stream\n//!\n//! Each type implements `Responder`; each macro can be invoked to generate a\n//! typed stream, exactly like [`stream!`] above. Additionally, each macro is\n//! also a _type_ macro, expanding to a wrapped `impl Stream<Item = $T>`, where\n//! `$T` is the input to the macro.\n//!\n//! As a concrete example, the route below produces an infinite series of\n//! `\"hello\"`s, one per second:\n//!\n//! ```rust\n//! # use rocket::get;\n//! use rocket::tokio::time::{self, Duration};\n//! use rocket::response::stream::TextStream;\n//!\n//! /// Produce an infinite series of `\"hello\"`s, one per second.\n//! #[get(\"/infinite-hellos\")]\n//! fn hello() -> TextStream![&'static str] {\n//!     TextStream! {\n//!         let mut interval = time::interval(Duration::from_secs(1));\n//!         loop {\n//!             yield \"hello\";\n//!             interval.tick().await;\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! The `TextStream![&'static str]` invocation expands to:\n//!\n//! ```rust\n//! # use rocket::response::stream::TextStream;\n//! # use rocket::futures::stream::Stream;\n//! # use rocket::response::stream::stream;\n//! # fn f() ->\n//! TextStream<impl Stream<Item = &'static str>>\n//! # { TextStream::from(stream! { yield \"hi\" }) }\n//! ```\n//!\n//! While the inner `TextStream! { .. }` invocation expands to:\n//!\n//! ```rust\n//! # use rocket::response::stream::{TextStream, stream};\n//! TextStream::from(stream! { /* .. */ })\n//! # ;\n//! ```\n//!\n//! The expansions are identical for `ReaderStream` and `ByteStream`, with\n//! `TextStream` replaced with `ReaderStream` and `ByteStream`, respectively.\n//!\n//! ## Borrowing\n//!\n//! A stream can _yield_ borrowed values with no extra effort:\n//!\n//! ```rust\n//! # use rocket::get;\n//! use rocket::State;\n//! use rocket::response::stream::TextStream;\n//!\n//! /// Produce a single string borrowed from the request.\n//! #[get(\"/infinite-hellos\")]\n//! fn hello(string: &State<String>) -> TextStream![&str] {\n//!     TextStream! {\n//!         yield string.as_str();\n//!     }\n//! }\n//! ```\n//!\n//! If the stream _contains_ a borrowed value or uses one internally, Rust\n//! requires this fact be explicit with a lifetime annotation:\n//!\n//! ```rust\n//! # use rocket::get;\n//! use rocket::State;\n//! use rocket::response::stream::TextStream;\n//!\n//! #[get(\"/\")]\n//! fn borrow1(ctxt: &State<bool>) -> TextStream![&'static str + '_] {\n//!     TextStream! {\n//!         // By using `ctxt` in the stream, the borrow is moved into it. Thus,\n//!         // the stream object contains a borrow, prompting the '_ annotation.\n//!         if *ctxt.inner() {\n//!             yield \"hello\";\n//!         }\n//!     }\n//! }\n//!\n//! // Just as before but yielding an owned yield value.\n//! #[get(\"/\")]\n//! fn borrow2(ctxt: &State<bool>) -> TextStream![String + '_] {\n//!     TextStream! {\n//!         if *ctxt.inner() {\n//!             yield \"hello\".to_string();\n//!         }\n//!     }\n//! }\n//!\n//! // As before but _also_ return a borrowed value. Without it, Rust gives:\n//! // - lifetime `'r` is missing in item created through this procedural macro\n//! #[get(\"/\")]\n//! fn borrow3<'r>(ctxt: &'r State<bool>, s: &'r State<String>) -> TextStream![&'r str + 'r] {\n//!     TextStream! {\n//!         if *ctxt.inner() {\n//!             yield s.as_str();\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! # Graceful Shutdown\n//!\n//! Infinite responders, like the one defined in `hello` above, will prolong\n//! shutdown initiated via [`Shutdown::notify()`](crate::Shutdown::notify()) for\n//! the defined grace period. After the grace period has elapsed, Rocket will\n//! abruptly terminate the responder.\n//!\n//! To avoid abrupt termination, graceful shutdown can be detected via the\n//! [`Shutdown`](crate::Shutdown) future, allowing the infinite responder to\n//! gracefully shut itself down. The following example modifies the previous\n//! `hello` with shutdown detection:\n//!\n//! ```rust\n//! # use rocket::get;\n//! use rocket::Shutdown;\n//! use rocket::response::stream::TextStream;\n//! use rocket::tokio::select;\n//! use rocket::tokio::time::{self, Duration};\n//!\n//! /// Produce an infinite series of `\"hello\"`s, 1/second, until shutdown.\n//! #[get(\"/infinite-hellos\")]\n//! fn hello(mut shutdown: Shutdown) -> TextStream![&'static str] {\n//!     TextStream! {\n//!         let mut interval = time::interval(Duration::from_secs(1));\n//!         loop {\n//!             select! {\n//!                 _ = interval.tick() => yield \"hello\",\n//!                 _ = &mut shutdown => {\n//!                     yield \"goodbye\";\n//!                     break;\n//!                 }\n//!             };\n//!         }\n//!     }\n//! }\n//! ```\n\nmod reader;\nmod bytes;\nmod text;\nmod one;\nmod sse;\nmod raw_sse;\n\npub(crate) use self::raw_sse::*;\n\npub use self::one::One;\npub use self::text::TextStream;\npub use self::bytes::ByteStream;\npub use self::reader::ReaderStream;\npub use self::sse::{Event, EventStream};\n\ncrate::export! {\n    /// Retrofitted support for [`Stream`]s with `yield`, `for await` syntax.\n    ///\n    /// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n    ///\n    /// This macro takes any series of statements and expands them into an\n    /// expression of type `impl Stream<Item = T>`, a stream that `yield`s\n    /// elements of type `T`. It supports any Rust statement syntax with the\n    /// following extensions:\n    ///\n    ///   * `yield expr`\n    ///\n    ///      Yields the result of evaluating `expr` to the caller (the stream\n    ///      consumer). `expr` must be of type `T`.\n    ///\n    ///   * `for await x in stream { .. }`\n    ///\n    ///      `await`s the next element in `stream`, binds it to `x`, and\n    ///      executes the block with the binding. `stream` must implement\n    ///      `Stream<Item = T>`; the type of `x` is `T`.\n    ///\n    ///   * `?` short-circuits stream termination on `Err`\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use rocket::response::stream::stream;\n    /// use rocket::futures::stream::Stream;\n    ///\n    /// fn f(stream: impl Stream<Item = u8>) -> impl Stream<Item = String> {\n    ///     stream! {\n    ///         for s in &[\"hi\", \"there\"]{\n    ///             yield s.to_string();\n    ///         }\n    ///\n    ///         for await n in stream {\n    ///             yield format!(\"n: {}\", n);\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// # rocket::async_test(async {\n    /// use rocket::futures::stream::{self, StreamExt};\n    ///\n    /// let stream = f(stream::iter(vec![3, 7, 11]));\n    /// let strings: Vec<_> = stream.collect().await;\n    /// assert_eq!(strings, [\"hi\", \"there\", \"n: 3\", \"n: 7\", \"n: 11\"]);\n    /// # });\n    /// ```\n    ///\n    /// Using `?` on an `Err` short-circuits stream termination:\n    ///\n    /// ```rust\n    /// use std::io;\n    ///\n    /// use rocket::response::stream::stream;\n    /// use rocket::futures::stream::Stream;\n    ///\n    /// fn g<S>(stream: S) -> impl Stream<Item = io::Result<u8>>\n    ///     where S: Stream<Item = io::Result<&'static str>>\n    /// {\n    ///     stream! {\n    ///         for await s in stream {\n    ///             let num = s?.parse();\n    ///             let num = num.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n    ///             yield Ok(num);\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// # rocket::async_test(async {\n    /// use rocket::futures::stream::{self, StreamExt};\n    ///\n    /// let e = io::Error::last_os_error();\n    /// let stream = g(stream::iter(vec![Ok(\"3\"), Ok(\"four\"), Err(e), Ok(\"2\")]));\n    /// let results: Vec<_> = stream.collect().await;\n    /// assert!(matches!(results.as_slice(), &[Ok(3), Err(_)]));\n    /// # });\n    /// ```\n    macro_rules! stream {\n        ($($t:tt)*) => ($crate::async_stream::stream!($($t)*));\n    }\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! _typed_stream {\n    ($S:ident, $($t:tt)*) => (\n        $crate::__typed_stream! {\n            $crate::response::stream::$S,\n            $crate::response::stream::stream,\n            $crate::futures::stream::Stream,\n            $($t)*\n        }\n    )\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::pin::Pin;\nuse std::task::{Context, Poll};\n\nuse futures::stream::Stream;\n\n/// A stream that yields exactly one value.\n///\n/// A `ReaderStream` which wraps this type and yields one `AsyncRead` is\n/// returned by [`ReaderStream::one()`]. A `One` can also be constructed via\n/// [`One::from()`].\n///\n/// [`ReaderStream::one()`]: crate::response::stream::ReaderStream::one()\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::response::stream::One;\n/// use rocket::futures::stream::StreamExt;\n///\n/// # rocket::async_test(async {\n/// let mut stream = One::from(\"hello!\");\n/// let values: Vec<_> = stream.collect().await;\n/// assert_eq!(values, [\"hello!\"]);\n/// # });\n/// ```\npub struct One<T: Unpin>(Option<T>);\n\n/// Returns a `One` stream that will yield `value` exactly once.\n///\n/// # Example\n///\n/// ```rust\n/// use rocket::response::stream::One;\n///\n/// let mut stream = One::from(\"hello!\");\n/// ```\nimpl<T: Unpin> From<T> for One<T> {\n    fn from(value: T) -> Self {\n        One(Some(value))\n    }\n}\n\nimpl<T: Unpin> Stream for One<T> {\n    type Item = T;\n\n    fn poll_next(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n    ) -> Poll<Option<Self::Item>> {\n        Poll::Ready(self.0.take())\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::borrow::Cow;\nuse std::io::{self, Cursor};\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\nuse std::cmp::min;\n\nuse tokio::io::{AsyncRead, AsyncReadExt, ReadBuf, Take};\n\n/// Low-level serialization of fields in text/event-stream format.\n///\n/// Based on https://html.spec.whatwg.org/multipage/server-sent-events.html,\n/// reproduced here for quick reference. Retrieved 2021-04-17.\n///\n/// ```text\n/// stream        = [ bom ] *event\n/// event         = *( comment / field ) end-of-line\n/// comment       = colon *any-char end-of-line\n/// field         = 1*name-char [ colon [ space ] *any-char ] end-of-line\n/// end-of-line   = ( cr lf / cr / lf )\n///\n/// ; characters\n/// lf            = %x000A ; U+000A LINE FEED (LF)\n/// cr            = %x000D ; U+000D CARRIAGE RETURN (CR)\n/// space         = %x0020 ; U+0020 SPACE\n/// colon         = %x003A ; U+003A COLON (:)\n/// bom           = %xFEFF ; U+FEFF BYTE ORDER MARK\n/// name-char     = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF\n///                 ; a scalar value other than:\n///                 ; U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)\n/// any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF\n///                 ; a scalar value other than:\n///                 ; U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)/\n/// ```\n///\n/// Notice that Multiple encodings are possible for the same data, especially in\n/// the choice of newline. This implementation always uses only \"\\n\" (LF).\n///\n/// Serializes (via `AsyncRead`) as a series of \"${name}:${value}\\n\" events.\n/// Either or both `name` and `value` may be empty. When the name is empty, this\n/// is a comment. Otherwise, this is a field.\n#[derive(Debug)]\npub struct RawLinedEvent {\n    name: Cursor<Cow<'static, [u8]>>,\n    value: Take<Cursor<Cow<'static, [u8]>>>,\n    state: State,\n}\n\n/// Converts a `Cow<str>` to a `Cow<[u8]>`.\nfn farm(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    match cow {\n        Cow::Borrowed(slice) => Cow::Borrowed(slice.as_bytes()),\n        Cow::Owned(vec) => Cow::Owned(vec.into_bytes())\n    }\n}\n\n/// Farms `cow`, replacing `\\r`, `\\n`, and `:` with ` ` in the process.\n///\n/// This converts any string into a valid event `name`.\nfn farm_name(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    let mut i = 0;\n    let mut cow = farm(cow);\n    while i < cow.len() {\n        if let Some(k) = memchr::memchr3(b'\\r', b'\\n', b':', &cow[i..]) {\n            cow.to_mut()[i + k] = b' ';\n            // This can't overflow as i + k + 1 <= len, since we found a char.\n            i += k + 1;\n        } else {\n            break;\n        }\n    }\n\n    cow\n}\n\n/// Farms `cow`, replacing `\\r` and `\\n` with ` ` in the process.\n///\n/// This converts any string into a valid event `value`.\nfn farm_value(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    let mut i = 0;\n    let mut cow = farm(cow);\n    while i < cow.len() {\n        if let Some(k) = memchr::memchr2(b'\\r', b'\\n', &cow[i..]) {\n            cow.to_mut()[i + k] = b' ';\n            // This can't overflow as i + k + 1 <= len, since we found a char.\n            i += k + 1;\n        } else {\n            break;\n        }\n    }\n\n    cow\n}\n\nimpl RawLinedEvent {\n    /// Create a `RawLinedEvent` from a valid, prefarmed `name` and `value`.\n    fn prefarmed(name: Cow<'static, [u8]>, value: Cow<'static, [u8]>) -> RawLinedEvent {\n        let name = Cursor::new(name);\n        let mut value = Cursor::new(value).take(0);\n        advance(&mut value);\n        RawLinedEvent { name, value, state: State::Name }\n    }\n\n    /// Create a `RawLinedEvent` from potentially invalid `name` and `value`\n    /// where `value` is not allowed to be multiple lines.\n    ///\n    /// Characters `\\n`, `\\r`, and ':' in `name` and characters `\\r` \\`n` in\n    /// `value` `are replaced with a space ` `.\n    pub fn one<N, V>(name: N, value: V) -> RawLinedEvent\n        where N: Into<Cow<'static, str>>, V: Into<Cow<'static, str>>\n    {\n        RawLinedEvent::prefarmed(farm_name(name.into()), farm_value(value.into()))\n    }\n\n    /// Create a `RawLinedEvent` from potentially invalid `name` and `value`\n    /// where `value` is allowed to be multiple lines.\n    ///\n    /// Characters `\\n`, `\\r`, and ':' in `name` are replaced with a space ` `.\n    /// `value` is allowed to contain any character. New lines (`\\r\\n` or `\\n`)\n    /// and carriage returns `\\r` result in a new event being emitted.\n    pub fn many<N, V>(name: N, value: V) -> RawLinedEvent\n        where N: Into<Cow<'static, str>>, V: Into<Cow<'static, str>>\n    {\n        RawLinedEvent::prefarmed(farm_name(name.into()), farm(value.into()))\n    }\n\n    /// Create a `RawLinedEvent` from known value `value`. The value is emitted\n    /// directly with _no_ name and suffixed with a `\\n`.\n    pub fn raw<V: Into<Cow<'static, str>>>(value: V) -> RawLinedEvent {\n        let value = value.into();\n        let len = value.len();\n        RawLinedEvent {\n            name: Cursor::new(Cow::Borrowed(&[])),\n            value: Cursor::new(farm(value)).take(len as u64),\n            state: State::Value\n        }\n    }\n}\n\n/// The `AsyncRead`er state.\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum State {\n    Name,\n    Colon,\n    Value,\n    NewLine,\n    Done\n}\n\n/// Find the next new-line (`\\n` or `\\r`) character in `buf` beginning at the\n/// current cursor position and sets the limit to be at that position.\nfn advance<T: AsRef<[u8]> + Unpin>(buf: &mut Take<Cursor<T>>) {\n    // Technically, the position need not be <= len, so we right it.\n    let pos = min(buf.get_ref().get_ref().as_ref().len() as u64, buf.get_ref().position());\n    let inner = buf.get_ref().get_ref().as_ref();\n    let next = memchr::memchr2(b'\\n', b'\\r', &inner[(pos as usize)..])\n        .map(|i| pos + i as u64)\n        .unwrap_or_else(|| inner.len() as u64);\n\n    let limit = next - pos;\n    buf.set_limit(limit);\n}\n\n/// If the cursor in `buf` is currently at an `\\r`, `\\r\\n` or `\\n`, sets the\n/// cursor position to be _after_ the characters.\nfn skip<T: AsRef<[u8]> + Unpin>(buf: &mut Take<Cursor<T>>) {\n    let pos = min(buf.get_ref().get_ref().as_ref().len() as u64, buf.get_ref().position());\n    match buf.get_ref().get_ref().as_ref().get(pos as usize) {\n        // This cannot overflow as clearly `buf.len() >= pos + 1`.\n        Some(b'\\n') => buf.get_mut().set_position(pos + 1),\n        Some(b'\\r') => {\n            let next = (pos as usize).saturating_add(1);\n            if buf.get_ref().get_ref().as_ref().get(next) == Some(&b'\\n') {\n                // This cannot overflow as clearly `buf.len() >= pos + 2`.\n                buf.get_mut().set_position(pos + 2);\n            } else {\n                // This cannot overflow as clearly `buf.len() >= pos + 1`.\n                buf.get_mut().set_position(pos + 1);\n            }\n        }\n        _ => return,\n    }\n}\n\n\nmacro_rules! dbg_assert_ready {\n    ($e:expr) => ({\n        let poll = $e;\n        debug_assert!(poll.is_ready());\n        ::futures::ready!(poll)\n    })\n}\n\n// NOTE: The correctness of this implementation depends on the types of `name`\n// and `value` having `AsyncRead` implementations that always return `Ready`.\n// Otherwise, we may return `Pending` after having written data to `buf` which\n// violates the contract. This can happen because even after a successful\n// partial or full read of `name`, we loop back to a `ready!(name.poll())` if\n// `buf` was not completely filled. So, we return `Pending` if that poll does.\nimpl AsyncRead for RawLinedEvent {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        use bytes::Buf;\n\n        loop {\n            if buf.remaining() == 0 {\n                return Poll::Ready(Ok(()));\n            }\n\n            match self.state {\n                State::Name => {\n                    dbg_assert_ready!(Pin::new(&mut self.name).poll_read(cx, buf))?;\n                    if !self.name.has_remaining() {\n                        self.name.set_position(0);\n                        self.state = State::Colon;\n                    }\n                }\n                State::Colon => {\n                    // Note that we've checked `buf.remaining() != 0`.\n                    buf.put_slice(&[b':']);\n                    self.state = State::Value;\n                }\n                State::Value => {\n                    dbg_assert_ready!(Pin::new(&mut self.value).poll_read(cx, buf))?;\n                    if self.value.limit() == 0 {\n                        self.state = State::NewLine;\n                    }\n                }\n                State::NewLine => {\n                    // Note that we've checked `buf.remaining() != 0`.\n                    buf.put_slice(&[b'\\n']);\n                    if self.value.get_ref().has_remaining() {\n                        skip(&mut self.value);\n                        advance(&mut self.value);\n                        self.state = State::Name;\n                    } else {\n                        self.state = State::Done;\n                    }\n                }\n                State::Done => return Poll::Ready(Ok(()))\n            }\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{fmt, io};\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\n\nuse futures::stream::Stream;\nuse tokio::io::{AsyncRead, ReadBuf};\nuse pin_project_lite::pin_project;\n\nuse crate::request::Request;\nuse crate::response::{self, Response, Responder};\nuse crate::response::stream::One;\n\npin_project! {\n    /// An async reader that reads from a stream of async readers.\n    ///\n    /// A `ReaderStream` can be constructed from any [`Stream`] of items of type\n    /// `T` where `T: AsyncRead`, or from a single `AsyncRead` type using\n    /// [`ReaderStream::one()`]. The `AsyncRead` implementation of\n    /// `ReaderStream` progresses the stream forward, returning the contents of\n    /// the inner readers. Thus, a `ReaderStream` can be thought of as a\n    /// _flattening_ of async readers.\n    ///\n    /// `ReaderStream` is designed to be used as a building-block for\n    /// stream-based responders by acting as the `streamed_body` of a\n    /// `Response`, though it may also be used as a responder itself.\n    ///\n    /// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n    ///\n    /// ```rust\n    /// use std::io::Cursor;\n    ///\n    /// use rocket::{Request, Response};\n    /// use rocket::futures::stream::{Stream, StreamExt};\n    /// use rocket::response::{self, Responder, stream::ReaderStream};\n    /// use rocket::http::ContentType;\n    ///\n    /// struct MyStream<S>(S);\n    ///\n    /// impl<'r, S: Stream<Item = String>> Responder<'r, 'r> for MyStream<S>\n    ///     where S: Send + 'r\n    /// {\n    ///     fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n    ///         Response::build()\n    ///             .header(ContentType::Text)\n    ///             .streamed_body(ReaderStream::from(self.0.map(Cursor::new)))\n    ///             .ok()\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Responder\n    ///\n    /// `ReaderStream` is a (potentially infinite) responder. No `Content-Type`\n    /// is set. The body is [unsized](crate::response::Body#unsized), and values\n    /// are sent as soon as they are yielded by the internal stream.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::*;\n    /// use rocket::response::stream::ReaderStream;\n    /// use rocket::futures::stream::{repeat, StreamExt};\n    /// use rocket::tokio::time::{self, Duration};\n    /// use rocket::tokio::fs::File;\n    ///\n    /// // Stream the contents of `safe/path` followed by `another/safe/path`.\n    /// #[get(\"/reader/stream\")]\n    /// fn stream() -> ReaderStream![File] {\n    ///     ReaderStream! {\n    ///         let paths = &[\"safe/path\", \"another/safe/path\"];\n    ///         for path in paths {\n    ///             if let Ok(file) = File::open(path).await {\n    ///                 yield file;\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// // Stream the contents of the file `safe/path`. This is identical to\n    /// // returning `File` directly; Rocket responders stream and never buffer.\n    /// #[get(\"/reader/stream/one\")]\n    /// async fn stream_one() -> std::io::Result<ReaderStream![File]> {\n    ///     let file = File::open(\"safe/path\").await?;\n    ///     Ok(ReaderStream::one(file))\n    /// }\n    /// ```\n    ///\n    /// The syntax of [`ReaderStream!`] as an expression is identical to that of\n    /// [`stream!`](crate::response::stream::stream).\n    pub struct ReaderStream<S: Stream> {\n        #[pin]\n        stream: S,\n        #[pin]\n        state: State<S::Item>,\n    }\n}\n\npin_project! {\n    #[project = StateProjection]\n    #[derive(Debug)]\n    enum State<R> {\n        Pending,\n        Reading { #[pin] reader: R },\n        Done,\n    }\n}\n\nimpl<R: Unpin> ReaderStream<One<R>> {\n    /// Create a `ReaderStream` that yields exactly one reader, streaming the\n    /// contents of the reader itself.\n    ///\n    /// # Example\n    ///\n    /// Stream the bytes from a remote TCP connection:\n    ///\n    /// ```rust\n    /// # use rocket::*;\n    /// use std::io;\n    /// use std::net::SocketAddr;\n    ///\n    /// use rocket::tokio::net::TcpStream;\n    /// use rocket::response::stream::ReaderStream;\n    ///\n    /// #[get(\"/stream\")]\n    /// async fn stream() -> io::Result<ReaderStream![TcpStream]> {\n    ///     let addr = SocketAddr::from(([127, 0, 0, 1], 9999));\n    ///     let stream = TcpStream::connect(addr).await?;\n    ///     Ok(ReaderStream::one(stream))\n    /// }\n    /// ```\n    pub fn one(reader: R) -> Self {\n        ReaderStream::from(One::from(reader))\n    }\n}\n\nimpl<S: Stream> From<S> for ReaderStream<S> {\n    fn from(stream: S) -> Self {\n        ReaderStream { stream, state: State::Pending }\n    }\n}\n\nimpl<'r, S: Stream> Responder<'r, 'r> for ReaderStream<S>\n    where S: Send + 'r, S::Item: AsyncRead + Send,\n{\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n        Response::build()\n            .streamed_body(self)\n            .ok()\n    }\n}\n\nimpl<S: Stream> AsyncRead for ReaderStream<S>\n    where S::Item: AsyncRead + Send\n{\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>\n    ) -> Poll<io::Result<()>> {\n        let mut me = self.project();\n        loop {\n            match me.state.as_mut().project() {\n                StateProjection::Pending => match me.stream.as_mut().poll_next(cx) {\n                    Poll::Pending => return Poll::Pending,\n                    Poll::Ready(None) => me.state.set(State::Done),\n                    Poll::Ready(Some(reader)) => me.state.set(State::Reading { reader }),\n                },\n                StateProjection::Reading { reader } => {\n                    let init = buf.filled().len();\n                    match reader.poll_read(cx, buf) {\n                        Poll::Ready(Ok(())) if buf.filled().len() == init => {\n                            me.state.set(State::Pending);\n                        },\n                        Poll::Ready(Ok(())) => return Poll::Ready(Ok(())),\n                        Poll::Ready(Err(e)) => return Poll::Ready(Err(e)),\n                        Poll::Pending => return Poll::Pending,\n                    }\n                },\n                StateProjection::Done => return Poll::Ready(Ok(())),\n            }\n        }\n    }\n}\n\nimpl<S: Stream + fmt::Debug> fmt::Debug for ReaderStream<S>\n    where S::Item: fmt::Debug\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"ReaderStream\")\n            .field(\"stream\", &self.stream)\n            .field(\"state\", &self.state)\n            .finish()\n    }\n}\n\ncrate::export! {\n    /// Type and stream expression macro for [`struct@ReaderStream`].\n    ///\n    /// See [`stream!`](crate::response::stream::stream) for the syntax\n    /// supported by this macro.\n    ///\n    /// See [`struct@ReaderStream`] and the [module level\n    /// docs](crate::response::stream#typed-streams) for usage details.\n    macro_rules! ReaderStream {\n        ($($s:tt)*) => ($crate::_typed_stream!(ReaderStream, $($s)*));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::borrow::Cow;\n\nuse tokio::io::AsyncRead;\nuse tokio::time::Duration;\nuse futures::stream::{self, Stream, StreamExt};\nuse futures::future::ready;\n\nuse crate::request::Request;\nuse crate::response::{self, Response, Responder, stream::{ReaderStream, RawLinedEvent}};\nuse crate::http::ContentType;\n\n/// A Server-Sent `Event` (SSE) in a Server-Sent [`struct@EventStream`].\n///\n/// A server-sent event is either a _field_ or a _comment_. Comments can be\n/// constructed via [`Event::comment()`] while fields can be constructed via\n/// [`Event::data()`], [`Event::json()`], and [`Event::retry()`].\n///\n/// ```rust\n/// use rocket::tokio::time::Duration;\n/// use rocket::response::stream::Event;\n///\n/// // A `data` event with message \"Hello, SSE!\".\n/// let event = Event::data(\"Hello, SSE!\");\n///\n/// // The same event but with event name of `hello`.\n/// let event = Event::data(\"Hello, SSE!\").event(\"hello\");\n///\n/// // A `retry` event to set the client-side reconnection time.\n/// let event = Event::retry(Duration::from_secs(5));\n///\n/// // An event with an attached comment, event name, and ID.\n/// let event = Event::data(\"Hello, SSE!\")\n///     .with_comment(\"just a hello message\")\n///     .event(\"hello\")\n///     .id(\"1\");\n/// ```\n///\n/// We largely defer to [MDN's using server-sent events] documentation for\n/// client-side details but reproduce, in our words, relevant server-side\n/// documentation here.\n///\n/// [MDN's using server-sent events]:\n/// https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\n///\n/// # Pitfalls\n///\n/// Server-Sent Events suffer from certain pitfalls. We encourage readers to\n/// read through [pitfalls](struct@EventStream#pitfalls) before making use of\n/// Rocket's SSE support.\n///\n/// # Comments\n///\n/// A server-sent _comment_, created via [`Event::comment()`], is an event that\n/// appears only in the raw server-sent event data stream and is inaccessible by\n/// most clients. This includes JavaScript's `EventSource`. As such, they serve\n/// little utility beyond debugging a raw data stream and keeping a connection\n/// alive. See [heartbeat](struct@EventStream#heartbeat) for information on\n/// Rocket's `EventStream` keep-alive.\n///\n/// # Fields\n///\n/// A server-sent field can be one of four kinds:\n///\n///   * `retry`\n///\n///     A `retry` event, created via [`Event::retry()`], sets the reconnection\n///     time on the client side. It is the duration the client will wait before\n///     attempting to reconnect when a connection is lost. Most applications\n///     will not need to set a `retry`, opting instead to use the\n///     implementation's default or to reconnect manually on error.\n///\n///   * `id`\n///\n///     Sets the event id to associate all subsequent fields with. This value\n///     cannot be retrieved directly via most clients, including JavaScript\n///     `EventSource`. Instead, it is sent by the implementation on reconnection\n///     via the `Last-Event-ID` header. An `id` can be attached to other fields\n///     via the [`Event::id()`] builder method.\n///\n///   * `event`\n///\n///     Sets the event name to associate the next `data` field with. In\n///     JavaScript's `EventSource`, this is the event to be listened for, which\n///     defaults to `message`. An `event` can be attached to other fields via\n///     the [`Event::event()`] builder method.\n///\n///   * `data`\n///\n///     Sends data to dispatch as an event at the client. In JavaScript's\n///     `EventSource`, this (and only this) results in an event handler for\n///     `event`, specified just prior, being triggered. A data field can be\n///     created via the [`Event::data()`] or [`Event::json()`] constructors.\n///\n/// # Implementation Notes\n///\n/// A constructed `Event` _always_ emits its fields in the following order:\n///\n///   1. `comment`\n///   2. `retry`\n///   3. `id`\n///   4. `event`\n///   5. `data`\n///\n/// The `event` and `id` fields _cannot_ contain new lines or carriage returns.\n/// Rocket's default implementation automatically converts new lines and\n/// carriage returns in `event` and `id` fields to spaces.\n///\n/// The `data` and `comment` fields _cannot_ contain carriage returns. Rocket\n/// converts the unencoded sequence `\\r\\n` and the isolated `\\r` into a\n/// protocol-level `\\n`, that is, in such a way that they are interpreted as\n/// `\\n` at the client. For example, the raw message `foo\\r\\nbar\\rbaz` is\n/// received as `foo\\nbar\\nbaz` at the client-side. Encoded sequences, such as\n/// those emitted by [`Event::json()`], have no such restrictions.\n#[derive(Clone, Eq, PartialEq, Hash, Debug)]\npub struct Event {\n    comment: Option<Cow<'static, str>>,\n    retry: Option<Duration>,\n    id: Option<Cow<'static, str>>,\n    event: Option<Cow<'static, str>>,\n    data: Option<Cow<'static, str>>,\n}\n\nimpl Event {\n    // We hide this since we never want to construct an `Event` with nothing.\n    fn new() -> Self {\n        Event { comment: None, retry: None, id: None, event: None, data: None, }\n    }\n\n    /// Creates a new `Event` with an empty data field.\n    ///\n    /// This is exactly equivalent to `Event::data(\"\")`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// let event = Event::empty();\n    /// ```\n    pub fn empty() -> Self {\n        Event::data(\"\")\n    }\n\n    /// Creates a new `Event` with a data field of `data` serialized as JSON.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::serde::Serialize;\n    /// use rocket::response::stream::Event;\n    ///\n    /// #[derive(Serialize)]\n    /// #[serde(crate = \"rocket::serde\")]\n    /// struct MyData<'r> {\n    ///     string: &'r str,\n    ///     number: usize,\n    /// }\n    ///\n    /// let data = MyData { string: \"hello!\", number: 10 };\n    /// let event = Event::json(&data);\n    /// ```\n    #[cfg(feature = \"json\")]\n    #[cfg_attr(nightly, doc(cfg(feature = \"json\")))]\n    pub fn json<T: serde::Serialize>(data: &T) -> Self {\n        let string = serde_json::to_string(data).unwrap_or_default();\n        Self::data(string)\n    }\n\n    /// Creates a new `Event` with a data field containing the raw `data`.\n    ///\n    /// # Raw SSE is Lossy\n    ///\n    /// Unencoded carriage returns cannot be expressed in the protocol. Thus,\n    /// any carriage returns in `data` will not appear at the client-side.\n    /// Instead, the sequence `\\r\\n` and the isolated `\\r` will each appear as\n    /// `\\n` at the client-side. For example, the message `foo\\r\\nbar\\rbaz` is\n    /// received as `foo\\nbar\\nbaz` at the client-side.\n    ///\n    /// See [pitfalls](struct@EventStream#pitfalls) for more details.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// // A `data` event with message \"Hello, SSE!\".\n    /// let event = Event::data(\"Hello, SSE!\");\n    /// ```\n    pub fn data<T: Into<Cow<'static, str>>>(data: T) -> Self {\n        Self { data: Some(data.into()), ..Event::new() }\n    }\n\n    /// Creates a new comment `Event`.\n    ///\n    /// As with [`Event::data()`], unencoded carriage returns cannot be\n    /// expressed in the protocol. Thus, any carriage returns in `data` will\n    /// not appear at the client-side. For comments, this is generally not a\n    /// concern as comments are discarded by client-side libraries.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// let event = Event::comment(\"bet you'll never see me!\");\n    /// ```\n    pub fn comment<T: Into<Cow<'static, str>>>(data: T) -> Self {\n        Self { comment: Some(data.into()), ..Event::new() }\n    }\n\n    /// Creates a new retry `Event`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    /// use rocket::tokio::time::Duration;\n    ///\n    /// let event = Event::retry(Duration::from_millis(250));\n    /// ```\n    pub fn retry(period: Duration) -> Self {\n        Self { retry: Some(period), ..Event::new() }\n    }\n\n    /// Sets the value of the 'event' (event type) field.\n    ///\n    /// Event names may not contain new lines `\\n` or carriage returns `\\r`. If\n    /// `event` _does_ contain new lines or carriage returns, they are replaced\n    /// with spaces (` `) before being sent to the client.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// // The event name is \"start\".\n    /// let event = Event::data(\"hi\").event(\"start\");\n    ///\n    /// // The event name is \"then end\", with `\\n` replaced with ` `.\n    /// let event = Event::data(\"bye\").event(\"then\\nend\");\n    /// ```\n    pub fn event<T: Into<Cow<'static, str>>>(mut self, event: T) -> Self {\n        self.event = Some(event.into());\n        self\n    }\n\n    /// Sets the value of the 'id' (last event ID) field.\n    ///\n    /// Event IDs may not contain new lines `\\n` or carriage returns `\\r`. If\n    /// `id` _does_ contain new lines or carriage returns, they are replaced\n    /// with spaces (` `) before being sent to the client.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// // The event ID is \"start\".\n    /// let event = Event::data(\"hi\").id(\"start\");\n    ///\n    /// // The event ID is \"then end\", with `\\n` replaced with ` `.\n    /// let event = Event::data(\"bye\").id(\"then\\nend\");\n    /// ```\n    /// Sets the value of the 'id' field. It may not contain newlines.\n    pub fn id<T: Into<Cow<'static, str>>>(mut self, id: T) -> Self {\n        self.id = Some(id.into());\n        self\n    }\n\n    /// Sets or replaces the value of the `data` field.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// // The data \"hello\" will be sent.\n    /// let event = Event::data(\"hi\").with_data(\"hello\");\n    ///\n    /// // The two below are equivalent.\n    /// let event = Event::comment(\"bye\").with_data(\"goodbye\");\n    /// let event = Event::data(\"goodbye\").with_comment(\"bye\");\n    /// ```\n    pub fn with_data<T: Into<Cow<'static, str>>>(mut self, data: T) -> Self {\n        self.data = Some(data.into());\n        self\n    }\n\n    /// Sets or replaces the value of the `comment` field.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    ///\n    /// // The comment \"\" will be sent.\n    /// let event = Event::comment(\"Rocket is great!\").with_comment(\"\");\n    ///\n    /// // The two below are equivalent.\n    /// let event = Event::comment(\"bye\").with_data(\"goodbye\");\n    /// let event = Event::data(\"goodbye\").with_comment(\"bye\");\n    /// ```\n    pub fn with_comment<T: Into<Cow<'static, str>>>(mut self, data: T) -> Self {\n        self.comment = Some(data.into());\n        self\n    }\n\n    /// Sets or replaces the value of the `retry` field.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::Event;\n    /// use rocket::tokio::time::Duration;\n    ///\n    /// // The reconnection will be set to 10 seconds.\n    /// let event = Event::retry(Duration::from_millis(500))\n    ///     .with_retry(Duration::from_secs(10));\n    ///\n    /// // The two below are equivalent.\n    /// let event = Event::comment(\"bye\").with_retry(Duration::from_millis(500));\n    /// let event = Event::retry(Duration::from_millis(500)).with_comment(\"bye\");\n    /// ```\n    pub fn with_retry(mut self, period: Duration) -> Self {\n        self.retry = Some(period);\n        self\n    }\n\n    fn into_stream(self) -> impl Stream<Item = RawLinedEvent> {\n        let events = [\n            self.comment.map(|v| RawLinedEvent::many(\"\", v)),\n            self.retry.map(|r| RawLinedEvent::one(\"retry\", format!(\"{}\", r.as_millis()))),\n            self.id.map(|v| RawLinedEvent::one(\"id\", v)),\n            self.event.map(|v| RawLinedEvent::one(\"event\", v)),\n            self.data.map(|v| RawLinedEvent::many(\"data\", v)),\n            Some(RawLinedEvent::raw(\"\")),\n        ];\n\n        stream::iter(events).filter_map(ready)\n    }\n}\n\n/// A potentially infinite stream of Server-Sent [`Event`]s (SSE).\n///\n/// An `EventStream` can be constructed from any [`Stream`] of items of type\n/// `Event`. The stream can be constructed directly via [`EventStream::from()`]\n/// or through generator syntax via [`EventStream!`].\n///\n/// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n///\n/// # Responder\n///\n/// `EventStream` is a (potentially infinite) responder. The response\n/// `Content-Type` is set to [`EventStream`](const@ContentType::EventStream).\n/// The body is [unsized](crate::response::Body#unsized), and values are sent as\n/// soon as they are yielded by the internal iterator.\n///\n/// ## Heartbeat\n///\n/// A heartbeat comment is injected into the internal stream and sent at a fixed\n/// interval. The comment is discarded by clients and serves only to keep the\n/// connection alive; it does not interfere with application data. The interval\n/// defaults to 30 seconds but can be adjusted with\n/// [`EventStream::heartbeat()`].\n///\n/// # Examples\n///\n/// Use [`EventStream!`] to yield an infinite series of \"ping\" SSE messages to\n/// the client, one per second:\n///\n/// ```rust\n/// # use rocket::*;\n/// use rocket::response::stream::{Event, EventStream};\n/// use rocket::tokio::time::{self, Duration};\n///\n/// #[get(\"/events\")]\n/// fn stream() -> EventStream![] {\n///     EventStream! {\n///         let mut interval = time::interval(Duration::from_secs(1));\n///         loop {\n///             yield Event::data(\"ping\");\n///             interval.tick().await;\n///         }\n///     }\n/// }\n/// ```\n///\n/// Yield 9 events: 3 triplets of `retry`, `data`, and `comment` events:\n///\n/// ```rust\n/// # use rocket::get;\n/// use rocket::response::stream::{Event, EventStream};\n/// use rocket::tokio::time::Duration;\n///\n/// #[get(\"/events\")]\n/// fn events() -> EventStream![] {\n///     EventStream! {\n///         for i in 0..3 {\n///             yield Event::retry(Duration::from_secs(10));\n///             yield Event::data(format!(\"{}\", i)).id(\"cat\").event(\"bar\");\n///             yield Event::comment(\"silly boy\");\n///         }\n///     }\n/// }\n/// ```\n///\n/// The syntax of `EventStream!` as an expression is identical to that of\n/// [`stream!`](crate::response::stream::stream). For how to gracefully\n/// terminate an otherwise infinite stream, see [graceful\n/// shutdown](crate::response::stream#graceful-shutdown).\n///\n/// # Borrowing\n///\n/// If an `EventStream` contains a borrow, the extended type syntax\n/// `EventStream![Event + '_]` must be used:\n///\n/// ```rust\n/// # use rocket::get;\n/// use rocket::State;\n/// use rocket::response::stream::{Event, EventStream};\n///\n/// #[get(\"/events\")]\n/// fn events(ctxt: &State<bool>) -> EventStream![Event + '_] {\n///     EventStream! {\n///         // By using `ctxt` in the stream, the borrow is moved into it. Thus,\n///         // the stream object contains a borrow, prompting the '_ annotation.\n///         if *ctxt.inner() {\n///             yield Event::data(\"hi\");\n///         }\n///     }\n/// }\n/// ```\n///\n/// See [`stream#borrowing`](crate::response::stream#borrowing) for further\n/// details on borrowing in streams.\n///\n/// # Pitfalls\n///\n/// Server-Sent Events are a rather simple mechanism, though there are some\n/// pitfalls to be aware of.\n///\n///  * **Buffering**\n///\n///    Protocol restrictions complicate implementing an API that does not\n///    buffer. As such, if you are sending _lots_ of data, consider sending the\n///    data via multiple data fields (with events to signal start and end).\n///    Alternatively, send _one_ event which instructs the client to fetch the\n///    data from another endpoint which in-turn streams the data.\n///\n///  * **Raw SSE requires UTF-8 data**\n///\n///    Only UTF-8 data can be sent via SSE. If you need to send arbitrary bytes,\n///    consider encoding it, for instance, as JSON using [`Event::json()`].\n///    Alternatively, as described before, use SSE as a notifier which alerts\n///    the client to fetch the data from elsewhere.\n///\n///  * **Raw SSE is Lossy**\n///\n///    Data sent via SSE cannot contain new lines `\\n` or carriage returns `\\r`\n///    due to interference with the line protocol.\n///\n///    The protocol allows expressing new lines as multiple messages, however,\n///    and Rocket automatically transforms a message of `foo\\nbar` into two\n///    messages, `foo` and `bar`, so that they are reconstructed (automatically)\n///    as `foo\\nbar` on the client-side. For messages that only contain new\n///    lines `\\n`, the conversion is lossless.\n///\n///    However, the protocol has no mechanism for expressing carriage returns\n///    and thus it is not possible to send unencoded carriage returns via SSE.\n///    Rocket handles carriage returns like it handles new lines: it splits the\n///    data into multiple messages. Thus, a sequence of `\\r\\n` becomes `\\n` at\n///    the client side. A single `\\r` that is not part of an `\\r\\n` sequence\n///    also becomes `\\n` at the client side. As a result, the message\n///    `foo\\r\\nbar\\rbaz` is read as `foo\\nbar\\nbaz` at the client-side.\n///\n///    To send messages losslessly, they must be encoded first, for instance, by\n///    using [`Event::json()`].\n///\n///  * **Clients reconnect ad-infinitum**\n///\n///    The [SSE standard] stipulates: _\"Clients will reconnect if the connection\n///    is closed; a client can be told to stop reconnecting using the HTTP 204\n///    No Content response code.\"_ As a result, clients will typically reconnect\n///    exhaustively until either they choose to disconnect or they receive a\n///    `204 No Content` response.\n///\n///    [SSE standard]: https://html.spec.whatwg.org/multipage/server-sent-events.html\npub struct EventStream<S> {\n    stream: S,\n    heartbeat: Option<Duration>,\n}\n\nimpl<S: Stream<Item = Event>> EventStream<S> {\n    /// Sets a \"ping\" interval for this `EventStream` to avoid connection\n    /// timeouts when no data is being transferred. The default `interval` is 30\n    /// seconds.\n    ///\n    /// The ping is implemented by sending an empty comment to the client every\n    /// `interval` seconds.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::get;\n    /// use rocket::response::stream::{Event, EventStream};\n    /// use rocket::tokio::time::Duration;\n    ///\n    /// #[get(\"/events\")]\n    /// fn events() -> EventStream![] {\n    ///     // Remove the default heartbeat.\n    ///     # let event_stream = rocket::futures::stream::pending();\n    ///     EventStream::from(event_stream).heartbeat(None);\n    ///\n    ///     // Set the heartbeat interval to 15 seconds.\n    ///     # let event_stream = rocket::futures::stream::pending();\n    ///     EventStream::from(event_stream).heartbeat(Duration::from_secs(15));\n    ///\n    ///     // Do the same but for a generated `EventStream`:\n    ///     let stream = EventStream! {\n    ///         yield Event::data(\"hello\");\n    ///     };\n    ///\n    ///     stream.heartbeat(Duration::from_secs(15))\n    /// }\n    /// ```\n    pub fn heartbeat<H: Into<Option<Duration>>>(mut self, heartbeat: H) -> Self {\n        self.heartbeat = heartbeat.into();\n        self\n    }\n\n    fn heartbeat_stream(&self) -> Option<impl Stream<Item = RawLinedEvent>> {\n        use tokio::time::interval;\n        use tokio_stream::wrappers::IntervalStream;\n\n        self.heartbeat\n            .map(|beat| IntervalStream::new(interval(beat)))\n            .map(|stream| stream.map(|_| RawLinedEvent::raw(\":\")))\n    }\n\n    fn into_stream(self) -> impl Stream<Item = RawLinedEvent> {\n        use futures::future::Either;\n        use crate::ext::StreamExt;\n\n        let heartbeat_stream = self.heartbeat_stream();\n        let raw_events = self.stream.map(|e| e.into_stream()).flatten();\n        match heartbeat_stream {\n            Some(heartbeat) => Either::Left(raw_events.join(heartbeat)),\n            None => Either::Right(raw_events)\n        }\n    }\n\n    fn into_reader(self) -> impl AsyncRead {\n        ReaderStream::from(self.into_stream())\n    }\n}\n\nimpl<S: Stream<Item = Event>> From<S> for EventStream<S> {\n    /// Creates an `EventStream` from a [`Stream`] of [`Event`]s.\n    ///\n    /// Use `EventStream::from()` to construct an `EventStream` from an already\n    /// existing stream. Otherwise, prefer to use [`EventStream!`].\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::response::stream::{Event, EventStream};\n    /// use rocket::futures::stream;\n    ///\n    /// let raw = stream::iter(vec![Event::data(\"a\"), Event::data(\"b\")]);\n    /// let stream = EventStream::from(raw);\n    /// ```\n    fn from(stream: S) -> Self {\n        EventStream { stream, heartbeat: Some(Duration::from_secs(30)), }\n    }\n}\n\nimpl<'r, S: Stream<Item = Event> + Send + 'r> Responder<'r, 'r> for EventStream<S> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n        Response::build()\n            .header(ContentType::EventStream)\n            .raw_header(\"Cache-Control\", \"no-cache\")\n            .raw_header(\"Expires\", \"0\")\n            .streamed_body(self.into_reader())\n            .ok()\n    }\n}\n\ncrate::export! {\n    /// Type and stream expression macro for [`struct@EventStream`].\n    ///\n    /// See [`stream!`](crate::response::stream::stream) for the syntax\n    /// supported by this macro. In addition to that syntax, this macro can also\n    /// be called with no arguments, `EventStream![]`, as shorthand for\n    /// `EventStream![Event]`.\n    ///\n    /// See [`struct@EventStream`] and the [module level\n    /// docs](crate::response::stream#typed-streams) for usage details.\n    macro_rules! EventStream {\n        () => ($crate::_typed_stream!(EventStream, $crate::response::stream::Event));\n        ($($s:tt)*) => ($crate::_typed_stream!(EventStream, $($s)*));\n    }\n}\n\n#[cfg(test)]\nmod sse_tests {\n    use tokio::io::AsyncReadExt;\n    use tokio::time::{self, Duration};\n    use futures::stream::Stream;\n    use crate::response::stream::{stream, Event, EventStream, ReaderStream};\n\n    impl Event {\n        fn into_string(self) -> String {\n            crate::async_test(async move {\n                let mut string = String::new();\n                let mut reader = ReaderStream::from(self.into_stream());\n                reader.read_to_string(&mut string).await.expect(\"event -> string\");\n                string\n            })\n        }\n    }\n\n    impl<S: Stream<Item = Event>> EventStream<S> {\n        fn into_string(self) -> String {\n            crate::async_test(async move {\n                let mut string = String::new();\n                let reader = self.into_reader();\n                tokio::pin!(reader);\n                reader.read_to_string(&mut string).await.expect(\"event stream -> string\");\n                string\n            })\n        }\n    }\n\n    #[test]\n    fn test_event_data() {\n        let event = Event::data(\"a\\nb\");\n        assert_eq!(event.into_string(), \"data:a\\ndata:b\\n\\n\");\n\n        let event = Event::data(\"a\\n\");\n        assert_eq!(event.into_string(), \"data:a\\ndata:\\n\\n\");\n\n        let event = Event::data(\"cats make me happy!\");\n        assert_eq!(event.into_string(), \"data:cats make me happy!\\n\\n\");\n\n        let event = Event::data(\"in the\\njungle\\nthe mighty\\njungle\");\n        assert_eq!(event.into_string(),\n            \"data:in the\\ndata:jungle\\ndata:the mighty\\ndata:jungle\\n\\n\");\n\n        let event = Event::data(\"in the\\njungle\\r\\nthe mighty\\rjungle\");\n        assert_eq!(event.into_string(),\n            \"data:in the\\ndata:jungle\\ndata:the mighty\\ndata:jungle\\n\\n\");\n\n        let event = Event::data(\"\\nb\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\r\\nb\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\r\\nb\\r\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\n\\nb\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\n\\rb\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\n\\rb\\r\");\n        assert_eq!(event.into_string(), \"data:\\ndata:\\ndata:b\\ndata:\\n\\n\");\n\n        let event = Event::comment(\"\\n\\rb\\r\");\n        assert_eq!(event.into_string(), \":\\n:\\n:b\\n:\\n\\n\");\n\n        let event = Event::data(\"\\n\\n\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:\\ndata:\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\\n\");\n        assert_eq!(event.into_string(), \"data:\\ndata:\\n\\n\");\n\n        let event = Event::data(\"\");\n        assert_eq!(event.into_string(), \"data:\\n\\n\");\n    }\n\n    #[test]\n    fn test_event_fields() {\n        let event = Event::data(\"foo\").id(\"moo\");\n        assert_eq!(event.into_string(), \"id:moo\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"foo\").id(\"moo\").with_retry(Duration::from_secs(45));\n        assert_eq!(event.into_string(), \"retry:45000\\nid:moo\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"foo\\nbar\").id(\"moo\").with_retry(Duration::from_secs(45));\n        assert_eq!(event.into_string(), \"retry:45000\\nid:moo\\ndata:foo\\ndata:bar\\n\\n\");\n\n        let event = Event::retry(Duration::from_secs(45));\n        assert_eq!(event.into_string(), \"retry:45000\\n\\n\");\n\n        let event = Event::comment(\"incoming data...\");\n        assert_eq!(event.into_string(), \":incoming data...\\n\\n\");\n\n        let event = Event::data(\"foo\").id(\"moo\").with_comment(\"cows, ey?\");\n        assert_eq!(event.into_string(), \":cows, ey?\\nid:moo\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"foo\\nbar\")\n            .id(\"moo\")\n            .event(\"milk\")\n            .with_retry(Duration::from_secs(3));\n\n        assert_eq!(event.into_string(), \"retry:3000\\nid:moo\\nevent:milk\\ndata:foo\\ndata:bar\\n\\n\");\n\n        let event = Event::data(\"foo\")\n            .id(\"moo\")\n            .event(\"milk\")\n            .with_comment(\"??\")\n            .with_retry(Duration::from_secs(3));\n\n        assert_eq!(event.into_string(), \":??\\nretry:3000\\nid:moo\\nevent:milk\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"foo\")\n            .id(\"moo\")\n            .event(\"milk\")\n            .with_comment(\"?\\n?\")\n            .with_retry(Duration::from_secs(3));\n\n        assert_eq!(event.into_string(), \":?\\n:?\\nretry:3000\\nid:moo\\nevent:milk\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"foo\\r\\nbar\\nbaz\")\n            .id(\"moo\")\n            .event(\"milk\")\n            .with_comment(\"?\\n?\")\n            .with_retry(Duration::from_secs(3));\n\n        assert_eq!(event.into_string(),\n            \":?\\n:?\\nretry:3000\\nid:moo\\nevent:milk\\ndata:foo\\ndata:bar\\ndata:baz\\n\\n\");\n    }\n\n    #[test]\n    fn test_bad_chars() {\n        let event = Event::data(\"foo\").id(\"dead\\nbeef\").event(\"m\\noo\");\n        assert_eq!(event.into_string(), \"id:dead beef\\nevent:m oo\\ndata:foo\\n\\n\");\n\n        let event = Event::data(\"f\\no\").id(\"d\\r\\nbe\\rf\").event(\"m\\n\\r\");\n        assert_eq!(event.into_string(), \"id:d  be f\\nevent:m  \\ndata:f\\ndata:o\\n\\n\");\n\n        let event = Event::data(\"f\\no\").id(\"\\r\\n\\n\\r\\n\\r\\r\").event(\"\\n\\rb\");\n        assert_eq!(event.into_string(), \"id:       \\nevent:  b\\ndata:f\\ndata:o\\n\\n\");\n    }\n\n    #[test]\n    fn test_event_stream() {\n        use futures::stream::iter;\n\n        let stream = EventStream::from(iter(vec![Event::data(\"foo\")]));\n        assert_eq!(stream.into_string().replace(\":\\n\\n\", \"\"), \"data:foo\\n\\n\");\n\n        let stream = EventStream::from(iter(vec![Event::data(\"a\"), Event::data(\"b\")]));\n        assert_eq!(stream.into_string().replace(\":\\n\\n\", \"\"), \"data:a\\n\\ndata:b\\n\\n\");\n\n        let stream = EventStream::from(iter(vec![\n                Event::data(\"a\\nb\"),\n                Event::data(\"b\"),\n                Event::data(\"c\\n\\nd\"),\n                Event::data(\"e\"),\n        ]));\n\n        assert_eq!(stream.into_string().replace(\":\\n\\n\", \"\"),\n            \"data:a\\ndata:b\\n\\ndata:b\\n\\ndata:c\\ndata:\\ndata:d\\n\\ndata:e\\n\\n\");\n    }\n\n    #[test]\n    fn test_heartbeat() {\n        use futures::future::ready;\n        use futures::stream::{once, iter, StreamExt};\n\n        const HEARTBEAT: &str = \":\\n\";\n\n        // Set a heartbeat interval of 250ms. Send nothing for 600ms. We should\n        // get 2 or 3 heartbeats, the latter if one is sent eagerly. Maybe 4.\n        let raw = stream!(time::sleep(Duration::from_millis(600)).await;)\n            .map(|_| unreachable!());\n\n        let string = EventStream::from(raw)\n            .heartbeat(Duration::from_millis(250))\n            .into_string();\n\n        let heartbeats = string.matches(HEARTBEAT).count();\n        assert!(heartbeats >= 2 && heartbeats <= 4, \"got {} beat(s)\", heartbeats);\n\n        let stream = EventStream! {\n            time::sleep(Duration::from_millis(250)).await;\n            yield Event::data(\"foo\");\n            time::sleep(Duration::from_millis(250)).await;\n            yield Event::data(\"bar\");\n        };\n\n        // We expect: foo\\n\\n [heartbeat] bar\\n\\n [maybe heartbeat].\n        let string = stream.heartbeat(Duration::from_millis(350)).into_string();\n        let heartbeats = string.matches(HEARTBEAT).count();\n        assert!(heartbeats >= 1 && heartbeats <= 3, \"got {} beat(s)\", heartbeats);\n        assert!(string.contains(\"data:foo\\n\\n\"), \"string = {:?}\", string);\n        assert!(string.contains(\"data:bar\\n\\n\"), \"string = {:?}\", string);\n\n        // We shouldn't send a heartbeat if a message is immediately available.\n        let stream = EventStream::from(once(ready(Event::data(\"hello\"))));\n        let string = stream.heartbeat(Duration::from_secs(1)).into_string();\n        assert_eq!(string, \"data:hello\\n\\n\", \"string = {:?}\", string);\n\n        // It's okay if we do it with two, though.\n        let stream = EventStream::from(iter(vec![Event::data(\"a\"), Event::data(\"b\")]));\n        let string = stream.heartbeat(Duration::from_secs(1)).into_string();\n        let heartbeats = string.matches(HEARTBEAT).count();\n        assert!(heartbeats <= 1);\n        assert!(string.contains(\"data:a\\n\\n\"), \"string = {:?}\", string);\n        assert!(string.contains(\"data:b\\n\\n\"), \"string = {:?}\", string);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use futures::stream::{Stream, StreamExt};\n\nuse crate::request::Request;\nuse crate::response::{self, Response, Responder};\nuse crate::http::ContentType;\nuse crate::response::stream::ReaderStream;\n\n/// A potentially infinite stream of text: `T: AsRef<str>`.\n///\n/// A `TextStream` can be constructed from any [`Stream`] of items of type `T`\n/// where `T: AsRef<str>`. This includes `&str`, `String`, `Cow<str>`,\n/// `&RawStr`, and more. The stream can be constructed directly, via\n/// `TextStream(..)` or [`TextStream::from()`], or through generator syntax via\n/// [`TextStream!`].\n///\n/// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n///\n/// # Responder\n///\n/// `TextStream` is a (potentially infinite) responder. The response\n/// `Content-Type` is set to [`Text`](ContentType::Text). The body is\n/// [unsized](crate::response::Body#unsized), and values are sent as soon as\n/// they are yielded by the internal iterator.\n///\n/// # Example\n///\n/// Use [`TextStream!`] to yield 10 strings, one every second, of the form `\"n:\n/// $k\"` for `$k` from `0` to `10` exclusive:\n///\n/// ```rust\n/// # use rocket::*;\n/// use rocket::response::stream::TextStream;\n/// use rocket::futures::stream::{repeat, StreamExt};\n/// use rocket::tokio::time::{self, Duration};\n///\n/// #[get(\"/text\")]\n/// fn text() -> TextStream![&'static str] {\n///     TextStream(repeat(\"hi\"))\n/// }\n///\n/// #[get(\"/text/stream\")]\n/// fn stream() -> TextStream![String] {\n///     TextStream! {\n///         let mut interval = time::interval(Duration::from_secs(1));\n///         for i in 0..10 {\n///             yield format!(\"n: {}\", i);\n///             interval.tick().await;\n///         }\n///     }\n/// }\n/// ```\n///\n/// The syntax of [`TextStream!`] as an expression is identical to that of\n/// [`stream!`](crate::response::stream::stream).\n#[derive(Debug, Clone)]\npub struct TextStream<S>(pub S);\n\nimpl<S> From<S> for TextStream<S> {\n    /// Creates a `TextStream` from any `S: Stream`.\n    fn from(stream: S) -> Self {\n        TextStream(stream)\n    }\n}\n\nimpl<'r, S: Stream> Responder<'r, 'r> for TextStream<S>\n    where S: Send + 'r, S::Item: AsRef<str> + Send + Unpin + 'r\n{\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n        struct ByteStr<T>(T);\n\n        impl<T: AsRef<str>> AsRef<[u8]> for ByteStr<T> {\n            fn as_ref(&self) -> &[u8] {\n                self.0.as_ref().as_bytes()\n            }\n        }\n\n        let inner = self.0.map(ByteStr).map(std::io::Cursor::new);\n        Response::build()\n            .header(ContentType::Text)\n            .streamed_body(ReaderStream::from(inner))\n            .ok()\n    }\n}\n\ncrate::export! {\n    /// Type and stream expression macro for [`struct@TextStream`].\n    ///\n    /// See [`stream!`](crate::response::stream::stream) for the syntax\n    /// supported by this macro.\n    ///\n    /// See [`struct@TextStream`] and the [module level\n    /// docs](crate::response::stream#typed-streams) for usage details.\n    macro_rules! TextStream {\n        ($($s:tt)*) => ($crate::_typed_stream!(TextStream, $($s)*));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::response::Redirect;\n\n#[get(\"/http\")]\nfn http() -> Redirect {\n    Redirect::to(uri!(\"http://rocket.rs\"))\n}\n\n#[get(\"/rocket\")]\nfn redirect() -> Redirect {\n    Redirect::to(\"https://rocket.rs:80\")\n}\n\nmod test_absolute_uris_okay {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn redirect_works() {\n        let client = Client::debug_with(routes![http, redirect]).unwrap();\n\n        let response = client.get(uri!(http)).dispatch();\n        let location = response.headers().get_one(\"Location\");\n        assert_eq!(location, Some(\"http://rocket.rs\"));\n\n        let response = client.get(uri!(redirect)).dispatch();\n        let location = response.headers().get_one(\"Location\");\n        assert_eq!(location, Some(\"https://rocket.rs:80\"));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse std::str::from_utf8;\n\nuse rocket::form::Form;\nuse rocket::http::{ContentType, Status};\nuse rocket::local::blocking::Client;\n\n#[derive(FromForm)]\nstruct DataForm<'r> {\n    foo: &'r [u8],\n    bar: &'r [u8],\n}\n\n#[post(\"/\", data = \"<form>\")]\nfn form(form: Form<DataForm<'_>>) -> String {\n    from_utf8(form.foo).unwrap().to_string() + from_utf8(form.bar).unwrap()\n}\n\n#[test]\nfn test_from_form_fields_of_multipart_files_into_byte_slices() {\n    let body = &[\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"foo\"; filename=\"foo.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"start>\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"foo\"; filename=\"foo2.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"second-start...\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"bar\"; filename=\"bar.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"<finish\",\n        \"--X-BOUNDARY--\",\n        \"\",\n    ].join(\"\\r\\n\");\n\n    let client = Client::debug_with(routes![form]).unwrap();\n    let response = client.post(\"/\")\n        .header(\"multipart/form-data; boundary=X-BOUNDARY\".parse::<ContentType>().unwrap())\n        .body(body)\n        .dispatch();\n\n    assert_eq!(response.status(), Status::Ok);\n    assert_eq!(response.into_string().unwrap(), \"start><finish\");\n}\n\n#[test]\nfn test_from_form_fields_of_values_into_byte_slices() {\n    let client = Client::debug_with(routes![form]).unwrap();\n    let response = client.post(\"/\")\n        .header(ContentType::Form)\n        .body(format!(\"bar={}&foo={}\", \"...finish\", \"start...\"))\n        .dispatch();\n\n    assert_eq!(response.status(), Status::Ok);\n    assert_eq!(response.into_string().unwrap(), \"start......finish\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::http::uri::Origin;\nuse rocket::local::blocking::Client;\n\n#[test]\nfn can_correct_bad_local_uri() {\n    #[rocket::get(\"/\")] fn f() {}\n\n    let client = Client::debug_with(rocket::routes![f]).unwrap();\n    let mut req = client.get(\"this is a bad URI\");\n    req.set_uri(Origin::parse(\"/\").unwrap());\n\n    assert_eq!(req.uri(), \"/\");\n    assert!(req.dispatch().status().class().is_success());\n\n    let req = client.get(\"this is a bad URI\");\n    assert!(req.dispatch().status().class().is_client_error());\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"tls\")]\n\nuse rocket::fs::relative;\nuse rocket::config::{Config, TlsConfig, CipherSuite};\nuse rocket::local::asynchronous::Client;\n\n#[rocket::async_test]\nasync fn can_launch_tls() {\n    let cert_path = relative!(\"examples/tls/private/rsa_sha256_cert.pem\");\n    let key_path = relative!(\"examples/tls/private/rsa_sha256_key.pem\");\n\n    let tls = TlsConfig::from_paths(cert_path, key_path)\n        .with_ciphers([\n            CipherSuite::TLS_AES_128_GCM_SHA256,\n            CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        ]);\n\n    let rocket = rocket::custom(Config { tls: Some(tls), ..Config::debug_default() });\n    let client = Client::debug(rocket).await.unwrap();\n\n    client.rocket().shutdown().notify();\n    client.rocket().shutdown().await;\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::request::Request;\nuse rocket::http::CookieJar;\n\n#[catch(404)]\nfn not_found(request: &Request) -> &'static str {\n    request.cookies().add((\"not_found\", \"404\"));\n    \"404 - Not Found\"\n}\n\n#[get(\"/\")]\nfn index(cookies: &CookieJar<'_>) -> &'static str {\n    cookies.add((\"index\", \"hi\"));\n    \"Hello, world!\"\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::fairing::AdHoc;\n\n    #[test]\n    fn error_catcher_sets_cookies() {\n        let rocket = rocket::build()\n            .mount(\"/\", routes![index])\n            .register(\"/\", catchers![not_found])\n            .attach(AdHoc::on_request(\"Add Cookie\", |req, _| Box::pin(async move {\n                req.cookies().add((\"fairing\", \"woo\"));\n            })));\n\n        let client = Client::debug(rocket).unwrap();\n\n        // Check that the index returns the `index` and `fairing` cookie.\n        let response = client.get(\"/\").dispatch();\n        let cookies = response.cookies();\n        assert_eq!(cookies.iter().count(), 2);\n        assert_eq!(cookies.get(\"index\").unwrap().value(), \"hi\");\n        assert_eq!(cookies.get(\"fairing\").unwrap().value(), \"woo\");\n\n        // Check that the catcher returns only the `not_found` cookie.\n        let response = client.get(\"/not-existent\").dispatch();\n        let cookies = response.cookies();\n        assert_eq!(cookies.iter().count(), 1);\n        assert_eq!(cookies.get(\"not_found\").unwrap().value(), \"404\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::http::Header;\n\n#[derive(Responder)]\nstruct HeaderOnly((), Header<'static>);\n\n#[get(\"/do_not_overwrite\")]\nfn do_not_overwrite() -> HeaderOnly {\n    HeaderOnly((), Header::new(\"Server\", \"Test\"))\n}\n\n#[get(\"/use_default\")]\nfn use_default() { }\n\nmod conditionally_set_server_header {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn do_not_overwrite_server_header() {\n        let client = Client::debug_with(routes![do_not_overwrite, use_default]).unwrap();\n\n        let response = client.get(\"/do_not_overwrite\").dispatch();\n        let server = response.headers().get_one(\"Server\");\n        assert_eq!(server, Some(\"Test\"));\n\n        let response = client.get(\"/use_default\").dispatch();\n        let server = response.headers().get_one(\"Server\");\n        assert_eq!(server, Some(\"Rocket\"));\n\n        // Now with a special `Ident`.\n\n        let config = rocket::Config {\n            ident: rocket::config::Ident::try_new(\"My Special Server\").unwrap(),\n            ..rocket::Config::debug_default()\n        };\n\n        let rocket = rocket::custom(config)\n            .mount(\"/\", routes![do_not_overwrite, use_default]);\n\n        let client = Client::debug(rocket).unwrap();\n\n        let response = client.get(\"/do_not_overwrite\").dispatch();\n        let server = response.headers().get_one(\"Server\");\n        assert_eq!(server, Some(\"Test\"));\n\n        let response = client.get(\"/use_default\").dispatch();\n        let server = response.headers().get_one(\"Server\");\n        assert_eq!(server, Some(\"My Special Server\"));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\n#[get(\"/\")]\nfn inspect_ip(ip: Option<std::net::IpAddr>) -> String {\n    ip.map(|ip| ip.to_string()).unwrap_or(\"<none>\".into())\n}\n\nmod tests {\n    use rocket::{Rocket, Build, Route};\n    use rocket::local::blocking::Client;\n    use rocket::figment::Figment;\n    use rocket::http::Header;\n\n    fn routes() -> Vec<Route> {\n        routes![super::inspect_ip]\n    }\n\n    fn rocket_with_custom_ip_header(header: Option<&'static str>) -> Rocket<Build> {\n        let mut config = rocket::Config::debug_default();\n        config.ip_header = header.map(|h| h.into());\n        rocket::custom(config).mount(\"/\", routes())\n    }\n\n    #[test]\n    fn check_real_ip_header_works() {\n        let client = Client::debug(rocket_with_custom_ip_header(Some(\"IP\"))).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Real-IP\", \"1.2.3.4\"))\n            .header(Header::new(\"IP\", \"8.8.8.8\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"8.8.8.8\".into()));\n\n        let response = client.get(\"/\")\n            .header(Header::new(\"IP\", \"1.1.1.1\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"1.1.1.1\".into()));\n\n        let response = client.get(\"/\").dispatch();\n        assert_eq!(response.into_string(), Some(\"<none>\".into()));\n    }\n\n    #[test]\n    fn check_real_ip_header_works_again() {\n        let client = Client::debug(rocket_with_custom_ip_header(Some(\"x-forward-ip\"))).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Forward-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"1.2.3.4\".into()));\n\n        let config = Figment::from(rocket::Config::debug_default())\n            .merge((\"ip_header\", \"x-forward-ip\"));\n\n        let client = Client::debug(rocket::custom(config).mount(\"/\", routes())).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Forward-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"1.2.3.4\".into()));\n    }\n\n    #[test]\n    fn check_default_real_ip_header_works() {\n        let client = Client::debug_with(routes()).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Real-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"1.2.3.4\".into()));\n    }\n\n    #[test]\n    fn check_no_ip_header_works() {\n        let client = Client::debug(rocket_with_custom_ip_header(None)).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Real-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"<none>\".into()));\n\n        let config = Figment::from(rocket::Config::debug_default())\n            .merge((\"ip_header\", false));\n\n        let client = Client::debug(rocket::custom(config).mount(\"/\", routes())).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Real-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"<none>\".into()));\n\n        let config = Figment::from(rocket::Config::debug_default());\n        let client = Client::debug(rocket::custom(config).mount(\"/\", routes())).unwrap();\n        let response = client.get(\"/\")\n            .header(Header::new(\"X-Real-IP\", \"1.2.3.4\"))\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"1.2.3.4\".into()));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"secrets\")]\n\nuse rocket::figment::Figment;\nuse rocket::config::{Config, SecretKey};\n\n#[test]\nfn secret_key_in_config_not_zero() {\n    let original_key = SecretKey::generate().expect(\"get key\");\n\n    let config = Config { secret_key: original_key.clone(), ..Default::default() };\n    let figment = Figment::from(config);\n    let figment_key: SecretKey = figment.extract_inner(\"secret_key\").unwrap();\n    assert_eq!(original_key, figment_key);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"secrets\")]\n#![deny(warnings)]\n\nuse rocket::http::{Cookie, CookieJar, SameSite};\nuse rocket::{get, post, routes};\n\n#[post(\"/\")]\nfn cookie_add_private(jar: &CookieJar<'_>) {\n    let mut cookie_a = Cookie::new(\"a\", \"v1\");\n    jar.add(cookie_a.clone());\n    let mut cookie_b = Cookie::new(\"b\", \"v2\");\n    jar.add_private(cookie_b.clone());\n    jar.add((\"c\", \"v3\"));\n\n    // private: CookieJar::set_defaults(&mut cookie_a);\n    cookie_a.set_path(\"/\");\n    cookie_a.set_same_site(SameSite::Strict);\n    assert_eq!(jar.get_pending(cookie_a.name()), Some(cookie_a));\n\n    // private: CookieJar::set_private_defaults(&mut cookie_b);\n    cookie_b.set_path(\"/\");\n    cookie_b.set_same_site(SameSite::Strict);\n    cookie_b.set_http_only(true);\n    let expires = time::OffsetDateTime::now_utc() + time::Duration::weeks(1);\n    cookie_b.set_expires(expires);\n    let mut cookie_b_pending = jar\n        .get_pending(cookie_b.name())\n        .expect(\"cookie_b_pending None\");\n    cookie_b_pending.set_expires(expires);\n    assert_eq!(cookie_b_pending, cookie_b);\n}\n\n#[get(\"/\")]\nfn cookie_get_private(jar: &CookieJar<'_>) -> String {\n    let (a, b, c) = (jar.get(\"a\"), jar.get_private(\"b\"), jar.get(\"c\"));\n    assert_ne!(a, b.as_ref());\n    assert_ne!(a, c);\n    assert_ne!(b.as_ref(), c);\n    assert_eq!(b, jar.get_pending(\"b\"));\n\n    format!(\n        \"{}{}{}\",\n        a.unwrap().value(),\n        b.unwrap().value(),\n        c.unwrap().value()\n    )\n}\n\n/// For test if we got really a private cookie\n#[get(\"/oh-no\")]\nfn cookie_get(jar: &CookieJar<'_>) -> String {\n    let (a, b, c) = (jar.get(\"a\"), jar.get(\"b\"), jar.get(\"c\"));\n    assert_eq!(b.cloned(), jar.get_pending(\"b\"));\n\n    format!(\n        \"{}{}{}\",\n        a.unwrap().value(),\n        b.unwrap().value(),\n        c.unwrap().value()\n    )\n}\n\n#[cfg(test)]\nmod cookies_private_tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::{Build, Rocket};\n\n    fn rocket() -> Rocket<Build> {\n        rocket::build()\n            .mount(\"/\", routes![cookie_add_private, cookie_get, cookie_get_private])\n    }\n\n    #[test]\n    fn test_cookie_add_private() {\n        let client = Client::debug(rocket()).unwrap();\n        let response = client.post(\"/\").dispatch();\n        let cookies = response.cookies();\n        assert_eq!(cookies.iter().count(), 3);\n        assert_eq!(cookies.get(\"a\").unwrap().value(), \"v1\");\n        assert_eq!(cookies.get_private(\"b\").unwrap().value(), \"v2\");\n        assert_eq!(cookies.get_pending(\"b\").unwrap().value(), \"v2\");\n        assert_ne!(cookies.get(\"b\").unwrap().value(), \"v2\");\n        assert_eq!(cookies.get(\"c\").unwrap().value(), \"v3\");\n    }\n\n    #[test]\n    fn test_cookie_get_private() {\n        let client = Client::debug(rocket()).unwrap();\n        let response = client\n            .get(\"/\")\n            .cookie((\"a\", \"Cookie\"))\n            .private_cookie((\"b\", \" tastes \"))\n            .cookie((\"c\", \"good!\"))\n            .dispatch();\n\n        assert_eq!(response.into_string().unwrap(), \"Cookie tastes good!\");\n    }\n\n    /// Test if we got really a private cookie\n    #[test]\n    fn test_cookie_get_ohno() {\n        let client = Client::debug(rocket()).unwrap();\n        let response = client\n            .get(\"/oh-no\")\n            .cookie((\"a\", \"Cookie\"))\n            .private_cookie((\"b\", \" tastes \"))\n            .cookie((\"c\", \"good!\"))\n            .dispatch();\n\n        assert_ne!(response.into_string().unwrap(), \"Cookie tastes good!\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket;\n\nuse rocket::{get, routes};\nuse rocket::form::{FromForm, FromFormField};\nuse rocket::response::Responder;\n\n#[derive(FromFormField)]\nenum Thing {\n    A,\n    B,\n    C,\n}\n\nimpl std::fmt::Display for Thing {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match *self {\n            Thing::A => write!(f, \"a\"),\n            Thing::B => write!(f, \"b\"),\n            Thing::C => write!(f, \"c\"),\n        }\n    }\n}\n\n#[derive(FromForm)]\nstruct ThingForm {\n    thing: Thing,\n}\n\n#[derive(Responder)]\nstruct DerivedResponder {\n    data: String,\n}\n\n#[get(\"/\")]\nfn index() -> DerivedResponder {\n    DerivedResponder { data: \"hello\".to_string() }\n}\n\n#[get(\"/?<params..>\")]\nfn number(params: ThingForm) -> DerivedResponder {\n    DerivedResponder { data: params.thing.to_string() }\n}\n\n#[test]\nfn test_derive_reexports() {\n    use rocket::local::blocking::Client;\n\n    let client = Client::debug_with(routes![index, number]).unwrap();\n\n    let response = client.get(\"/\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"hello\");\n\n    let response = client.get(\"/?thing=b\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"b\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::config::Config;\nuse rocket::data::Limits;\nuse rocket::figment::{providers::Serialized, Figment};\nuse ubyte::ToByteUnit;\n\n#[test]\nfn deserialize_mixed_case_limits_should_work() {\n    let figment = Figment::default()\n        .merge(Serialized::default(\"key1\", 1.kibibytes()))\n        .merge(Serialized::default(\"key5\", 5.kibibytes()))\n        .merge(Serialized::default(\"key3\", 3.kibibytes()))\n        .merge(Serialized::default(\"Key2\", 2.kibibytes()))\n        .merge(Serialized::default(\"Key4\", 4.kibibytes()))\n        .merge(Serialized::default(\"Key6\", 6.kibibytes()));\n\n    let limits: Limits = figment.extract().unwrap();\n    assert_eq!(limits.get(\"key1\"), Some(1.kibibytes()));\n    assert_eq!(limits.get(\"key2\"), Some(2.kibibytes()));\n    assert_eq!(limits.get(\"key3\"), Some(3.kibibytes()));\n    assert_eq!(limits.get(\"key4\"), Some(4.kibibytes()));\n    assert_eq!(limits.get(\"key5\"), Some(5.kibibytes()));\n    assert_eq!(limits.get(\"key6\"), Some(6.kibibytes()));\n}\n\n#[test]\nfn deserialize_extra_limits_in_config_should_work() {\n    let extra_limits = Limits::new().limit(\"Phactory\", 1.kibibytes());\n    let figment = Config::figment().merge((\"limits\", extra_limits));\n    let config = Config::from(figment);\n    assert_eq!(config.limits.get(\"Phactory\"), Some(1.kibibytes()));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\n#[get(\"/hello sper $?a&?&<value>\")]\nfn index(value: &str) -> &str {\n    value\n}\n\nmod encoded_uris {\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn can_route_to_encoded_uri() {\n        let client = Client::debug_with(routes![super::index]).unwrap();\n        let response = client.get(\"/hello%20s%C3%BCper%20%24?a&%3F&value=a+b\")\n            .dispatch()\n            .into_string();\n\n        assert_eq!(response.unwrap(), \"a b\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nconst RESPONSE_STRING: &'static str = \"This is the body. Hello, world!\";\n\n#[head(\"/\")]\nfn head() -> &'static str {\n    RESPONSE_STRING\n}\n\n#[get(\"/\")]\nfn auto() -> &'static str {\n    RESPONSE_STRING\n}\n\n// Test that response fairings see the response body for all `HEAD` requests,\n// whether they are auto-handled or not.\nmod fairing_before_head_strip {\n    use super::*;\n    use std::sync::atomic::{AtomicUsize, Ordering};\n    use std::io::Cursor;\n\n    use rocket::fairing::AdHoc;\n    use rocket::local::blocking::Client;\n    use rocket::http::{Method, Status};\n\n    #[test]\n    fn not_auto_handled() {\n        let rocket = rocket::build()\n            .mount(\"/\", routes![head])\n            .attach(AdHoc::on_request(\"Check HEAD\", |req, _| {\n                Box::pin(async move {\n                    assert_eq!(req.method(), Method::Head);\n                })\n            }))\n            .attach(AdHoc::on_response(\"Check HEAD 2\", |req, res| {\n                Box::pin(async move {\n                    assert_eq!(req.method(), Method::Head);\n                    let body_bytes = res.body_mut().to_bytes().await.unwrap();\n                    assert_eq!(body_bytes, RESPONSE_STRING.as_bytes());\n                    res.set_sized_body(body_bytes.len(), Cursor::new(body_bytes));\n                })\n            }));\n\n        let client = Client::debug(rocket).unwrap();\n        let response = client.head(\"/\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n        assert!(response.into_string().unwrap_or_default().is_empty());\n    }\n\n    #[test]\n    fn auto_handled() {\n        #[derive(Default)]\n        struct Counter(AtomicUsize);\n\n        let counter = Counter::default();\n        let rocket = rocket::build()\n            .mount(\"/\", routes![auto])\n            .manage(counter)\n            .attach(AdHoc::on_request(\"Check HEAD + Count\", |req, _| {\n                Box::pin(async move {\n                    assert_eq!(req.method(), Method::Head);\n\n                    // This should be called exactly once.\n                    let c = req.rocket().state::<Counter>().unwrap();\n                    assert_eq!(c.0.fetch_add(1, Ordering::SeqCst), 0);\n                })\n            }))\n            .attach(AdHoc::on_response(\"Check GET\", |req, res| {\n                Box::pin(async move {\n                    assert_eq!(req.method(), Method::Get);\n                    let body_bytes = res.body_mut().to_bytes().await.unwrap();\n                    assert_eq!(body_bytes, RESPONSE_STRING.as_bytes());\n                    res.set_sized_body(body_bytes.len(), Cursor::new(body_bytes));\n                })\n            }));\n\n        let client = Client::debug(rocket).unwrap();\n        let response = client.head(\"/\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n        assert!(response.into_string().unwrap_or_default().is_empty());\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{io::Read, fs::File};\nuse std::path::Path;\n\nuse rocket::{Rocket, Route, Build};\nuse rocket::http::Status;\nuse rocket::local::blocking::Client;\nuse rocket::fs::{FileServer, Options, relative};\n\nfn static_root() -> &'static Path {\n    Path::new(relative!(\"/tests/static\"))\n}\n\nfn rocket() -> Rocket<Build> {\n    let root = static_root();\n    rocket::build()\n        .mount(\"/default\", FileServer::from(&root))\n        .mount(\"/no_index\", FileServer::new(&root, Options::None))\n        .mount(\"/dots\", FileServer::new(&root, Options::DotFiles))\n        .mount(\"/index\", FileServer::new(&root, Options::Index))\n        .mount(\"/both\", FileServer::new(&root, Options::DotFiles | Options::Index))\n        .mount(\"/redir\", FileServer::new(&root, Options::NormalizeDirs))\n        .mount(\"/redir_index\", FileServer::new(&root, Options::NormalizeDirs | Options::Index))\n}\n\nstatic REGULAR_FILES: &[&str] = &[\n    \"index.html\",\n    \"inner/goodbye\",\n    \"inner/index.html\",\n    \"other/hello.txt\",\n];\n\nstatic HIDDEN_FILES: &[&str] = &[\n    \".hidden\",\n    \"inner/.hideme\",\n];\n\nstatic INDEXED_DIRECTORIES: &[&str] = &[\n    \"\",\n    \"inner/\",\n];\n\nfn assert_file(client: &Client, prefix: &str, path: &str, exists: bool) {\n    let full_path = format!(\"/{}/{}\", prefix, path);\n    let response = client.get(full_path).dispatch();\n    if exists {\n        assert_eq!(response.status(), Status::Ok);\n\n        let mut path = static_root().join(path);\n        if path.is_dir() {\n            path = path.join(\"index.html\");\n        }\n\n        let mut file = File::open(path).expect(\"open file\");\n        let mut expected_contents = String::new();\n        file.read_to_string(&mut expected_contents).expect(\"read file\");\n        assert_eq!(response.into_string(), Some(expected_contents));\n    } else {\n        assert_eq!(response.status(), Status::NotFound);\n    }\n}\n\nfn assert_all(client: &Client, prefix: &str, paths: &[&str], exist: bool) {\n    for path in paths.iter() {\n        assert_file(client, prefix, path, exist);\n    }\n}\n\n#[test]\nfn test_static_no_index() {\n    let client = Client::debug(rocket()).expect(\"valid rocket\");\n    assert_all(&client, \"no_index\", REGULAR_FILES, true);\n    assert_all(&client, \"no_index\", HIDDEN_FILES, false);\n    assert_all(&client, \"no_index\", INDEXED_DIRECTORIES, false);\n}\n\n#[test]\nfn test_static_hidden() {\n    let client = Client::debug(rocket()).expect(\"valid rocket\");\n    assert_all(&client, \"dots\", REGULAR_FILES, true);\n    assert_all(&client, \"dots\", HIDDEN_FILES, true);\n    assert_all(&client, \"dots\", INDEXED_DIRECTORIES, false);\n}\n\n#[test]\nfn test_static_index() {\n    let client = Client::debug(rocket()).expect(\"valid rocket\");\n    assert_all(&client, \"index\", REGULAR_FILES, true);\n    assert_all(&client, \"index\", HIDDEN_FILES, false);\n    assert_all(&client, \"index\", INDEXED_DIRECTORIES, true);\n\n    assert_all(&client, \"default\", REGULAR_FILES, true);\n    assert_all(&client, \"default\", HIDDEN_FILES, false);\n    assert_all(&client, \"default\", INDEXED_DIRECTORIES, true);\n}\n\n#[test]\nfn test_static_all() {\n    let client = Client::debug(rocket()).expect(\"valid rocket\");\n    assert_all(&client, \"both\", REGULAR_FILES, true);\n    assert_all(&client, \"both\", HIDDEN_FILES, true);\n    assert_all(&client, \"both\", INDEXED_DIRECTORIES, true);\n}\n\n#[test]\nfn test_ranking() {\n    let root = static_root();\n    for rank in -128..128 {\n        let a = FileServer::new(&root, Options::None).rank(rank);\n        let b = FileServer::from(&root).rank(rank);\n\n        for handler in vec![a, b] {\n            let routes: Vec<Route> = handler.into();\n            assert!(routes.iter().all(|route| route.rank == rank), \"{}\", rank);\n        }\n    }\n}\n\n#[test]\nfn test_forwarding() {\n    use rocket::{get, routes};\n\n    #[get(\"/<value>\", rank = 20)]\n    fn catch_one(value: String) -> String { value }\n\n    #[get(\"/<a>/<b>\", rank = 20)]\n    fn catch_two(a: &str, b: &str) -> String { format!(\"{}/{}\", a, b) }\n\n    let rocket = rocket().mount(\"/default\", routes![catch_one, catch_two]);\n    let client = Client::debug(rocket).expect(\"valid rocket\");\n\n    let response = client.get(\"/default/ireallydontexist\").dispatch();\n    assert_eq!(response.status(), Status::Ok);\n    assert_eq!(response.into_string().unwrap(), \"ireallydontexist\");\n\n    let response = client.get(\"/default/idont/exist\").dispatch();\n    assert_eq!(response.status(), Status::Ok);\n    assert_eq!(response.into_string().unwrap(), \"idont/exist\");\n\n    assert_all(&client, \"both\", REGULAR_FILES, true);\n    assert_all(&client, \"both\", HIDDEN_FILES, true);\n    assert_all(&client, \"both\", INDEXED_DIRECTORIES, true);\n}\n\n#[test]\nfn test_redirection() {\n    let client = Client::debug(rocket()).expect(\"valid rocket\");\n\n    // Redirection only happens if enabled, and doesn't affect index behavior.\n    let response = client.get(\"/no_index/inner\").dispatch();\n    assert_eq!(response.status(), Status::NotFound);\n\n    let response = client.get(\"/index/inner\").dispatch();\n    assert_eq!(response.status(), Status::Ok);\n\n    let response = client.get(\"/redir/inner\").dispatch();\n    assert_eq!(response.status(), Status::PermanentRedirect);\n    assert_eq!(response.headers().get(\"Location\").next(), Some(\"/redir/inner/\"));\n\n    let response = client.get(\"/redir/inner?foo=bar\").dispatch();\n    assert_eq!(response.status(), Status::PermanentRedirect);\n    assert_eq!(response.headers().get(\"Location\").next(), Some(\"/redir/inner/?foo=bar\"));\n\n    let response = client.get(\"/redir_index/inner\").dispatch();\n    assert_eq!(response.status(), Status::PermanentRedirect);\n    assert_eq!(response.headers().get(\"Location\").next(), Some(\"/redir_index/inner/\"));\n\n    // Paths with trailing slash are unaffected.\n    let response = client.get(\"/redir/inner/\").dispatch();\n    assert_eq!(response.status(), Status::NotFound);\n\n    let response = client.get(\"/redir_index/inner/\").dispatch();\n    assert_eq!(response.status(), Status::Ok);\n\n    // Root of route is also redirected.\n    let response = client.get(\"/no_index\").dispatch();\n    assert_eq!(response.status(), Status::NotFound);\n\n    let response = client.get(\"/index\").dispatch();\n    assert_eq!(response.status(), Status::Ok);\n\n    let response = client.get(\"/redir\").dispatch();\n    assert_eq!(response.status(), Status::PermanentRedirect);\n    assert_eq!(response.headers().get(\"Location\").next(), Some(\"/redir/\"));\n\n    let response = client.get(\"/redir_index\").dispatch();\n    assert_eq!(response.status(), Status::PermanentRedirect);\n    assert_eq!(response.headers().get(\"Location\").next(), Some(\"/redir_index/\"));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::request::FlashMessage;\nuse rocket::response::Flash;\n\nconst FLASH_MESSAGE: &str = \"Hey! I'm a flash message. :)\";\n\n#[post(\"/\")]\nfn set() -> Flash<&'static str> {\n    Flash::success(\"This is the page.\", FLASH_MESSAGE)\n}\n\n#[get(\"/unused\")]\nfn unused(flash: Option<FlashMessage<'_>>) -> Option<()> {\n    flash.map(|_| ())\n}\n\n#[get(\"/use\")]\nfn used(flash: Option<FlashMessage<'_>>) -> Option<String> {\n    flash.map(|f| f.message().into())\n}\n\nmod flash_lazy_remove_tests {\n    use rocket::local::blocking::Client;\n    use rocket::http::Status;\n\n    #[test]\n    fn test() {\n        use super::*;\n\n        // Ensure the cookie's not there at first.\n        let client = Client::debug_with(routes![set, unused, used]).unwrap();\n        let response = client.get(\"/unused\").dispatch();\n        assert_eq!(response.status(), Status::NotFound);\n\n        // Set the flash cookie.\n        client.post(\"/\").dispatch();\n\n        // Try once.\n        let response = client.get(\"/unused\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n\n        // Try again; should still be there.\n        let response = client.get(\"/unused\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n\n        // Now use it.\n        let response = client.get(\"/use\").dispatch();\n        assert_eq!(response.into_string(), Some(FLASH_MESSAGE.into()));\n\n        // Now it should be gone.\n        let response = client.get(\"/unused\").dispatch();\n        assert_eq!(response.status(), Status::NotFound);\n\n        // Still gone.\n        let response = client.get(\"/use\").dispatch();\n        assert_eq!(response.status(), Status::NotFound);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::fmt::Debug;\n\nuse rocket::form::{Form, FromForm};\nuse rocket::form::error::{Error, Errors, ErrorKind};\n\n#[derive(Debug, FromForm)]\n#[allow(dead_code)]\nstruct Cat<'v> {\n    #[field(validate = len(5..))]\n    name: &'v str,\n    #[field(validate = starts_with(\"kitty\"))]\n    nick: &'v str,\n}\n\n#[derive(Debug, FromForm)]\n#[allow(dead_code)]\nstruct Dog<'v> {\n    #[field(validate = len(5..))]\n    name: &'v str,\n}\n\n#[derive(Debug, FromForm)]\n#[allow(dead_code)]\nstruct Person<'v> {\n    kitty: Cat<'v>,\n    #[field(validate = len(1..))]\n    cats: Vec<Cat<'v>>,\n    dog: Dog<'v>,\n}\n\nfn starts_with<'v, S: AsRef<str>>(string: S, prefix: &str) -> Result<(), Errors<'v>> {\n    if !string.as_ref().starts_with(prefix) {\n        Err(Error::validation(format!(\"must start with {:?}\", prefix)))?\n    }\n\n    Ok(())\n}\n\n#[track_caller]\nfn errors<'v, T: FromForm<'v> + Debug + 'v>(string: &'v str) -> Errors<'v> {\n    Form::<T>::parse(string).expect_err(\"expected an error\")\n}\n\n#[test]\nfn test_form_validation_context() {\n    use ErrorKind::*;\n\n    fn count<'a, K>(c: &Errors<'_>, n: &str, kind: K, fuzz: bool) -> usize\n        where K: Into<Option<ErrorKind<'a>>>\n    {\n        let kind = kind.into();\n        c.iter().filter(|e| {\n            let matches = (fuzz && e.is_for(n)) || (!fuzz && e.is_for_exactly(n));\n            let kinded = kind.as_ref().map(|k| k == &e.kind).unwrap_or(true);\n            matches && kinded\n        }).count()\n    }\n\n    fn fuzzy<'a, K>(c: &Errors<'_>, n: &str, kind: K) -> usize\n        where K: Into<Option<ErrorKind<'a>>>\n    {\n        count(c, n, kind, true)\n    }\n\n    fn exact<'a, K>(c: &Errors<'_>, n: &str, kind: K) -> usize\n        where K: Into<Option<ErrorKind<'a>>>\n    {\n        count(c, n, kind, false)\n    }\n\n    let c = errors::<Cat>(\"name=littlebobby\");\n    assert_eq!(exact(&c, \"nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"nick\", None), 1);\n\n    let c = errors::<Person>(\"cats[0].name=Bob\");\n    assert_eq!(exact(&c, \"kitty\", None), 1);\n    assert_eq!(exact(&c, \"kitty\", Missing), 1);\n    assert_eq!(exact(&c, \"cats[0].nick\", None), 1);\n    assert_eq!(exact(&c, \"cats[0].nick\", Missing), 1);\n    assert_eq!(exact(&c, \"dog\", None), 1);\n    assert_eq!(exact(&c, \"dog\", Missing), 1);\n    assert_eq!(exact(&c, \"dog.name\", None), 0);\n    assert_eq!(exact(&c, \"kitty.name\", None), 0);\n    assert_eq!(exact(&c, \"kitty.nick\", None), 0);\n\n    assert_eq!(fuzzy(&c, \"kitty\", None), 1);\n    assert_eq!(fuzzy(&c, \"kitty.name\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"kitty.nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"cats[0].nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"dog.name\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"dog\", None), 1);\n\n    let c = errors::<Person>(\"cats[0].name=Bob&cats[0].nick=kit&kitty.name=Hi\");\n    assert_eq!(exact(&c, \"kitty.nick\", Missing), 1);\n    assert_eq!(exact(&c, \"kitty\", None), 0);\n    assert_eq!(exact(&c, \"dog\", Missing), 1);\n    assert_eq!(exact(&c, \"dog\", None), 1);\n    assert_eq!(exact(&c, \"cats[0].name\", None), 1);\n    assert_eq!(exact(&c, \"cats[0].name\", InvalidLength { min: Some(5), max: None }), 1);\n    assert_eq!(exact(&c, \"cats[0].nick\", None), 1);\n    assert_eq!(exact(&c, \"cats[0].nick\", Validation(\"must start with \\\"kitty\\\"\".into())), 1);\n\n    assert_eq!(fuzzy(&c, \"kitty.nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"kitty.nick\", None), 1);\n    assert_eq!(fuzzy(&c, \"kitty\", None), 0);\n    assert_eq!(fuzzy(&c, \"dog.name\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"dog\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"cats[0].nick\", None), 1);\n    assert_eq!(exact(&c, \"cats[0].name\", None), 1);\n\n    let c = errors::<Person>(\"kitty.name=Michael\");\n    assert_eq!(exact(&c, \"kitty.nick\", Missing), 1);\n    assert_eq!(exact(&c, \"dog\", Missing), 1);\n    assert_eq!(exact(&c, \"cats[0].name\", None), 0);\n    assert_eq!(exact(&c, \"cats[0].nick\", None), 0);\n\n    assert_eq!(exact(&c, \"cats\", None), 1);\n    assert_eq!(exact(&c, \"cats\", InvalidLength { min: Some(1), max: None }), 1);\n\n    assert_eq!(fuzzy(&c, \"kitty.nick\", Missing), 1);\n    assert_eq!(fuzzy(&c, \"kitty.nick\", None), 1);\n    assert_eq!(fuzzy(&c, \"dog\", None), 1);\n    assert_eq!(fuzzy(&c, \"dog.name\", Missing), 1);\n    assert_eq!(exact(&c, \"cats[0].name\", None), 0);\n    assert_eq!(exact(&c, \"cats[0].nick\", None), 0);\n\n    let c = errors::<Person>(\"kitty.name=Michael&kitty.nick=kittykat&dog.name=woofy\");\n    assert_eq!(c.iter().count(), 1);\n    assert_eq!(exact(&c, \"cats\", None), 1);\n    assert_eq!(exact(&c, \"cats\", InvalidLength { min: Some(1), max: None }), 1);\n    assert_eq!(fuzzy(&c, \"cats[0].name\", None), 1);\n}\n\n// #[derive(Debug, FromForm)]\n// struct Person<'v> {\n//     kitty: Cat<'v>,\n//     #[field(validate = len(1..))]\n//     cats: Vec<Cat<'v>>,\n//     dog: Dog<'v>,\n// }"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::form::Form;\n\n#[derive(FromForm)]\nstruct FormData {\n    form_data: String,\n}\n\n#[patch(\"/\", data = \"<form_data>\")]\nfn bug(form_data: Form<FormData>) -> &'static str {\n    assert_eq!(\"Form data\", form_data.into_inner().form_data);\n    \"OK\"\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::http::{Status, ContentType};\n\n    #[test]\n    fn method_eval() {\n        let client = Client::debug_with(routes![bug]).unwrap();\n        let response = client.post(\"/\")\n            .header(ContentType::Form)\n            .body(\"_method=patch&form_data=Form+data\")\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"OK\".into()));\n    }\n\n    #[test]\n    fn get_passes_through() {\n        let client = Client::debug_with(routes![bug]).unwrap();\n        let response = client.get(\"/\")\n            .header(ContentType::Form)\n            .body(\"_method=patch&form_data=Form+data\")\n            .dispatch();\n\n        assert_eq!(response.status(), Status::NotFound);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::form::Form;\n\n#[post(\"/\", data = \"<form_data>\")]\nfn bug(form_data: Form<String>) -> String {\n    form_data.into_inner()\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::http::ContentType;\n    use rocket::http::Status;\n\n    fn check_decoding(raw: &str, decoded: &str) {\n        let client = Client::debug_with(routes![bug]).unwrap();\n        let response = client.post(\"/\")\n            .header(ContentType::Form)\n            .body(format!(\"form_data={}\", raw))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(Some(decoded.to_string()), response.into_string());\n    }\n\n    #[test]\n    fn test_proper_decoding() {\n        check_decoding(\"password\", \"password\");\n        check_decoding(\"\", \"\");\n        check_decoding(\"+\", \" \");\n        check_decoding(\"%2B\", \"+\");\n        check_decoding(\"1+1\", \"1 1\");\n        check_decoding(\"1%2B1\", \"1+1\");\n        check_decoding(\"%3Fa%3D1%26b%3D2\", \"?a=1&b=2\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::net::{Ipv4Addr, Ipv6Addr, SocketAddrV4, SocketAddrV6};\n\nuse rocket::http::RawStr;\nuse rocket::form::Form;\n\nmacro_rules! assert_from_form_field_eq {\n    ($string:literal as $T:ty, $expected:expr) => (\n        let value_str = RawStr::new(concat!(\"=\", $string));\n        let value = Form::<$T>::parse_encoded(value_str).unwrap();\n        assert_eq!(value, $expected);\n    )\n}\n\n#[test]\nfn test_from_form_value_encoded() {\n    assert_from_form_field_eq!(\n        \"127.0.0.1%3A80\" as SocketAddrV4,\n        SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 80)\n    );\n\n    assert_from_form_field_eq!(\n        \"2001%3A0db8%3A85a3%3A0000%3A0000%3A8a2e%3A0370%3A7334\" as Ipv6Addr,\n        Ipv6Addr::new(0x2001, 0x0db8, 0x85a3, 0, 0, 0x8a2e, 0x0370, 0x7334)\n    );\n\n    assert_from_form_field_eq!(\n        \"%5B2001%3Adb8%3A%3A1%5D%3A8080\" as SocketAddrV6,\n        SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0)\n    );\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::http::Status;\nuse rocket::request::{self, Request, FromRequest};\n\nstruct Authenticated;\n\n#[rocket::async_trait]\nimpl<'r> FromRequest<'r> for Authenticated {\n    type Error = std::convert::Infallible;\n\n    async fn from_request(request: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n        if request.headers().contains(\"Authenticated\") {\n            request::Outcome::Success(Authenticated)\n        } else {\n            request::Outcome::Forward(Status::Unauthorized)\n        }\n    }\n}\n\nstruct TeapotForward;\n\n#[rocket::async_trait]\nimpl<'r> FromRequest<'r> for TeapotForward {\n    type Error = std::convert::Infallible;\n\n    async fn from_request(_: &'r Request<'_>) -> request::Outcome<Self, Self::Error> {\n        request::Outcome::Forward(Status::ImATeapot)\n    }\n}\n\n#[get(\"/auth\")]\nfn auth(_name: Authenticated) -> &'static str {\n    \"Protected\"\n}\n\n#[get(\"/auth\", rank = 2)]\nfn public() -> &'static str {\n    \"Public\"\n}\n\n#[get(\"/auth\", rank = 3)]\nfn teapot(_teapot: TeapotForward) -> &'static str {\n    \"Protected\"\n}\n\n#[get(\"/need-auth\")]\nfn auth_needed(_auth: Authenticated) -> &'static str {\n    \"Have Auth\"\n}\n\n#[catch(401)]\nfn catcher() -> &'static str {\n    \"Custom Catcher\"\n}\n\nmod tests {\n    use super::*;\n    use rocket::routes;\n    use rocket::local::blocking::Client;\n    use rocket::http::{Header, Status};\n\n    #[test]\n    fn authorized_forwards() {\n        let client = Client::debug_with(routes![auth, public, auth_needed]).unwrap();\n\n        let response = client.get(\"/auth\")\n            .header(Header::new(\"Authenticated\", \"true\"))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string().unwrap(), \"Protected\");\n\n        let response = client.get(\"/auth\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string().unwrap(), \"Public\");\n\n        let response = client.get(\"/need-auth\")\n            .header(Header::new(\"Authenticated\", \"true\"))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string().unwrap(), \"Have Auth\");\n\n        let response = client.get(\"/need-auth\").dispatch();\n        assert_eq!(response.status(), Status::Unauthorized);\n        assert!(response.into_string().unwrap().contains(\"Rocket\"));\n    }\n\n    #[test]\n    fn unauthorized_custom_catcher() {\n        let rocket = rocket::build()\n            .mount(\"/\", routes![auth_needed])\n            .register(\"/\", catchers![catcher]);\n\n        let client = Client::debug(rocket).unwrap();\n        let response = client.get(\"/need-auth\").dispatch();\n        assert_eq!(response.status(), Status::Unauthorized);\n        assert_eq!(response.into_string().unwrap(), \"Custom Catcher\");\n    }\n\n    #[test]\n    fn use_last_forward() {\n        let client = Client::debug_with(routes![auth, teapot]).unwrap();\n        let response = client.get(\"/auth\").dispatch();\n        assert_eq!(response.status(), Status::ImATeapot);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::http::Status;\nuse rocket::response::content::RawJson;\n\n#[get(\"/empty\")]\nfn empty() -> Status {\n    Status::NoContent\n}\n\n#[get(\"/\")]\nfn index() -> &'static str {\n    \"Hello, world!\"\n}\n\n#[head(\"/other\")]\nfn other() -> RawJson<&'static str> {\n    RawJson(\"{ 'hi': 'hello' }\")\n}\n\nmod head_handling_tests {\n    use super::*;\n\n    use rocket::Route;\n    use rocket::local::blocking::Client;\n    use rocket::http::{Status, ContentType};\n\n    fn routes() -> Vec<Route> {\n        routes![index, empty, other]\n    }\n\n    #[test]\n    fn auto_head() {\n        let client = Client::debug_with(routes()).unwrap();\n        let response = client.head(\"/\").dispatch();\n\n        let content_type: Vec<_> = response.headers().get(\"Content-Type\").collect();\n        assert_eq!(content_type, vec![ContentType::Plain.to_string()]);\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.body().preset_size(), Some(13));\n        assert!(response.into_bytes().unwrap().is_empty());\n\n        let response = client.head(\"/empty\").dispatch();\n        assert_eq!(response.status(), Status::NoContent);\n        assert!(response.into_bytes().is_none());\n    }\n\n    #[test]\n    fn user_head() {\n        let client = Client::debug_with(routes()).unwrap();\n        let response = client.head(\"/other\").dispatch();\n\n        let content_type: Vec<_> = response.headers().get(\"Content-Type\").collect();\n        assert_eq!(content_type, vec![ContentType::JSON.to_string()]);\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.body().preset_size(), Some(17));\n        assert!(response.into_bytes().unwrap().is_empty());\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use serde::{Serialize, Deserialize};\nuse figment::{Figment, providers::Serialized};\nuse pretty_assertions::assert_eq;\n\nuse rocket::{Config, uri};\nuse rocket::http::uri::{Absolute, Asterisk, Authority, Origin, Reference};\nuse rocket::http::{Method, Status};\n\n#[derive(PartialEq, Debug, Serialize, Deserialize)]\nstruct UriContainer<'a> {\n    asterisk: Asterisk,\n    origin: Origin<'a>,\n    authority: Authority<'a>,\n    absolute: Absolute<'a>,\n    reference: Reference<'a>,\n}\n\n#[derive(PartialEq, Debug, Serialize, Deserialize)]\nstruct UriContainerOwned {\n    asterisk: Asterisk,\n    origin: Origin<'static>,\n    authority: Authority<'static>,\n    absolute: Absolute<'static>,\n    reference: Reference<'static>,\n}\n\n#[derive(PartialEq, Debug, Serialize, Deserialize)]\nstruct MethodContainer {\n    mget: Method,\n    mput: Method,\n    mpost: Method,\n}\n\n#[derive(PartialEq, Debug, Serialize, Deserialize)]\nstruct StatusContainer {\n    a: Status,\n    b: Status,\n    c: Status,\n}\n\n#[test]\nfn uri_serde() {\n    figment::Jail::expect_with(|jail| {\n        jail.create_file(\"Rocket.toml\", r#\"\n            [default]\n            asterisk = \"*\"\n            origin = \"/foo/bar?baz\"\n            authority = \"user:pass@rocket.rs:80\"\n            absolute = \"https://rocket.rs/foo/bar\"\n            reference = \"https://rocket.rs:8000/index.html\"\n        \"#)?;\n\n        let uris: UriContainer<'_> = Config::figment().extract()?;\n        assert_eq!(uris, UriContainer {\n            asterisk: Asterisk,\n            origin: uri!(\"/foo/bar?baz\"),\n            authority: uri!(\"user:pass@rocket.rs:80\"),\n            absolute: uri!(\"https://rocket.rs/foo/bar\"),\n            reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n        });\n\n        let uris: UriContainerOwned = Config::figment().extract()?;\n        assert_eq!(uris, UriContainerOwned {\n            asterisk: Asterisk,\n            origin: uri!(\"/foo/bar?baz\"),\n            authority: uri!(\"user:pass@rocket.rs:80\"),\n            absolute: uri!(\"https://rocket.rs/foo/bar\"),\n            reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n        });\n\n        Ok(())\n    });\n}\n\n#[test]\nfn uri_serde_round_trip() {\n    let tmp = Figment::from(Serialized::defaults(UriContainer {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    }));\n\n    let uris: UriContainer<'_> = tmp.extract().unwrap();\n    assert_eq!(uris, UriContainer {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    });\n\n    let uris: UriContainerOwned = tmp.extract().unwrap();\n    assert_eq!(uris, UriContainerOwned {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    });\n\n    let tmp = Figment::from(Serialized::defaults(UriContainerOwned {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    }));\n\n    let uris: UriContainer<'_> = tmp.extract().unwrap();\n    assert_eq!(uris, UriContainer {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    });\n\n    let uris: UriContainerOwned = tmp.extract().unwrap();\n    assert_eq!(uris, UriContainerOwned {\n        asterisk: Asterisk,\n        origin: uri!(\"/foo/bar?baz\"),\n        authority: uri!(\"user:pass@rocket.rs:80\"),\n        absolute: uri!(\"https://rocket.rs/foo/bar\"),\n        reference: uri!(\"https://rocket.rs:8000/index.html\").into(),\n    });\n}\n\n#[test]\nfn method_serde() {\n    figment::Jail::expect_with(|jail| {\n        jail.create_file(\"Rocket.toml\", r#\"\n            [default]\n            mget = \"GET\"\n            mput = \"PuT\"\n            mpost = \"post\"\n        \"#)?;\n\n        let methods: MethodContainer = Config::figment().extract()?;\n        assert_eq!(methods, MethodContainer {\n            mget: Method::Get,\n            mput: Method::Put,\n            mpost: Method::Post\n        });\n\n        let tmp = Figment::from(Serialized::defaults(methods));\n        let methods: MethodContainer = tmp.extract()?;\n        assert_eq!(methods, MethodContainer {\n            mget: Method::Get,\n            mput: Method::Put,\n            mpost: Method::Post\n        });\n\n        Ok(())\n    });\n}\n\n#[test]\nfn status_serde() {\n    figment::Jail::expect_with(|jail| {\n        jail.create_file(\"Rocket.toml\", r#\"\n            [default]\n            a = 500\n            b = 100\n            c = 404\n        \"#)?;\n\n        let statuses: StatusContainer = Config::figment().extract()?;\n        assert_eq!(statuses, StatusContainer {\n            a: Status::InternalServerError,\n            b: Status::Continue,\n            c: Status::NotFound\n        });\n\n        let tmp = Figment::from(Serialized::defaults(statuses));\n        let statuses: StatusContainer = tmp.extract()?;\n        assert_eq!(statuses, StatusContainer {\n            a: Status::InternalServerError,\n            b: Status::Continue,\n            c: Status::NotFound\n        });\n\n        jail.create_file(\"Rocket.toml\", r#\"\n            [default]\n            a = 99\n            b = 100\n            c = 404\n        \"#)?;\n\n        let statuses: Result<StatusContainer, _> = Config::figment().extract();\n        assert!(statuses.is_err());\n\n        jail.create_file(\"Rocket.toml\", r#\"\n            [default]\n            a = 500\n            b = 100\n            c = 600\n        \"#)?;\n\n        let statuses: Result<StatusContainer, _> = Config::figment().extract();\n        assert!(statuses.is_err());\n\n        Ok(())\n    });\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::fairing::AdHoc;\n\n#[rocket::async_test]\nasync fn test_inspectable_launch_state() -> Result<(), rocket::Error> {\n    let rocket = rocket::custom(rocket::Config::debug_default())\n        .attach(AdHoc::on_ignite(\"Add State\", |rocket| async {\n            rocket.manage(\"Hi!\")\n        }))\n        .ignite()\n        .await?;\n\n    let state = rocket.state::<&'static str>();\n    assert_eq!(state, Some(&\"Hi!\"));\n    Ok(())\n}\n\n#[rocket::async_test]\nasync fn test_inspectable_launch_state_in_liftoff() -> Result<(), rocket::Error> {\n    let rocket = rocket::custom(rocket::Config::debug_default())\n        .attach(AdHoc::on_ignite(\"Add State\", |rocket| async {\n            rocket.manage(\"Hi!\")\n        }))\n        .attach(AdHoc::on_ignite(\"Inspect State\", |rocket| async {\n            let state = rocket.state::<&'static str>();\n            assert_eq!(state, Some(&\"Hi!\"));\n            rocket\n        }))\n        .attach(AdHoc::on_liftoff(\"Inspect State\", |rocket| Box::pin(async move {\n            let state = rocket.state::<&'static str>();\n            assert_eq!(state, Some(&\"Hi!\"));\n        })))\n        .ignite()\n        .await?;\n\n    let state = rocket.state::<&'static str>();\n    assert_eq!(state, Some(&\"Hi!\"));\n    Ok(())\n}\n\n#[rocket::async_test]\nasync fn test_launch_state_is_well_ordered() -> Result<(), rocket::Error> {\n    let rocket = rocket::custom(rocket::Config::debug_default())\n        .attach(AdHoc::on_ignite(\"Inspect State Pre\", |rocket| async {\n            let state = rocket.state::<&'static str>();\n            assert_eq!(state, None);\n            rocket\n        }))\n        .attach(AdHoc::on_ignite(\"Add State\", |rocket| async {\n            rocket.manage(\"Hi!\")\n        }))\n        .attach(AdHoc::on_ignite(\"Inspect State\", |rocket| async {\n            let state = rocket.state::<&'static str>();\n            assert_eq!(state, Some(&\"Hi!\"));\n            rocket\n        }))\n        .ignite()\n        .await?;\n\n    let state = rocket.state::<&'static str>();\n    assert_eq!(state, Some(&\"Hi!\"));\n    Ok(())\n}\n\n#[should_panic]\n#[rocket::async_test]\nasync fn negative_test_launch_state() {\n    let _ = rocket::custom(rocket::Config::debug_default())\n        .attach(AdHoc::on_ignite(\"Add State\", |rocket| async {\n            rocket.manage(\"Hi!\")\n        }))\n        .attach(AdHoc::on_ignite(\"Inspect State\", |rocket| async {\n            let state = rocket.state::<&'static str>();\n            assert_ne!(state, Some(&\"Hi!\"));\n            rocket\n        }))\n        .ignite()\n        .await;\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::form::Form;\n\n#[post(\"/\", data = \"<form>\")]\nfn index(form: Form<String>) -> String {\n    form.into_inner()\n}\n\nmod limits_tests {\n    use rocket::{Rocket, Build};\n    use rocket::local::blocking::Client;\n    use rocket::http::{Status, ContentType};\n    use rocket::data::Limits;\n\n    fn rocket_with_forms_limit(limit: u64) -> Rocket<Build> {\n        let mut config = rocket::Config::debug_default();\n        config.limits = Limits::default().limit(\"form\", limit.into());\n        rocket::custom(config).mount(\"/\", routes![super::index])\n    }\n\n    #[test]\n    fn large_enough() {\n        let client = Client::debug(rocket_with_forms_limit(128)).unwrap();\n        let response = client.post(\"/\")\n            .body(\"value=Hello+world\")\n            .header(ContentType::Form)\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"Hello world\".into()));\n    }\n\n    #[test]\n    fn just_large_enough() {\n        let client = Client::debug(rocket_with_forms_limit(17)).unwrap();\n        let response = client.post(\"/\")\n            .body(\"value=Hello+world\")\n            .header(ContentType::Form)\n            .dispatch();\n\n        assert_eq!(response.into_string(), Some(\"Hello world\".into()));\n    }\n\n    #[test]\n    fn much_too_small() {\n        let client = Client::debug(rocket_with_forms_limit(4)).unwrap();\n        let response = client.post(\"/\")\n            .body(\"value=Hello+world\")\n            .header(ContentType::Form)\n            .dispatch();\n\n        assert_eq!(response.status(), Status::PayloadTooLarge);\n    }\n\n    #[test]\n    fn contracted() {\n        let client = Client::debug(rocket_with_forms_limit(10)).unwrap();\n        let response = client.post(\"/\")\n            .body(\"value=Hello+world\")\n            .header(ContentType::Form)\n            .dispatch();\n\n        assert_eq!(response.status(), Status::PayloadTooLarge);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::local::blocking::Client;\n\nstruct SpawnBlockingOnDrop;\n\nimpl Drop for SpawnBlockingOnDrop {\n    fn drop(&mut self) {\n        rocket::tokio::task::spawn_blocking(|| ());\n    }\n}\n\n#[test]\nfn test_access_runtime_in_state_drop() {\n    Client::debug(rocket::build().manage(SpawnBlockingOnDrop)).unwrap();\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"json\")]\n\n#[macro_use] extern crate rocket;\n\nuse rocket::serde::json::Json;\n\n#[get(\"/int\")] fn int() -> Json<i32> { Json(5) }\n#[get(\"/nil\")] fn nil() -> Json<()> { Json(()) }\n\n#[async_test]\nasync fn async_json_works() {\n    use rocket::local::asynchronous::Client;\n\n    let client = Client::debug_with(routes![int, nil]).await.unwrap();\n\n    let int0 = client.get(\"/int\").dispatch().await.into_json::<u32>().await;\n    let int1 = client.get(\"/int\").dispatch().await.into_json::<i32>().await;\n\n    assert_eq!(int0, Some(5));\n    assert_eq!(int1, Some(5));\n\n    let nil0 = client.get(\"/nil\").dispatch().await.into_json::<()>().await;\n    assert_eq!(nil0, Some(()));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::{Request, Data};\nuse rocket::request::{self, FromRequest};\nuse rocket::outcome::IntoOutcome;\nuse rocket::http::Status;\n\nstruct HasContentType;\n\n#[rocket::async_trait]\nimpl<'r> FromRequest<'r> for HasContentType {\n    type Error = ();\n\n    async fn from_request(req: &'r Request<'_>) -> request::Outcome<Self, ()> {\n        req.content_type().map(|_| HasContentType).or_forward(Status::NotFound)\n    }\n}\n\nuse rocket::data::{self, FromData};\n\n#[rocket::async_trait]\nimpl<'r> FromData<'r> for HasContentType {\n    type Error = ();\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> data::Outcome<'r, Self> {\n        req.content_type().map(|_| HasContentType).or_forward((data, Status::NotFound))\n    }\n}\n\n#[post(\"/\")]\nfn rg_ct(ct: Option<HasContentType>) -> &'static str {\n    ct.map_or(\"Absent\", |_| \"Present\")\n}\n\n#[post(\"/data\", data = \"<_ct>\", rank = 1)]\nfn data_has_ct(_ct: HasContentType) -> &'static str {\n    \"Data Present\"\n}\n\n#[post(\"/data\", rank = 2)]\nfn data_no_ct() -> &'static str {\n    \"Data Absent\"\n}\n\nmod local_request_content_type_tests {\n    use super::*;\n\n    use rocket::{Rocket, Build};\n    use rocket::local::blocking::Client;\n    use rocket::http::ContentType;\n\n    fn rocket() -> Rocket<Build> {\n        rocket::build().mount(\"/\", routes![rg_ct, data_has_ct, data_no_ct])\n    }\n\n    #[test]\n    fn has_no_ct() {\n        let client = Client::debug(rocket()).unwrap();\n\n        let req = client.post(\"/\");\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Absent\".to_string()));\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Absent\".to_string()));\n        assert_eq!(req.dispatch().into_string(), Some(\"Absent\".to_string()));\n\n        let req = client.post(\"/data\");\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Data Absent\".to_string()));\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Data Absent\".to_string()));\n        assert_eq!(req.dispatch().into_string(), Some(\"Data Absent\".to_string()));\n    }\n\n    #[test]\n    fn has_ct() {\n        let client = Client::debug(rocket()).unwrap();\n\n        let req = client.post(\"/\").header(ContentType::JSON);\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Present\".to_string()));\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Present\".to_string()));\n        assert_eq!(req.dispatch().into_string(), Some(\"Present\".to_string()));\n\n        let req = client.post(\"/data\").header(ContentType::JSON);\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Data Present\".to_string()));\n        assert_eq!(req.clone().dispatch().into_string(), Some(\"Data Present\".to_string()));\n        assert_eq!(req.dispatch().into_string(), Some(\"Data Present\".to_string()));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"secrets\")]\n\nuse rocket::http::CookieJar;\n\n#[rocket::get(\"/\")]\nfn return_private_cookie(cookies: &CookieJar<'_>) -> Option<String> {\n    match cookies.get_private(\"cookie_name\") {\n        Some(cookie) => Some(cookie.value().into()),\n        None => None,\n    }\n}\n\nmod tests {\n    use super::*;\n    use rocket::routes;\n    use rocket::local::blocking::Client;\n    use rocket::http::Status;\n\n    #[test]\n    fn private_cookie_is_returned() {\n        let rocket = rocket::build().mount(\"/\", routes![return_private_cookie]);\n\n        let client = Client::debug(rocket).unwrap();\n        let req = client.get(\"/\").private_cookie((\"cookie_name\", \"cookie_value\"));\n        let response = req.dispatch();\n\n        assert_eq!(response.headers().get_one(\"Set-Cookie\"), None);\n        assert_eq!(response.into_string(), Some(\"cookie_value\".into()));\n    }\n\n    #[test]\n    fn regular_cookie_is_not_returned() {\n        let rocket = rocket::build().mount(\"/\", routes![return_private_cookie]);\n\n        let client = Client::debug(rocket).unwrap();\n        let req = client.get(\"/\").cookie((\"cookie_name\", \"cookie_value\"));\n        let response = req.dispatch();\n\n        assert_eq!(response.status(), Status::NotFound);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\nuse rocket::{Rocket, Route, Build};\n\npub fn prepend(prefix: &str, route: Route) -> Route {\n    route.map_base(|base| format!(\"{}{}\", prefix, base)).unwrap()\n}\n\npub fn extend_routes(prefix: &str, routes: Vec<Route>) -> Vec<Route> {\n    routes.into_iter()\n        .map(|route| prepend(prefix, route))\n        .collect()\n}\n\nmod a {\n    #[get(\"/b/<id>\")]\n    fn b(id: u8) -> String { id.to_string() }\n\n    pub fn routes() -> Vec<rocket::Route> {\n        super::extend_routes(\"/a\", routes![b])\n    }\n}\n\nfn rocket() -> Rocket<Build> {\n    rocket::build().mount(\"/\", a::routes()).mount(\"/foo\", a::routes())\n}\n\nmod mapped_base_tests {\n    use rocket::local::blocking::Client;\n    use rocket::http::Status;\n\n    #[test]\n    fn only_prefix() {\n        let client = Client::debug(super::rocket()).unwrap();\n\n        let response = client.get(\"/a/b/3\").dispatch();\n        assert_eq!(response.into_string().unwrap(), \"3\");\n\n        let response = client.get(\"/a/b/239\").dispatch();\n        assert_eq!(response.into_string().unwrap(), \"239\");\n\n        let response = client.get(\"/b/239\").dispatch();\n        assert_eq!(response.status(), Status::NotFound);\n    }\n\n    #[test]\n    fn prefix_and_base() {\n        let client = Client::debug(super::rocket()).unwrap();\n\n        let response = client.get(\"/foo/a/b/23\").dispatch();\n        assert_eq!(response.into_string().unwrap(), \"23\");\n\n        let response = client.get(\"/foo/a/b/99\").dispatch();\n        assert_eq!(response.into_string().unwrap(), \"99\");\n\n        let response = client.get(\"/foo/b/239\").dispatch();\n        assert_eq!(response.status(), Status::NotFound);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[test]\n#[should_panic]\nfn bad_dynamic_mount() {\n    let _ = rocket::build().mount(\"<name>\", vec![]);\n}\n\n#[test]\nfn good_static_mount() {\n    let _ = rocket::build().mount(\"/abcdefghijkl_mno\", vec![]);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::{Config, Build, Rocket};\nuse rocket::{data::Limits, form::Form};\nuse rocket::http::{ContentType, Status};\nuse ubyte::{ToByteUnit, ByteUnit};\n\n#[derive(FromForm)]\nstruct Data<'r> {\n    foo: Option<&'r str>,\n}\n\n#[rocket::post(\"/\", data = \"<form>\")]\nfn form<'r>(form: Form<Data<'r>>) -> &'r str {\n    form.foo.unwrap_or(\"missing\")\n}\n\nfn rocket_with_form_data_limit(limit: ByteUnit) -> Rocket<Build> {\n    rocket::custom(Config {\n        limits: Limits::default().limit(\"data-form\", limit),\n        ..Config::debug_default()\n    }).mount(\"/\", routes![form])\n}\n\n#[test]\nfn test_multipart_limit() {\n    use rocket::local::blocking::Client;\n\n    let body = &[\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"foo\"; filename=\"foo.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"hi\",\n        \"--X-BOUNDARY--\",\n        \"\",\n    ].join(\"\\r\\n\");\n\n    let client = Client::debug(rocket_with_form_data_limit(body.len().bytes())).unwrap();\n    let response = client.post(\"/\")\n        .header(\"multipart/form-data; boundary=X-BOUNDARY\".parse::<ContentType>().unwrap())\n        .body(body)\n        .dispatch();\n\n    assert_eq!(response.into_string().unwrap(), \"hi\");\n\n    let client = Client::debug(rocket_with_form_data_limit(body.len().bytes() - 1)).unwrap();\n    let response = client.post(\"/\")\n        .header(\"multipart/form-data; boundary=X-BOUNDARY\".parse::<ContentType>().unwrap())\n        .body(body)\n        .dispatch();\n\n    assert_eq!(response.status(), Status::PayloadTooLarge);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\nuse rocket::{Rocket, State, Build};\nuse rocket::fairing::AdHoc;\nuse rocket::http::Method;\n\n#[derive(Default)]\nstruct Counter {\n    attach: AtomicUsize,\n    get: AtomicUsize,\n}\n\n#[get(\"/\")]\nfn index(counter: &State<Counter>) -> String {\n    let attaches = counter.attach.load(Ordering::Relaxed);\n    let gets = counter.get.load(Ordering::Acquire);\n    format!(\"{}, {}\", attaches, gets)\n}\n\nfn rocket() -> Rocket<Build> {\n    rocket::build()\n        .mount(\"/\", routes![index])\n        .attach(AdHoc::on_ignite(\"Outer\", |rocket| async {\n            let counter = Counter::default();\n            counter.attach.fetch_add(1, Ordering::Relaxed);\n            let rocket = rocket.manage(counter)\n                .attach(AdHoc::on_request(\"Inner\", |req, _| {\n                    Box::pin(async move {\n                        if req.method() == Method::Get {\n                            let counter = req.rocket().state::<Counter>().unwrap();\n                            counter.get.fetch_add(1, Ordering::Release);\n                        }\n                    })\n                }));\n\n            rocket\n        }))\n}\n\nmod nested_fairing_attaches_tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn test_counts() {\n        let client = Client::debug(rocket()).unwrap();\n        let response = client.get(\"/\").dispatch();\n        assert_eq!(response.into_string(), Some(\"1, 1\".into()));\n\n        let response = client.get(\"/\").dispatch();\n        assert_eq!(response.into_string(), Some(\"1, 2\".into()));\n\n        client.get(\"/\").dispatch();\n        client.get(\"/\").dispatch();\n        let response = client.get(\"/\").dispatch();\n        assert_eq!(response.into_string(), Some(\"1, 5\".into()));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::config::Config;\nuse rocket::fairing::AdHoc;\nuse rocket::futures::channel::oneshot;\n\n#[rocket::async_test]\nasync fn on_ignite_fairing_can_inspect_port() {\n    let (tx, rx) = oneshot::channel();\n    let rocket = rocket::custom(Config { port: 0, ..Config::debug_default() })\n        .attach(AdHoc::on_liftoff(\"Send Port -> Channel\", move |rocket| {\n            Box::pin(async move {\n                tx.send(rocket.config().port).unwrap();\n            })\n        }));\n\n    rocket::tokio::spawn(rocket.launch());\n    assert_ne!(rx.await.unwrap(), 0);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::{Request, Rocket, Route, Catcher, Build, route, catcher};\nuse rocket::data::Data;\nuse rocket::http::{Method, Status};\nuse rocket::local::blocking::Client;\n\n#[get(\"/panic\")]\nfn panic_route() -> &'static str {\n    panic!(\"Panic in route\")\n}\n\n#[catch(404)]\nfn panic_catcher() -> &'static str {\n    panic!(\"Panic in catcher\")\n}\n\n#[catch(500)]\nfn ise() -> &'static str {\n    \"Hey, sorry! :(\"\n}\n\nfn pre_future_route<'r>(_: &'r Request<'_>, _: Data<'r>) -> route::BoxFuture<'r> {\n    panic!(\"hey now...\");\n}\n\nfn rocket() -> Rocket<Build> {\n    rocket::build()\n        .mount(\"/\", routes![panic_route])\n        .mount(\"/\", vec![Route::new(Method::Get, \"/pre\", pre_future_route)])\n}\n\n#[test]\nfn catches_route_panic() {\n    let rocket = rocket().register(\"/\", catchers![panic_catcher, ise]);\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/panic\").dispatch();\n    assert_eq!(response.status(), Status::InternalServerError);\n    assert_eq!(response.into_string().unwrap(), \"Hey, sorry! :(\");\n}\n\n#[test]\nfn catches_catcher_panic() {\n    let rocket = rocket().register(\"/\", catchers![panic_catcher, ise]);\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/noroute\").dispatch();\n    assert_eq!(response.status(), Status::InternalServerError);\n    assert_eq!(response.into_string().unwrap(), \"Hey, sorry! :(\");\n}\n\n#[test]\nfn catches_double_panic() {\n    #[catch(500)]\n    fn double_panic() {\n        panic!(\"so, so sorry...\")\n    }\n\n    let rocket = rocket().register(\"/\", catchers![panic_catcher, double_panic]);\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/noroute\").dispatch();\n    assert_eq!(response.status(), Status::InternalServerError);\n    assert!(response.into_string().unwrap().contains(\"Rocket\"));\n}\n\n#[test]\nfn catches_early_route_panic() {\n    let rocket = rocket().register(\"/\", catchers![panic_catcher, ise]);\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/pre\").dispatch();\n    assert_eq!(response.status(), Status::InternalServerError);\n    assert_eq!(response.into_string().unwrap(), \"Hey, sorry! :(\");\n}\n\n#[test]\nfn catches_early_catcher_panic() {\n    fn pre_future_catcher<'r>(_: Status, _: &'r Request) -> catcher::BoxFuture<'r> {\n        panic!(\"a panicking pre-future catcher\")\n    }\n\n    let rocket = rocket()\n        .register(\"/\", vec![Catcher::new(404, pre_future_catcher)])\n        .register(\"/\", catchers![ise]);\n\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/idontexist\").dispatch();\n    assert_eq!(response.status(), Status::InternalServerError);\n    assert_eq!(response.into_string().unwrap(), \"Hey, sorry! :(\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\n#[post(\"/\", format = \"application/json\")]\nfn specified() -> &'static str {\n    \"specified\"\n}\n\n#[post(\"/\", rank = 2)]\nfn unspecified() -> &'static str {\n    \"unspecified\"\n}\n\n#[post(\"/\", format = \"application/json\")]\nfn specified_json() -> &'static str {\n    \"specified_json\"\n}\n\n#[post(\"/\", format = \"text/html\")]\nfn specified_html() -> &'static str {\n    \"specified_html\"\n}\n\nmod tests {\n    use super::*;\n\n    use rocket::{Rocket, Build};\n    use rocket::local::blocking::Client;\n    use rocket::http::{Status, ContentType};\n\n    fn rocket() -> Rocket<Build> {\n        rocket::build()\n            .mount(\"/first\", routes![specified, unspecified])\n            .mount(\"/second\", routes![specified_json, specified_html])\n    }\n\n    macro_rules! check_dispatch {\n        ($mount:expr, $ct:expr, $body:expr) => (\n            let client = Client::debug(rocket()).unwrap();\n            let mut req = client.post($mount);\n            let ct: Option<ContentType> = $ct;\n            if let Some(ct) = ct {\n                req.add_header(ct);\n            }\n\n            let response = req.dispatch();\n            let status = response.status();\n            let body_str = response.into_string();\n            let body: Option<&'static str> = $body;\n            match body {\n                Some(string) => assert_eq!(body_str, Some(string.to_string())),\n                None => assert_eq!(status, Status::NotFound)\n            }\n        )\n    }\n\n    #[test]\n    fn exact_match_or_forward() {\n        check_dispatch!(\"/first\", Some(ContentType::JSON), Some(\"specified\"));\n        check_dispatch!(\"/first\", None, Some(\"unspecified\"));\n        check_dispatch!(\"/first\", Some(ContentType::HTML), Some(\"unspecified\"));\n    }\n\n    #[test]\n    fn exact_match_or_none() {\n        check_dispatch!(\"/second\", Some(ContentType::JSON), Some(\"specified_json\"));\n        check_dispatch!(\"/second\", Some(ContentType::HTML), Some(\"specified_html\"));\n        check_dispatch!(\"/second\", Some(ContentType::CSV), None);\n        check_dispatch!(\"/second\", None, None);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::form::Form;\nuse rocket::http::ContentType;\nuse rocket::local::blocking::Client;\n\n#[derive(FromForm)]\nstruct Data<'r> {\n    foo: &'r str,\n    bar: &'r str,\n    baz: &'r str,\n}\n\n#[rocket::post(\"/\", data = \"<form>\")]\nfn form(form: Form<Data<'_>>) -> String {\n    form.foo.to_string() + form.bar + form.baz\n}\n\n#[test]\nfn test_multipart_raw_strings_from_files() {\n    let body = &[\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"foo\"; filename=\"foo.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"hi\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"bar\"; filename=\"bar.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"hey\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"baz\"; filename=\"baz.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"bye\",\n        \"--X-BOUNDARY--\",\n        \"\",\n    ].join(\"\\r\\n\");\n\n    let client = Client::debug_with(rocket::routes![form]).unwrap();\n    let response = client.post(\"/\")\n        .header(\"multipart/form-data; boundary=X-BOUNDARY\".parse::<ContentType>().unwrap())\n        .body(body)\n        .dispatch();\n\n    assert_eq!(response.into_string().unwrap(), \"hiheybye\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::{Rocket, Build, Config};\nuse rocket::fairing::{self, Fairing, Info, Kind};\nuse rocket::error::ErrorKind;\n\nstruct Singleton(Kind, Kind, bool);\n\n#[rocket::async_trait]\nimpl Fairing for Singleton {\n    fn info(&self) -> Info {\n        Info {\n            name: \"Singleton\",\n            kind: self.0\n        }\n    }\n\n    async fn on_ignite(&self, rocket: Rocket<Build>) -> fairing::Result {\n        if self.2 {\n            Ok(rocket.attach(Singleton(self.1, self.1, false)))\n        } else {\n            Ok(rocket)\n        }\n    }\n}\n\n\n// Have => two `Singleton`s. This is okay; we keep the latter.\n#[rocket::async_test]\nasync fn recursive_singleton_ok() {\n    let result = rocket::custom(Config::debug_default())\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .ignite()\n        .await;\n\n    assert!(result.is_ok(), \"{:?}\", result);\n\n    let result = rocket::custom(Config::debug_default())\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, false))\n        .ignite()\n        .await;\n\n    assert!(result.is_ok(), \"{:?}\", result);\n}\n\n// Have a `Singleton` add itself `on_ignite()`. Since it already ran, the one it\n// adds can't be unique, so ensure we error in this case.\n#[rocket::async_test]\nasync fn recursive_singleton_bad() {\n    #[track_caller]\n    fn assert_err(error: rocket::Error) {\n        if let ErrorKind::FailedFairings(v) = error.kind() {\n            assert_eq!(v.len(), 1);\n            assert_eq!(v[0].name, \"Singleton\");\n        } else {\n            panic!(\"unexpected error: {:?}\", error);\n        }\n    }\n\n    let result = rocket::custom(Config::debug_default())\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Ignite | Kind::Singleton, true))\n        .ignite()\n        .await;\n\n    assert_err(result.unwrap_err());\n\n    let result = rocket::custom(Config::debug_default())\n        .attach(Singleton(Kind::Ignite | Kind::Singleton, Kind::Singleton, true))\n        .ignite()\n        .await;\n\n    assert_err(result.unwrap_err());\n\n    let result = rocket::custom(Config::debug_default())\n        .attach(Singleton(Kind::Ignite, Kind::Singleton, true))\n        .ignite()\n        .await;\n\n    assert_err(result.unwrap_err());\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::response::Redirect;\n\n#[catch(404)]\nfn not_found() -> Redirect {\n    Redirect::to(\"/\")\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::http::Status;\n\n    #[test]\n    fn error_catcher_redirect() {\n        let client = Client::debug(rocket::build().register(\"/\", catchers![not_found])).unwrap();\n        let response = client.get(\"/unknown\").dispatch();\n\n        let location: Vec<_> = response.headers().get(\"location\").collect();\n        assert_eq!(response.status(), Status::SeeOther);\n        assert_eq!(location, vec![\"/\"]);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::{Rocket, Build};\nuse rocket::{fairing::AdHoc, http::ContentType, local::blocking::Client};\n\n#[rocket::post(\"/\", data = \"<_data>\", format = \"json\")]\nfn index(_data: rocket::Data<'_>) -> &'static str { \"json\" }\n\n#[rocket::post(\"/\", data = \"<_data>\", rank = 2)]\nfn other_index(_data: rocket::Data<'_>) -> &'static str { \"other\" }\n\nfn rocket() -> Rocket<Build> {\n    rocket::build()\n        .mount(\"/\", rocket::routes![index, other_index])\n        .attach(AdHoc::on_request(\"Change CT\", |req, _| Box::pin(async move {\n            let need_ct = req.content_type().is_none();\n            if req.uri().path().starts_with(\"/add\") {\n                req.set_uri(rocket::uri!(index));\n                if need_ct { req.add_header(ContentType::JSON); }\n            } else if need_ct {\n                req.replace_header(ContentType::JSON);\n            }\n        })))\n}\n\n#[test]\nfn check_fairing_changes_content_type() {\n    let client = Client::debug(rocket()).unwrap();\n    let response = client.post(\"/\").header(ContentType::PNG).dispatch();\n    assert_eq!(response.into_string().unwrap(), \"other\");\n\n    let response = client.post(\"/\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"json\");\n\n    let response = client.post(\"/add\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"json\");\n\n    let response = client.post(\"/add\").header(ContentType::HTML).dispatch();\n    assert_eq!(response.into_string().unwrap(), \"other\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![allow(dead_code)] // This test is only here so that we can ensure it compiles.\n\n#[macro_use] extern crate rocket;\n\nuse rocket::{Request, State};\nuse rocket::response::{Responder, Result};\n\nstruct SomeState;\n\npub struct CustomResponder<'r, R> {\n    responder: R,\n    state: &'r SomeState,\n}\n\nimpl<'r, 'o: 'r, R: Responder<'r, 'o>> Responder<'r, 'o> for CustomResponder<'r, R> {\n    fn respond_to(self, req: &'r Request<'_>) -> Result<'o> {\n        self.responder.respond_to(req)\n    }\n}\n\n#[get(\"/unit_state\")]\nfn unit_state(state: &State<SomeState>) -> CustomResponder<()> {\n    CustomResponder { responder: (), state: &*state }\n}\n\n#[get(\"/string_state\")]\nfn string_state(state: &State<SomeState>) -> CustomResponder<String> {\n    CustomResponder { responder: \"\".to_string(), state: &*state }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse std::path::{Path, PathBuf};\nuse rocket::http::ext::Normalize;\nuse rocket::Route;\n\n#[get(\"/<path..>\")]\nfn files(route: &Route, path: PathBuf) -> String {\n    Path::new(route.uri.base()).join(path).normalized_str().to_string()\n}\n\nmod route_guard_tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    fn assert_path(client: &Client, path: &str) {\n        let res = client.get(path).dispatch();\n        assert_eq!(res.into_string(), Some(path.into()));\n    }\n\n    #[test]\n    fn check_mount_path() {\n        let rocket = rocket::build()\n            .mount(\"/first\", routes![files])\n            .mount(\"/second\", routes![files]);\n\n        let client = Client::debug(rocket).unwrap();\n        assert_path(&client, \"/first/some/path\");\n        assert_path(&client, \"/second/some/path\");\n        assert_path(&client, \"/first/second/b/c\");\n        assert_path(&client, \"/second/a/b/c\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::{Rocket, Build};\nuse rocket::local::blocking::Client;\n\nmod inner {\n    use rocket::uri;\n\n    #[rocket::get(\"/\")]\n    pub fn hello() -> String {\n        format!(\"Hello! Try {}.\", uri!(super::hello_name(\"Rust 2018\")))\n    }\n}\n\n#[rocket::get(\"/<name>\")]\nfn hello_name(name: String) -> String {\n    format!(\"Hello, {}! This is {}.\", name, rocket::uri!(hello_name(&name)))\n}\n\nfn rocket() -> Rocket<Build> {\n    rocket::build()\n        .mount(\"/\", rocket::routes![hello_name])\n        .mount(\"/\", rocket::routes![inner::hello])\n}\n\n#[test]\nfn test_inner_hello() {\n    let client = Client::debug(rocket()).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert_eq!(response.into_string(), Some(\"Hello! Try /Rust%202018.\".into()));\n}\n\n#[test]\nfn test_hello_name() {\n    let client = Client::debug(rocket()).unwrap();\n    let response = client.get(\"/Rust%202018\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"Hello, Rust 2018! This is /Rust%202018.\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::http::uri::{Segments, fmt::Path};\n\n#[get(\"/test/<path..>\")]\nfn test(path: Segments<'_, Path>) -> String {\n    path.collect::<Vec<_>>().join(\"/\")\n}\n\n#[get(\"/two/<path..>\")]\nfn two(path: Segments<'_, Path>) -> String {\n    path.collect::<Vec<_>>().join(\"/\")\n}\n\n#[get(\"/one/two/<path..>\")]\nfn one_two(path: Segments<'_, Path>) -> String {\n    path.collect::<Vec<_>>().join(\"/\")\n}\n\n#[get(\"/<path..>\", rank = 2)]\nfn none(path: Segments<'_, Path>) -> String {\n    path.collect::<Vec<_>>().join(\"/\")\n}\n\n#[get(\"/static/<user>/is/<path..>\")]\nfn dual(user: String, path: Segments<'_, Path>) -> String {\n    user + \"/is/\" + &path.collect::<Vec<_>>().join(\"/\")\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn segments_works() {\n        let rocket = rocket::build()\n            .mount(\"/\", routes![test, two, one_two, none, dual])\n            .mount(\"/point\", routes![test, two, one_two, dual]);\n        let client = Client::debug(rocket).unwrap();\n\n        // We construct a path that matches each of the routes above. We ensure the\n        // prefix is stripped, confirming that dynamic segments are working.\n        for prefix in &[\"\", \"/test\", \"/two\", \"/one/two\",\n                        \"/point/test\", \"/point/two\", \"/point/one/two\",\n                        \"/static\", \"/point/static\"]\n        {\n            let path = \"this/is/the/path/we/want\";\n            let response = client.get(format!(\"{}/{}\", prefix, path)).dispatch();\n            assert_eq!(response.into_string(), Some(path.into()));\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::{*, error::ErrorKind::SentinelAborts};\n\n#[get(\"/two\")]\nfn two_states(_one: &State<u32>, _two: &State<String>) {}\n\n#[post(\"/one\", data = \"<s>\")]\nfn one_state<'r>(_three: &'r State<u8>, s: &'r str) -> &'r str { s }\n\n#[async_test]\nasync fn state_sentinel_works() {\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![two_states])\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 2));\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![two_states])\n        .manage(String::new())\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![two_states])\n        .manage(1 as u32)\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    let result = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![two_states])\n        .manage(String::new())\n        .manage(1 as u32)\n        .ignite().await;\n\n    assert!(result.is_ok());\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state])\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    let result = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state])\n        .manage(1 as u8)\n        .ignite().await;\n\n    assert!(result.is_ok());\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state, two_states])\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 3));\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state, two_states])\n        .manage(1 as u32)\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 2));\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state, two_states])\n        .manage(1 as u8)\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 2));\n\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state, two_states])\n        .manage(1 as u32)\n        .manage(1 as u8)\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    let result = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![one_state, two_states])\n        .manage(1 as u32)\n        .manage(1 as u8)\n        .manage(String::new())\n        .ignite().await;\n\n    assert!(result.is_ok());\n}\n\nstruct Data;\n\n#[crate::async_trait]\nimpl<'r> data::FromData<'r> for Data {\n    type Error = Error;\n    async fn from_data(_: &'r Request<'_>, _: data::Data<'r>) -> data::Outcome<'r, Self> {\n        unimplemented!()\n    }\n}\n\nimpl Sentinel for Data {\n    fn abort(rocket: &Rocket<Ignite>) -> bool {\n        rocket.state::<Data>().is_none()\n    }\n}\n\n#[post(\"/data\", data = \"<_data>\")]\nfn with_data(_data: Data) {}\n\n#[async_test]\nasync fn data_sentinel_works() {\n    let err = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![with_data])\n        .ignite().await\n        .unwrap_err();\n\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    let result = rocket::build()\n        .configure(Config::debug_default())\n        .mount(\"/\", routes![with_data])\n        .manage(Data)\n        .ignite().await;\n\n    assert!(result.is_ok());\n}\n\n#[test]\nfn inner_sentinels_detected() {\n    use rocket::local::blocking::Client;\n\n    #[derive(Responder)]\n    struct MyThing<T>(T);\n\n    struct ResponderSentinel;\n\n    impl<'r, 'o: 'r> response::Responder<'r, 'o> for ResponderSentinel {\n        fn respond_to(self, _: &'r Request<'_>) -> response::Result<'o> {\n            todo!()\n        }\n    }\n\n    impl Sentinel for ResponderSentinel {\n        fn abort(_: &Rocket<Ignite>) -> bool {\n            true\n        }\n    }\n\n    #[get(\"/\")]\n    fn route() -> MyThing<ResponderSentinel> { todo!() }\n\n    let err = Client::debug_with(routes![route]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    #[derive(Responder)]\n    struct Inner<T>(T);\n\n    #[get(\"/\")]\n    fn inner() -> MyThing<Inner<ResponderSentinel>> { todo!() }\n\n    let err = Client::debug_with(routes![inner]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    #[get(\"/\")]\n    fn inner_either() -> Either<Inner<ResponderSentinel>, ResponderSentinel> { todo!() }\n\n    let err = Client::debug_with(routes![inner_either]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 2));\n\n    #[derive(Responder)]\n    struct Block<T>(T);\n\n    impl<T> Sentinel for Block<T> {\n        fn abort(_: &Rocket<Ignite>) -> bool {\n            false\n        }\n    }\n\n    #[get(\"/\")]\n    fn blocked() -> Block<ResponderSentinel> { todo!() }\n\n    Client::debug_with(routes![blocked]).expect(\"no sentinel errors\");\n\n    #[get(\"/a\")]\n    fn inner_b() -> Either<Inner<Block<ResponderSentinel>>, Block<ResponderSentinel>> {\n        todo!()\n    }\n\n    #[get(\"/b\")]\n    fn inner_b2() -> Either<Block<Inner<ResponderSentinel>>, Block<ResponderSentinel>> {\n        todo!()\n    }\n\n    Client::debug_with(routes![inner_b, inner_b2]).expect(\"no sentinel errors\");\n\n    #[get(\"/\")]\n    fn half_b() -> Either<Inner<ResponderSentinel>, Block<ResponderSentinel>> {\n        todo!()\n    }\n\n    let err = Client::debug_with(routes![half_b]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    use rocket::response::Responder;\n\n    #[get(\"/\")]\n    fn half_c<'r>() -> Either<\n        Inner<impl Responder<'r, 'static>>,\n        Result<ResponderSentinel, Inner<ResponderSentinel>>\n    > {\n        Either::Left(Inner(()))\n    }\n\n    let err = Client::debug_with(routes![half_c]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 2));\n\n    #[get(\"/\")]\n    fn half_d<'r>() -> Either<\n        Inner<impl Responder<'r, 'static>>,\n        Result<Block<ResponderSentinel>, Inner<ResponderSentinel>>\n    > {\n        Either::Left(Inner(()))\n    }\n\n    let err = Client::debug_with(routes![half_d]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    // The special `Result` implementation.\n    type MyResult = Result<ResponderSentinel, ResponderSentinel>;\n\n    #[get(\"/\")]\n    fn half_e<'r>() -> Either<Inner<impl Responder<'r, 'static>>, MyResult> {\n        Either::Left(Inner(()))\n    }\n\n    let err = Client::debug_with(routes![half_e]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    // Another specialized sentinel.\n\n    #[get(\"/\")] fn either_route() -> Either<ResponderSentinel, ResponderSentinel> { todo!() }\n    let err = Client::debug_with(routes![either_route]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    #[get(\"/\")] fn either_route2() -> Either<ResponderSentinel, ()> { todo!() }\n    let err = Client::debug_with(routes![either_route2]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    #[get(\"/\")] fn either_route3() -> Either<(), ResponderSentinel> { todo!() }\n    let err = Client::debug_with(routes![either_route3]).unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 1));\n\n    #[get(\"/\")] fn either_route4() -> Either<(), ()> { todo!() }\n    Client::debug_with(routes![either_route4]).expect(\"no sentinel error\");\n}\n\n#[async_test]\nasync fn known_macro_sentinel_works() {\n    use rocket::response::stream::{TextStream, ByteStream, ReaderStream};\n    use rocket::local::asynchronous::Client;\n    use rocket::tokio::io::AsyncRead;\n\n    #[derive(Responder)]\n    struct TextSentinel<'r>(&'r str);\n\n    impl Sentinel for TextSentinel<'_> {\n        fn abort(_: &Rocket<Ignite>) -> bool {\n            true\n        }\n    }\n\n    impl AsRef<str> for TextSentinel<'_> {\n        fn as_ref(&self) -> &str {\n            self.0\n        }\n    }\n\n    impl AsRef<[u8]> for TextSentinel<'_> {\n        fn as_ref(&self) -> &[u8] {\n            self.0.as_bytes()\n        }\n    }\n\n    impl AsyncRead for TextSentinel<'_> {\n        fn poll_read(\n            self: std::pin::Pin<&mut Self>,\n            _: &mut futures::task::Context<'_>,\n            _: &mut tokio::io::ReadBuf<'_>,\n        ) -> futures::task::Poll<std::io::Result<()>> {\n            futures::task::Poll::Ready(Ok(()))\n        }\n    }\n\n    #[get(\"/text\")]\n    fn text<'r>() -> TextStream![TextSentinel<'r>] {\n        TextStream!(yield TextSentinel(\"hi\");)\n    }\n\n    #[get(\"/<a>\")]\n    fn byte(a: &str) -> ByteStream![TextSentinel<'_>] {\n        ByteStream!(yield TextSentinel(a);)\n    }\n\n    #[get(\"/<_a>/<b>\")]\n    fn reader<'a, 'b>(_a: &'a str, b: &'b str) -> ReaderStream![TextSentinel<'b>] {\n        ReaderStream!(yield TextSentinel(b);)\n    }\n\n    macro_rules! UnknownStream {\n        ($t:ty) => (ReaderStream![$t])\n    }\n\n    #[get(\"/ignore\")]\n    fn ignore() -> UnknownStream![TextSentinel<'static>] {\n        ReaderStream!(yield TextSentinel(\"hi\");)\n    }\n\n    let err = Client::debug_with(routes![text, byte, reader, ignore]).await.unwrap_err();\n    assert!(matches!(err.kind(), SentinelAborts(vec) if vec.len() == 3));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"secrets\")]\n\nuse rocket::http::{CookieJar, Cookie};\n\n#[rocket::get(\"/\")]\nfn index(jar: &CookieJar<'_>) {\n    jar.add_private(Cookie::build((\"key\", \"value\")).expires(None));\n}\n\nmod test_session_cookies {\n    use super::*;\n    use rocket::local::blocking::Client;\n\n    #[test]\n    fn session_cookie_is_session() {\n        let rocket = rocket::build().mount(\"/\", rocket::routes![index]);\n        let client = Client::debug(rocket).unwrap();\n\n        let response = client.get(\"/\").dispatch();\n        let cookie = response.cookies().get_private(\"key\").unwrap();\n        assert_eq!(cookie.expires_datetime(), None);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::Config;\nuse rocket::http::Status;\nuse rocket::local::blocking::{Client, LocalResponse};\nuse rocket::shield::*;\n\nuse time::Duration;\n\n#[get(\"/\")] fn hello() { }\n\nmacro_rules! assert_header {\n    ($response:ident, $name:expr, $value:expr) => {\n        match $response.headers().get_one($name) {\n            Some(value) => assert_eq!(value, $value),\n            None => panic!(\"missing header '{}' with value '{}'\", $name, $value)\n        }\n    };\n}\n\nmacro_rules! assert_no_header {\n    ($response:ident, $name:expr) => {\n        if let Some(value) = $response.headers().get_one($name) {\n            panic!(\"unexpected header: '{}={}\", $name, value);\n        }\n    };\n}\n\nmacro_rules! dispatch {\n    ($shield:expr, $closure:expr) => {{\n        let rocket = rocket::build().mount(\"/\", routes![hello]).attach($shield);\n        let client = Client::debug(rocket).unwrap();\n        let response = client.get(\"/\").dispatch();\n        assert_eq!(response.status(), Status::Ok);\n        $closure(response)\n    }}\n}\n\n#[test]\nfn default_shield() {\n    let client = Client::debug(rocket::build()).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert_header!(response, \"Permissions-Policy\", \"interest-cohort=()\");\n    assert_header!(response, \"X-Frame-Options\", \"SAMEORIGIN\");\n    assert_header!(response, \"X-Content-Type-Options\", \"nosniff\");\n\n    let client = Client::debug(rocket::custom(Config::debug_default())).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert_header!(response, \"Permissions-Policy\", \"interest-cohort=()\");\n    assert_header!(response, \"X-Frame-Options\", \"SAMEORIGIN\");\n    assert_header!(response, \"X-Content-Type-Options\", \"nosniff\");\n}\n\n#[test]\nfn shield_singleton() {\n    let rocket = rocket::build().attach(Shield::new());\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert_no_header!(response, \"Permissions-Policy\");\n    assert_no_header!(response, \"X-Frame-Options\");\n    assert_no_header!(response, \"X-Content-Type-Options\");\n\n    let rocket = rocket::custom(Config::debug_default()).attach(Shield::new());\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert_no_header!(response, \"Permissions-Policy\");\n    assert_no_header!(response, \"X-Frame-Options\");\n    assert_no_header!(response, \"X-Content-Type-Options\");\n}\n\n#[test]\nfn default_headers_test() {\n    dispatch!(Shield::default(), |response: LocalResponse<'_>| {\n        assert_header!(response, \"Permissions-Policy\", \"interest-cohort=()\");\n        assert_header!(response, \"X-Frame-Options\", \"SAMEORIGIN\");\n        assert_header!(response, \"X-Content-Type-Options\", \"nosniff\");\n    })\n}\n\n#[test]\nfn disable_headers_test() {\n    let shield = Shield::default().disable::<Permission>();\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"X-Frame-Options\", \"SAMEORIGIN\");\n        assert_header!(response, \"X-Content-Type-Options\", \"nosniff\");\n        assert_no_header!(response, \"Permissions-Policy\");\n    });\n\n    let shield = Shield::default().disable::<Frame>();\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"Permissions-Policy\", \"interest-cohort=()\");\n        assert_header!(response, \"X-Content-Type-Options\", \"nosniff\");\n        assert_no_header!(response, \"X-Frame-Options\");\n    });\n\n    let shield = Shield::default()\n        .disable::<Frame>()\n        .disable::<Permission>()\n        .disable::<NoSniff>();\n\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_no_header!(response, \"X-Frame-Options\");\n        assert_no_header!(response, \"Permissions-Policy\");\n        assert_no_header!(response, \"X-Content-Type-Options\");\n    });\n\n    dispatch!(Shield::new(), |response: LocalResponse<'_>| {\n        assert_no_header!(response, \"X-Frame-Options\");\n        assert_no_header!(response, \"Permissions-Policy\");\n        assert_no_header!(response, \"X-Content-Type-Options\");\n    });\n}\n\n#[test]\nfn additional_headers_test() {\n    let shield = Shield::default()\n        .enable(Hsts::default())\n        .enable(ExpectCt::default())\n        .enable(Referrer::default());\n\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(\n            response,\n            \"Strict-Transport-Security\",\n            format!(\"max-age={}\", Duration::days(365).whole_seconds())\n        );\n\n        assert_header!(\n            response,\n            \"Expect-CT\",\n            format!(\"max-age={}, enforce\", Duration::days(30).whole_seconds())\n        );\n\n        assert_header!(response, \"Referrer-Policy\", \"no-referrer\");\n    })\n}\n\n#[test]\nfn uri_test() {\n    let enforce_uri = uri!(\"https://rocket.rs\");\n    let shield = Shield::default()\n        .enable(ExpectCt::ReportAndEnforce(Duration::seconds(30), enforce_uri));\n\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"Expect-CT\",\n            \"max-age=30, enforce, report-uri=\\\"https://rocket.rs\\\"\");\n    });\n}\n\n#[test]\nfn prefetch_test() {\n    let shield = Shield::default().enable(Prefetch::default());\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"X-DNS-Prefetch-Control\", \"off\");\n    });\n\n    let shield = Shield::default().enable(Prefetch::Off);\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"X-DNS-Prefetch-Control\", \"off\");\n    });\n\n    let shield = Shield::default().enable(Prefetch::On);\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"X-DNS-Prefetch-Control\", \"on\");\n    });\n}\n\n#[test]\n#[should_panic]\nfn bad_uri_permission_test() {\n    let uri = uri!(\"http://:200\");\n    Permission::allowed(Feature::Usb, Allow::Origin(uri));\n}\n\n#[test]\n#[should_panic]\nfn bad_uri_permission_test2() {\n    let uri = uri!(\"http://:200\");\n    Permission::default().allow(Feature::Camera, Allow::Origin(uri));\n}\n\n#[test]\nfn permission_test() {\n    let shield = Shield::default().enable(Permission::default());\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"Permissions-Policy\", \"interest-cohort=()\");\n    });\n\n    let shield = Shield::default().enable(Permission::blocked(Feature::Usb));\n    dispatch!(shield, |response: LocalResponse<'_>| {\n        assert_header!(response, \"Permissions-Policy\", \"usb=()\");\n    });\n\n    let permission = Permission::blocked(Feature::Usb)\n        .block(Feature::Camera)\n        .block(Feature::WebShare);\n\n    let shield = Shield::default().enable(permission);\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\", \"usb=(), camera=(), web-share=()\");\n    });\n\n    let permission = Permission::blocked(Feature::Usb)\n        .allow(Feature::Camera, [Allow::Any, Allow::This])\n        .block(Feature::WebShare);\n\n    let shield = Shield::default().enable(permission);\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\", \"usb=(), camera=(*), web-share=()\");\n    });\n\n    let permission = Permission::blocked(Feature::Usb)\n        .allow(Feature::Camera, [Allow::This])\n        .block(Feature::WebShare);\n\n    let shield = Shield::default().enable(permission);\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\", \"usb=(), camera=(self), web-share=()\");\n    });\n\n    let uri = uri!(\"http://rocket.rs\");\n    let permission = Permission::allowed(Feature::Usb, Allow::Origin(uri))\n        .allow(Feature::Camera, [Allow::This])\n        .block(Feature::WebShare);\n\n    let shield = Shield::default().enable(permission);\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\",\n            \"usb=(\\\"http://rocket.rs\\\"), camera=(self), web-share=()\");\n    });\n\n    let origin1 = Allow::Origin(uri!(\"http://rocket.rs\"));\n    let origin2 = Allow::Origin(uri!(\"https://rocket.rs\"));\n    let shield = Shield::default()\n        .enable(Permission::allowed(Feature::Camera, [origin1, origin2]));\n\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\",\n            \"camera=(\\\"http://rocket.rs\\\" \\\"https://rocket.rs\\\")\");\n    });\n\n    let origin1 = Allow::Origin(uri!(\"http://rocket.rs\"));\n    let origin2 = Allow::Origin(uri!(\"https://rocket.rs\"));\n    let perm = Permission::allowed(Feature::Accelerometer, [origin1, origin2])\n        .block(Feature::Usb);\n\n    let shield = Shield::default().enable(perm);\n    dispatch!(shield, |r: LocalResponse<'_>| {\n        assert_header!(r, \"Permissions-Policy\",\n            \"accelerometer=(\\\"http://rocket.rs\\\" \\\"https://rocket.rs\\\"), usb=()\");\n    });\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n\nuse rocket::fairing::AdHoc;\n\n// Want to test:\n//\n//   * stalled connection + sleep in shutdown -> conn closed\n//   * stalled shutdown fairing stalls shutdown but not > grace + mercy\n//     - sleep < grace + mercy\n//     - sleep > grace + mercy\n\n#[derive(Default)]\nstruct Flags {\n    liftoff: AtomicBool,\n    shutdown: AtomicUsize\n}\n\n#[test]\nfn shutdown_fairing_runs() {\n    use rocket::local::blocking::Client;\n\n    let rocket = rocket::build()\n        .manage(Flags::default())\n        .attach(AdHoc::on_liftoff(\"Liftoff Flag\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.liftoff.store(true, Ordering::SeqCst);\n        })))\n        .attach(AdHoc::on_shutdown(\"Shutdown Flag\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.shutdown.fetch_add(1, Ordering::SeqCst);\n        })));\n\n    let client = Client::debug(rocket).unwrap();\n    let flags = client.rocket().state::<Flags>().unwrap();\n    assert!(flags.liftoff.load(Ordering::SeqCst));\n    assert_eq!(0, flags.shutdown.load(Ordering::SeqCst));\n\n    let rocket = client.terminate();\n    let flags = rocket.state::<Flags>().unwrap();\n    assert_eq!(1, flags.shutdown.load(Ordering::SeqCst));\n}\n\n#[async_test]\nasync fn async_shutdown_fairing_runs() {\n    use rocket::local::asynchronous::Client;\n\n    let rocket = rocket::build()\n        .manage(Flags::default())\n        .attach(AdHoc::on_liftoff(\"Liftoff Flag\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.liftoff.store(true, Ordering::SeqCst);\n        })))\n        .attach(AdHoc::on_shutdown(\"Shutdown Flag\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.shutdown.fetch_add(1, Ordering::SeqCst);\n        })));\n\n    let client = Client::debug(rocket).await.unwrap();\n    let flags = client.rocket().state::<Flags>().unwrap();\n    assert!(flags.liftoff.load(Ordering::SeqCst));\n    assert_eq!(0, flags.shutdown.load(Ordering::SeqCst));\n\n    let rocket = client.terminate().await;\n    let flags = rocket.state::<Flags>().unwrap();\n    assert_eq!(1, flags.shutdown.load(Ordering::SeqCst));\n}\n\n#[async_test]\nasync fn multiple_shutdown_fairing_runs() {\n    use rocket::local::asynchronous::Client;\n\n    let rocket = rocket::build()\n        .manage(Flags::default())\n        .attach(AdHoc::on_shutdown(\"Shutdown Flag 1\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.shutdown.fetch_add(1, Ordering::SeqCst);\n        })))\n        .attach(AdHoc::on_shutdown(\"Shutdown Flag 2\", |rocket| Box::pin(async move {\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.shutdown.fetch_add(1, Ordering::SeqCst);\n        })));\n\n    let client = Client::debug(rocket).await.unwrap();\n    let flags = client.rocket().state::<Flags>().unwrap();\n    assert_eq!(0, flags.shutdown.load(Ordering::SeqCst));\n\n    let rocket = client.terminate().await;\n    let flags = rocket.state::<Flags>().unwrap();\n    assert_eq!(2, flags.shutdown.load(Ordering::SeqCst));\n}\n\n#[async_test]\nasync fn async_slow_shutdown_doesnt_elongate_grace() {\n    use rocket::local::asynchronous::Client;\n\n    let mut config = rocket::Config::debug_default();\n    config.shutdown.grace = 1;\n    config.shutdown.mercy = 1;\n\n    let rocket = rocket::build()\n        .manage(Flags::default())\n        .configure(config)\n        .attach(AdHoc::on_shutdown(\"Slow Shutdown\", |rocket| Box::pin(async move {\n            tokio::time::sleep(std::time::Duration::from_secs(4)).await;\n            let flags = rocket.state::<Flags>().unwrap();\n            flags.shutdown.fetch_add(1, Ordering::SeqCst);\n        })));\n\n    let client = Client::debug(rocket).await.unwrap();\n    let flags = client.rocket().state::<Flags>().unwrap();\n    assert_eq!(0, flags.shutdown.load(Ordering::SeqCst));\n\n    let start = std::time::Instant::now();\n    let rocket = client.terminate().await;\n    let elapsed = start.elapsed();\n\n    let flags = rocket.state::<Flags>().unwrap();\n    assert!(elapsed > std::time::Duration::from_secs(2));\n    assert!(elapsed < std::time::Duration::from_secs(5));\n    assert_eq!(1, flags.shutdown.load(Ordering::SeqCst));\n}\n\n#[test]\nfn background_tasks_dont_prevent_terminate() {\n    use rocket::local::blocking::Client;\n\n    #[get(\"/\")]\n    fn index() {\n        tokio::task::spawn(async {\n            tokio::time::sleep(std::time::Duration::from_secs(10)).await;\n        });\n\n        tokio::task::spawn_blocking(|| {\n            std::thread::sleep(std::time::Duration::from_secs(10));\n        });\n    }\n\n    let mut config = rocket::Config::debug_default();\n    config.shutdown.grace = 1;\n    config.shutdown.mercy = 1;\n\n    let rocket = rocket::build().configure(config).mount(\"/\", routes![index]);\n\n    let client = Client::debug(rocket).unwrap();\n    let response = client.get(\"/\").dispatch();\n    assert!(response.status().class().is_success());\n    drop(response);\n    let _ = client.terminate();\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::form::{Form, Strict};\n\n#[derive(FromForm)]\nstruct MyForm<'r> {\n    field: &'r str,\n}\n\n#[post(\"/strict\", data = \"<form>\")]\nfn strict<'r>(form: Form<Strict<MyForm<'r>>>) -> &'r str {\n    form.field\n}\n\n#[post(\"/lenient\", data = \"<form>\")]\nfn lenient<'r>(form: Form<MyForm<'r>>) -> &'r str {\n    form.field\n}\n\nmod strict_and_lenient_forms_tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::http::{Status, ContentType};\n\n    const FIELD_VALUE: &str = \"just_some_value\";\n\n    fn client() -> Client {\n        Client::debug_with(routes![strict, lenient]).unwrap()\n    }\n\n    #[test]\n    fn test_strict_form() {\n        let client = client();\n        let response = client.post(\"/strict\")\n            .header(ContentType::Form)\n            .body(format!(\"field={}\", FIELD_VALUE))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string(), Some(FIELD_VALUE.into()));\n\n        let response = client.post(\"/strict\")\n            .header(ContentType::Form)\n            .body(format!(\"field={}&extra=whoops\", FIELD_VALUE))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::UnprocessableEntity);\n    }\n\n    #[test]\n    fn test_lenient_form() {\n        let client = client();\n        let response = client.post(\"/lenient\")\n            .header(ContentType::Form)\n            .body(format!(\"field={}\", FIELD_VALUE))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string(), Some(FIELD_VALUE.into()));\n\n        let response = client.post(\"/lenient\")\n            .header(ContentType::Form)\n            .body(format!(\"field={}&extra=whoops\", FIELD_VALUE))\n            .dispatch();\n\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string(), Some(FIELD_VALUE.into()));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[rocket::async_test]\nasync fn test_await_timer_inside_attach() {\n\n    async fn do_async_setup() {\n        // By using a timer or I/O resource, we ensure that do_async_setup will\n        // deadlock if no thread is able to tick the time or I/O drivers.\n        rocket::tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n    }\n\n    let _ = rocket::build()\n        .attach(rocket::fairing::AdHoc::on_ignite(\"1\", |rocket| async {\n            do_async_setup().await;\n            rocket\n        }));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg(feature = \"tls\")]\n\nmacro_rules! relative {\n    ($path:expr) => {\n        std::path::Path::new(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/\", $path))\n    };\n}\n\n#[test]\nfn tls_config_from_source() {\n    use rocket::config::{Config, TlsConfig};\n    use rocket::figment::Figment;\n\n    let cert_path = relative!(\"examples/tls/private/cert.pem\");\n    let key_path = relative!(\"examples/tls/private/key.pem\");\n\n    let rocket_config = Config {\n        tls: Some(TlsConfig::from_paths(cert_path, key_path)),\n        ..Default::default()\n    };\n\n    let config: Config = Figment::from(rocket_config).extract().unwrap();\n    let tls = config.tls.expect(\"have TLS config\");\n    assert_eq!(tls.certs().unwrap_left(), cert_path);\n    assert_eq!(tls.key().unwrap_left(), key_path);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "struct A;\n\n#[test]\n#[should_panic]\nfn twice_managed_state() {\n    let _ = rocket::build().manage(A).manage(A);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![allow(dead_code)] // This test is only here to ensure it compiles.\n#![allow(unused_variables)] // This test is only here to ensure it compiles.\n\nmod a {\n    /// Docs.\n    #[rocket::post(\"/typed_uris/<id>\")]\n    fn simple(id: i32) { }\n}\n\nmod b {\n    /// Docs.\n    #[rocket::post(\"/typed_uris/<id>\")]\n    fn simple(id: i32) { }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rocket::http::Header;\nuse rocket::local::blocking::Client;\n\n#[test]\nfn test_local_request_clone_soundness() {\n    let client = Client::debug_with(vec![]).unwrap();\n\n    // creates two LocalRequest instances that shouldn't share the same req\n    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));\n    let mut r2 = r1.clone();\n\n    // save the iterator, which internally holds a slice\n    let mut iter = r1.inner().headers().get(\"key\");\n\n    // insert headers to force header map reallocation.\n    for i in 0..100 {\n        r2.add_header(Header::new(i.to_string(), i.to_string()));\n    }\n\n    // Replace the original key/val.\n    r2.add_header(Header::new(\"key\", \"val2\"));\n\n    // Heap massage: so we've got crud to print.\n    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];\n\n    // Ensure we're good.\n    let s = iter.next().unwrap();\n    println!(\"{}\", s);\n\n    // And that we've got the right data.\n    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);\n    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[macro_use] extern crate rocket;\n\nuse rocket::{Rocket, Build};\nuse rocket::response::Redirect;\n\nconst NAME: &str = \"John[]|\\\\%@^\";\n\n#[get(\"/hello/<name>\")]\nfn hello(name: String) -> String {\n    format!(\"Hello, {}!\", name)\n}\n\n#[get(\"/raw\")]\nfn raw_redirect() -> Redirect {\n    Redirect::to(uri!(hello(NAME)))\n}\n\n#[get(\"/uri\")]\nfn uri_redirect() -> Redirect {\n    Redirect::to(uri!(hello(NAME)))\n}\n\nfn rocket() -> Rocket<Build> {\n    rocket::build().mount(\"/\", routes![hello, uri_redirect, raw_redirect])\n}\n\nmod tests {\n    use super::*;\n    use rocket::local::blocking::Client;\n    use rocket::http::Status;\n\n    #[test]\n    fn uri_percent_encoding_redirect() {\n        let expected_location = vec![\"/hello/John[]%7C%5C%25@%5E\"];\n        let client = Client::debug(rocket()).unwrap();\n\n        let response = client.get(\"/raw\").dispatch();\n        let location: Vec<_> = response.headers().get(\"location\").collect();\n        assert_eq!(response.status(), Status::SeeOther);\n        assert_eq!(&location, &expected_location);\n\n        let response = client.get(\"/uri\").dispatch();\n        let location: Vec<_> = response.headers().get(\"location\").collect();\n        assert_eq!(response.status(), Status::SeeOther);\n        assert_eq!(&location, &expected_location);\n    }\n\n    #[test]\n    fn uri_percent_encoding_get() {\n        let client = Client::debug(rocket()).unwrap();\n        let response = client.get(uri!(hello(NAME))).dispatch();\n        assert_eq!(response.status(), Status::Ok);\n        assert_eq!(response.into_string().unwrap(), format!(\"Hello, {}!\", NAME));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! A Rust parser for the [WebAssembly Text format][wat]\n//!\n//! This crate contains a stable interface to the parser for the [WAT][wat]\n//! format of WebAssembly text files. The format parsed by this crate follows\n//! the [online specification][wat].\n//!\n//! # Examples\n//!\n//! Parse an in-memory string:\n//!\n//! ```\n//! # fn foo() -> wat::Result<()> {\n//! let wat = r#\"\n//!     (module\n//!         (func $foo)\n//!\n//!         (func (export \"bar\")\n//!             call $foo\n//!         )\n//!     )\n//! \"#;\n//!\n//! let binary = wat::parse_str(wat)?;\n//! // ...\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! Parse an on-disk file:\n//!\n//! ```\n//! # fn foo() -> wat::Result<()> {\n//! let binary = wat::parse_file(\"./foo.wat\")?;\n//! // ...\n//! # Ok(())\n//! # }\n//! ```\n//!\n//! ## Evolution of the WAT Format\n//!\n//! WebAssembly, and the WAT format, are an evolving specification. Features are\n//! added to WAT, WAT changes, and sometimes WAT breaks. The policy of this\n//! crate is that it will always follow the [official specification][wat] for\n//! WAT files.\n//!\n//! Future WebAssembly features will be accepted to this parser **and they will\n//! not require a feature gate to opt-in**. All implemented WebAssembly features\n//! will be enabled at all times. Using a future WebAssembly feature in the WAT\n//! format may cause breakage because while specifications are in development\n//! the WAT syntax (and/or binary encoding) will often change. This crate will\n//! do its best to keep up with these proposals, but breaking textual changes\n//! will be published as non-breaking semver changes to this crate.\n//!\n//! ## Stability\n//!\n//! This crate is intended to be a very stable shim over the `wast` crate\n//! which is expected to be much more unstable. The `wast` crate contains\n//! AST data structures for parsing `*.wat` files and they will evolve was the\n//! WAT and WebAssembly specifications evolve over time.\n//!\n//! This crate is currently at version 1.x.y, and it is intended that it will\n//! remain here for quite some time. Breaking changes to the WAT format will be\n//! landed as a non-semver-breaking version change in this crate. This crate\n//! will always follow the [official specification for WAT][wat].\n//!\n//! [wat]: http://webassembly.github.io/spec/core/text/index.html\n\n#![deny(missing_docs)]\n#![cfg_attr(docsrs, feature(doc_cfg))]\n\nuse std::borrow::Cow;\nuse std::fmt;\nuse std::path::{Path, PathBuf};\nuse std::str;\nuse wast::core::EncodeOptions;\nuse wast::lexer::{Lexer, TokenKind};\nuse wast::parser::{self, ParseBuffer};\n\n#[doc(inline)]\npub use wast::core::GenerateDwarf;\n\n/// Parses a file on disk as a [WebAssembly Text format][wat] file, or a binary\n/// WebAssembly file\n///\n/// This function will read the bytes on disk and delegate them to the\n/// [`parse_bytes`] function. For more information on the behavior of parsing\n/// see [`parse_bytes`].\n///\n/// # Errors\n///\n/// For information about errors, see the [`parse_bytes`] documentation.\n///\n/// # Examples\n///\n/// ```\n/// # fn foo() -> wat::Result<()> {\n/// let binary = wat::parse_file(\"./foo.wat\")?;\n/// // ...\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [wat]: http://webassembly.github.io/spec/core/text/index.html\npub fn parse_file(file: impl AsRef<Path>) -> Result<Vec<u8>> {\n    Parser::new().parse_file(file)\n}\n\n/// Parses in-memory bytes as either the [WebAssembly Text format][wat], or a\n/// binary WebAssembly module.\n///\n/// This function will attempt to interpret the given bytes as one of two\n/// options:\n///\n/// * A utf-8 string which is a `*.wat` file to be parsed.\n/// * A binary WebAssembly file starting with `b\"\\0asm\"`\n///\n/// If the input is a string then it will be parsed as `*.wat`, and then after\n/// parsing it will be encoded back into a WebAssembly binary module. If the\n/// input is a binary that starts with `b\"\\0asm\"` it will be returned verbatim.\n/// Everything that doesn't start with `b\"\\0asm\"` will be parsed as a utf-8\n/// `*.wat` file, returning errors as appropriate.\n///\n/// For more information about parsing wat files, see [`parse_str`].\n///\n/// # Errors\n///\n/// In addition to all of the errors that can be returned from [`parse_str`],\n/// this function will also return an error if the input does not start with\n/// `b\"\\0asm\"` and is invalid utf-8. (failed to even try to call [`parse_str`]).\n///\n/// # Examples\n///\n/// ```\n/// # fn foo() -> wat::Result<()> {\n/// // Parsing bytes that are actually `*.wat` files\n/// assert_eq!(&*wat::parse_bytes(b\"(module)\")?, b\"\\0asm\\x01\\0\\0\\0\");\n/// assert!(wat::parse_bytes(b\"module\").is_err());\n/// assert!(wat::parse_bytes(b\"binary\\0file\\0\\that\\0is\\0not\\0wat\").is_err());\n///\n/// // Pass through binaries that look like real wasm files\n/// assert_eq!(&*wat::parse_bytes(b\"\\0asm\\x01\\0\\0\\0\")?, b\"\\0asm\\x01\\0\\0\\0\");\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [wat]: http://webassembly.github.io/spec/core/text/index.html\npub fn parse_bytes(bytes: &[u8]) -> Result<Cow<'_, [u8]>> {\n    Parser::new().parse_bytes(None, bytes)\n}\n\n/// Parses an in-memory string as the [WebAssembly Text format][wat], returning\n/// the file as a binary WebAssembly file.\n///\n/// This function is intended to be a stable convenience function for parsing a\n/// wat file into a WebAssembly binary file. This is a high-level operation\n/// which does not expose any parsing internals, for that you'll want to use the\n/// `wast` crate.\n///\n/// # Errors\n///\n/// This function can fail for a number of reasons, including (but not limited\n/// to):\n///\n/// * The `wat` input may fail to lex, such as having invalid tokens or syntax\n/// * The `wat` input may fail to parse, such as having incorrect syntactical\n///   structure\n/// * The `wat` input may contain names that could not be resolved\n///\n/// # Examples\n///\n/// ```\n/// # fn foo() -> wat::Result<()> {\n/// assert_eq!(wat::parse_str(\"(module)\")?, b\"\\0asm\\x01\\0\\0\\0\");\n/// assert!(wat::parse_str(\"module\").is_err());\n///\n/// let wat = r#\"\n///     (module\n///         (func $foo)\n///\n///         (func (export \"bar\")\n///             call $foo\n///         )\n///     )\n/// \"#;\n///\n/// let binary = wat::parse_str(wat)?;\n/// // ...\n/// # Ok(())\n/// # }\n/// ```\n///\n/// [wat]: http://webassembly.github.io/spec/core/text/index.html\npub fn parse_str(wat: impl AsRef<str>) -> Result<Vec<u8>> {\n    Parser::default().parse_str(None, wat)\n}\n\n/// Parser configuration for transforming bytes into WebAssembly binaries.\n#[derive(Default)]\npub struct Parser {\n    #[cfg(feature = \"dwarf\")]\n    generate_dwarf: Option<GenerateDwarf>,\n    _private: (),\n}\n\nimpl Parser {\n    /// Creates a new parser with th default settings.\n    pub fn new() -> Parser {\n        Parser::default()\n    }\n\n    /// Indicates that DWARF debugging information should be generated and\n    /// emitted by default.\n    ///\n    /// Note that DWARF debugging information is only emitted for textual-based\n    /// modules. For example if a WebAssembly binary is parsed via\n    /// [`Parser::parse_bytes`] this won't insert new DWARF information in such\n    /// a binary. Additionally if the text format used the `(module binary ...)`\n    /// form then no DWARF information will be emitted.\n    #[cfg(feature = \"dwarf\")]\n    pub fn generate_dwarf(&mut self, generate: GenerateDwarf) -> &mut Self {\n        self.generate_dwarf = Some(generate);\n        self\n    }\n\n    /// Equivalent of [`parse_file`] but uses this parser's settings.\n    pub fn parse_file(&self, path: impl AsRef<Path>) -> Result<Vec<u8>> {\n        self._parse_file(path.as_ref())\n    }\n\n    fn _parse_file(&self, file: &Path) -> Result<Vec<u8>> {\n        let contents = std::fs::read(file).map_err(|err| Error {\n            kind: Box::new(ErrorKind::Io {\n                err,\n                file: Some(file.to_owned()),\n            }),\n        })?;\n        match self.parse_bytes(Some(file), &contents) {\n            // If the result here is borrowed then that means that the input\n            // `&contents` was itself already a wasm module. We've already got\n            // an owned copy of that so return `contents` directly after\n            // double-checking it is indeed the same as the `bytes` return value\n            // here. That helps avoid a copy of `bytes` via something like\n            // `Cow::to_owned` which would otherwise copy the bytes.\n            Ok(Cow::Borrowed(bytes)) => {\n                assert_eq!(bytes.len(), contents.len());\n                assert_eq!(bytes.as_ptr(), contents.as_ptr());\n                Ok(contents)\n            }\n            Ok(Cow::Owned(bytes)) => Ok(bytes),\n            Err(mut e) => {\n                e.set_path(file);\n                Err(e)\n            }\n        }\n    }\n\n    /// Equivalent of [`parse_bytes`] but uses this parser's settings.\n    ///\n    /// The `path` argument is an optional path to use when error messages are\n    /// generated.\n    pub fn parse_bytes<'a>(&self, path: Option<&Path>, bytes: &'a [u8]) -> Result<Cow<'a, [u8]>> {\n        if bytes.starts_with(b\"\\0asm\") {\n            return Ok(bytes.into());\n        }\n        match str::from_utf8(bytes) {\n            Ok(s) => self._parse_str(path, s).map(|s| s.into()),\n            Err(_) => Err(Error {\n                kind: Box::new(ErrorKind::Custom {\n                    msg: \"input bytes aren't valid utf-8\".to_string(),\n                    file: path.map(|p| p.to_owned()),\n                }),\n            }),\n        }\n    }\n\n    /// Equivalent of [`parse_str`] but uses this parser's settings.\n    ///\n    /// The `path` argument is an optional path to use when error messages are\n    /// generated.\n    pub fn parse_str(&self, path: Option<&Path>, wat: impl AsRef<str>) -> Result<Vec<u8>> {\n        self._parse_str(path, wat.as_ref())\n    }\n\n    fn _parse_str(&self, path: Option<&Path>, wat: &str) -> Result<Vec<u8>> {\n        let mut _buf = ParseBuffer::new(wat).map_err(|e| Error::cvt(e, wat, path))?;\n        #[cfg(feature = \"dwarf\")]\n        _buf.track_instr_spans(self.generate_dwarf.is_some());\n        let mut ast = parser::parse::<wast::Wat>(&_buf).map_err(|e| Error::cvt(e, wat, path))?;\n\n        let mut _opts = EncodeOptions::default();\n        #[cfg(feature = \"dwarf\")]\n        if let Some(style) = self.generate_dwarf {\n            _opts.dwarf(path.unwrap_or(\"<input>.wat\".as_ref()), wat, style);\n        }\n        _opts\n            .encode_wat(&mut ast)\n            .map_err(|e| Error::cvt(e, wat, path))\n    }\n}\n\n/// Result of [`Detect::from_bytes`] to indicate what some input bytes look\n/// like.\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\npub enum Detect {\n    /// The input bytes look like the WebAssembly text format.\n    WasmText,\n    /// The input bytes look like the WebAssembly binary format.\n    WasmBinary,\n    /// The input bytes don't look like WebAssembly at all.\n    Unknown,\n}\n\nimpl Detect {\n    /// Detect quickly if supplied bytes represent a Wasm module,\n    /// whether binary encoded or in WAT-encoded.\n    ///\n    /// This briefly lexes past whitespace and comments as a `*.wat` file to see if\n    /// we can find a left-paren. If that fails then it's probably `*.wit` instead.\n    ///\n    ///\n    /// Examples\n    /// ```\n    /// use wat::Detect;\n    ///\n    /// assert_eq!(Detect::from_bytes(r#\"\n    /// (module\n    ///   (type (;0;) (func))\n    ///   (func (;0;) (type 0)\n    ///     nop\n    ///   )\n    /// )\n    /// \"#), Detect::WasmText);\n    /// ```\n    pub fn from_bytes(bytes: impl AsRef<[u8]>) -> Detect {\n        if bytes.as_ref().starts_with(b\"\\0asm\") {\n            return Detect::WasmBinary;\n        }\n        let text = match std::str::from_utf8(bytes.as_ref()) {\n            Ok(s) => s,\n            Err(_) => return Detect::Unknown,\n        };\n\n        let lexer = Lexer::new(text);\n        let mut iter = lexer.iter(0);\n\n        while let Some(next) = iter.next() {\n            match next.map(|t| t.kind) {\n                Ok(TokenKind::Whitespace)\n                | Ok(TokenKind::BlockComment)\n                | Ok(TokenKind::LineComment) => {}\n                Ok(TokenKind::LParen) => return Detect::WasmText,\n                _ => break,\n            }\n        }\n\n        Detect::Unknown\n    }\n\n    /// Returns whether this is either binary or textual wasm.\n    pub fn is_wasm(&self) -> bool {\n        match self {\n            Detect::WasmText | Detect::WasmBinary => true,\n            Detect::Unknown => false,\n        }\n    }\n}\n\n/// A convenience type definition for `Result` where the error is [`Error`]\npub type Result<T> = std::result::Result<T, Error>;\n\n/// Errors from this crate related to parsing WAT files\n///\n/// An error can during example phases like:\n///\n/// * Lexing can fail if the document is syntactically invalid.\n/// * A string may not be utf-8\n/// * The syntactical structure of the wat file may be invalid\n/// * The wat file may be semantically invalid such as having name resolution\n///   failures\n#[derive(Debug)]\npub struct Error {\n    kind: Box<ErrorKind>,\n}\n\n#[derive(Debug)]\nenum ErrorKind {\n    Wast(wast::Error),\n    Io {\n        err: std::io::Error,\n        file: Option<PathBuf>,\n    },\n    Custom {\n        msg: String,\n        file: Option<PathBuf>,\n    },\n}\n\nimpl Error {\n    fn cvt<E: Into<wast::Error>>(e: E, contents: &str, path: Option<&Path>) -> Error {\n        let mut err = e.into();\n        if let Some(path) = path {\n            err.set_path(path);\n        }\n        err.set_text(contents);\n        Error {\n            kind: Box::new(ErrorKind::Wast(err)),\n        }\n    }\n\n    /// To provide a more useful error this function can be used to set\n    /// the file name that this error is associated with.\n    ///\n    /// The `file` here will be stored in this error and later rendered in the\n    /// `Display` implementation.\n    pub fn set_path<P: AsRef<Path>>(&mut self, file: P) {\n        let file = file.as_ref();\n        match &mut *self.kind {\n            ErrorKind::Wast(e) => e.set_path(file),\n            ErrorKind::Custom { file: f, .. } => *f = Some(file.to_owned()),\n            ErrorKind::Io { file: f, .. } => *f = Some(file.to_owned()),\n        }\n    }\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match &*self.kind {\n            ErrorKind::Wast(err) => err.fmt(f),\n            ErrorKind::Custom { msg, file, .. } => match file {\n                Some(file) => {\n                    write!(f, \"failed to parse `{}`: {}\", file.display(), msg)\n                }\n                None => msg.fmt(f),\n            },\n            ErrorKind::Io { err, file, .. } => match file {\n                Some(file) => {\n                    write!(f, \"failed to read from `{}`\", file.display())\n                }\n                None => err.fmt(f),\n            },\n        }\n    }\n}\n\nimpl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match &*self.kind {\n            ErrorKind::Wast(_) => None,\n            ErrorKind::Custom { .. } => None,\n            ErrorKind::Io { err, .. } => Some(err),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_set_path() {\n        let mut e = parse_bytes(&[0xFF]).unwrap_err();\n        e.set_path(\"foo\");\n        assert_eq!(\n            e.to_string(),\n            \"failed to parse `foo`: input bytes aren't valid utf-8\"\n        );\n\n        let e = parse_file(\"_does_not_exist_\").unwrap_err();\n        assert!(\n            e.to_string()\n                .starts_with(\"failed to read from `_does_not_exist_`\")\n        );\n\n        let mut e = parse_bytes(\"()\".as_bytes()).unwrap_err();\n        e.set_path(\"foo\");\n        assert_eq!(\n            e.to_string(),\n            \"expected valid module field\\n     --> foo:1:2\\n      |\\n    1 | ()\\n      |  ^\"\n        );\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use alloc::boxed::Box;\nuse core::any::TypeId;\nuse core::mem::{self, MaybeUninit};\nuse core::ptr;\n\n#[cfg(feature = \"unstable-debug\")]\nuse core::any;\n\npub struct Any {\n    value: Value,\n    drop: unsafe fn(&mut Value),\n    type_id: TypeId,\n\n    /// For panic messages only. Not used for comparison.\n    #[cfg(feature = \"unstable-debug\")]\n    type_name: &'static str,\n}\n\nunion Value {\n    ptr: *mut (),\n    inline: [MaybeUninit<usize>; 2],\n}\n\nfn is_small<T>() -> bool {\n    mem::size_of::<T>() <= mem::size_of::<Value>()\n        && mem::align_of::<T>() <= mem::align_of::<Value>()\n}\n\nimpl Any {\n    // This is unsafe -- caller must not hold on to the Any beyond the lifetime\n    // of T.\n    //\n    // Example of bad code:\n    //\n    //    let s = \"bad\".to_owned();\n    //    let a = Any::new(&s);\n    //    drop(s);\n    //\n    // Now `a.as_ref()` and `a.take()` return references to a dead String.\n    pub(crate) unsafe fn new<T>(t: T) -> Self {\n        let value: Value;\n        let drop: unsafe fn(&mut Value);\n        let type_id = typeid::of::<T>();\n\n        if is_small::<T>() {\n            let mut inline = [MaybeUninit::uninit(); 2];\n            unsafe { ptr::write(inline.as_mut_ptr().cast::<T>(), t) };\n            value = Value { inline };\n            unsafe fn inline_drop<T>(value: &mut Value) {\n                unsafe { ptr::drop_in_place(value.inline.as_mut_ptr().cast::<T>()) }\n            }\n            drop = inline_drop::<T>;\n        } else {\n            let ptr = Box::into_raw(Box::new(t)).cast::<()>();\n            value = Value { ptr };\n            unsafe fn ptr_drop<T>(value: &mut Value) {\n                mem::drop(unsafe { Box::from_raw(value.ptr.cast::<T>()) });\n            }\n            drop = ptr_drop::<T>;\n        }\n\n        Any {\n            value,\n            drop,\n            type_id,\n            #[cfg(feature = \"unstable-debug\")]\n            type_name: any::type_name::<T>(),\n        }\n    }\n\n    // This is unsafe -- caller is responsible that T is the correct type.\n    pub(crate) unsafe fn take<T>(mut self) -> T {\n        if self.type_id != typeid::of::<T>() {\n            self.invalid_cast_to::<T>();\n        }\n\n        if is_small::<T>() {\n            let ptr = unsafe { self.value.inline.as_mut_ptr().cast::<T>() };\n            let value = unsafe { ptr::read(ptr) };\n            mem::forget(self);\n            value\n        } else {\n            let ptr = unsafe { self.value.ptr.cast::<T>() };\n            let box_t = unsafe { Box::from_raw(ptr) };\n            mem::forget(self);\n            *box_t\n        }\n    }\n\n    #[cfg(not(feature = \"unstable-debug\"))]\n    fn invalid_cast_to<T>(&self) -> ! {\n        panic!(\"invalid cast; enable `unstable-debug` feature to debug\");\n    }\n\n    #[cfg(feature = \"unstable-debug\")]\n    fn invalid_cast_to<T>(&self) -> ! {\n        let from = self.type_name;\n        let to = any::type_name::<T>();\n        panic!(\"invalid cast: {} to {}\", from, to);\n    }\n}\n\nimpl Drop for Any {\n    fn drop(&mut self) {\n        unsafe { (self.drop)(&mut self.value) }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::any::Any;\nuse crate::error::{erase_de as erase, unerase_de as unerase, Error};\nuse crate::map::{OptionExt, ResultExt};\nuse crate::sealed::deserializer::Sealed;\nuse alloc::boxed::Box;\n#[cfg(feature = \"alloc\")]\nuse alloc::string::String;\n#[cfg(feature = \"alloc\")]\nuse alloc::vec::Vec;\nuse core::fmt;\n\n/// Deserialize a value of type `T` from the given trait object.\n///\n/// ```rust\n/// use erased_serde::Deserializer;\n/// use std::collections::BTreeMap as Map;\n///\n/// fn main() {\n///     static JSON: &'static [u8] = br#\"{\"A\": 65, \"B\": 66}\"#;\n///     static CBOR: &'static [u8] = &[162, 97, 65, 24, 65, 97, 66, 24, 66];\n///\n///     // Construct some deserializers.\n///     let json = &mut serde_json::Deserializer::from_slice(JSON);\n///     let cbor = &mut serde_cbor::Deserializer::from_slice(CBOR);\n///\n///     // The values in this map are boxed trait objects, which is not possible\n///     // with the normal serde::Deserializer because of object safety.\n///     let mut formats: Map<&str, Box<dyn Deserializer>> = Map::new();\n///     formats.insert(\"json\", Box::new(<dyn Deserializer>::erase(json)));\n///     formats.insert(\"cbor\", Box::new(<dyn Deserializer>::erase(cbor)));\n///\n///     // Pick a Deserializer out of the formats map.\n///     let format = formats.get_mut(\"json\").unwrap();\n///\n///     let data: Map<String, usize> = erased_serde::deserialize(format).unwrap();\n///\n///     println!(\"{}\", data[\"A\"] + data[\"B\"]);\n/// }\n/// ```\npub fn deserialize<'de, T>(deserializer: &mut dyn Deserializer<'de>) -> Result<T, Error>\nwhere\n    T: serde::Deserialize<'de>,\n{\n    serde::Deserialize::deserialize(deserializer)\n}\n\n// TRAITS //////////////////////////////////////////////////////////////////////\n\npub trait DeserializeSeed<'de> {\n    fn erased_deserialize_seed(\n        &mut self,\n        deserializer: &mut dyn Deserializer<'de>,\n    ) -> Result<Out, Error>;\n}\n\n/// An object-safe equivalent of Serde's `Deserializer` trait.\n///\n/// Any implementation of Serde's `Deserializer` can be converted to a\n/// `&dyn erased_serde::Deserializer` or `Box<dyn erased_serde::Deserializer>`\n/// trait object using `erased_serde::Deserializer::erase`.\n///\n/// ```rust\n/// use erased_serde::Deserializer;\n/// use std::collections::BTreeMap as Map;\n///\n/// fn main() {\n///     static JSON: &'static [u8] = br#\"{\"A\": 65, \"B\": 66}\"#;\n///     static CBOR: &'static [u8] = &[162, 97, 65, 24, 65, 97, 66, 24, 66];\n///\n///     // Construct some deserializers.\n///     let json = &mut serde_json::Deserializer::from_slice(JSON);\n///     let cbor = &mut serde_cbor::Deserializer::from_slice(CBOR);\n///\n///     // The values in this map are boxed trait objects, which is not possible\n///     // with the normal serde::Deserializer because of object safety.\n///     let mut formats: Map<&str, Box<dyn Deserializer>> = Map::new();\n///     formats.insert(\"json\", Box::new(<dyn Deserializer>::erase(json)));\n///     formats.insert(\"cbor\", Box::new(<dyn Deserializer>::erase(cbor)));\n///\n///     // Pick a Deserializer out of the formats map.\n///     let format = formats.get_mut(\"json\").unwrap();\n///\n///     let data: Map<String, usize> = erased_serde::deserialize(format).unwrap();\n///\n///     println!(\"{}\", data[\"A\"] + data[\"B\"]);\n/// }\n/// ```\n///\n/// This trait is sealed and can only be implemented via a\n/// `serde::Deserializer<'de>` impl.\npub trait Deserializer<'de>: Sealed {\n    fn erased_deserialize_any(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_bool(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_i8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_i16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_i32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_i64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_i128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_u8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_u16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_u32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_u64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_u128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_f32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_f64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_char(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_str(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_string(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_bytes(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_byte_buf(&mut self, visitor: &mut dyn Visitor<'de>)\n        -> Result<Out, Error>;\n    fn erased_deserialize_option(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_unit(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_unit_struct(\n        &mut self,\n        name: &'static str,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_newtype_struct(\n        &mut self,\n        name: &'static str,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_seq(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_tuple(\n        &mut self,\n        len: usize,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_tuple_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_map(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>;\n    fn erased_deserialize_struct(\n        &mut self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_identifier(\n        &mut self,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_enum(\n        &mut self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_deserialize_ignored_any(\n        &mut self,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_is_human_readable(&self) -> bool;\n}\n\npub trait Visitor<'de> {\n    fn erased_expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n    fn erased_visit_bool(&mut self, v: bool) -> Result<Out, Error>;\n    fn erased_visit_i8(&mut self, v: i8) -> Result<Out, Error>;\n    fn erased_visit_i16(&mut self, v: i16) -> Result<Out, Error>;\n    fn erased_visit_i32(&mut self, v: i32) -> Result<Out, Error>;\n    fn erased_visit_i64(&mut self, v: i64) -> Result<Out, Error>;\n    fn erased_visit_i128(&mut self, v: i128) -> Result<Out, Error>;\n    fn erased_visit_u8(&mut self, v: u8) -> Result<Out, Error>;\n    fn erased_visit_u16(&mut self, v: u16) -> Result<Out, Error>;\n    fn erased_visit_u32(&mut self, v: u32) -> Result<Out, Error>;\n    fn erased_visit_u64(&mut self, v: u64) -> Result<Out, Error>;\n    fn erased_visit_u128(&mut self, v: u128) -> Result<Out, Error>;\n    fn erased_visit_f32(&mut self, v: f32) -> Result<Out, Error>;\n    fn erased_visit_f64(&mut self, v: f64) -> Result<Out, Error>;\n    fn erased_visit_char(&mut self, v: char) -> Result<Out, Error>;\n    fn erased_visit_str(&mut self, v: &str) -> Result<Out, Error>;\n    fn erased_visit_borrowed_str(&mut self, v: &'de str) -> Result<Out, Error>;\n    #[cfg(feature = \"alloc\")]\n    fn erased_visit_string(&mut self, v: String) -> Result<Out, Error>;\n    fn erased_visit_bytes(&mut self, v: &[u8]) -> Result<Out, Error>;\n    fn erased_visit_borrowed_bytes(&mut self, v: &'de [u8]) -> Result<Out, Error>;\n    #[cfg(feature = \"alloc\")]\n    fn erased_visit_byte_buf(&mut self, v: Vec<u8>) -> Result<Out, Error>;\n    fn erased_visit_none(&mut self) -> Result<Out, Error>;\n    fn erased_visit_some(&mut self, deserializer: &mut dyn Deserializer<'de>)\n        -> Result<Out, Error>;\n    fn erased_visit_unit(&mut self) -> Result<Out, Error>;\n    fn erased_visit_newtype_struct(\n        &mut self,\n        deserializer: &mut dyn Deserializer<'de>,\n    ) -> Result<Out, Error>;\n    fn erased_visit_seq(&mut self, seq: &mut dyn SeqAccess<'de>) -> Result<Out, Error>;\n    fn erased_visit_map(&mut self, map: &mut dyn MapAccess<'de>) -> Result<Out, Error>;\n    fn erased_visit_enum(&mut self, data: &mut dyn EnumAccess<'de>) -> Result<Out, Error>;\n}\n\npub trait SeqAccess<'de> {\n    fn erased_next_element(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<Out>, Error>;\n    fn erased_size_hint(&self) -> Option<usize>;\n}\n\npub trait MapAccess<'de> {\n    fn erased_next_key(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<Out>, Error>;\n    fn erased_next_value(&mut self, seed: &mut dyn DeserializeSeed<'de>) -> Result<Out, Error>;\n    fn erased_next_entry(\n        &mut self,\n        key: &mut dyn DeserializeSeed<'de>,\n        value: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<(Out, Out)>, Error>;\n    fn erased_size_hint(&self) -> Option<usize>;\n}\n\npub trait EnumAccess<'de> {\n    fn erased_variant_seed(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<(Out, Variant<'de>), Error>;\n}\n\nimpl<'de> dyn Deserializer<'de> {\n    return_impl_trait! {\n        /// Convert any Serde `Deserializer` to a trait object.\n        ///\n        /// ```rust\n        /// use erased_serde::Deserializer;\n        /// use std::collections::BTreeMap as Map;\n        ///\n        /// fn main() {\n        ///     static JSON: &'static [u8] = br#\"{\"A\": 65, \"B\": 66}\"#;\n        ///     static CBOR: &'static [u8] = &[162, 97, 65, 24, 65, 97, 66, 24, 66];\n        ///\n        ///     // Construct some deserializers.\n        ///     let json = &mut serde_json::Deserializer::from_slice(JSON);\n        ///     let cbor = &mut serde_cbor::Deserializer::from_slice(CBOR);\n        ///\n        ///     // The values in this map are boxed trait objects, which is not possible\n        ///     // with the normal serde::Deserializer because of object safety.\n        ///     let mut formats: Map<&str, Box<dyn Deserializer>> = Map::new();\n        ///     formats.insert(\"json\", Box::new(<dyn Deserializer>::erase(json)));\n        ///     formats.insert(\"cbor\", Box::new(<dyn Deserializer>::erase(cbor)));\n        ///\n        ///     // Pick a Deserializer out of the formats map.\n        ///     let format = formats.get_mut(\"json\").unwrap();\n        ///\n        ///     let data: Map<String, usize> = erased_serde::deserialize(format).unwrap();\n        ///\n        ///     println!(\"{}\", data[\"A\"] + data[\"B\"]);\n        /// }\n        /// ```\n        pub fn erase<D>(deserializer: D) -> impl Deserializer<'de> [erase::Deserializer<D>]\n        where\n            D: serde::Deserializer<'de>,\n        {\n            erase::Deserializer::new(deserializer)\n        }\n    }\n}\n\n// OUT /////////////////////////////////////////////////////////////////////////\n\npub struct Out(Any);\n\nimpl Out {\n    unsafe fn new<T>(t: T) -> Self {\n        Out(unsafe { Any::new(t) })\n    }\n\n    unsafe fn take<T>(self) -> T {\n        unsafe { self.0.take() }\n    }\n}\n\n// IMPL ERASED SERDE FOR SERDE /////////////////////////////////////////////////\n\nmod erase {\n    pub struct DeserializeSeed<D> {\n        state: Option<D>,\n    }\n\n    impl<D> DeserializeSeed<D> {\n        pub(crate) fn new(seed: D) -> Self {\n            DeserializeSeed { state: Some(seed) }\n        }\n\n        pub(crate) fn take(&mut self) -> D {\n            self.state.take().unwrap()\n        }\n    }\n\n    pub struct Deserializer<D> {\n        state: Option<D>,\n    }\n\n    impl<D> Deserializer<D> {\n        pub(crate) fn new(deserializer: D) -> Self {\n            Deserializer {\n                state: Some(deserializer),\n            }\n        }\n\n        pub(crate) fn take(&mut self) -> D {\n            self.state.take().unwrap()\n        }\n\n        pub(crate) fn as_ref(&self) -> &D {\n            self.state.as_ref().unwrap()\n        }\n    }\n\n    pub struct Visitor<D> {\n        state: Option<D>,\n    }\n\n    impl<D> Visitor<D> {\n        pub(crate) fn new(visitor: D) -> Self {\n            Visitor {\n                state: Some(visitor),\n            }\n        }\n\n        pub(crate) fn take(&mut self) -> D {\n            self.state.take().unwrap()\n        }\n\n        pub(crate) fn as_ref(&self) -> &D {\n            self.state.as_ref().unwrap()\n        }\n    }\n\n    pub struct SeqAccess<D> {\n        state: D,\n    }\n\n    impl<D> SeqAccess<D> {\n        pub(crate) fn new(seq_access: D) -> Self {\n            SeqAccess { state: seq_access }\n        }\n\n        pub(crate) fn as_ref(&self) -> &D {\n            &self.state\n        }\n\n        pub(crate) fn as_mut(&mut self) -> &mut D {\n            &mut self.state\n        }\n    }\n\n    pub struct MapAccess<D> {\n        state: D,\n    }\n\n    impl<D> MapAccess<D> {\n        pub(crate) fn new(map_access: D) -> Self {\n            MapAccess { state: map_access }\n        }\n\n        pub(crate) fn as_ref(&self) -> &D {\n            &self.state\n        }\n\n        pub(crate) fn as_mut(&mut self) -> &mut D {\n            &mut self.state\n        }\n    }\n\n    pub struct EnumAccess<D> {\n        state: Option<D>,\n    }\n\n    impl<D> EnumAccess<D> {\n        pub(crate) fn new(enum_access: D) -> Self {\n            EnumAccess {\n                state: Some(enum_access),\n            }\n        }\n\n        pub(crate) fn take(&mut self) -> D {\n            self.state.take().unwrap()\n        }\n    }\n}\n\nimpl<'de, T> DeserializeSeed<'de> for erase::DeserializeSeed<T>\nwhere\n    T: serde::de::DeserializeSeed<'de>,\n{\n    fn erased_deserialize_seed(\n        &mut self,\n        deserializer: &mut dyn Deserializer<'de>,\n    ) -> Result<Out, Error> {\n        unsafe { self.take().deserialize(deserializer).unsafe_map(Out::new) }\n    }\n}\n\nimpl<'de, T> Deserializer<'de> for erase::Deserializer<T>\nwhere\n    T: serde::Deserializer<'de>,\n{\n    fn erased_deserialize_any(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_any(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_bool(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_bool(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_i8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_i8(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_i16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_i16(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_i32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_i32(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_i64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_i64(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_i128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_i128(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_u8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_u8(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_u16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_u16(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_u32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_u32(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_u64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_u64(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_u128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_u128(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_f32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_f32(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_f64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_f64(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_char(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_char(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_str(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_str(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_string(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_string(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_bytes(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_bytes(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_byte_buf(\n        &mut self,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take().deserialize_byte_buf(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_option(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_option(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_unit(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_unit(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_unit_struct(\n        &mut self,\n        name: &'static str,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take()\n            .deserialize_unit_struct(name, visitor)\n            .map_err(erase)\n    }\n\n    fn erased_deserialize_newtype_struct(\n        &mut self,\n        name: &'static str,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take()\n            .deserialize_newtype_struct(name, visitor)\n            .map_err(erase)\n    }\n\n    fn erased_deserialize_seq(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_seq(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_tuple(\n        &mut self,\n        len: usize,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take().deserialize_tuple(len, visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_tuple_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take()\n            .deserialize_tuple_struct(name, len, visitor)\n            .map_err(erase)\n    }\n\n    fn erased_deserialize_map(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n        self.take().deserialize_map(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_struct(\n        &mut self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take()\n            .deserialize_struct(name, fields, visitor)\n            .map_err(erase)\n    }\n\n    fn erased_deserialize_identifier(\n        &mut self,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take().deserialize_identifier(visitor).map_err(erase)\n    }\n\n    fn erased_deserialize_enum(\n        &mut self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take()\n            .deserialize_enum(name, variants, visitor)\n            .map_err(erase)\n    }\n\n    fn erased_deserialize_ignored_any(\n        &mut self,\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error> {\n        self.take().deserialize_ignored_any(visitor).map_err(erase)\n    }\n\n    fn erased_is_human_readable(&self) -> bool {\n        self.as_ref().is_human_readable()\n    }\n}\n\nimpl<'de, T> Sealed for erase::Deserializer<T> where T: serde::Deserializer<'de> {}\n\nimpl<'de, T> Visitor<'de> for erase::Visitor<T>\nwhere\n    T: serde::de::Visitor<'de>,\n{\n    fn erased_expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        self.as_ref().expecting(formatter)\n    }\n\n    fn erased_visit_bool(&mut self, v: bool) -> Result<Out, Error> {\n        unsafe { self.take().visit_bool(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_i8(&mut self, v: i8) -> Result<Out, Error> {\n        unsafe { self.take().visit_i8(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_i16(&mut self, v: i16) -> Result<Out, Error> {\n        unsafe { self.take().visit_i16(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_i32(&mut self, v: i32) -> Result<Out, Error> {\n        unsafe { self.take().visit_i32(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_i64(&mut self, v: i64) -> Result<Out, Error> {\n        unsafe { self.take().visit_i64(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_i128(&mut self, v: i128) -> Result<Out, Error> {\n        unsafe { self.take().visit_i128(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_u8(&mut self, v: u8) -> Result<Out, Error> {\n        unsafe { self.take().visit_u8(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_u16(&mut self, v: u16) -> Result<Out, Error> {\n        unsafe { self.take().visit_u16(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_u32(&mut self, v: u32) -> Result<Out, Error> {\n        unsafe { self.take().visit_u32(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_u64(&mut self, v: u64) -> Result<Out, Error> {\n        unsafe { self.take().visit_u64(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_u128(&mut self, v: u128) -> Result<Out, Error> {\n        unsafe { self.take().visit_u128(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_f32(&mut self, v: f32) -> Result<Out, Error> {\n        unsafe { self.take().visit_f32(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_f64(&mut self, v: f64) -> Result<Out, Error> {\n        unsafe { self.take().visit_f64(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_char(&mut self, v: char) -> Result<Out, Error> {\n        unsafe { self.take().visit_char(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_str(&mut self, v: &str) -> Result<Out, Error> {\n        unsafe { self.take().visit_str(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_borrowed_str(&mut self, v: &'de str) -> Result<Out, Error> {\n        unsafe { self.take().visit_borrowed_str(v).unsafe_map(Out::new) }\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn erased_visit_string(&mut self, v: String) -> Result<Out, Error> {\n        unsafe { self.take().visit_string(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_bytes(&mut self, v: &[u8]) -> Result<Out, Error> {\n        unsafe { self.take().visit_bytes(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_borrowed_bytes(&mut self, v: &'de [u8]) -> Result<Out, Error> {\n        unsafe { self.take().visit_borrowed_bytes(v).unsafe_map(Out::new) }\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn erased_visit_byte_buf(&mut self, v: Vec<u8>) -> Result<Out, Error> {\n        unsafe { self.take().visit_byte_buf(v).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_none(&mut self) -> Result<Out, Error> {\n        unsafe { self.take().visit_none().unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_some(\n        &mut self,\n        deserializer: &mut dyn Deserializer<'de>,\n    ) -> Result<Out, Error> {\n        unsafe { self.take().visit_some(deserializer).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_unit(&mut self) -> Result<Out, Error> {\n        unsafe { self.take().visit_unit().unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_newtype_struct(\n        &mut self,\n        deserializer: &mut dyn Deserializer<'de>,\n    ) -> Result<Out, Error> {\n        unsafe {\n            self.take()\n                .visit_newtype_struct(deserializer)\n                .unsafe_map(Out::new)\n        }\n    }\n\n    fn erased_visit_seq(&mut self, seq: &mut dyn SeqAccess<'de>) -> Result<Out, Error> {\n        unsafe { self.take().visit_seq(seq).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_map(&mut self, map: &mut dyn MapAccess<'de>) -> Result<Out, Error> {\n        unsafe { self.take().visit_map(map).unsafe_map(Out::new) }\n    }\n\n    fn erased_visit_enum(&mut self, data: &mut dyn EnumAccess<'de>) -> Result<Out, Error> {\n        unsafe { self.take().visit_enum(data).unsafe_map(Out::new) }\n    }\n}\n\nimpl<'de, T> SeqAccess<'de> for erase::SeqAccess<T>\nwhere\n    T: serde::de::SeqAccess<'de>,\n{\n    fn erased_next_element(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<Out>, Error> {\n        self.as_mut().next_element_seed(seed).map_err(erase)\n    }\n\n    fn erased_size_hint(&self) -> Option<usize> {\n        self.as_ref().size_hint()\n    }\n}\n\nimpl<'de, T> MapAccess<'de> for erase::MapAccess<T>\nwhere\n    T: serde::de::MapAccess<'de>,\n{\n    fn erased_next_key(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<Out>, Error> {\n        self.as_mut().next_key_seed(seed).map_err(erase)\n    }\n\n    fn erased_next_value(&mut self, seed: &mut dyn DeserializeSeed<'de>) -> Result<Out, Error> {\n        self.as_mut().next_value_seed(seed).map_err(erase)\n    }\n\n    fn erased_next_entry(\n        &mut self,\n        kseed: &mut dyn DeserializeSeed<'de>,\n        vseed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<Option<(Out, Out)>, Error> {\n        self.as_mut().next_entry_seed(kseed, vseed).map_err(erase)\n    }\n\n    fn erased_size_hint(&self) -> Option<usize> {\n        self.as_ref().size_hint()\n    }\n}\n\nimpl<'de, T> EnumAccess<'de> for erase::EnumAccess<T>\nwhere\n    T: serde::de::EnumAccess<'de>,\n{\n    fn erased_variant_seed(\n        &mut self,\n        seed: &mut dyn DeserializeSeed<'de>,\n    ) -> Result<(Out, Variant<'de>), Error> {\n        self.take()\n            .variant_seed(seed)\n            .map(|(out, variant)| {\n                use serde::de::VariantAccess;\n                let erased = Variant {\n                    data: unsafe { Any::new(variant) },\n                    unit_variant: {\n                        unsafe fn unit_variant<'de, T>(a: Any) -> Result<(), Error>\n                        where\n                            T: serde::de::EnumAccess<'de>,\n                        {\n                            unsafe { a.take::<T::Variant>().unit_variant().map_err(erase) }\n                        }\n                        unit_variant::<T>\n                    },\n                    visit_newtype: {\n                        unsafe fn visit_newtype<'de, T>(\n                            a: Any,\n                            seed: &mut dyn DeserializeSeed<'de>,\n                        ) -> Result<Out, Error>\n                        where\n                            T: serde::de::EnumAccess<'de>,\n                        {\n                            unsafe {\n                                a.take::<T::Variant>()\n                                    .newtype_variant_seed(seed)\n                                    .map_err(erase)\n                            }\n                        }\n                        visit_newtype::<T>\n                    },\n                    tuple_variant: {\n                        unsafe fn tuple_variant<'de, T>(\n                            a: Any,\n                            len: usize,\n                            visitor: &mut dyn Visitor<'de>,\n                        ) -> Result<Out, Error>\n                        where\n                            T: serde::de::EnumAccess<'de>,\n                        {\n                            unsafe {\n                                a.take::<T::Variant>()\n                                    .tuple_variant(len, visitor)\n                                    .map_err(erase)\n                            }\n                        }\n                        tuple_variant::<T>\n                    },\n                    struct_variant: {\n                        unsafe fn struct_variant<'de, T>(\n                            a: Any,\n                            fields: &'static [&'static str],\n                            visitor: &mut dyn Visitor<'de>,\n                        ) -> Result<Out, Error>\n                        where\n                            T: serde::de::EnumAccess<'de>,\n                        {\n                            unsafe {\n                                a.take::<T::Variant>()\n                                    .struct_variant(fields, visitor)\n                                    .map_err(erase)\n                            }\n                        }\n                        struct_variant::<T>\n                    },\n                };\n                (out, erased)\n            })\n            .map_err(erase)\n    }\n}\n\n// IMPL SERDE FOR ERASED SERDE /////////////////////////////////////////////////\n\nimpl<'de> serde::de::DeserializeSeed<'de> for &mut (dyn DeserializeSeed<'de> + '_) {\n    type Value = Out;\n    fn deserialize<D>(self, deserializer: D) -> Result<Out, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let mut erased = erase::Deserializer::new(deserializer);\n        self.erased_deserialize_seed(&mut erased).map_err(unerase)\n    }\n}\n\nmacro_rules! impl_deserializer_for_trait_object {\n    ({$($mut:tt)*} $ty:ty) => {\n        impl<'de> serde::Deserializer<'de> for $ty {\n            type Error = Error;\n\n            fn deserialize_any<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_any(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_bool<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_bool(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_i8<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_i8(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_i16<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_i16(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_i32<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_i32(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_i64<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_i64(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_i128<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_i128(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_u8<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_u8(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_u16<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_u16(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_u32<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_u32(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_u64<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_u64(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_u128<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_u128(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_f32<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_f32(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_f64<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_f64(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_char<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_char(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_str<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_str(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_string<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_string(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_bytes<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_bytes(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_byte_buf<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_byte_buf(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_option<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_option(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_unit<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_unit(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_unit_struct<V>($($mut)* self, name: &'static str, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_unit_struct(name, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_newtype_struct<V>($($mut)* self, name: &'static str, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_newtype_struct(name, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_seq<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_seq(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_tuple<V>($($mut)* self, len: usize, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_tuple(len, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_tuple_struct<V>($($mut)* self, name: &'static str, len: usize, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_tuple_struct(name, len, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_map<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_map(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_struct<V>($($mut)* self, name: &'static str, fields: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_struct(name, fields, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_identifier<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_identifier(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_enum<V>($($mut)* self, name: &'static str, variants: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_enum(name, variants, &mut erased).unsafe_map(Out::take) }\n            }\n\n            fn deserialize_ignored_any<V>($($mut)* self, visitor: V) -> Result<V::Value, Error>\n            where\n                V: serde::de::Visitor<'de>,\n            {\n                let mut erased = erase::Visitor::new(visitor);\n                unsafe { self.erased_deserialize_ignored_any(&mut erased).unsafe_map(Out::take) }\n            }\n\n            fn is_human_readable(&self) -> bool {\n                self.erased_is_human_readable()\n            }\n        }\n    };\n}\n\nimpl_deserializer_for_trait_object!({} &mut (dyn Deserializer<'de> + '_));\nimpl_deserializer_for_trait_object!({} &mut (dyn Deserializer<'de> + Send + '_));\nimpl_deserializer_for_trait_object!({} &mut (dyn Deserializer<'de> + Sync + '_));\nimpl_deserializer_for_trait_object!({} &mut (dyn Deserializer<'de> + Send + Sync + '_));\nimpl_deserializer_for_trait_object!({mut} Box<dyn Deserializer<'de> + '_>);\nimpl_deserializer_for_trait_object!({mut} Box<dyn Deserializer<'de> + Send + '_>);\nimpl_deserializer_for_trait_object!({mut} Box<dyn Deserializer<'de> + Sync + '_>);\nimpl_deserializer_for_trait_object!({mut} Box<dyn Deserializer<'de> + Send + Sync + '_>);\n\nimpl<'de> serde::de::Visitor<'de> for &mut (dyn Visitor<'de> + '_) {\n    type Value = Out;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        (**self).erased_expecting(formatter)\n    }\n\n    fn visit_bool<E>(self, v: bool) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_bool(v).map_err(unerase)\n    }\n\n    fn visit_i8<E>(self, v: i8) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_i8(v).map_err(unerase)\n    }\n\n    fn visit_i16<E>(self, v: i16) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_i16(v).map_err(unerase)\n    }\n\n    fn visit_i32<E>(self, v: i32) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_i32(v).map_err(unerase)\n    }\n\n    fn visit_i64<E>(self, v: i64) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_i64(v).map_err(unerase)\n    }\n\n    fn visit_i128<E>(self, v: i128) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_i128(v).map_err(unerase)\n    }\n\n    fn visit_u8<E>(self, v: u8) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_u8(v).map_err(unerase)\n    }\n\n    fn visit_u16<E>(self, v: u16) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_u16(v).map_err(unerase)\n    }\n\n    fn visit_u32<E>(self, v: u32) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_u32(v).map_err(unerase)\n    }\n\n    fn visit_u64<E>(self, v: u64) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_u64(v).map_err(unerase)\n    }\n\n    fn visit_u128<E>(self, v: u128) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_u128(v).map_err(unerase)\n    }\n\n    fn visit_f32<E>(self, v: f32) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_f32(v).map_err(unerase)\n    }\n\n    fn visit_f64<E>(self, v: f64) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_f64(v).map_err(unerase)\n    }\n\n    fn visit_char<E>(self, v: char) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_char(v).map_err(unerase)\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_str(v).map_err(unerase)\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_borrowed_str(v).map_err(unerase)\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn visit_string<E>(self, v: String) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_string(v).map_err(unerase)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_bytes(v).map_err(unerase)\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_borrowed_bytes(v).map_err(unerase)\n    }\n\n    #[cfg(feature = \"alloc\")]\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_byte_buf(v).map_err(unerase)\n    }\n\n    fn visit_none<E>(self) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_none().map_err(unerase)\n    }\n\n    fn visit_some<D>(self, deserializer: D) -> Result<Out, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let mut erased = erase::Deserializer::new(deserializer);\n        self.erased_visit_some(&mut erased).map_err(unerase)\n    }\n\n    fn visit_unit<E>(self) -> Result<Out, E>\n    where\n        E: serde::de::Error,\n    {\n        self.erased_visit_unit().map_err(unerase)\n    }\n\n    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Out, D::Error>\n    where\n        D: serde::Deserializer<'de>,\n    {\n        let mut erased = erase::Deserializer::new(deserializer);\n        self.erased_visit_newtype_struct(&mut erased)\n            .map_err(unerase)\n    }\n\n    fn visit_seq<V>(self, seq: V) -> Result<Out, V::Error>\n    where\n        V: serde::de::SeqAccess<'de>,\n    {\n        let mut erased = erase::SeqAccess::new(seq);\n        self.erased_visit_seq(&mut erased).map_err(unerase)\n    }\n\n    fn visit_map<V>(self, map: V) -> Result<Out, V::Error>\n    where\n        V: serde::de::MapAccess<'de>,\n    {\n        let mut erased = erase::MapAccess::new(map);\n        self.erased_visit_map(&mut erased).map_err(unerase)\n    }\n\n    fn visit_enum<V>(self, data: V) -> Result<Out, V::Error>\n    where\n        V: serde::de::EnumAccess<'de>,\n    {\n        let mut erased = erase::EnumAccess::new(data);\n        self.erased_visit_enum(&mut erased).map_err(unerase)\n    }\n}\n\nimpl<'de> serde::de::SeqAccess<'de> for &mut (dyn SeqAccess<'de> + '_) {\n    type Error = Error;\n\n    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n    where\n        T: serde::de::DeserializeSeed<'de>,\n    {\n        let mut seed = erase::DeserializeSeed::new(seed);\n        unsafe {\n            (**self)\n                .erased_next_element(&mut seed)\n                .map(|opt| opt.unsafe_map(Out::take))\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        (**self).erased_size_hint()\n    }\n}\n\nimpl<'de> serde::de::MapAccess<'de> for &mut (dyn MapAccess<'de> + '_) {\n    type Error = Error;\n\n    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n    where\n        K: serde::de::DeserializeSeed<'de>,\n    {\n        let mut erased = erase::DeserializeSeed::new(seed);\n        unsafe {\n            (**self)\n                .erased_next_key(&mut erased)\n                .map(|opt| opt.unsafe_map(Out::take))\n        }\n    }\n\n    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::DeserializeSeed<'de>,\n    {\n        let mut erased = erase::DeserializeSeed::new(seed);\n        unsafe {\n            (**self)\n                .erased_next_value(&mut erased)\n                .unsafe_map(Out::take)\n        }\n    }\n\n    fn size_hint(&self) -> Option<usize> {\n        (**self).erased_size_hint()\n    }\n}\n\nimpl<'de> serde::de::EnumAccess<'de> for &mut (dyn EnumAccess<'de> + '_) {\n    type Error = Error;\n    type Variant = Variant<'de>;\n\n    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n    where\n        V: serde::de::DeserializeSeed<'de>,\n    {\n        let mut erased = erase::DeserializeSeed::new(seed);\n        match self.erased_variant_seed(&mut erased) {\n            Ok((out, variant)) => Ok((unsafe { out.take() }, variant)),\n            Err(err) => Err(err),\n        }\n    }\n}\n\npub struct Variant<'de> {\n    data: Any,\n    unit_variant: unsafe fn(Any) -> Result<(), Error>,\n    visit_newtype: unsafe fn(Any, seed: &mut dyn DeserializeSeed<'de>) -> Result<Out, Error>,\n    tuple_variant: unsafe fn(Any, len: usize, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error>,\n    struct_variant: unsafe fn(\n        Any,\n        fields: &'static [&'static str],\n        visitor: &mut dyn Visitor<'de>,\n    ) -> Result<Out, Error>,\n}\n\nimpl<'de> serde::de::VariantAccess<'de> for Variant<'de> {\n    type Error = Error;\n\n    fn unit_variant(self) -> Result<(), Error> {\n        unsafe { (self.unit_variant)(self.data) }\n    }\n\n    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Error>\n    where\n        T: serde::de::DeserializeSeed<'de>,\n    {\n        let mut erased = erase::DeserializeSeed::new(seed);\n        unsafe { (self.visit_newtype)(self.data, &mut erased).unsafe_map(Out::take) }\n    }\n\n    fn tuple_variant<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let mut erased = erase::Visitor::new(visitor);\n        unsafe { (self.tuple_variant)(self.data, len, &mut erased).unsafe_map(Out::take) }\n    }\n\n    fn struct_variant<V>(\n        self,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Error>\n    where\n        V: serde::de::Visitor<'de>,\n    {\n        let mut erased = erase::Visitor::new(visitor);\n        unsafe { (self.struct_variant)(self.data, fields, &mut erased).unsafe_map(Out::take) }\n    }\n}\n\n// IMPL ERASED SERDE FOR ERASED SERDE //////////////////////////////////////////\n\nmacro_rules! deref_erased_deserializer {\n    (<'de $(, $T:ident)*> Deserializer<'de> for $ty:ty $(where $($where:tt)*)?) => {\n        impl<'de $(, $T)*> Deserializer<'de> for $ty $(where $($where)*)? {\n            fn erased_deserialize_any(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_any(visitor)\n            }\n\n            fn erased_deserialize_bool(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_bool(visitor)\n            }\n\n            fn erased_deserialize_i8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_i8(visitor)\n            }\n\n            fn erased_deserialize_i16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_i16(visitor)\n            }\n\n            fn erased_deserialize_i32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_i32(visitor)\n            }\n\n            fn erased_deserialize_i64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_i64(visitor)\n            }\n\n            fn erased_deserialize_i128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_i128(visitor)\n            }\n\n            fn erased_deserialize_u8(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_u8(visitor)\n            }\n\n            fn erased_deserialize_u16(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_u16(visitor)\n            }\n\n            fn erased_deserialize_u32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_u32(visitor)\n            }\n\n            fn erased_deserialize_u64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_u64(visitor)\n            }\n\n            fn erased_deserialize_u128(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_u128(visitor)\n            }\n\n            fn erased_deserialize_f32(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_f32(visitor)\n            }\n\n            fn erased_deserialize_f64(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_f64(visitor)\n            }\n\n            fn erased_deserialize_char(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_char(visitor)\n            }\n\n            fn erased_deserialize_str(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_str(visitor)\n            }\n\n            fn erased_deserialize_string(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_string(visitor)\n            }\n\n            fn erased_deserialize_bytes(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_bytes(visitor)\n            }\n\n            fn erased_deserialize_byte_buf(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_byte_buf(visitor)\n            }\n\n            fn erased_deserialize_option(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_option(visitor)\n            }\n\n            fn erased_deserialize_unit(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_unit(visitor)\n            }\n\n            fn erased_deserialize_unit_struct(&mut self, name: &'static str, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_unit_struct(name, visitor)\n            }\n\n            fn erased_deserialize_newtype_struct(&mut self, name: &'static str, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_newtype_struct(name, visitor)\n            }\n\n            fn erased_deserialize_seq(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_seq(visitor)\n            }\n\n            fn erased_deserialize_tuple(&mut self, len: usize, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_tuple(len, visitor)\n            }\n\n            fn erased_deserialize_tuple_struct(&mut self, name: &'static str, len: usize, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_tuple_struct(name, len, visitor)\n            }\n\n            fn erased_deserialize_map(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_map(visitor)\n            }\n\n            fn erased_deserialize_struct(&mut self, name: &'static str, fields: &'static [&'static str], visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_struct(name, fields, visitor)\n            }\n\n            fn erased_deserialize_identifier(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_identifier(visitor)\n            }\n\n            fn erased_deserialize_enum(&mut self, name: &'static str, variants: &'static [&'static str], visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_enum(name, variants, visitor)\n            }\n\n            fn erased_deserialize_ignored_any(&mut self, visitor: &mut dyn Visitor<'de>) -> Result<Out, Error> {\n                (**self).erased_deserialize_ignored_any(visitor)\n            }\n\n            fn erased_is_human_readable(&self) -> bool {\n                (**self).erased_is_human_readable()\n            }\n        }\n\n        impl<'de $(, $T)*> Sealed for $ty $(where $($where)*)? {}\n    };\n}\n\nderef_erased_deserializer!(<'de, T> Deserializer<'de> for &mut T where T: ?Sized + Deserializer<'de>);\nderef_erased_deserializer!(<'de, T> Deserializer<'de> for Box<T> where T: ?Sized + Deserializer<'de>);\n\n// TEST ////////////////////////////////////////////////////////////////////////\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::borrow::ToOwned;\n    use core::fmt::Debug;\n    use serde_derive::Deserialize;\n\n    fn test_json<'de, T>(json: &'de [u8])\n    where\n        T: serde::Deserialize<'de> + PartialEq + Debug,\n    {\n        let expected: T = serde_json::from_slice(json).unwrap();\n\n        // test borrowed trait object\n        {\n            let mut de = serde_json::Deserializer::from_slice(json);\n            let de: &mut dyn Deserializer = &mut <dyn Deserializer>::erase(&mut de);\n            assert_eq!(expected, deserialize::<T>(de).unwrap());\n        }\n\n        // test boxed trait object\n        {\n            let mut de = serde_json::Deserializer::from_slice(json);\n            let mut de: Box<dyn Deserializer> = Box::new(<dyn Deserializer>::erase(&mut de));\n            assert_eq!(expected, deserialize::<T>(&mut de).unwrap());\n        }\n    }\n\n    #[test]\n    fn test_value() {\n        test_json::<serde_json::Value>(br#\"[\"a\", 1, [true], {\"a\": 1}]\"#);\n    }\n\n    #[test]\n    fn test_struct() {\n        #[derive(Deserialize, PartialEq, Debug)]\n        struct S {\n            f: usize,\n        }\n\n        test_json::<S>(br#\"{\"f\":256}\"#);\n    }\n\n    #[test]\n    fn test_enum() {\n        #[derive(Deserialize, PartialEq, Debug)]\n        enum E {\n            Unit,\n            Newtype(bool),\n            Tuple(bool, bool),\n            Struct { t: bool, f: bool },\n        }\n\n        test_json::<E>(br#\"\"Unit\"\"#);\n        test_json::<E>(br#\"{\"Newtype\":true}\"#);\n        test_json::<E>(br#\"{\"Tuple\":[true,false]}\"#);\n        test_json::<E>(br#\"{\"Struct\":{\"t\":true,\"f\":false}}\"#);\n    }\n\n    #[test]\n    fn test_borrowed() {\n        let bytes = br#\"\"borrowed\"\"#.to_owned();\n        test_json::<&str>(&bytes);\n    }\n\n    #[test]\n    fn assert_deserializer() {\n        fn assert<'de, T: serde::Deserializer<'de>>() {}\n\n        assert::<&mut dyn Deserializer>();\n        assert::<&mut (dyn Deserializer + Send)>();\n        assert::<&mut (dyn Deserializer + Sync)>();\n        assert::<&mut (dyn Deserializer + Send + Sync)>();\n        assert::<&mut (dyn Deserializer + Sync + Send)>();\n\n        assert::<Box<dyn Deserializer>>();\n        assert::<Box<dyn Deserializer + Send>>();\n        assert::<Box<dyn Deserializer + Sync>>();\n        assert::<Box<dyn Deserializer + Send + Sync>>();\n        assert::<Box<dyn Deserializer + Sync + Send>>();\n    }\n\n    #[test]\n    fn test_dangle() {\n        let mut json_deserializer = serde_json::Deserializer::from_str(\"\");\n        let _erased_deserializer = <dyn Deserializer>::erase(&mut json_deserializer);\n        drop(json_deserializer);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use alloc::borrow::ToOwned;\nuse alloc::boxed::Box;\nuse alloc::string::{String, ToString};\nuse alloc::vec::Vec;\nuse core::fmt::{self, Debug, Display};\nuse serde::de::Expected;\n\n/// Error when a `Serializer` or `Deserializer` trait object fails.\npub struct Error {\n    imp: Box<ErrorImpl>,\n}\n\n/// Result type alias where the error is `erased_serde::Error`.\npub type Result<T> = core::result::Result<T, Error>;\n\npub(crate) fn erase_de<E: serde::de::Error>(e: E) -> Error {\n    serde::de::Error::custom(e)\n}\n\npub(crate) fn unerase_de<E: serde::de::Error>(e: Error) -> E {\n    e.as_serde_de_error()\n}\n\nimpl Display for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let error = self.as_serde_de_error::<serde::de::value::Error>();\n        Display::fmt(&error, formatter)\n    }\n}\n\nimpl Debug for Error {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        let error = self.as_serde_de_error::<serde::de::value::Error>();\n        Debug::fmt(&error, formatter)\n    }\n}\n\nimpl serde::ser::StdError for Error {}\n\nenum ErrorImpl {\n    Custom(String),\n    InvalidType {\n        unexpected: Unexpected,\n        expected: String,\n    },\n    InvalidValue {\n        unexpected: Unexpected,\n        expected: String,\n    },\n    InvalidLength {\n        len: usize,\n        expected: String,\n    },\n    UnknownVariant {\n        variant: String,\n        expected: &'static [&'static str],\n    },\n    UnknownField {\n        field: String,\n        expected: &'static [&'static str],\n    },\n    MissingField {\n        field: &'static str,\n    },\n    DuplicateField {\n        field: &'static str,\n    },\n}\n\nenum Unexpected {\n    Bool(bool),\n    Unsigned(u64),\n    Signed(i64),\n    Float(f64),\n    Char(char),\n    Str(String),\n    Bytes(Vec<u8>),\n    Unit,\n    Option,\n    NewtypeStruct,\n    Seq,\n    Map,\n    Enum,\n    UnitVariant,\n    NewtypeVariant,\n    TupleVariant,\n    StructVariant,\n    Other(String),\n}\n\nimpl serde::ser::Error for Error {\n    fn custom<T: Display>(msg: T) -> Self {\n        let imp = Box::new(ErrorImpl::Custom(msg.to_string()));\n        Error { imp }\n    }\n}\n\nimpl serde::de::Error for Error {\n    fn custom<T: Display>(msg: T) -> Self {\n        let imp = Box::new(ErrorImpl::Custom(msg.to_string()));\n        Error { imp }\n    }\n\n    fn invalid_type(unexpected: serde::de::Unexpected, expected: &dyn Expected) -> Self {\n        let imp = Box::new(ErrorImpl::InvalidType {\n            unexpected: Unexpected::from_serde(unexpected),\n            expected: expected.to_string(),\n        });\n        Error { imp }\n    }\n\n    fn invalid_value(unexpected: serde::de::Unexpected, expected: &dyn Expected) -> Self {\n        let imp = Box::new(ErrorImpl::InvalidValue {\n            unexpected: Unexpected::from_serde(unexpected),\n            expected: expected.to_string(),\n        });\n        Error { imp }\n    }\n\n    fn invalid_length(len: usize, expected: &dyn Expected) -> Self {\n        let imp = Box::new(ErrorImpl::InvalidLength {\n            len,\n            expected: expected.to_string(),\n        });\n        Error { imp }\n    }\n\n    fn unknown_variant(variant: &str, expected: &'static [&'static str]) -> Self {\n        let imp = Box::new(ErrorImpl::UnknownVariant {\n            variant: variant.to_owned(),\n            expected,\n        });\n        Error { imp }\n    }\n\n    fn unknown_field(field: &str, expected: &'static [&'static str]) -> Self {\n        let imp = Box::new(ErrorImpl::UnknownField {\n            field: field.to_owned(),\n            expected,\n        });\n        Error { imp }\n    }\n\n    fn missing_field(field: &'static str) -> Self {\n        let imp = Box::new(ErrorImpl::MissingField { field });\n        Error { imp }\n    }\n\n    fn duplicate_field(field: &'static str) -> Self {\n        let imp = Box::new(ErrorImpl::DuplicateField { field });\n        Error { imp }\n    }\n}\n\nimpl Error {\n    fn as_serde_de_error<E: serde::de::Error>(&self) -> E {\n        match self.imp.as_ref() {\n            ErrorImpl::Custom(msg) => E::custom(msg),\n            ErrorImpl::InvalidType {\n                unexpected,\n                expected,\n            } => E::invalid_type(unexpected.as_serde(), &expected.as_str()),\n            ErrorImpl::InvalidValue {\n                unexpected,\n                expected,\n            } => E::invalid_value(unexpected.as_serde(), &expected.as_str()),\n            ErrorImpl::InvalidLength { len, expected } => {\n                E::invalid_length(*len, &expected.as_str())\n            }\n            ErrorImpl::UnknownVariant { variant, expected } => {\n                E::unknown_variant(variant, expected)\n            }\n            ErrorImpl::UnknownField { field, expected } => E::unknown_field(field, expected),\n            ErrorImpl::MissingField { field } => E::missing_field(field),\n            ErrorImpl::DuplicateField { field } => E::duplicate_field(field),\n        }\n    }\n}\n\nimpl Unexpected {\n    fn from_serde(unexpected: serde::de::Unexpected) -> Self {\n        match unexpected {\n            serde::de::Unexpected::Bool(value) => Unexpected::Bool(value),\n            serde::de::Unexpected::Unsigned(value) => Unexpected::Unsigned(value),\n            serde::de::Unexpected::Signed(value) => Unexpected::Signed(value),\n            serde::de::Unexpected::Float(value) => Unexpected::Float(value),\n            serde::de::Unexpected::Char(value) => Unexpected::Char(value),\n            serde::de::Unexpected::Str(value) => Unexpected::Str(value.to_owned()),\n            serde::de::Unexpected::Bytes(value) => Unexpected::Bytes(value.to_owned()),\n            serde::de::Unexpected::Unit => Unexpected::Unit,\n            serde::de::Unexpected::Option => Unexpected::Option,\n            serde::de::Unexpected::NewtypeStruct => Unexpected::NewtypeStruct,\n            serde::de::Unexpected::Seq => Unexpected::Seq,\n            serde::de::Unexpected::Map => Unexpected::Map,\n            serde::de::Unexpected::Enum => Unexpected::Enum,\n            serde::de::Unexpected::UnitVariant => Unexpected::UnitVariant,\n            serde::de::Unexpected::NewtypeVariant => Unexpected::NewtypeVariant,\n            serde::de::Unexpected::TupleVariant => Unexpected::TupleVariant,\n            serde::de::Unexpected::StructVariant => Unexpected::StructVariant,\n            serde::de::Unexpected::Other(msg) => Unexpected::Other(msg.to_owned()),\n        }\n    }\n\n    fn as_serde(&self) -> serde::de::Unexpected {\n        match self {\n            Unexpected::Bool(value) => serde::de::Unexpected::Bool(*value),\n            Unexpected::Unsigned(value) => serde::de::Unexpected::Unsigned(*value),\n            Unexpected::Signed(value) => serde::de::Unexpected::Signed(*value),\n            Unexpected::Float(value) => serde::de::Unexpected::Float(*value),\n            Unexpected::Char(value) => serde::de::Unexpected::Char(*value),\n            Unexpected::Str(value) => serde::de::Unexpected::Str(value),\n            Unexpected::Bytes(value) => serde::de::Unexpected::Bytes(value),\n            Unexpected::Unit => serde::de::Unexpected::Unit,\n            Unexpected::Option => serde::de::Unexpected::Option,\n            Unexpected::NewtypeStruct => serde::de::Unexpected::NewtypeStruct,\n            Unexpected::Seq => serde::de::Unexpected::Seq,\n            Unexpected::Map => serde::de::Unexpected::Map,\n            Unexpected::Enum => serde::de::Unexpected::Enum,\n            Unexpected::UnitVariant => serde::de::Unexpected::UnitVariant,\n            Unexpected::NewtypeVariant => serde::de::Unexpected::NewtypeVariant,\n            Unexpected::TupleVariant => serde::de::Unexpected::TupleVariant,\n            Unexpected::StructVariant => serde::de::Unexpected::StructVariant,\n            Unexpected::Other(msg) => serde::de::Unexpected::Other(msg),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! [![github]](https://github.com/dtolnay/erased-serde)&ensp;[![crates-io]](https://crates.io/crates/erased-serde)&ensp;[![docs-rs]](https://docs.rs/erased-serde)\n//!\n//! [github]: https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github\n//! [crates-io]: https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust\n//! [docs-rs]: https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs\n//!\n//! <br>\n//!\n//! This crate provides type-erased versions of Serde's `Serialize`, `Serializer`\n//! and `Deserializer` traits that can be used as [trait objects].\n//!\n//! [trait objects]: https://doc.rust-lang.org/book/trait-objects.html\n//!\n//! The usual Serde `Serialize`, `Serializer` and `Deserializer` traits cannot\n//! be used as trait objects like `&dyn Serialize` or boxed trait objects like\n//! `Box<dyn Serialize>` because of Rust's [\"object safety\" rules]. In\n//! particular, all three traits contain generic methods which cannot be made\n//! into a trait object.\n//!\n//! [\"object safety\" rules]: http://huonw.github.io/blog/2015/01/object-safety/\n//!\n//! This library should be considered a low-level building block for interacting\n//! with Serde APIs in an object-safe way. Most use cases will require higher\n//! level functionality such as provided by [`typetag`] which uses this crate\n//! internally.\n//!\n//! [`typetag`]: https://github.com/dtolnay/typetag\n//!\n//! **The traits in this crate work seamlessly with any existing Serde\n//! `Serialize` and `Deserialize` type and any existing Serde `Serializer` and\n//! `Deserializer` format.**\n//!\n//! ## Serialization\n//!\n//! ```rust\n//! use erased_serde::{Serialize, Serializer};\n//! use std::collections::BTreeMap as Map;\n//! use std::io;\n//!\n//! fn main() {\n//!     // Construct some serializers.\n//!     let json = &mut serde_json::Serializer::new(io::stdout());\n//!     let cbor = &mut serde_cbor::Serializer::new(serde_cbor::ser::IoWrite::new(io::stdout()));\n//!\n//!     // The values in this map are boxed trait objects. Ordinarily this would not\n//!     // be possible with serde::Serializer because of object safety, but type\n//!     // erasure makes it possible with erased_serde::Serializer.\n//!     let mut formats: Map<&str, Box<dyn Serializer>> = Map::new();\n//!     formats.insert(\"json\", Box::new(<dyn Serializer>::erase(json)));\n//!     formats.insert(\"cbor\", Box::new(<dyn Serializer>::erase(cbor)));\n//!\n//!     // These are boxed trait objects as well. Same thing here - type erasure\n//!     // makes this possible.\n//!     let mut values: Map<&str, Box<dyn Serialize>> = Map::new();\n//!     values.insert(\"vec\", Box::new(vec![\"a\", \"b\"]));\n//!     values.insert(\"int\", Box::new(65536));\n//!\n//!     // Pick a Serializer out of the formats map.\n//!     let format = formats.get_mut(\"json\").unwrap();\n//!\n//!     // Pick a Serialize out of the values map.\n//!     let value = values.get(\"vec\").unwrap();\n//!\n//!     // This line prints `[\"a\",\"b\"]` to stdout.\n//!     value.erased_serialize(format).unwrap();\n//! }\n//! ```\n//!\n//! ## Deserialization\n//!\n//! ```rust\n//! use erased_serde::Deserializer;\n//! use std::collections::BTreeMap as Map;\n//!\n//! fn main() {\n//!     static JSON: &'static [u8] = br#\"{\"A\": 65, \"B\": 66}\"#;\n//!     static CBOR: &'static [u8] = &[162, 97, 65, 24, 65, 97, 66, 24, 66];\n//!\n//!     // Construct some deserializers.\n//!     let json = &mut serde_json::Deserializer::from_slice(JSON);\n//!     let cbor = &mut serde_cbor::Deserializer::from_slice(CBOR);\n//!\n//!     // The values in this map are boxed trait objects, which is not possible\n//!     // with the normal serde::Deserializer because of object safety.\n//!     let mut formats: Map<&str, Box<dyn Deserializer>> = Map::new();\n//!     formats.insert(\"json\", Box::new(<dyn Deserializer>::erase(json)));\n//!     formats.insert(\"cbor\", Box::new(<dyn Deserializer>::erase(cbor)));\n//!\n//!     // Pick a Deserializer out of the formats map.\n//!     let format = formats.get_mut(\"json\").unwrap();\n//!\n//!     let data: Map<String, usize> = erased_serde::deserialize(format).unwrap();\n//!\n//!     println!(\"{}\", data[\"A\"] + data[\"B\"]);\n//! }\n//! ```\n\n#![doc(html_root_url = \"https://docs.rs/erased-serde/0.4.9\")]\n#![no_std]\n#![deny(unsafe_op_in_unsafe_fn)]\n#![allow(\n    clippy::box_collection,\n    clippy::derive_partial_eq_without_eq,\n    clippy::extra_unused_type_parameters,\n    clippy::items_after_statements,\n    clippy::manual_map, // https://github.com/rust-lang/rust-clippy/issues/7820\n    clippy::missing_errors_doc,\n    clippy::needless_doctest_main,\n    clippy::needless_pass_by_ref_mut,\n    clippy::needless_pass_by_value,\n    clippy::semicolon_if_nothing_returned, // https://github.com/rust-lang/rust-clippy/issues/7324\n    clippy::similar_names,\n    clippy::struct_field_names,\n    clippy::unused_self,\n    clippy::wildcard_imports\n)]\n#![allow(unknown_lints, mismatched_lifetime_syntaxes)]\n\nextern crate alloc;\n\n#[cfg(feature = \"std\")]\nextern crate std;\n\nextern crate serde_core as serde;\n\n#[macro_use]\nmod macros;\n\nmod any;\nmod de;\nmod error;\nmod features_check;\nmod map;\nmod sealed;\nmod ser;\n\npub use crate::de::{deserialize, Deserializer};\npub use crate::error::{Error, Result};\npub use crate::ser::{serialize, Serialize, Serializer};\n\n// Not public API.\n#[doc(hidden)]\n#[path = \"private.rs\"]\npub mod __private;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "/// Implement `serde::Serialize` for a trait object that has\n/// `erased_serde::Serialize` as a supertrait.\n///\n/// ```\n/// use erased_serde::serialize_trait_object;\n///\n/// trait Event: erased_serde::Serialize {\n///     /* ... */\n/// }\n///\n/// erased_serde::serialize_trait_object!(Event);\n/// ```\n///\n/// The macro supports traits that have type parameters and/or `where` clauses.\n///\n/// ```\n/// # use erased_serde::serialize_trait_object;\n/// #\n/// trait Difficult<T>: erased_serde::Serialize where T: Copy {\n///     /* ... */\n/// }\n///\n/// serialize_trait_object!(<T> Difficult<T> where T: Copy);\n/// ```\n#[macro_export]\nmacro_rules! serialize_trait_object {\n    ($($path:tt)+) => {\n        $crate::__internal_serialize_trait_object!(begin $($path)+);\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __internal_serialize_trait_object {\n    // Invocation started with `<`, parse generics.\n    (begin < $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(generics () () $($rest)*);\n    };\n\n    // Invocation did not start with `<`.\n    (begin $first:tt $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(path () ($first) $($rest)*);\n    };\n\n    // End of generics with trailing comma.\n    (generics ($($generics:tt)*) () , > $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(path ($($generics)* ,) () $($rest)*);\n    };\n\n    // End of generics without trailing comma.\n    (generics ($($generics:tt)*) () > $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(path ($($generics)* ,) () $($rest)*);\n    };\n\n    // Generics open bracket.\n    (generics ($($generics:tt)*) ($($brackets:tt)*) < $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(generics ($($generics)* <) ($($brackets)* <) $($rest)*);\n    };\n\n    // Generics close bracket.\n    (generics ($($generics:tt)*) (< $($brackets:tt)*) > $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(generics ($($generics)* >) ($($brackets)*) $($rest)*);\n    };\n\n    // Token inside of generics.\n    (generics ($($generics:tt)*) ($($brackets:tt)*) $first:tt $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(generics ($($generics)* $first) ($($brackets)*) $($rest)*);\n    };\n\n    // End with `where` clause.\n    (path ($($generics:tt)*) ($($path:tt)*) where $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(sendsync ($($generics)*) ($($path)*) ($($rest)*));\n    };\n\n    // End without `where` clause.\n    (path ($($generics:tt)*) ($($path:tt)*)) => {\n        $crate::__internal_serialize_trait_object!(sendsync ($($generics)*) ($($path)*) ());\n    };\n\n    // Token inside of path.\n    (path ($($generics:tt)*) ($($path:tt)*) $first:tt $($rest:tt)*) => {\n        $crate::__internal_serialize_trait_object!(path ($($generics)*) ($($path)* $first) $($rest)*);\n    };\n\n    // Expand into four impls.\n    (sendsync ($($generics:tt)*) ($($path:tt)*) ($($bound:tt)*)) => {\n        $crate::__internal_serialize_trait_object!(impl ($($generics)*) ($($path)*) ($($bound)*) {\n            fn __check_erased_serialize_supertrait<$($generics)* __T>()\n            where\n                __T: ?$crate::__private::Sized + $($path)*,\n                $($bound)*\n            {\n                $crate::__private::require_erased_serialize_impl::<__T>();\n            }\n        });\n        $crate::__internal_serialize_trait_object!(impl ($($generics)*) ($($path)* + $crate::__private::Send) ($($bound)*));\n        $crate::__internal_serialize_trait_object!(impl ($($generics)*) ($($path)* + $crate::__private::Sync) ($($bound)*));\n        $crate::__internal_serialize_trait_object!(impl ($($generics)*) ($($path)* + $crate::__private::Send + $crate::__private::Sync) ($($bound)*));\n    };\n\n    // The impl.\n    (impl ($($generics:tt)*) ($($path:tt)*) ($($bound:tt)*) $({$($body:tt)*})*) => {\n        impl<'erased, $($generics)*> $crate::__private::serde::Serialize for dyn $($path)* + 'erased\n        where\n            $($bound)*\n        {\n            fn serialize<S>(&self, serializer: S) -> $crate::__private::Result<S::Ok, S::Error>\n            where\n                S: $crate::__private::serde::Serializer,\n            {\n                $($($body)*)*\n                $crate::serialize(self, serializer)\n            }\n        }\n    };\n}\n\nmacro_rules! return_impl_trait {\n    (\n        $(#[$attr:meta])*\n        $vis:vis fn $name:ident <$param:ident> $args:tt -> $impl_trait:ty [$concrete:ty] $($body:tt)+\n    ) => {\n        #[cfg(not(docsrs))]\n        $(#[$attr])*\n        $vis fn $name <$param> $args -> $concrete $($body)+\n\n        #[cfg(docsrs)]\n        $(#[$attr])*\n        $vis fn $name <$param> $args -> $impl_trait $($body)+\n    };\n}\n\n// TEST ////////////////////////////////////////////////////////////////////////\n\n#[cfg(test)]\nmod tests {\n    use crate::Serialize;\n\n    fn assert_serialize<T: ?Sized + serde::Serialize>() {}\n\n    #[test]\n    fn test_plain() {\n        trait Trait: Serialize {}\n\n        serialize_trait_object!(Trait);\n        assert_serialize::<dyn Trait>();\n        assert_serialize::<dyn Trait + Send>();\n    }\n\n    #[test]\n    fn test_type_parameter() {\n        trait Trait<T>: Serialize {}\n\n        serialize_trait_object!(<T> Trait<T>);\n        assert_serialize::<dyn Trait<u32>>();\n        assert_serialize::<dyn Trait<u32> + Send>();\n    }\n\n    #[test]\n    fn test_generic_bound() {\n        trait Trait<T: PartialEq<T>, U>: Serialize {}\n\n        serialize_trait_object!(<T: PartialEq<T>, U> Trait<T, U>);\n        assert_serialize::<dyn Trait<u32, ()>>();\n        assert_serialize::<dyn Trait<u32, ()> + Send>();\n    }\n\n    #[test]\n    fn test_where_clause() {\n        trait Trait<T>: Serialize\n        where\n            T: Clone,\n        {\n        }\n\n        serialize_trait_object!(<T> Trait<T> where T: Clone);\n        assert_serialize::<dyn Trait<u32>>();\n        assert_serialize::<dyn Trait<u32> + Send>();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "pub(crate) trait ResultExt<T, E> {\n    unsafe fn unsafe_map<U>(self, op: unsafe fn(T) -> U) -> Result<U, E>;\n}\n\nimpl<T, E> ResultExt<T, E> for Result<T, E> {\n    unsafe fn unsafe_map<U>(self, op: unsafe fn(T) -> U) -> Result<U, E> {\n        match self {\n            Ok(t) => Ok(unsafe { op(t) }),\n            Err(e) => Err(e),\n        }\n    }\n}\n\npub(crate) trait OptionExt<T> {\n    unsafe fn unsafe_map<U>(self, op: unsafe fn(T) -> U) -> Option<U>;\n}\n\nimpl<T> OptionExt<T> for Option<T> {\n    unsafe fn unsafe_map<U>(self, op: unsafe fn(T) -> U) -> Option<U> {\n        match self {\n            Some(t) => Some(unsafe { op(t) }),\n            None => None,\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Not public API. Used as `$crate::__private` by macros.\n\n#[doc(hidden)]\npub mod serde {\n    #[doc(hidden)]\n    pub use serde::*;\n}\n\n#[doc(hidden)]\npub use core::marker::{Send, Sized, Sync};\n\n#[doc(hidden)]\npub type Result<T, E> = core::result::Result<T, E>;\n\n#[doc(hidden)]\npub fn require_erased_serialize_impl<T>()\nwhere\n    T: ?Sized + crate::Serialize,\n{\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "pub mod serialize {\n    pub trait Sealed {}\n}\n\npub mod serializer {\n    pub trait Sealed {}\n}\n\npub mod deserializer {\n    pub trait Sealed {}\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use self::ErrorImpl::ShortCircuit;\nuse crate::error::Error;\nuse crate::sealed;\nuse alloc::boxed::Box;\nuse alloc::string::{String, ToString};\nuse core::fmt::{self, Debug, Display};\nuse serde::ser::{\n    SerializeMap as _, SerializeSeq as _, SerializeStruct as _, SerializeStructVariant as _,\n    SerializeTuple as _, SerializeTupleStruct as _, SerializeTupleVariant as _,\n};\n\n// TRAITS //////////////////////////////////////////////////////////////////////\n\n/// An object-safe equivalent of Serde's `Serialize` trait.\n///\n/// Any implementation of Serde's `Serialize` converts seamlessly to a\n/// `&dyn erased_serde::Serialize` or `Box<dyn erased_serde::Serialize>` trait\n/// object.\n///\n/// ```rust\n/// use erased_serde::{Serialize, Serializer};\n/// use std::collections::BTreeMap as Map;\n/// use std::io;\n///\n/// fn main() {\n///     // Construct some serializers.\n///     let json = &mut serde_json::Serializer::new(io::stdout());\n///     let cbor = &mut serde_cbor::Serializer::new(serde_cbor::ser::IoWrite::new(io::stdout()));\n///\n///     // The values in this map are boxed trait objects. Ordinarily this would not\n///     // be possible with serde::Serializer because of object safety, but type\n///     // erasure makes it possible with erased_serde::Serializer.\n///     let mut formats: Map<&str, Box<dyn Serializer>> = Map::new();\n///     formats.insert(\"json\", Box::new(<dyn Serializer>::erase(json)));\n///     formats.insert(\"cbor\", Box::new(<dyn Serializer>::erase(cbor)));\n///\n///     // These are boxed trait objects as well. Same thing here - type erasure\n///     // makes this possible.\n///     let mut values: Map<&str, Box<dyn Serialize>> = Map::new();\n///     values.insert(\"vec\", Box::new(vec![\"a\", \"b\"]));\n///     values.insert(\"int\", Box::new(65536));\n///\n///     // Pick a Serializer out of the formats map.\n///     let format = formats.get_mut(\"json\").unwrap();\n///\n///     // Pick a Serialize out of the values map.\n///     let value = values.get(\"vec\").unwrap();\n///\n///     // This line prints `[\"a\",\"b\"]` to stdout.\n///     value.erased_serialize(format).unwrap();\n/// }\n/// ```\n///\n/// This trait is sealed and can only be implemented via a `serde::Serialize`\n/// impl.\n#[cfg_attr(\n    not(no_diagnostic_namespace),\n    diagnostic::on_unimplemented(\n        message = \"the trait bound `{Self}: serde::Serialize` is not satisfied\",\n        label = \"the trait `serde::Serialize` is not implemented for `{Self}`, so it does not implement `erased_serde::Serialize`\",\n    )\n)]\npub trait Serialize: sealed::serialize::Sealed {\n    fn erased_serialize(&self, serializer: &mut dyn Serializer) -> Result<(), Error>;\n\n    #[doc(hidden)]\n    fn do_erased_serialize(&self, serializer: &mut dyn Serializer) -> Result<(), ErrorImpl>;\n}\n\n/// An object-safe equivalent of Serde's `Serializer` trait.\n///\n/// Any implementation of Serde's `Serializer` can be converted to a\n/// `&dyn erased_serde::Serializer` or `Box<dyn erased_serde::Serializer>` trait\n/// object using `erased_serde::Serializer::erase`.\n///\n/// ```rust\n/// use erased_serde::{Serialize, Serializer};\n/// use std::collections::BTreeMap as Map;\n/// use std::io;\n///\n/// fn main() {\n///     // Construct some serializers.\n///     let json = &mut serde_json::Serializer::new(io::stdout());\n///     let cbor = &mut serde_cbor::Serializer::new(serde_cbor::ser::IoWrite::new(io::stdout()));\n///\n///     // The values in this map are boxed trait objects. Ordinarily this would not\n///     // be possible with serde::Serializer because of object safety, but type\n///     // erasure makes it possible with erased_serde::Serializer.\n///     let mut formats: Map<&str, Box<dyn Serializer>> = Map::new();\n///     formats.insert(\"json\", Box::new(<dyn Serializer>::erase(json)));\n///     formats.insert(\"cbor\", Box::new(<dyn Serializer>::erase(cbor)));\n///\n///     // These are boxed trait objects as well. Same thing here - type erasure\n///     // makes this possible.\n///     let mut values: Map<&str, Box<dyn Serialize>> = Map::new();\n///     values.insert(\"vec\", Box::new(vec![\"a\", \"b\"]));\n///     values.insert(\"int\", Box::new(65536));\n///\n///     // Pick a Serializer out of the formats map.\n///     let format = formats.get_mut(\"json\").unwrap();\n///\n///     // Pick a Serialize out of the values map.\n///     let value = values.get(\"vec\").unwrap();\n///\n///     // This line prints `[\"a\",\"b\"]` to stdout.\n///     value.erased_serialize(format).unwrap();\n/// }\n/// ```\n///\n/// This trait is sealed and can only be implemented via a `serde::Serializer`\n/// impl.\npub trait Serializer: sealed::serializer::Sealed {\n    fn erased_serialize_bool(&mut self, v: bool);\n    fn erased_serialize_i8(&mut self, v: i8);\n    fn erased_serialize_i16(&mut self, v: i16);\n    fn erased_serialize_i32(&mut self, v: i32);\n    fn erased_serialize_i64(&mut self, v: i64);\n    fn erased_serialize_i128(&mut self, v: i128);\n    fn erased_serialize_u8(&mut self, v: u8);\n    fn erased_serialize_u16(&mut self, v: u16);\n    fn erased_serialize_u32(&mut self, v: u32);\n    fn erased_serialize_u64(&mut self, v: u64);\n    fn erased_serialize_u128(&mut self, v: u128);\n    fn erased_serialize_f32(&mut self, v: f32);\n    fn erased_serialize_f64(&mut self, v: f64);\n    fn erased_serialize_char(&mut self, v: char);\n    fn erased_serialize_str(&mut self, v: &str);\n    fn erased_serialize_bytes(&mut self, v: &[u8]);\n    fn erased_serialize_none(&mut self);\n    fn erased_serialize_some(&mut self, value: &dyn Serialize);\n    fn erased_serialize_unit(&mut self);\n    fn erased_serialize_unit_struct(&mut self, name: &'static str);\n    fn erased_serialize_unit_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    );\n    fn erased_serialize_newtype_struct(&mut self, name: &'static str, value: &dyn Serialize);\n    fn erased_serialize_newtype_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &dyn Serialize,\n    );\n    fn erased_serialize_seq(\n        &mut self,\n        len: Option<usize>,\n    ) -> Result<&mut dyn SerializeSeq, ErrorImpl>;\n    fn erased_serialize_tuple(&mut self, len: usize) -> Result<&mut dyn SerializeTuple, ErrorImpl>;\n    fn erased_serialize_tuple_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeTupleStruct, ErrorImpl>;\n    fn erased_serialize_tuple_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeTupleVariant, ErrorImpl>;\n    fn erased_serialize_map(\n        &mut self,\n        len: Option<usize>,\n    ) -> Result<&mut dyn SerializeMap, ErrorImpl>;\n    fn erased_serialize_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeStruct, ErrorImpl>;\n    fn erased_serialize_struct_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeStructVariant, ErrorImpl>;\n    fn erased_is_human_readable(&self) -> bool;\n    #[doc(hidden)]\n    fn erased_display_error(&self) -> &dyn Display;\n}\n\nimpl dyn Serializer {\n    return_impl_trait! {\n        /// Convert any Serde `Serializer` to a trait object.\n        ///\n        /// ```rust\n        /// use erased_serde::{Serialize, Serializer};\n        /// use std::collections::BTreeMap as Map;\n        /// use std::io;\n        ///\n        /// fn main() {\n        ///     // Construct some serializers.\n        ///     let json = &mut serde_json::Serializer::new(io::stdout());\n        ///     let cbor = &mut serde_cbor::Serializer::new(serde_cbor::ser::IoWrite::new(io::stdout()));\n        ///\n        ///     // The values in this map are boxed trait objects. Ordinarily this would not\n        ///     // be possible with serde::Serializer because of object safety, but type\n        ///     // erasure makes it possible with erased_serde::Serializer.\n        ///     let mut formats: Map<&str, Box<dyn Serializer>> = Map::new();\n        ///     formats.insert(\"json\", Box::new(<dyn Serializer>::erase(json)));\n        ///     formats.insert(\"cbor\", Box::new(<dyn Serializer>::erase(cbor)));\n        ///\n        ///     // These are boxed trait objects as well. Same thing here - type erasure\n        ///     // makes this possible.\n        ///     let mut values: Map<&str, Box<dyn Serialize>> = Map::new();\n        ///     values.insert(\"vec\", Box::new(vec![\"a\", \"b\"]));\n        ///     values.insert(\"int\", Box::new(65536));\n        ///\n        ///     // Pick a Serializer out of the formats map.\n        ///     let format = formats.get_mut(\"json\").unwrap();\n        ///\n        ///     // Pick a Serialize out of the values map.\n        ///     let value = values.get(\"vec\").unwrap();\n        ///\n        ///     // This line prints `[\"a\",\"b\"]` to stdout.\n        ///     value.erased_serialize(format).unwrap();\n        /// }\n        /// ```\n        pub fn erase<S>(serializer: S) -> impl Serializer [erase::Serializer<S>]\n        where\n            S: serde::Serializer,\n        {\n            erase::Serializer::new(serializer)\n        }\n    }\n}\n\n// IMPL ERASED SERDE FOR SERDE /////////////////////////////////////////////////\n\nimpl<T> Serialize for T\nwhere\n    T: ?Sized + serde::Serialize,\n{\n    fn erased_serialize(&self, serializer: &mut dyn Serializer) -> Result<(), Error> {\n        match self.do_erased_serialize(serializer) {\n            Ok(()) => Ok(()),\n            Err(ShortCircuit) => Err(serde::ser::Error::custom(serializer.erased_display_error())),\n            Err(ErrorImpl::Custom(msg)) => Err(serde::ser::Error::custom(msg)),\n        }\n    }\n\n    fn do_erased_serialize(&self, serializer: &mut dyn Serializer) -> Result<(), ErrorImpl> {\n        self.serialize(MakeSerializer(serializer))\n    }\n}\n\nimpl<T> sealed::serialize::Sealed for T where T: ?Sized + serde::Serialize {}\n\nmod erase {\n    use core::mem;\n\n    pub enum Serializer<S>\n    where\n        S: serde::Serializer,\n    {\n        Ready(S),\n        Seq(S::SerializeSeq),\n        Tuple(S::SerializeTuple),\n        TupleStruct(S::SerializeTupleStruct),\n        TupleVariant(S::SerializeTupleVariant),\n        Map(S::SerializeMap),\n        Struct(S::SerializeStruct),\n        StructVariant(S::SerializeStructVariant),\n        Error(S::Error),\n        Complete(S::Ok),\n        Unusable,\n    }\n\n    impl<S> Serializer<S>\n    where\n        S: serde::Serializer,\n    {\n        pub(crate) fn new(serializer: S) -> Self {\n            Serializer::Ready(serializer)\n        }\n\n        pub(crate) fn take(&mut self) -> Self {\n            mem::replace(self, Serializer::Unusable)\n        }\n\n        pub(crate) fn take_serializer(&mut self) -> S {\n            match self.take() {\n                Serializer::Ready(serializer) => serializer,\n                _ => unreachable!(),\n            }\n        }\n    }\n}\n\nimpl<T> Serializer for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_bool(&mut self, v: bool) {\n        *self = match self.take_serializer().serialize_bool(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_i8(&mut self, v: i8) {\n        *self = match self.take_serializer().serialize_i8(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_i16(&mut self, v: i16) {\n        *self = match self.take_serializer().serialize_i16(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_i32(&mut self, v: i32) {\n        *self = match self.take_serializer().serialize_i32(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_i64(&mut self, v: i64) {\n        *self = match self.take_serializer().serialize_i64(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_i128(&mut self, v: i128) {\n        *self = match self.take_serializer().serialize_i128(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_u8(&mut self, v: u8) {\n        *self = match self.take_serializer().serialize_u8(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_u16(&mut self, v: u16) {\n        *self = match self.take_serializer().serialize_u16(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_u32(&mut self, v: u32) {\n        *self = match self.take_serializer().serialize_u32(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_u64(&mut self, v: u64) {\n        *self = match self.take_serializer().serialize_u64(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_u128(&mut self, v: u128) {\n        *self = match self.take_serializer().serialize_u128(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_f32(&mut self, v: f32) {\n        *self = match self.take_serializer().serialize_f32(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_f64(&mut self, v: f64) {\n        *self = match self.take_serializer().serialize_f64(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_char(&mut self, v: char) {\n        *self = match self.take_serializer().serialize_char(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_str(&mut self, v: &str) {\n        *self = match self.take_serializer().serialize_str(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_bytes(&mut self, v: &[u8]) {\n        *self = match self.take_serializer().serialize_bytes(v) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_none(&mut self) {\n        *self = match self.take_serializer().serialize_none() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_some(&mut self, value: &dyn Serialize) {\n        *self = match self.take_serializer().serialize_some(value) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_unit(&mut self) {\n        *self = match self.take_serializer().serialize_unit() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_unit_struct(&mut self, name: &'static str) {\n        *self = match self.take_serializer().serialize_unit_struct(name) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_unit_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) {\n        *self = match self\n            .take_serializer()\n            .serialize_unit_variant(name, variant_index, variant)\n        {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_newtype_struct(&mut self, name: &'static str, value: &dyn Serialize) {\n        *self = match self.take_serializer().serialize_newtype_struct(name, value) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_newtype_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &dyn Serialize,\n    ) {\n        *self = match self.take_serializer().serialize_newtype_variant(\n            name,\n            variant_index,\n            variant,\n            value,\n        ) {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n\n    fn erased_serialize_seq(\n        &mut self,\n        len: Option<usize>,\n    ) -> Result<&mut dyn SerializeSeq, ErrorImpl> {\n        match self.take_serializer().serialize_seq(len) {\n            Ok(ok) => {\n                *self = erase::Serializer::Seq(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_tuple(&mut self, len: usize) -> Result<&mut dyn SerializeTuple, ErrorImpl> {\n        match self.take_serializer().serialize_tuple(len) {\n            Ok(ok) => {\n                *self = erase::Serializer::Tuple(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_tuple_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeTupleStruct, ErrorImpl> {\n        match self.take_serializer().serialize_tuple_struct(name, len) {\n            Ok(ok) => {\n                *self = erase::Serializer::TupleStruct(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_tuple_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeTupleVariant, ErrorImpl> {\n        match self\n            .take_serializer()\n            .serialize_tuple_variant(name, variant_index, variant, len)\n        {\n            Ok(ok) => {\n                *self = erase::Serializer::TupleVariant(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_map(\n        &mut self,\n        len: Option<usize>,\n    ) -> Result<&mut dyn SerializeMap, ErrorImpl> {\n        match self.take_serializer().serialize_map(len) {\n            Ok(ok) => {\n                *self = erase::Serializer::Map(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_struct(\n        &mut self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeStruct, ErrorImpl> {\n        match self.take_serializer().serialize_struct(name, len) {\n            Ok(ok) => {\n                *self = erase::Serializer::Struct(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_serialize_struct_variant(\n        &mut self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<&mut dyn SerializeStructVariant, ErrorImpl> {\n        match self\n            .take_serializer()\n            .serialize_struct_variant(name, variant_index, variant, len)\n        {\n            Ok(ok) => {\n                *self = erase::Serializer::StructVariant(ok);\n                Ok(self)\n            }\n            Err(err) => {\n                *self = erase::Serializer::Error(err);\n                Err(ShortCircuit)\n            }\n        }\n    }\n\n    fn erased_is_human_readable(&self) -> bool {\n        match self {\n            erase::Serializer::Ready(serializer) => serializer.is_human_readable(),\n            _ => unreachable!(),\n        }\n    }\n\n    fn erased_display_error(&self) -> &dyn Display {\n        match self {\n            erase::Serializer::Error(err) => err,\n            _ => unreachable!(),\n        }\n    }\n}\n\nimpl<T> sealed::serializer::Sealed for erase::Serializer<T> where T: serde::Serializer {}\n\npub enum ErrorImpl {\n    ShortCircuit,\n    Custom(Box<String>),\n}\n\nimpl Display for ErrorImpl {\n    fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n        unimplemented!()\n    }\n}\n\nimpl Debug for ErrorImpl {\n    fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n        unimplemented!()\n    }\n}\n\nimpl serde::ser::StdError for ErrorImpl {}\n\nimpl serde::ser::Error for ErrorImpl {\n    fn custom<T: Display>(msg: T) -> Self {\n        ErrorImpl::Custom(Box::new(msg.to_string()))\n    }\n}\n\n// IMPL SERDE FOR ERASED SERDE /////////////////////////////////////////////////\n\n/// Serialize the given type-erased serializable value.\n///\n/// This can be used to implement `serde::Serialize` for trait objects that have\n/// `erased_serde::Serialize` as a supertrait.\n///\n/// ```\n/// trait Event: erased_serde::Serialize {\n///     /* ... */\n/// }\n///\n/// impl<'a> serde::Serialize for dyn Event + 'a {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: serde::Serializer,\n///     {\n///         erased_serde::serialize(self, serializer)\n///     }\n/// }\n/// ```\n///\n/// Since this is reasonably common, the `serialize_trait_object!` macro\n/// generates such a Serialize impl.\n///\n/// ```\n/// use erased_serde::serialize_trait_object;\n/// #\n/// # trait Event: erased_serde::Serialize {}\n///\n/// serialize_trait_object!(Event);\n/// ```\npub fn serialize<T, S>(value: &T, serializer: S) -> Result<S::Ok, S::Error>\nwhere\n    T: ?Sized + Serialize,\n    S: serde::Serializer,\n{\n    let mut erased = erase::Serializer::new(serializer);\n    match value.do_erased_serialize(&mut erased) {\n        Ok(()) | Err(ShortCircuit) => {}\n        Err(ErrorImpl::Custom(msg)) => return Err(serde::ser::Error::custom(msg)),\n    }\n    match erased {\n        erase::Serializer::Complete(ok) => Ok(ok),\n        erase::Serializer::Error(err) => Err(err),\n        _ => unreachable!(),\n    }\n}\n\nserialize_trait_object!(Serialize);\n\nstruct MakeSerializer<TraitObject>(TraitObject);\n\nimpl<'a> serde::Serializer for MakeSerializer<&'a mut (dyn Serializer + '_)> {\n    type Ok = ();\n    type Error = ErrorImpl;\n    type SerializeSeq = MakeSerializer<&'a mut dyn SerializeSeq>;\n    type SerializeTuple = MakeSerializer<&'a mut dyn SerializeTuple>;\n    type SerializeTupleStruct = MakeSerializer<&'a mut dyn SerializeTupleStruct>;\n    type SerializeTupleVariant = MakeSerializer<&'a mut dyn SerializeTupleVariant>;\n    type SerializeMap = MakeSerializer<&'a mut dyn SerializeMap>;\n    type SerializeStruct = MakeSerializer<&'a mut dyn SerializeStruct>;\n    type SerializeStructVariant = MakeSerializer<&'a mut dyn SerializeStructVariant>;\n\n    fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_bool(v);\n        Ok(())\n    }\n\n    fn serialize_i8(self, v: i8) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_i8(v);\n        Ok(())\n    }\n\n    fn serialize_i16(self, v: i16) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_i16(v);\n        Ok(())\n    }\n\n    fn serialize_i32(self, v: i32) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_i32(v);\n        Ok(())\n    }\n\n    fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_i64(v);\n        Ok(())\n    }\n\n    fn serialize_i128(self, v: i128) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_i128(v);\n        Ok(())\n    }\n\n    fn serialize_u8(self, v: u8) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_u8(v);\n        Ok(())\n    }\n\n    fn serialize_u16(self, v: u16) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_u16(v);\n        Ok(())\n    }\n\n    fn serialize_u32(self, v: u32) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_u32(v);\n        Ok(())\n    }\n\n    fn serialize_u64(self, v: u64) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_u64(v);\n        Ok(())\n    }\n\n    fn serialize_u128(self, v: u128) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_u128(v);\n        Ok(())\n    }\n\n    fn serialize_f32(self, v: f32) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_f32(v);\n        Ok(())\n    }\n\n    fn serialize_f64(self, v: f64) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_f64(v);\n        Ok(())\n    }\n\n    fn serialize_char(self, v: char) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_char(v);\n        Ok(())\n    }\n\n    fn serialize_str(self, v: &str) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_str(v);\n        Ok(())\n    }\n\n    fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_bytes(v);\n        Ok(())\n    }\n\n    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_none();\n        Ok(())\n    }\n\n    fn serialize_some<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_some(&value);\n        Ok(())\n    }\n\n    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_unit();\n        Ok(())\n    }\n\n    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_serialize_unit_struct(name);\n        Ok(())\n    }\n\n    fn serialize_unit_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n    ) -> Result<Self::Ok, Self::Error> {\n        self.0\n            .erased_serialize_unit_variant(name, variant_index, variant);\n        Ok(())\n    }\n\n    fn serialize_newtype_struct<T>(\n        self,\n        name: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_newtype_struct(name, &value);\n        Ok(())\n    }\n\n    fn serialize_newtype_variant<T>(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        value: &T,\n    ) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0\n            .erased_serialize_newtype_variant(name, variant_index, variant, &value);\n        Ok(())\n    }\n\n    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n        self.0.erased_serialize_seq(len).map(MakeSerializer)\n    }\n\n    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error> {\n        self.0.erased_serialize_tuple(len).map(MakeSerializer)\n    }\n\n    fn serialize_tuple_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleStruct, Self::Error> {\n        self.0\n            .erased_serialize_tuple_struct(name, len)\n            .map(MakeSerializer)\n    }\n\n    fn serialize_tuple_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeTupleVariant, Self::Error> {\n        self.0\n            .erased_serialize_tuple_variant(name, variant_index, variant, len)\n            .map(MakeSerializer)\n    }\n\n    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n        self.0.erased_serialize_map(len).map(MakeSerializer)\n    }\n\n    fn serialize_struct(\n        self,\n        name: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStruct, Self::Error> {\n        self.0\n            .erased_serialize_struct(name, len)\n            .map(MakeSerializer)\n    }\n\n    fn serialize_struct_variant(\n        self,\n        name: &'static str,\n        variant_index: u32,\n        variant: &'static str,\n        len: usize,\n    ) -> Result<Self::SerializeStructVariant, Self::Error> {\n        self.0\n            .erased_serialize_struct_variant(name, variant_index, variant, len)\n            .map(MakeSerializer)\n    }\n\n    #[cfg(not(feature = \"alloc\"))]\n    fn collect_str<T>(self, value: &T) -> Result<Self::Ok, Self::Error>\n    where\n        T: ?Sized + Display,\n    {\n        unreachable!()\n    }\n\n    fn is_human_readable(&self) -> bool {\n        self.0.erased_is_human_readable()\n    }\n}\n\npub trait SerializeSeq {\n    fn erased_serialize_element(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeSeq for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_element(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Seq(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_element(value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::Seq(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeSeq for MakeSerializer<&mut dyn SerializeSeq> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_element(&value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeTuple {\n    fn erased_serialize_element(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeTuple for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_element(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Tuple(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_element(value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::Tuple(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeTuple for MakeSerializer<&mut dyn SerializeTuple> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_element<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_element(&value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeTupleStruct {\n    fn erased_serialize_field(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeTupleStruct for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_field(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::TupleStruct(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_field(value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::TupleStruct(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeTupleStruct for MakeSerializer<&mut dyn SerializeTupleStruct> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_field(&value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeTupleVariant {\n    fn erased_serialize_field(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeTupleVariant for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_field(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::TupleVariant(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_field(value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::TupleVariant(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeTupleVariant for MakeSerializer<&mut dyn SerializeTupleVariant> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_field<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_field(&value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeMap {\n    fn erased_serialize_key(&mut self, key: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_serialize_value(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl>;\n    fn erased_serialize_entry(\n        &mut self,\n        key: &dyn Serialize,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeMap for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_key(&mut self, key: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Map(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_key(key).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_serialize_value(&mut self, value: &dyn Serialize) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Map(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_value(value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_serialize_entry(\n        &mut self,\n        key: &dyn Serialize,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Map(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_entry(key, value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::Map(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeMap for MakeSerializer<&mut dyn SerializeMap> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_key<T>(&mut self, key: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_key(&key)\n    }\n\n    fn serialize_value<T>(&mut self, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_value(&value)\n    }\n\n    fn serialize_entry<K, V>(&mut self, key: &K, value: &V) -> Result<(), Self::Error>\n    where\n        K: ?Sized + serde::Serialize,\n        V: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_entry(&key, &value)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeStruct {\n    fn erased_serialize_field(\n        &mut self,\n        key: &'static str,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl>;\n    fn erased_skip_field(&mut self, key: &'static str) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeStruct for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_field(\n        &mut self,\n        key: &'static str,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Struct(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_field(key, value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_skip_field(&mut self, key: &'static str) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Struct(serializer) = self else {\n            unreachable!();\n        };\n        serializer.skip_field(key).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::Struct(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeStruct for MakeSerializer<&mut dyn SerializeStruct> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_field(key, &value)\n    }\n\n    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n        self.0.erased_skip_field(key)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\npub trait SerializeStructVariant {\n    fn erased_serialize_field(\n        &mut self,\n        key: &'static str,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl>;\n    fn erased_skip_field(&mut self, key: &'static str) -> Result<(), ErrorImpl>;\n    fn erased_end(&mut self);\n}\n\nimpl<T> SerializeStructVariant for erase::Serializer<T>\nwhere\n    T: serde::Serializer,\n{\n    fn erased_serialize_field(\n        &mut self,\n        key: &'static str,\n        value: &dyn Serialize,\n    ) -> Result<(), ErrorImpl> {\n        let erase::Serializer::StructVariant(serializer) = self else {\n            unreachable!();\n        };\n        serializer.serialize_field(key, value).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_skip_field(&mut self, key: &'static str) -> Result<(), ErrorImpl> {\n        let erase::Serializer::Struct(serializer) = self else {\n            unreachable!();\n        };\n        serializer.skip_field(key).map_err(|err| {\n            *self = erase::Serializer::Error(err);\n            ShortCircuit\n        })\n    }\n\n    fn erased_end(&mut self) {\n        let erase::Serializer::StructVariant(serializer) = self.take() else {\n            unreachable!();\n        };\n        *self = match serializer.end() {\n            Ok(ok) => erase::Serializer::Complete(ok),\n            Err(err) => erase::Serializer::Error(err),\n        };\n    }\n}\n\nimpl serde::ser::SerializeStructVariant for MakeSerializer<&mut dyn SerializeStructVariant> {\n    type Ok = ();\n    type Error = ErrorImpl;\n\n    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n    where\n        T: ?Sized + serde::Serialize,\n    {\n        self.0.erased_serialize_field(key, &value)\n    }\n\n    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n        self.0.erased_skip_field(key)\n    }\n\n    fn end(self) -> Result<Self::Ok, Self::Error> {\n        self.0.erased_end();\n        Ok(())\n    }\n}\n\n// IMPL ERASED SERDE FOR ERASED SERDE //////////////////////////////////////////\n\nmacro_rules! deref_erased_serializer {\n    (<$T:ident> Serializer for $ty:ty $(where $($where:tt)*)?) => {\n        impl<$T> Serializer for $ty $(where $($where)*)? {\n            fn erased_serialize_bool(&mut self, v: bool) {\n                (**self).erased_serialize_bool(v);\n            }\n\n            fn erased_serialize_i8(&mut self, v: i8) {\n                (**self).erased_serialize_i8(v);\n            }\n\n            fn erased_serialize_i16(&mut self, v: i16) {\n                (**self).erased_serialize_i16(v);\n            }\n\n            fn erased_serialize_i32(&mut self, v: i32) {\n                (**self).erased_serialize_i32(v);\n            }\n\n            fn erased_serialize_i64(&mut self, v: i64) {\n                (**self).erased_serialize_i64(v);\n            }\n\n            fn erased_serialize_i128(&mut self, v: i128) {\n                (**self).erased_serialize_i128(v);\n            }\n\n            fn erased_serialize_u8(&mut self, v: u8) {\n                (**self).erased_serialize_u8(v);\n            }\n\n            fn erased_serialize_u16(&mut self, v: u16) {\n                (**self).erased_serialize_u16(v);\n            }\n\n            fn erased_serialize_u32(&mut self, v: u32) {\n                (**self).erased_serialize_u32(v);\n            }\n\n            fn erased_serialize_u64(&mut self, v: u64) {\n                (**self).erased_serialize_u64(v);\n            }\n\n            fn erased_serialize_u128(&mut self, v: u128) {\n                (**self).erased_serialize_u128(v);\n            }\n\n            fn erased_serialize_f32(&mut self, v: f32) {\n                (**self).erased_serialize_f32(v);\n            }\n\n            fn erased_serialize_f64(&mut self, v: f64) {\n                (**self).erased_serialize_f64(v);\n            }\n\n            fn erased_serialize_char(&mut self, v: char) {\n                (**self).erased_serialize_char(v);\n            }\n\n            fn erased_serialize_str(&mut self, v: &str) {\n                (**self).erased_serialize_str(v);\n            }\n\n            fn erased_serialize_bytes(&mut self, v: &[u8]) {\n                (**self).erased_serialize_bytes(v);\n            }\n\n            fn erased_serialize_none(&mut self) {\n                (**self).erased_serialize_none();\n            }\n\n            fn erased_serialize_some(&mut self, value: &dyn Serialize) {\n                (**self).erased_serialize_some(value);\n            }\n\n            fn erased_serialize_unit(&mut self) {\n                (**self).erased_serialize_unit();\n            }\n\n            fn erased_serialize_unit_struct(&mut self, name: &'static str) {\n                (**self).erased_serialize_unit_struct(name);\n            }\n\n            fn erased_serialize_unit_variant(&mut self, name: &'static str, variant_index: u32, variant: &'static str) {\n                (**self).erased_serialize_unit_variant(name, variant_index, variant);\n            }\n\n            fn erased_serialize_newtype_struct(&mut self, name: &'static str, value: &dyn Serialize) {\n                (**self).erased_serialize_newtype_struct(name, value);\n            }\n\n            fn erased_serialize_newtype_variant(&mut self, name: &'static str, variant_index: u32, variant: &'static str, value: &dyn Serialize) {\n                (**self).erased_serialize_newtype_variant(name, variant_index, variant, value);\n            }\n\n            fn erased_serialize_seq(&mut self, len: Option<usize>) -> Result<&mut dyn SerializeSeq, ErrorImpl> {\n                (**self).erased_serialize_seq(len)\n            }\n\n            fn erased_serialize_tuple(&mut self, len: usize) -> Result<&mut dyn SerializeTuple, ErrorImpl> {\n                (**self).erased_serialize_tuple(len)\n            }\n\n            fn erased_serialize_tuple_struct(&mut self, name: &'static str, len: usize) -> Result<&mut dyn SerializeTupleStruct, ErrorImpl> {\n                (**self).erased_serialize_tuple_struct(name, len)\n            }\n\n            fn erased_serialize_tuple_variant(&mut self, name: &'static str, variant_index: u32, variant: &'static str, len: usize) -> Result<&mut dyn SerializeTupleVariant, ErrorImpl> {\n                (**self).erased_serialize_tuple_variant(name, variant_index, variant, len)\n            }\n\n            fn erased_serialize_map(&mut self, len: Option<usize>) -> Result<&mut dyn SerializeMap, ErrorImpl> {\n                (**self).erased_serialize_map(len)\n            }\n\n            fn erased_serialize_struct(&mut self, name: &'static str, len: usize) -> Result<&mut dyn SerializeStruct, ErrorImpl> {\n                (**self).erased_serialize_struct(name, len)\n            }\n\n            fn erased_serialize_struct_variant(&mut self, name: &'static str, variant_index: u32, variant: &'static str, len: usize) -> Result<&mut dyn SerializeStructVariant, ErrorImpl> {\n                (**self).erased_serialize_struct_variant(name, variant_index, variant, len)\n            }\n\n            fn erased_is_human_readable(&self) -> bool {\n                (**self).erased_is_human_readable()\n            }\n\n            fn erased_display_error(&self) -> &dyn Display {\n                (**self).erased_display_error()\n            }\n        }\n\n        impl<$T> sealed::serializer::Sealed for $ty $(where $($where)*)? {}\n    };\n}\n\nderef_erased_serializer!(<T> Serializer for &mut T where T: ?Sized + Serializer);\nderef_erased_serializer!(<T> Serializer for Box<T> where T: ?Sized + Serializer);\n\n// TEST ////////////////////////////////////////////////////////////////////////\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use alloc::{vec, vec::Vec};\n    use serde_derive::Serialize;\n\n    fn test_json<T>(t: T)\n    where\n        T: serde::Serialize,\n    {\n        let expected = serde_json::to_vec(&t).unwrap();\n\n        // test borrowed trait object\n        {\n            let obj: &dyn Serialize = &t;\n\n            let mut buf = Vec::new();\n\n            {\n                let mut ser = serde_json::Serializer::new(&mut buf);\n                let ser: &mut dyn Serializer = &mut <dyn Serializer>::erase(&mut ser);\n\n                obj.erased_serialize(ser).unwrap();\n            }\n\n            assert_eq!(buf, expected);\n        }\n\n        // test boxed trait object\n        {\n            let obj: Box<dyn Serialize> = Box::new(t);\n\n            let mut buf = Vec::new();\n\n            {\n                let mut ser = serde_json::Serializer::new(&mut buf);\n                let mut ser: Box<dyn Serializer> = Box::new(<dyn Serializer>::erase(&mut ser));\n\n                obj.erased_serialize(&mut ser).unwrap();\n            }\n\n            assert_eq!(buf, expected);\n        }\n    }\n\n    #[test]\n    fn test_vec() {\n        test_json(vec![\"a\", \"b\"]);\n    }\n\n    #[test]\n    fn test_struct() {\n        #[derive(Serialize)]\n        struct S {\n            f: usize,\n        }\n\n        test_json(S { f: 256 });\n    }\n\n    #[test]\n    fn test_enum() {\n        #[derive(Serialize)]\n        enum E {\n            Unit,\n            Newtype(bool),\n            Tuple(bool, bool),\n            Struct { t: bool, f: bool },\n        }\n\n        test_json(E::Unit);\n        test_json(E::Newtype(true));\n        test_json(E::Tuple(true, false));\n        test_json(E::Struct { t: true, f: false });\n    }\n\n    #[test]\n    fn test_error_custom() {\n        struct Kaboom;\n\n        impl serde::Serialize for Kaboom {\n            fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n            where\n                S: serde::Serializer,\n            {\n                use serde::ser::Error as _;\n\n                Err(S::Error::custom(\"kaboom\"))\n            }\n        }\n\n        let obj: &dyn Serialize = &Kaboom;\n\n        let err = serde_json::to_vec(obj).unwrap_err();\n        assert_eq!(err.to_string(), \"kaboom\");\n    }\n\n    #[test]\n    fn assert_serialize() {\n        fn assert<T: serde::Serialize>() {}\n\n        assert::<&dyn Serialize>();\n        assert::<&(dyn Serialize + Send)>();\n        assert::<&(dyn Serialize + Sync)>();\n        assert::<&(dyn Serialize + Send + Sync)>();\n        assert::<&(dyn Serialize + Sync + Send)>();\n        assert::<Vec<&dyn Serialize>>();\n        assert::<Vec<&(dyn Serialize + Send)>>();\n\n        assert::<Box<dyn Serialize>>();\n        assert::<Box<dyn Serialize + Send>>();\n        assert::<Box<dyn Serialize + Sync>>();\n        assert::<Box<dyn Serialize + Send + Sync>>();\n        assert::<Box<dyn Serialize + Sync + Send>>();\n        assert::<Vec<Box<dyn Serialize>>>();\n        assert::<Vec<Box<dyn Serialize + Send>>>();\n    }\n\n    #[test]\n    fn test_dangle() {\n        let mut json_serializer = serde_json::Serializer::new(Vec::new());\n        let _erased_serializer = <dyn Serializer>::erase(&mut json_serializer);\n        drop(json_serializer);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "\"erased-serde requires that either `std` (default) or `alloc` feature is enabled\""}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Shows a user-friendly compiler error on incompatible selected features.\n\n#[allow(unused_macros)]\nmacro_rules! hide_from_rustfmt {\n    ($mod:item) => {\n        $mod\n    };\n}\n\n#[cfg(not(feature = \"alloc\"))]\nhide_from_rustfmt! {\n    mod error;\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[rustversion::attr(not(nightly), ignore = \"requires nightly\")]\n#[cfg_attr(miri, ignore = \"incompatible with miri\")]\n#[test]\nfn ui() {\n    let t = trybuild::TestCases::new();\n    t.compile_fail(\"tests/ui/*.rs\");\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "// Please also update README.md when making changes to this code.\n\nuse erased_serde::{Deserializer, Serialize, Serializer};\nuse std::collections::BTreeMap as Map;\nuse std::io;\n\n#[test]\nfn serialization() {\n    // Construct some serializers.\n    let json = &mut serde_json::Serializer::new(io::stdout());\n    let cbor = &mut serde_cbor::Serializer::new(serde_cbor::ser::IoWrite::new(io::stdout()));\n\n    // The values in this map are boxed trait objects. Ordinarily this would not\n    // be possible with serde::Serializer because of object safety, but type\n    // erasure makes it possible with erased_serde::Serializer.\n    let mut formats: Map<&str, Box<dyn Serializer>> = Map::new();\n    formats.insert(\"json\", Box::new(<dyn Serializer>::erase(json)));\n    formats.insert(\"cbor\", Box::new(<dyn Serializer>::erase(cbor)));\n\n    // These are boxed trait objects as well. Same thing here - type erasure\n    // makes this possible.\n    let mut values: Map<&str, Box<dyn Serialize>> = Map::new();\n    values.insert(\"vec\", Box::new(vec![\"a\", \"b\"]));\n    values.insert(\"int\", Box::new(65536));\n\n    // Pick a Serializer out of the formats map.\n    let format = formats.get_mut(\"json\").unwrap();\n\n    // Pick a Serialize out of the values map.\n    let value = values.get(\"vec\").unwrap();\n\n    // This line prints `[\"a\",\"b\"]` to stdout.\n    value.erased_serialize(format).unwrap();\n}\n\n#[test]\nfn deserialization() {\n    static JSON: &[u8] = br#\"{\"A\": 65, \"B\": 66}\"#;\n    static CBOR: &[u8] = &[162, 97, 65, 24, 65, 97, 66, 24, 66];\n\n    // Construct some deserializers.\n    let json = &mut serde_json::Deserializer::from_slice(JSON);\n    let cbor = &mut serde_cbor::Deserializer::from_slice(CBOR);\n\n    // The values in this map are boxed trait objects, which is not possible\n    // with the normal serde::Deserializer because of object safety.\n    let mut formats: Map<&str, Box<dyn Deserializer>> = Map::new();\n    formats.insert(\"json\", Box::new(<dyn Deserializer>::erase(json)));\n    formats.insert(\"cbor\", Box::new(<dyn Deserializer>::erase(cbor)));\n\n    // Pick a Deserializer out of the formats map.\n    let format = formats.get_mut(\"json\").unwrap();\n\n    let data: Map<String, usize> = erased_serde::deserialize(format).unwrap();\n\n    println!(\"{}\", data[\"A\"] + data[\"B\"]);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use erased_serde::serialize_trait_object;\n\npub trait MyTrait: erased_serde::Serialize {}\n\nserialize_trait_object!(MyTrait);\n\npub trait MyGenericTrait<'a, T>: erased_serde::Serialize {}\n\nserialize_trait_object!(<'a, T> MyGenericTrait<'a, T>);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use erased_serde::serialize_trait_object;\n\npub trait MyTrait {}\n\nserialize_trait_object!(MyTrait);\n\nfn main() {}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{env, fs, path::PathBuf};\n\nfn main() {\n    let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n\n    #[cfg(feature = \"bindgen\")]\n    generate_bindings(&out_dir);\n\n    fs::copy(\n        \"src/wasm/stdlib-symbols.txt\",\n        out_dir.join(\"stdlib-symbols.txt\"),\n    )\n    .unwrap();\n\n    let mut config = cc::Build::new();\n\n    println!(\"cargo:rerun-if-env-changed=CARGO_FEATURE_WASM\");\n    if env::var(\"CARGO_FEATURE_WASM\").is_ok() {\n        config\n            .define(\"TREE_SITTER_FEATURE_WASM\", \"\")\n            .define(\"static_assert(...)\", \"\")\n            .include(env::var(\"DEP_WASMTIME_C_API_INCLUDE\").unwrap());\n    }\n\n    let manifest_path = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n    let include_path = manifest_path.join(\"include\");\n    let src_path = manifest_path.join(\"src\");\n    let wasm_path = src_path.join(\"wasm\");\n    for entry in fs::read_dir(&src_path).unwrap() {\n        let entry = entry.unwrap();\n        let path = src_path.join(entry.file_name());\n        println!(\"cargo:rerun-if-changed={}\", path.to_str().unwrap());\n    }\n\n    config\n        .flag_if_supported(\"-std=c11\")\n        .flag_if_supported(\"-fvisibility=hidden\")\n        .flag_if_supported(\"-Wshadow\")\n        .flag_if_supported(\"-Wno-unused-parameter\")\n        .flag_if_supported(\"-Wno-incompatible-pointer-types\")\n        .include(&src_path)\n        .include(&wasm_path)\n        .include(&include_path)\n        .define(\"_POSIX_C_SOURCE\", \"200112L\")\n        .define(\"_DEFAULT_SOURCE\", None)\n        .define(\"_DARWIN_C_SOURCE\", None)\n        .warnings(false)\n        .file(src_path.join(\"lib.c\"))\n        .compile(\"tree-sitter\");\n\n    println!(\"cargo:include={}\", include_path.display());\n}\n\n#[cfg(feature = \"bindgen\")]\nfn generate_bindings(out_dir: &std::path::Path) {\n    use std::{process::Command, str::FromStr};\n\n    use bindgen::RustTarget;\n\n    let output = Command::new(\"cargo\")\n        .args([\"metadata\", \"--format-version\", \"1\"])\n        .output()\n        .unwrap();\n\n    let metadata = serde_json::from_slice::<serde_json::Value>(&output.stdout).unwrap();\n\n    let Some(rust_version) = metadata\n        .get(\"packages\")\n        .and_then(|packages| packages.as_array())\n        .and_then(|packages| {\n            packages.iter().find_map(|package| {\n                if package[\"name\"] == \"tree-sitter\" {\n                    package.get(\"rust_version\").and_then(|v| v.as_str())\n                } else {\n                    None\n                }\n            })\n        })\n    else {\n        panic!(\"Failed to find tree-sitter package in cargo metadata\");\n    };\n\n    const HEADER_PATH: &str = \"include/tree_sitter/api.h\";\n\n    println!(\"cargo:rerun-if-changed={HEADER_PATH}\");\n\n    let no_copy = [\n        \"TSInput\",\n        \"TSLanguage\",\n        \"TSLogger\",\n        \"TSLookaheadIterator\",\n        \"TSParser\",\n        \"TSTree\",\n        \"TSQuery\",\n        \"TSQueryCursor\",\n        \"TSQueryCapture\",\n        \"TSQueryMatch\",\n        \"TSQueryPredicateStep\",\n    ];\n\n    let bindings = bindgen::Builder::default()\n        .header(HEADER_PATH)\n        .layout_tests(false)\n        .allowlist_type(\"^TS.*\")\n        .allowlist_function(\"^ts_.*\")\n        .allowlist_var(\"^TREE_SITTER.*\")\n        .no_copy(no_copy.join(\"|\"))\n        .prepend_enum_name(false)\n        .use_core()\n        .clang_arg(\"-D TREE_SITTER_FEATURE_WASM\")\n        .rust_target(RustTarget::from_str(rust_version).unwrap())\n        .generate()\n        .expect(\"Failed to generate bindings\");\n\n    let bindings_rs = out_dir.join(\"bindings.rs\");\n    bindings.write_to_file(&bindings_rs).unwrap_or_else(|_| {\n        panic!(\n            \"Failed to write bindings into path: {}\",\n            bindings_rs.display()\n        )\n    });\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![allow(dead_code)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(clippy::missing_const_for_fn)]\n\n#[cfg(feature = \"bindgen\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/bindings.rs\"));\n\n#[cfg(not(feature = \"bindgen\"))]\ninclude!(\"./bindings.rs\");\n\n#[cfg(unix)]\n#[cfg(feature = \"std\")]\nextern \"C\" {\n    pub(crate) fn _ts_dup(fd: std::os::raw::c_int) -> std::os::raw::c_int;\n}\n\n#[cfg(windows)]\n#[cfg(feature = \"std\")]\nextern \"C\" {\n    pub(crate) fn _ts_dup(handle: *mut std::os::raw::c_void) -> std::os::raw::c_int;\n}\n\nuse core::{marker::PhantomData, mem::ManuallyDrop, ptr::NonNull, str};\n\nuse crate::{\n    Language, LookaheadIterator, Node, ParseState, Parser, Query, QueryCursor, QueryCursorState,\n    QueryError, Tree, TreeCursor,\n};\n\nimpl Language {\n    /// Reconstructs a [`Language`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *const TSLanguage) -> Self {\n        Self(ptr)\n    }\n\n    /// Consumes the [`Language`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *const TSLanguage {\n        ManuallyDrop::new(self).0\n    }\n}\n\nimpl Parser {\n    /// Reconstructs a [`Parser`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSParser) -> Self {\n        Self(NonNull::new_unchecked(ptr))\n    }\n\n    /// Consumes the [`Parser`], returning a raw pointer to the underlying C structure.\n    ///\n    /// # Safety\n    ///\n    /// It's a caller responsibility to adjust parser's state\n    /// like disable logging or dot graphs printing if this\n    /// may cause issues like use after free.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSParser {\n        ManuallyDrop::new(self).0.as_ptr()\n    }\n}\n\nimpl ParseState {\n    /// Reconstructs a [`ParseState`] from a raw pointer\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSParseState) -> Self {\n        Self(NonNull::new_unchecked(ptr))\n    }\n\n    /// Consumes the [`ParseState`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSParseState {\n        ManuallyDrop::new(self).0.as_ptr()\n    }\n}\n\nimpl Tree {\n    /// Reconstructs a [`Tree`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSTree) -> Self {\n        Self(NonNull::new_unchecked(ptr))\n    }\n\n    /// Consumes the [`Tree`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSTree {\n        ManuallyDrop::new(self).0.as_ptr()\n    }\n}\n\nimpl Node<'_> {\n    /// Reconstructs a [`Node`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(raw: TSNode) -> Self {\n        Self(raw, PhantomData)\n    }\n\n    /// Consumes the [`Node`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> TSNode {\n        ManuallyDrop::new(self).0\n    }\n}\n\nimpl TreeCursor<'_> {\n    /// Reconstructs a [`TreeCursor`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(raw: TSTreeCursor) -> Self {\n        Self(raw, PhantomData)\n    }\n\n    /// Consumes the [`TreeCursor`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> TSTreeCursor {\n        ManuallyDrop::new(self).0\n    }\n}\n\nimpl Query {\n    /// Reconstructs a [`Query`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    pub unsafe fn from_raw(ptr: *mut TSQuery, source: &str) -> Result<Self, QueryError> {\n        Self::from_raw_parts(ptr, source)\n    }\n\n    /// Consumes the [`Query`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSQuery {\n        ManuallyDrop::new(self).ptr.as_ptr()\n    }\n}\n\nimpl QueryCursor {\n    /// Reconstructs a [`QueryCursor`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSQueryCursor) -> Self {\n        Self {\n            ptr: NonNull::new_unchecked(ptr),\n        }\n    }\n\n    /// Consumes the [`QueryCursor`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSQueryCursor {\n        ManuallyDrop::new(self).ptr.as_ptr()\n    }\n}\n\nimpl QueryCursorState {\n    /// Reconstructs a [`QueryCursorState`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSQueryCursorState) -> Self {\n        Self(NonNull::new_unchecked(ptr))\n    }\n\n    /// Consumes the [`QueryCursorState`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSQueryCursorState {\n        ManuallyDrop::new(self).0.as_ptr()\n    }\n}\n\nimpl LookaheadIterator {\n    /// Reconstructs a [`LookaheadIterator`] from a raw pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[must_use]\n    pub const unsafe fn from_raw(ptr: *mut TSLookaheadIterator) -> Self {\n        Self(NonNull::new_unchecked(ptr))\n    }\n\n    /// Consumes the [`LookaheadIterator`], returning a raw pointer to the underlying C structure.\n    #[must_use]\n    pub fn into_raw(self) -> *mut TSLookaheadIterator {\n        ManuallyDrop::new(self).0.as_ptr()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![doc = include_str!(\"./README.md\")]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![cfg_attr(docsrs, feature(doc_cfg))]\n\npub mod ffi;\nmod util;\n\n#[cfg(not(feature = \"std\"))]\nextern crate alloc;\n#[cfg(not(feature = \"std\"))]\nuse alloc::{boxed::Box, format, string::String, string::ToString, vec::Vec};\nuse core::{\n    ffi::{c_char, c_void, CStr},\n    fmt::{self, Write},\n    hash, iter,\n    marker::PhantomData,\n    mem::MaybeUninit,\n    num::NonZeroU16,\n    ops::{self, Deref},\n    ptr::{self, NonNull},\n    slice, str,\n    sync::atomic::AtomicUsize,\n};\n#[cfg(feature = \"std\")]\nuse std::error;\n#[cfg(all(unix, feature = \"std\"))]\nuse std::os::fd::AsRawFd;\n#[cfg(all(windows, feature = \"std\"))]\nuse std::os::windows::io::AsRawHandle;\n\npub use streaming_iterator::{StreamingIterator, StreamingIteratorMut};\nuse tree_sitter_language::LanguageFn;\n\n#[cfg(feature = \"wasm\")]\nmod wasm_language;\n#[cfg(feature = \"wasm\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"wasm\")))]\npub use wasm_language::*;\n\n/// The latest ABI version that is supported by the current version of the\n/// library.\n///\n/// When Languages are generated by the Tree-sitter CLI, they are\n/// assigned an ABI version number that corresponds to the current CLI version.\n/// The Tree-sitter library is generally backwards-compatible with languages\n/// generated using older CLI versions, but is not forwards-compatible.\n#[doc(alias = \"TREE_SITTER_LANGUAGE_VERSION\")]\npub const LANGUAGE_VERSION: usize = ffi::TREE_SITTER_LANGUAGE_VERSION as usize;\n\n/// The earliest ABI version that is supported by the current version of the\n/// library.\n#[doc(alias = \"TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\")]\npub const MIN_COMPATIBLE_LANGUAGE_VERSION: usize =\n    ffi::TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION as usize;\n\npub const PARSER_HEADER: &str = include_str!(\"../src/parser.h\");\n\n/// An opaque object that defines how to parse a particular language. The code\n/// for each `Language` is generated by the Tree-sitter CLI.\n#[doc(alias = \"TSLanguage\")]\n#[derive(Debug, PartialEq, Eq, Hash)]\n#[repr(transparent)]\npub struct Language(*const ffi::TSLanguage);\n\npub struct LanguageRef<'a>(*const ffi::TSLanguage, PhantomData<&'a ()>);\n\n/// The metadata associated with a language.\n///\n/// Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)\n/// of the language. This version information should be used to signal if a given parser might\n/// be incompatible with existing queries when upgrading between major versions, or minor versions\n/// if it's in zerover.\n#[doc(alias = \"TSLanguageMetadata\")]\npub struct LanguageMetadata {\n    pub major_version: u8,\n    pub minor_version: u8,\n    pub patch_version: u8,\n}\n\nimpl From<ffi::TSLanguageMetadata> for LanguageMetadata {\n    fn from(val: ffi::TSLanguageMetadata) -> Self {\n        Self {\n            major_version: val.major_version,\n            minor_version: val.minor_version,\n            patch_version: val.patch_version,\n        }\n    }\n}\n\n/// A tree that represents the syntactic structure of a source code file.\n#[doc(alias = \"TSTree\")]\npub struct Tree(NonNull<ffi::TSTree>);\n\n/// A position in a multi-line text document, in terms of rows and columns.\n///\n/// Rows and columns are zero-based.\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub struct Point {\n    pub row: usize,\n    pub column: usize,\n}\n\n/// A range of positions in a multi-line text document, both in terms of bytes\n/// and of rows and columns.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub struct Range {\n    pub start_byte: usize,\n    pub end_byte: usize,\n    pub start_point: Point,\n    pub end_point: Point,\n}\n\n/// A summary of a change to a text document.\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub struct InputEdit {\n    pub start_byte: usize,\n    pub old_end_byte: usize,\n    pub new_end_byte: usize,\n    pub start_position: Point,\n    pub old_end_position: Point,\n    pub new_end_position: Point,\n}\n\n/// A single node within a syntax [`Tree`].\n#[doc(alias = \"TSNode\")]\n#[derive(Clone, Copy)]\n#[repr(transparent)]\npub struct Node<'tree>(ffi::TSNode, PhantomData<&'tree ()>);\n\n/// A stateful object that this is used to produce a [`Tree`] based on some\n/// source code.\n#[doc(alias = \"TSParser\")]\npub struct Parser(NonNull<ffi::TSParser>);\n\n/// A stateful object that is used to look up symbols valid in a specific parse\n/// state\n#[doc(alias = \"TSLookaheadIterator\")]\npub struct LookaheadIterator(NonNull<ffi::TSLookaheadIterator>);\nstruct LookaheadNamesIterator<'a>(&'a mut LookaheadIterator);\n\n/// A stateful object that is passed into a [`ParseProgressCallback`]\n/// to pass in the current state of the parser.\npub struct ParseState(NonNull<ffi::TSParseState>);\n\nimpl ParseState {\n    #[must_use]\n    pub const fn current_byte_offset(&self) -> usize {\n        unsafe { self.0.as_ref() }.current_byte_offset as usize\n    }\n\n    #[must_use]\n    pub const fn has_error(&self) -> bool {\n        unsafe { self.0.as_ref() }.has_error\n    }\n}\n\n/// A stateful object that is passed into a [`QueryProgressCallback`]\n/// to pass in the current state of the query execution.\npub struct QueryCursorState(NonNull<ffi::TSQueryCursorState>);\n\nimpl QueryCursorState {\n    #[must_use]\n    pub const fn current_byte_offset(&self) -> usize {\n        unsafe { self.0.as_ref() }.current_byte_offset as usize\n    }\n}\n\n#[derive(Default)]\npub struct ParseOptions<'a> {\n    pub progress_callback: Option<ParseProgressCallback<'a>>,\n}\n\nimpl<'a> ParseOptions<'a> {\n    #[must_use]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    #[must_use]\n    pub fn progress_callback<F: FnMut(&ParseState) -> bool>(mut self, callback: &'a mut F) -> Self {\n        self.progress_callback = Some(callback);\n        self\n    }\n}\n\n#[derive(Default)]\npub struct QueryCursorOptions<'a> {\n    pub progress_callback: Option<QueryProgressCallback<'a>>,\n}\n\nimpl<'a> QueryCursorOptions<'a> {\n    #[must_use]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    #[must_use]\n    pub fn progress_callback<F: FnMut(&QueryCursorState) -> bool>(\n        mut self,\n        callback: &'a mut F,\n    ) -> Self {\n        self.progress_callback = Some(callback);\n        self\n    }\n}\n\nstruct QueryCursorOptionsDrop(*mut ffi::TSQueryCursorOptions);\n\nimpl Drop for QueryCursorOptionsDrop {\n    fn drop(&mut self) {\n        unsafe {\n            if !(*self.0).payload.is_null() {\n                drop(Box::from_raw(\n                    (*self.0).payload.cast::<QueryProgressCallback>(),\n                ));\n            }\n            drop(Box::from_raw(self.0));\n        }\n    }\n}\n\n/// A type of log message.\n#[derive(Debug, PartialEq, Eq)]\npub enum LogType {\n    Parse,\n    Lex,\n}\n\ntype FieldId = NonZeroU16;\n\n/// A callback that receives log messages during parsing.\ntype Logger<'a> = Box<dyn FnMut(LogType, &str) + 'a>;\n\n/// A callback that receives the parse state during parsing.\ntype ParseProgressCallback<'a> = &'a mut dyn FnMut(&ParseState) -> bool;\n\n/// A callback that receives the query state during query execution.\ntype QueryProgressCallback<'a> = &'a mut dyn FnMut(&QueryCursorState) -> bool;\n\npub trait Decode {\n    /// A callback that decodes the next code point from the input slice. It should return the code\n    /// point, and how many bytes were decoded.\n    fn decode(bytes: &[u8]) -> (i32, u32);\n}\n\n/// A stateful object for walking a syntax [`Tree`] efficiently.\n#[doc(alias = \"TSTreeCursor\")]\npub struct TreeCursor<'cursor>(ffi::TSTreeCursor, PhantomData<&'cursor ()>);\n\n/// A set of patterns that match nodes in a syntax tree.\n#[doc(alias = \"TSQuery\")]\n#[derive(Debug)]\n#[allow(clippy::type_complexity)]\npub struct Query {\n    ptr: NonNull<ffi::TSQuery>,\n    capture_names: Box<[&'static str]>,\n    capture_quantifiers: Box<[Box<[CaptureQuantifier]>]>,\n    text_predicates: Box<[Box<[TextPredicateCapture]>]>,\n    property_settings: Box<[Box<[QueryProperty]>]>,\n    property_predicates: Box<[Box<[(QueryProperty, bool)]>]>,\n    general_predicates: Box<[Box<[QueryPredicate]>]>,\n}\n\n/// A quantifier for captures\n#[derive(Debug, PartialEq, Eq, Clone, Copy)]\npub enum CaptureQuantifier {\n    Zero,\n    ZeroOrOne,\n    ZeroOrMore,\n    One,\n    OneOrMore,\n}\n\nimpl From<ffi::TSQuantifier> for CaptureQuantifier {\n    fn from(value: ffi::TSQuantifier) -> Self {\n        match value {\n            ffi::TSQuantifierZero => Self::Zero,\n            ffi::TSQuantifierZeroOrOne => Self::ZeroOrOne,\n            ffi::TSQuantifierZeroOrMore => Self::ZeroOrMore,\n            ffi::TSQuantifierOne => Self::One,\n            ffi::TSQuantifierOneOrMore => Self::OneOrMore,\n            _ => panic!(\"Unrecognized quantifier: {value}\"),\n        }\n    }\n}\n\n/// A stateful object for executing a [`Query`] on a syntax [`Tree`].\n#[doc(alias = \"TSQueryCursor\")]\npub struct QueryCursor {\n    ptr: NonNull<ffi::TSQueryCursor>,\n}\n\n/// A key-value pair associated with a particular pattern in a [`Query`].\n#[derive(Debug, PartialEq, Eq)]\npub struct QueryProperty {\n    pub key: Box<str>,\n    pub value: Option<Box<str>>,\n    pub capture_id: Option<usize>,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum QueryPredicateArg {\n    Capture(u32),\n    String(Box<str>),\n}\n\n/// A key-value pair associated with a particular pattern in a [`Query`].\n#[derive(Debug, PartialEq, Eq)]\npub struct QueryPredicate {\n    pub operator: Box<str>,\n    pub args: Box<[QueryPredicateArg]>,\n}\n\n/// A match of a [`Query`] to a particular set of [`Node`]s.\npub struct QueryMatch<'cursor, 'tree> {\n    pub pattern_index: usize,\n    pub captures: &'cursor [QueryCapture<'tree>],\n    id: u32,\n    cursor: *mut ffi::TSQueryCursor,\n}\n\n/// A sequence of [`QueryMatch`]es associated with a given [`QueryCursor`].\npub struct QueryMatches<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> {\n    ptr: *mut ffi::TSQueryCursor,\n    query: &'query Query,\n    text_provider: T,\n    buffer1: Vec<u8>,\n    buffer2: Vec<u8>,\n    current_match: Option<QueryMatch<'query, 'tree>>,\n    _options: Option<QueryCursorOptionsDrop>,\n    _phantom: PhantomData<(&'tree (), I)>,\n}\n\n/// A sequence of [`QueryCapture`]s associated with a given [`QueryCursor`].\n///\n/// During iteration, each element contains a [`QueryMatch`] and index. The index can\n/// be used to access the new capture inside of the [`QueryMatch::captures`]'s [`captures`].\npub struct QueryCaptures<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> {\n    ptr: *mut ffi::TSQueryCursor,\n    query: &'query Query,\n    text_provider: T,\n    buffer1: Vec<u8>,\n    buffer2: Vec<u8>,\n    current_match: Option<(QueryMatch<'query, 'tree>, usize)>,\n    _options: Option<QueryCursorOptionsDrop>,\n    _phantom: PhantomData<(&'tree (), I)>,\n}\n\npub trait TextProvider<I>\nwhere\n    I: AsRef<[u8]>,\n{\n    type I: Iterator<Item = I>;\n    fn text(&mut self, node: Node) -> Self::I;\n}\n\n/// A particular [`Node`] that has been captured with a particular name within a\n/// [`Query`].\n#[derive(Clone, Copy, Debug)]\n#[repr(C)]\npub struct QueryCapture<'tree> {\n    pub node: Node<'tree>,\n    pub index: u32,\n}\n\n/// An error that occurred when trying to assign an incompatible [`Language`] to\n/// a [`Parser`].\n#[derive(Debug, PartialEq, Eq)]\npub struct LanguageError {\n    version: usize,\n}\n\n/// An error that occurred in [`Parser::set_included_ranges`].\n#[derive(Debug, PartialEq, Eq)]\npub struct IncludedRangesError(pub usize);\n\n/// An error that occurred when trying to create a [`Query`].\n#[derive(Debug, PartialEq, Eq)]\npub struct QueryError {\n    pub row: usize,\n    pub column: usize,\n    pub offset: usize,\n    pub message: String,\n    pub kind: QueryErrorKind,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum QueryErrorKind {\n    Syntax,\n    NodeType,\n    Field,\n    Capture,\n    Predicate,\n    Structure,\n    Language,\n}\n\n#[derive(Debug)]\n/// The first item is the capture index\n/// The next is capture specific, depending on what item is expected\n/// The first bool is if the capture is positive\n/// The last item is a bool signifying whether or not it's meant to match\n/// any or all captures\nenum TextPredicateCapture {\n    EqString(u32, Box<str>, bool, bool),\n    EqCapture(u32, u32, bool, bool),\n    MatchString(u32, regex::bytes::Regex, bool, bool),\n    AnyString(u32, Box<[Box<str>]>, bool),\n}\n\n// TODO: Remove this struct at some point. If `core::str::lossy::Utf8Lossy`\n// is ever stabilized.\npub struct LossyUtf8<'a> {\n    bytes: &'a [u8],\n    in_replacement: bool,\n}\n\nimpl Language {\n    #[must_use]\n    pub fn new(builder: LanguageFn) -> Self {\n        Self(unsafe { builder.into_raw()().cast() })\n    }\n\n    /// Get the name of this language. This returns `None` in older parsers.\n    #[doc(alias = \"ts_language_name\")]\n    #[must_use]\n    pub fn name(&self) -> Option<&'static str> {\n        let ptr = unsafe { ffi::ts_language_name(self.0) };\n        (!ptr.is_null()).then(|| unsafe { CStr::from_ptr(ptr) }.to_str().unwrap())\n    }\n\n    /// Get the ABI version number that indicates which version of the\n    /// Tree-sitter CLI that was used to generate this [`Language`].\n    #[doc(alias = \"ts_language_version\")]\n    #[deprecated(since = \"0.25.0\", note = \"Use abi_version instead\")]\n    #[must_use]\n    pub fn version(&self) -> usize {\n        unsafe { ffi::ts_language_version(self.0) as usize }\n    }\n\n    /// Get the ABI version number that indicates which version of the\n    /// Tree-sitter CLI that was used to generate this [`Language`].\n    #[doc(alias = \"ts_language_abi_version\")]\n    #[must_use]\n    pub fn abi_version(&self) -> usize {\n        unsafe { ffi::ts_language_abi_version(self.0) as usize }\n    }\n\n    /// Get the metadata for this language. This information is generated by the\n    /// CLI, and relies on the language author providing the correct metadata in\n    /// the language's `tree-sitter.json` file.\n    ///\n    /// See also [`LanguageMetadata`].\n    #[doc(alias = \"ts_language_metadata\")]\n    #[must_use]\n    pub fn metadata(&self) -> Option<LanguageMetadata> {\n        unsafe {\n            let ptr = ffi::ts_language_metadata(self.0);\n            (!ptr.is_null()).then(|| (*ptr).into())\n        }\n    }\n\n    /// Get the number of distinct node types in this language.\n    #[doc(alias = \"ts_language_symbol_count\")]\n    #[must_use]\n    pub fn node_kind_count(&self) -> usize {\n        unsafe { ffi::ts_language_symbol_count(self.0) as usize }\n    }\n\n    /// Get the number of valid states in this language.\n    #[doc(alias = \"ts_language_state_count\")]\n    #[must_use]\n    pub fn parse_state_count(&self) -> usize {\n        unsafe { ffi::ts_language_state_count(self.0) as usize }\n    }\n\n    /// Get a list of all supertype symbols for the language.\n    #[doc(alias = \"ts_language_supertypes\")]\n    #[must_use]\n    pub fn supertypes(&self) -> &[u16] {\n        let mut length = 0u32;\n        unsafe {\n            let ptr = ffi::ts_language_supertypes(self.0, core::ptr::addr_of_mut!(length));\n            if length == 0 {\n                &[]\n            } else {\n                slice::from_raw_parts(ptr.cast_mut(), length as usize)\n            }\n        }\n    }\n\n    /// Get a list of all subtype symbols for a given supertype symbol.\n    #[doc(alias = \"ts_language_supertype_map\")]\n    #[must_use]\n    pub fn subtypes_for_supertype(&self, supertype: u16) -> &[u16] {\n        unsafe {\n            let mut length = 0u32;\n            let ptr = ffi::ts_language_subtypes(self.0, supertype, core::ptr::addr_of_mut!(length));\n            if length == 0 {\n                &[]\n            } else {\n                slice::from_raw_parts(ptr.cast_mut(), length as usize)\n            }\n        }\n    }\n\n    /// Get the name of the node kind for the given numerical id.\n    #[doc(alias = \"ts_language_symbol_name\")]\n    #[must_use]\n    pub fn node_kind_for_id(&self, id: u16) -> Option<&'static str> {\n        let ptr = unsafe { ffi::ts_language_symbol_name(self.0, id) };\n        (!ptr.is_null()).then(|| unsafe { CStr::from_ptr(ptr) }.to_str().unwrap())\n    }\n\n    /// Get the numeric id for the given node kind.\n    #[doc(alias = \"ts_language_symbol_for_name\")]\n    #[must_use]\n    pub fn id_for_node_kind(&self, kind: &str, named: bool) -> u16 {\n        unsafe {\n            ffi::ts_language_symbol_for_name(\n                self.0,\n                kind.as_bytes().as_ptr().cast::<c_char>(),\n                kind.len() as u32,\n                named,\n            )\n        }\n    }\n\n    /// Check if the node type for the given numerical id is named (as opposed\n    /// to an anonymous node type).\n    #[must_use]\n    pub fn node_kind_is_named(&self, id: u16) -> bool {\n        unsafe { ffi::ts_language_symbol_type(self.0, id) == ffi::TSSymbolTypeRegular }\n    }\n\n    /// Check if the node type for the given numerical id is visible (as opposed\n    /// to a hidden node type).\n    #[must_use]\n    pub fn node_kind_is_visible(&self, id: u16) -> bool {\n        unsafe { ffi::ts_language_symbol_type(self.0, id) <= ffi::TSSymbolTypeAnonymous }\n    }\n\n    /// Check if the node type for the given numerical id is a supertype.\n    #[must_use]\n    pub fn node_kind_is_supertype(&self, id: u16) -> bool {\n        unsafe { ffi::ts_language_symbol_type(self.0, id) == ffi::TSSymbolTypeSupertype }\n    }\n\n    /// Get the number of distinct field names in this language.\n    #[doc(alias = \"ts_language_field_count\")]\n    #[must_use]\n    pub fn field_count(&self) -> usize {\n        unsafe { ffi::ts_language_field_count(self.0) as usize }\n    }\n\n    /// Get the field name for the given numerical id.\n    #[doc(alias = \"ts_language_field_name_for_id\")]\n    #[must_use]\n    pub fn field_name_for_id(&self, field_id: u16) -> Option<&'static str> {\n        let ptr = unsafe { ffi::ts_language_field_name_for_id(self.0, field_id) };\n        (!ptr.is_null()).then(|| unsafe { CStr::from_ptr(ptr) }.to_str().unwrap())\n    }\n\n    /// Get the numerical id for the given field name.\n    #[doc(alias = \"ts_language_field_id_for_name\")]\n    #[must_use]\n    pub fn field_id_for_name(&self, field_name: impl AsRef<[u8]>) -> Option<FieldId> {\n        let field_name = field_name.as_ref();\n        let id = unsafe {\n            ffi::ts_language_field_id_for_name(\n                self.0,\n                field_name.as_ptr().cast::<c_char>(),\n                field_name.len() as u32,\n            )\n        };\n        FieldId::new(id)\n    }\n\n    /// Get the next parse state. Combine this with\n    /// [`lookahead_iterator`](Language::lookahead_iterator) to\n    /// generate completion suggestions or valid symbols in error nodes.\n    ///\n    /// Example:\n    /// ```\n    /// let state = language.next_state(node.parse_state(), node.grammar_id());\n    /// ```\n    #[doc(alias = \"ts_language_next_state\")]\n    #[must_use]\n    pub fn next_state(&self, state: u16, id: u16) -> u16 {\n        unsafe { ffi::ts_language_next_state(self.0, state, id) }\n    }\n\n    /// Create a new lookahead iterator for this language and parse state.\n    ///\n    /// This returns `None` if state is invalid for this language.\n    ///\n    /// Iterating [`LookaheadIterator`] will yield valid symbols in the given\n    /// parse state. Newly created lookahead iterators will return the `ERROR`\n    /// symbol from [`LookaheadIterator::current_symbol`].\n    ///\n    /// Lookahead iterators can be useful to generate suggestions and improve\n    /// syntax error diagnostics. To get symbols valid in an `ERROR` node, use the\n    /// lookahead iterator on its first leaf node state. For `MISSING` nodes, a\n    /// lookahead iterator created on the previous non-extra leaf node may be\n    /// appropriate.\n    #[doc(alias = \"ts_lookahead_iterator_new\")]\n    #[must_use]\n    pub fn lookahead_iterator(&self, state: u16) -> Option<LookaheadIterator> {\n        let ptr = unsafe { ffi::ts_lookahead_iterator_new(self.0, state) };\n        (!ptr.is_null()).then(|| unsafe { LookaheadIterator::from_raw(ptr) })\n    }\n}\n\nimpl From<LanguageFn> for Language {\n    fn from(value: LanguageFn) -> Self {\n        Self::new(value)\n    }\n}\n\nimpl Clone for Language {\n    fn clone(&self) -> Self {\n        unsafe { Self(ffi::ts_language_copy(self.0)) }\n    }\n}\n\nimpl Drop for Language {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_language_delete(self.0) }\n    }\n}\n\nimpl Deref for LanguageRef<'_> {\n    type Target = Language;\n\n    fn deref(&self) -> &Self::Target {\n        unsafe { &*(core::ptr::addr_of!(self.0).cast::<Language>()) }\n    }\n}\n\nimpl Default for Parser {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Parser {\n    /// Create a new parser.\n    #[doc(alias = \"ts_parser_new\")]\n    #[must_use]\n    pub fn new() -> Self {\n        unsafe {\n            let parser = ffi::ts_parser_new();\n            Self(NonNull::new_unchecked(parser))\n        }\n    }\n\n    /// Set the language that the parser should use for parsing.\n    ///\n    /// Returns a Result indicating whether or not the language was successfully\n    /// assigned. True means assignment succeeded. False means there was a\n    /// version mismatch: the language was generated with an incompatible\n    /// version of the Tree-sitter CLI. Check the language's version using\n    /// [`Language::version`] and compare it to this library's\n    /// [`LANGUAGE_VERSION`] and [`MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.\n    #[doc(alias = \"ts_parser_set_language\")]\n    pub fn set_language(&mut self, language: &Language) -> Result<(), LanguageError> {\n        let version = language.abi_version();\n        if (MIN_COMPATIBLE_LANGUAGE_VERSION..=LANGUAGE_VERSION).contains(&version) {\n            unsafe {\n                ffi::ts_parser_set_language(self.0.as_ptr(), language.0);\n            }\n            Ok(())\n        } else {\n            Err(LanguageError { version })\n        }\n    }\n\n    /// Get the parser's current language.\n    #[doc(alias = \"ts_parser_language\")]\n    #[must_use]\n    pub fn language(&self) -> Option<LanguageRef<'_>> {\n        let ptr = unsafe { ffi::ts_parser_language(self.0.as_ptr()) };\n        (!ptr.is_null()).then_some(LanguageRef(ptr, PhantomData))\n    }\n\n    /// Get the parser's current logger.\n    #[doc(alias = \"ts_parser_logger\")]\n    #[must_use]\n    pub fn logger(&self) -> Option<&Logger> {\n        let logger = unsafe { ffi::ts_parser_logger(self.0.as_ptr()) };\n        unsafe { logger.payload.cast::<Logger>().as_ref() }\n    }\n\n    /// Set the logging callback that the parser should use during parsing.\n    #[doc(alias = \"ts_parser_set_logger\")]\n    pub fn set_logger(&mut self, logger: Option<Logger>) {\n        let prev_logger = unsafe { ffi::ts_parser_logger(self.0.as_ptr()) };\n        if !prev_logger.payload.is_null() {\n            drop(unsafe { Box::from_raw(prev_logger.payload.cast::<Logger>()) });\n        }\n\n        let c_logger = if let Some(logger) = logger {\n            let container = Box::new(logger);\n\n            unsafe extern \"C\" fn log(\n                payload: *mut c_void,\n                c_log_type: ffi::TSLogType,\n                c_message: *const c_char,\n            ) {\n                let callback = payload.cast::<Logger>().as_mut().unwrap();\n                if let Ok(message) = CStr::from_ptr(c_message).to_str() {\n                    let log_type = if c_log_type == ffi::TSLogTypeParse {\n                        LogType::Parse\n                    } else {\n                        LogType::Lex\n                    };\n                    callback(log_type, message);\n                }\n            }\n\n            let raw_container = Box::into_raw(container);\n\n            ffi::TSLogger {\n                payload: raw_container.cast::<c_void>(),\n                log: Some(log),\n            }\n        } else {\n            ffi::TSLogger {\n                payload: ptr::null_mut(),\n                log: None,\n            }\n        };\n\n        unsafe { ffi::ts_parser_set_logger(self.0.as_ptr(), c_logger) };\n    }\n\n    /// Set the destination to which the parser should write debugging graphs\n    /// during parsing. The graphs are formatted in the DOT language. You may\n    /// want to pipe these graphs directly to a `dot(1)` process in order to\n    /// generate SVG output.\n    #[doc(alias = \"ts_parser_print_dot_graphs\")]\n    #[cfg(not(target_os = \"wasi\"))]\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    pub fn print_dot_graphs(\n        &mut self,\n        #[cfg(unix)] file: &impl AsRawFd,\n        #[cfg(windows)] file: &impl AsRawHandle,\n    ) {\n        #[cfg(unix)]\n        {\n            let fd = file.as_raw_fd();\n            unsafe {\n                ffi::ts_parser_print_dot_graphs(self.0.as_ptr(), ffi::_ts_dup(fd));\n            }\n        }\n\n        #[cfg(windows)]\n        {\n            let handle = file.as_raw_handle();\n            unsafe {\n                ffi::ts_parser_print_dot_graphs(self.0.as_ptr(), ffi::_ts_dup(handle));\n            }\n        }\n    }\n\n    /// Stop the parser from printing debugging graphs while parsing.\n    #[doc(alias = \"ts_parser_print_dot_graphs\")]\n    #[cfg(not(target_os = \"wasi\"))]\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    pub fn stop_printing_dot_graphs(&mut self) {\n        unsafe { ffi::ts_parser_print_dot_graphs(self.0.as_ptr(), -1) }\n    }\n\n    /// Parse a slice of UTF8 text.\n    ///\n    /// # Arguments:\n    /// * `text` The UTF8-encoded text to parse.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    ///\n    /// Returns a [`Tree`] if parsing succeeded, or `None` if:\n    ///  * The parser has not yet had a language assigned with [`Parser::set_language`]\n    ///  * The timeout set with [`Parser::set_timeout_micros`] expired (deprecated)\n    ///  * The cancellation flag set with [`Parser::set_cancellation_flag`] was flipped (deprecated)\n    #[doc(alias = \"ts_parser_parse\")]\n    pub fn parse(&mut self, text: impl AsRef<[u8]>, old_tree: Option<&Tree>) -> Option<Tree> {\n        let bytes = text.as_ref();\n        let len = bytes.len();\n        self.parse_with_options(\n            &mut |i, _| (i < len).then(|| &bytes[i..]).unwrap_or_default(),\n            old_tree,\n            None,\n        )\n    }\n\n    /// Parse a slice of UTF16 text.\n    ///\n    /// # Arguments:\n    /// * `text` The UTF16-encoded text to parse.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    #[deprecated(since = \"0.25.0\", note = \"Prefer parse_utf16_le instead\")]\n    pub fn parse_utf16(\n        &mut self,\n        input: impl AsRef<[u16]>,\n        old_tree: Option<&Tree>,\n    ) -> Option<Tree> {\n        let code_points = input.as_ref();\n        let len = code_points.len();\n        self.parse_utf16_le_with_options(\n            &mut |i, _| (i < len).then(|| &code_points[i..]).unwrap_or_default(),\n            old_tree,\n            None,\n        )\n    }\n\n    /// Parse UTF8 text provided in chunks by a callback.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a byte offset and position and returns a slice of\n    ///   UTF8-encoded text starting at that byte offset and position. The slices can be of any\n    ///   length. If the given position is at the end of the text, the callback should return an\n    ///   empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    #[deprecated(since = \"0.25.0\", note = \"Prefer `parse_with_options` instead\")]\n    pub fn parse_with<T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n    ) -> Option<Tree> {\n        self.parse_with_options(callback, old_tree, None)\n    }\n\n    /// Parse text provided in chunks by a callback.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a byte offset and position and returns a slice of\n    ///   UTF8-encoded text starting at that byte offset and position. The slices can be of any\n    ///   length. If the given position is at the end of the text, the callback should return an\n    ///   empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    /// * `options` Options for parsing the text. This can be used to set a progress callback.\n    pub fn parse_with_options<T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n        options: Option<ParseOptions>,\n    ) -> Option<Tree> {\n        type Payload<'a, F, T> = (&'a mut F, Option<T>);\n\n        // This C function is passed to Tree-sitter as the progress callback.\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSParseState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<ParseProgressCallback>()\n                .as_mut()\n                .unwrap();\n            callback(&ParseState::from_raw(state))\n        }\n\n        // This C function is passed to Tree-sitter as the input callback.\n        unsafe extern \"C\" fn read<T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(\n            payload: *mut c_void,\n            byte_offset: u32,\n            position: ffi::TSPoint,\n            bytes_read: *mut u32,\n        ) -> *const c_char {\n            let (callback, text) = payload.cast::<Payload<F, T>>().as_mut().unwrap();\n            *text = Some(callback(byte_offset as usize, position.into()));\n            let slice = text.as_ref().unwrap().as_ref();\n            *bytes_read = slice.len() as u32;\n            slice.as_ptr().cast::<c_char>()\n        }\n\n        let empty_options = ffi::TSParseOptions {\n            payload: ptr::null_mut(),\n            progress_callback: None,\n        };\n\n        let mut callback_ptr;\n        let parse_options = if let Some(options) = options {\n            if let Some(cb) = options.progress_callback {\n                callback_ptr = cb;\n                ffi::TSParseOptions {\n                    payload: core::ptr::addr_of_mut!(callback_ptr).cast::<c_void>(),\n                    progress_callback: Some(progress),\n                }\n            } else {\n                empty_options\n            }\n        } else {\n            empty_options\n        };\n\n        // A pointer to this payload is passed on every call to the `read` C function.\n        // The payload contains two things:\n        // 1. A reference to the rust `callback`.\n        // 2. The text that was returned from the previous call to `callback`. This allows the\n        //    callback to return owned values like vectors.\n        let mut payload: Payload<F, T> = (callback, None);\n\n        let c_input = ffi::TSInput {\n            payload: ptr::addr_of_mut!(payload).cast::<c_void>(),\n            read: Some(read::<T, F>),\n            encoding: ffi::TSInputEncodingUTF8,\n            decode: None,\n        };\n\n        let c_old_tree = old_tree.map_or(ptr::null_mut(), |t| t.0.as_ptr());\n        unsafe {\n            let c_new_tree = ffi::ts_parser_parse_with_options(\n                self.0.as_ptr(),\n                c_old_tree,\n                c_input,\n                parse_options,\n            );\n\n            NonNull::new(c_new_tree).map(Tree)\n        }\n    }\n\n    /// Parse UTF16 text provided in chunks by a callback.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a code point offset and position and returns a slice of\n    ///   UTF16-encoded text starting at that byte offset and position. The slices can be of any\n    ///   length. If the given position is at the end of the text, the callback should return an\n    ///   empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer `parse_utf16_le_with_options` instead\"\n    )]\n    pub fn parse_utf16_with<T: AsRef<[u16]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n    ) -> Option<Tree> {\n        self.parse_utf16_le_with_options(callback, old_tree, None)\n    }\n\n    /// Parse a slice of UTF16 little-endian text.\n    ///\n    /// # Arguments:\n    /// * `text` The UTF16-encoded text to parse.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    pub fn parse_utf16_le(\n        &mut self,\n        input: impl AsRef<[u16]>,\n        old_tree: Option<&Tree>,\n    ) -> Option<Tree> {\n        let code_points = input.as_ref();\n        let len = code_points.len();\n        self.parse_utf16_le_with_options(\n            &mut |i, _| (i < len).then(|| &code_points[i..]).unwrap_or_default(),\n            old_tree,\n            None,\n        )\n    }\n\n    /// Parse UTF16 little-endian text provided in chunks by a callback.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a code point offset and position and returns a slice of\n    ///   UTF16-encoded text starting at that byte offset and position. The slices can be of any\n    ///   length. If the given position is at the end of the text, the callback should return an\n    ///   empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    /// * `options` Options for parsing the text. This can be used to set a progress callback.\n    pub fn parse_utf16_le_with_options<T: AsRef<[u16]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n        options: Option<ParseOptions>,\n    ) -> Option<Tree> {\n        type Payload<'a, F, T> = (&'a mut F, Option<T>);\n\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSParseState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<ParseProgressCallback>()\n                .as_mut()\n                .unwrap();\n            callback(&ParseState::from_raw(state))\n        }\n\n        // This C function is passed to Tree-sitter as the input callback.\n        unsafe extern \"C\" fn read<T: AsRef<[u16]>, F: FnMut(usize, Point) -> T>(\n            payload: *mut c_void,\n            byte_offset: u32,\n            position: ffi::TSPoint,\n            bytes_read: *mut u32,\n        ) -> *const c_char {\n            let (callback, text) = payload.cast::<Payload<F, T>>().as_mut().unwrap();\n            *text = Some(callback(\n                (byte_offset / 2) as usize,\n                Point {\n                    row: position.row as usize,\n                    column: position.column as usize / 2,\n                },\n            ));\n            let slice = text.as_ref().unwrap().as_ref();\n            *bytes_read = slice.len() as u32 * 2;\n            slice.as_ptr().cast::<c_char>()\n        }\n\n        let empty_options = ffi::TSParseOptions {\n            payload: ptr::null_mut(),\n            progress_callback: None,\n        };\n\n        let mut callback_ptr;\n        let parse_options = if let Some(options) = options {\n            if let Some(cb) = options.progress_callback {\n                callback_ptr = cb;\n                ffi::TSParseOptions {\n                    payload: core::ptr::addr_of_mut!(callback_ptr).cast::<c_void>(),\n                    progress_callback: Some(progress),\n                }\n            } else {\n                empty_options\n            }\n        } else {\n            empty_options\n        };\n\n        // A pointer to this payload is passed on every call to the `read` C function.\n        // The payload contains two things:\n        // 1. A reference to the rust `callback`.\n        // 2. The text that was returned from the previous call to `callback`. This allows the\n        //    callback to return owned values like vectors.\n        let mut payload: Payload<F, T> = (callback, None);\n\n        let c_input = ffi::TSInput {\n            payload: core::ptr::addr_of_mut!(payload).cast::<c_void>(),\n            read: Some(read::<T, F>),\n            encoding: ffi::TSInputEncodingUTF16LE,\n            decode: None,\n        };\n\n        let c_old_tree = old_tree.map_or(ptr::null_mut(), |t| t.0.as_ptr());\n        unsafe {\n            let c_new_tree = ffi::ts_parser_parse_with_options(\n                self.0.as_ptr(),\n                c_old_tree,\n                c_input,\n                parse_options,\n            );\n\n            NonNull::new(c_new_tree).map(Tree)\n        }\n    }\n\n    /// Parse a slice of UTF16 big-endian text.\n    ///\n    /// # Arguments:\n    /// * `text` The UTF16-encoded text to parse.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    pub fn parse_utf16_be(\n        &mut self,\n        input: impl AsRef<[u16]>,\n        old_tree: Option<&Tree>,\n    ) -> Option<Tree> {\n        let code_points = input.as_ref();\n        let len = code_points.len();\n        self.parse_utf16_be_with_options(\n            &mut |i, _| if i < len { &code_points[i..] } else { &[] },\n            old_tree,\n            None,\n        )\n    }\n\n    /// Parse UTF16 big-endian text provided in chunks by a callback.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a code point offset and position and returns a slice of\n    ///   UTF16-encoded text starting at that byte offset and position. The slices can be of any\n    ///   length. If the given position is at the end of the text, the callback should return an\n    ///   empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    /// * `options` Options for parsing the text. This can be used to set a progress callback.\n    pub fn parse_utf16_be_with_options<T: AsRef<[u16]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n        options: Option<ParseOptions>,\n    ) -> Option<Tree> {\n        type Payload<'a, F, T> = (&'a mut F, Option<T>);\n\n        // This C function is passed to Tree-sitter as the progress callback.\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSParseState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<ParseProgressCallback>()\n                .as_mut()\n                .unwrap();\n            callback(&ParseState::from_raw(state))\n        }\n\n        // This C function is passed to Tree-sitter as the input callback.\n        unsafe extern \"C\" fn read<T: AsRef<[u16]>, F: FnMut(usize, Point) -> T>(\n            payload: *mut c_void,\n            byte_offset: u32,\n            position: ffi::TSPoint,\n            bytes_read: *mut u32,\n        ) -> *const c_char {\n            let (callback, text) = payload.cast::<Payload<F, T>>().as_mut().unwrap();\n            *text = Some(callback(\n                (byte_offset / 2) as usize,\n                Point {\n                    row: position.row as usize,\n                    column: position.column as usize / 2,\n                },\n            ));\n            let slice = text.as_ref().unwrap().as_ref();\n            *bytes_read = slice.len() as u32 * 2;\n            slice.as_ptr().cast::<c_char>()\n        }\n\n        let empty_options = ffi::TSParseOptions {\n            payload: ptr::null_mut(),\n            progress_callback: None,\n        };\n\n        let mut callback_ptr;\n        let parse_options = if let Some(options) = options {\n            if let Some(cb) = options.progress_callback {\n                callback_ptr = cb;\n                ffi::TSParseOptions {\n                    payload: core::ptr::addr_of_mut!(callback_ptr).cast::<c_void>(),\n                    progress_callback: Some(progress),\n                }\n            } else {\n                empty_options\n            }\n        } else {\n            empty_options\n        };\n\n        // A pointer to this payload is passed on every call to the `read` C function.\n        // The payload contains two things:\n        // 1. A reference to the rust `callback`.\n        // 2. The text that was returned from the previous call to `callback`. This allows the\n        //    callback to return owned values like vectors.\n        let mut payload: Payload<F, T> = (callback, None);\n\n        let c_input = ffi::TSInput {\n            payload: core::ptr::addr_of_mut!(payload).cast::<c_void>(),\n            read: Some(read::<T, F>),\n            encoding: ffi::TSInputEncodingUTF16BE,\n            decode: None,\n        };\n\n        let c_old_tree = old_tree.map_or(ptr::null_mut(), |t| t.0.as_ptr());\n        unsafe {\n            let c_new_tree = ffi::ts_parser_parse_with_options(\n                self.0.as_ptr(),\n                c_old_tree,\n                c_input,\n                parse_options,\n            );\n\n            NonNull::new(c_new_tree).map(Tree)\n        }\n    }\n\n    /// Parse text provided in chunks by a callback using a custom encoding.\n    /// This is useful for parsing text in encodings that are not UTF-8 or UTF-16.\n    ///\n    /// # Arguments:\n    /// * `callback` A function that takes a byte offset and position and returns a slice of text\n    ///   starting at that byte offset and position. The slices can be of any length. If the given\n    ///   position is at the end of the text, the callback should return an empty slice.\n    /// * `old_tree` A previous syntax tree parsed from the same document. If the text of the\n    ///   document has changed since `old_tree` was created, then you must edit `old_tree` to match\n    ///   the new text using [`Tree::edit`].\n    /// * `options` Options for parsing the text. This can be used to set a progress callback.\n    ///\n    /// Additionally, you must set the generic parameter [`D`] to a type that implements the\n    /// [`Decode`] trait. This trait has a single method, [`decode`](Decode::decode), which takes a\n    /// slice of bytes and returns a tuple of the code point and the number of bytes consumed.\n    /// The `decode` method should return `-1` for the code point if decoding fails.\n    pub fn parse_custom_encoding<D: Decode, T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(\n        &mut self,\n        callback: &mut F,\n        old_tree: Option<&Tree>,\n        options: Option<ParseOptions>,\n    ) -> Option<Tree> {\n        type Payload<'a, F, T> = (&'a mut F, Option<T>);\n\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSParseState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<ParseProgressCallback>()\n                .as_mut()\n                .unwrap();\n            callback(&ParseState::from_raw(state))\n        }\n\n        // At compile time, create a C-compatible callback that calls the custom `decode` method.\n        unsafe extern \"C\" fn decode_fn<D: Decode>(\n            data: *const u8,\n            len: u32,\n            code_point: *mut i32,\n        ) -> u32 {\n            let (c, len) = D::decode(core::slice::from_raw_parts(data, len as usize));\n            if let Some(code_point) = code_point.as_mut() {\n                *code_point = c;\n            }\n            len\n        }\n\n        // This C function is passed to Tree-sitter as the input callback.\n        unsafe extern \"C\" fn read<T: AsRef<[u8]>, F: FnMut(usize, Point) -> T>(\n            payload: *mut c_void,\n            byte_offset: u32,\n            position: ffi::TSPoint,\n            bytes_read: *mut u32,\n        ) -> *const c_char {\n            let (callback, text) = payload.cast::<Payload<F, T>>().as_mut().unwrap();\n            *text = Some(callback(byte_offset as usize, position.into()));\n            let slice = text.as_ref().unwrap().as_ref();\n            *bytes_read = slice.len() as u32;\n            slice.as_ptr().cast::<c_char>()\n        }\n\n        let empty_options = ffi::TSParseOptions {\n            payload: ptr::null_mut(),\n            progress_callback: None,\n        };\n\n        let mut callback_ptr;\n        let parse_options = if let Some(options) = options {\n            if let Some(cb) = options.progress_callback {\n                callback_ptr = cb;\n                ffi::TSParseOptions {\n                    payload: core::ptr::addr_of_mut!(callback_ptr).cast::<c_void>(),\n                    progress_callback: Some(progress),\n                }\n            } else {\n                empty_options\n            }\n        } else {\n            empty_options\n        };\n\n        // A pointer to this payload is passed on every call to the `read` C function.\n        // The payload contains two things:\n        // 1. A reference to the rust `callback`.\n        // 2. The text that was returned from the previous call to `callback`. This allows the\n        //    callback to return owned values like vectors.\n        let mut payload: Payload<F, T> = (callback, None);\n\n        let c_input = ffi::TSInput {\n            payload: core::ptr::addr_of_mut!(payload).cast::<c_void>(),\n            read: Some(read::<T, F>),\n            encoding: ffi::TSInputEncodingCustom,\n            // Use this custom decode callback\n            decode: Some(decode_fn::<D>),\n        };\n\n        let c_old_tree = old_tree.map_or(ptr::null_mut(), |t| t.0.as_ptr());\n        unsafe {\n            let c_new_tree = ffi::ts_parser_parse_with_options(\n                self.0.as_ptr(),\n                c_old_tree,\n                c_input,\n                parse_options,\n            );\n\n            NonNull::new(c_new_tree).map(Tree)\n        }\n    }\n\n    /// Instruct the parser to start the next parse from the beginning.\n    ///\n    /// If the parser previously failed because of a timeout, cancellation,\n    /// or callback, then by default, it will resume where it left off on the\n    /// next call to [`parse`](Parser::parse) or other parsing functions.\n    /// If you don't want to resume, and instead intend to use this parser to\n    /// parse some other document, you must call `reset` first.\n    #[doc(alias = \"ts_parser_reset\")]\n    pub fn reset(&mut self) {\n        unsafe { ffi::ts_parser_reset(self.0.as_ptr()) }\n    }\n\n    /// Get the duration in microseconds that parsing is allowed to take.\n    ///\n    /// This is set via [`set_timeout_micros`](Parser::set_timeout_micros).\n    #[doc(alias = \"ts_parser_timeout_micros\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `parse_with_options` and using a callback\"\n    )]\n    #[must_use]\n    pub fn timeout_micros(&self) -> u64 {\n        unsafe { ffi::ts_parser_timeout_micros(self.0.as_ptr()) }\n    }\n\n    /// Set the maximum duration in microseconds that parsing should be allowed\n    /// to take before halting.\n    ///\n    /// If parsing takes longer than this, it will halt early, returning `None`.\n    /// See [`parse`](Parser::parse) for more information.\n    #[doc(alias = \"ts_parser_set_timeout_micros\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `parse_with_options` and using a callback\"\n    )]\n    pub fn set_timeout_micros(&mut self, timeout_micros: u64) {\n        unsafe { ffi::ts_parser_set_timeout_micros(self.0.as_ptr(), timeout_micros) }\n    }\n\n    /// Set the ranges of text that the parser should include when parsing.\n    ///\n    /// By default, the parser will always include entire documents. This\n    /// function allows you to parse only a *portion* of a document but\n    /// still return a syntax tree whose ranges match up with the document\n    /// as a whole. You can also pass multiple disjoint ranges.\n    ///\n    /// If `ranges` is empty, then the entire document will be parsed.\n    /// Otherwise, the given ranges must be ordered from earliest to latest\n    /// in the document, and they must not overlap. That is, the following\n    /// must hold for all `i` < `length - 1`:\n    /// ```text\n    ///     ranges[i].end_byte <= ranges[i + 1].start_byte\n    /// ```\n    /// If this requirement is not satisfied, method will return\n    /// [`IncludedRangesError`] error with an offset in the passed ranges\n    /// slice pointing to a first incorrect range.\n    #[doc(alias = \"ts_parser_set_included_ranges\")]\n    pub fn set_included_ranges(&mut self, ranges: &[Range]) -> Result<(), IncludedRangesError> {\n        let ts_ranges = ranges.iter().copied().map(Into::into).collect::<Vec<_>>();\n        let result = unsafe {\n            ffi::ts_parser_set_included_ranges(\n                self.0.as_ptr(),\n                ts_ranges.as_ptr(),\n                ts_ranges.len() as u32,\n            )\n        };\n\n        if result {\n            Ok(())\n        } else {\n            let mut prev_end_byte = 0;\n            for (i, range) in ranges.iter().enumerate() {\n                if range.start_byte < prev_end_byte || range.end_byte < range.start_byte {\n                    return Err(IncludedRangesError(i));\n                }\n                prev_end_byte = range.end_byte;\n            }\n            Err(IncludedRangesError(0))\n        }\n    }\n\n    /// Get the ranges of text that the parser will include when parsing.\n    #[doc(alias = \"ts_parser_included_ranges\")]\n    #[must_use]\n    pub fn included_ranges(&self) -> Vec<Range> {\n        let mut count = 0u32;\n        unsafe {\n            let ptr =\n                ffi::ts_parser_included_ranges(self.0.as_ptr(), core::ptr::addr_of_mut!(count));\n            let ranges = slice::from_raw_parts(ptr, count as usize);\n            let result = ranges.iter().copied().map(Into::into).collect();\n            result\n        }\n    }\n\n    /// Get the parser's current cancellation flag pointer.\n    ///\n    /// # Safety\n    ///\n    /// It uses FFI\n    #[doc(alias = \"ts_parser_cancellation_flag\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `parse_with_options` and using a callback\"\n    )]\n    #[must_use]\n    pub unsafe fn cancellation_flag(&self) -> Option<&AtomicUsize> {\n        ffi::ts_parser_cancellation_flag(self.0.as_ptr())\n            .cast::<AtomicUsize>()\n            .as_ref()\n    }\n\n    /// Set the parser's current cancellation flag pointer.\n    ///\n    /// If a pointer is assigned, then the parser will periodically read from\n    /// this pointer during parsing. If it reads a non-zero value, it will halt\n    /// early, returning `None`. See [`parse`](Parser::parse) for more\n    /// information.\n    ///\n    /// # Safety\n    ///\n    /// It uses FFI\n    #[doc(alias = \"ts_parser_set_cancellation_flag\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `parse_with_options` and using a callback\"\n    )]\n    pub unsafe fn set_cancellation_flag(&mut self, flag: Option<&AtomicUsize>) {\n        if let Some(flag) = flag {\n            ffi::ts_parser_set_cancellation_flag(\n                self.0.as_ptr(),\n                core::ptr::from_ref::<AtomicUsize>(flag).cast::<usize>(),\n            );\n        } else {\n            ffi::ts_parser_set_cancellation_flag(self.0.as_ptr(), ptr::null());\n        }\n    }\n}\n\nimpl Drop for Parser {\n    fn drop(&mut self) {\n        #[cfg(feature = \"std\")]\n        #[cfg(not(target_os = \"wasi\"))]\n        {\n            self.stop_printing_dot_graphs();\n        }\n        self.set_logger(None);\n        unsafe { ffi::ts_parser_delete(self.0.as_ptr()) }\n    }\n}\n\n#[cfg(windows)]\nextern \"C\" {\n    fn _open_osfhandle(osfhandle: isize, flags: core::ffi::c_int) -> core::ffi::c_int;\n}\n\nimpl Tree {\n    /// Get the root node of the syntax tree.\n    #[doc(alias = \"ts_tree_root_node\")]\n    #[must_use]\n    pub fn root_node(&self) -> Node {\n        Node::new(unsafe { ffi::ts_tree_root_node(self.0.as_ptr()) }).unwrap()\n    }\n\n    /// Get the root node of the syntax tree, but with its position shifted\n    /// forward by the given offset.\n    #[doc(alias = \"ts_tree_root_node_with_offset\")]\n    #[must_use]\n    pub fn root_node_with_offset(&self, offset_bytes: usize, offset_extent: Point) -> Node {\n        Node::new(unsafe {\n            ffi::ts_tree_root_node_with_offset(\n                self.0.as_ptr(),\n                offset_bytes as u32,\n                offset_extent.into(),\n            )\n        })\n        .unwrap()\n    }\n\n    /// Get the language that was used to parse the syntax tree.\n    #[doc(alias = \"ts_tree_language\")]\n    #[must_use]\n    pub fn language(&self) -> LanguageRef {\n        LanguageRef(\n            unsafe { ffi::ts_tree_language(self.0.as_ptr()) },\n            PhantomData,\n        )\n    }\n\n    /// Edit the syntax tree to keep it in sync with source code that has been\n    /// edited.\n    ///\n    /// You must describe the edit both in terms of byte offsets and in terms of\n    /// row/column coordinates.\n    #[doc(alias = \"ts_tree_edit\")]\n    pub fn edit(&mut self, edit: &InputEdit) {\n        let edit = edit.into();\n        unsafe { ffi::ts_tree_edit(self.0.as_ptr(), &edit) };\n    }\n\n    /// Create a new [`TreeCursor`] starting from the root of the tree.\n    #[must_use]\n    pub fn walk(&self) -> TreeCursor {\n        self.root_node().walk()\n    }\n\n    /// Compare this old edited syntax tree to a new syntax tree representing\n    /// the same document, returning a sequence of ranges whose syntactic\n    /// structure has changed.\n    ///\n    /// For this to work correctly, this syntax tree must have been edited such\n    /// that its ranges match up to the new tree. Generally, you'll want to\n    /// call this method right after calling one of the [`Parser::parse`]\n    /// functions. Call it on the old tree that was passed to parse, and\n    /// pass the new tree that was returned from `parse`.\n    #[doc(alias = \"ts_tree_get_changed_ranges\")]\n    #[must_use]\n    pub fn changed_ranges(&self, other: &Self) -> impl ExactSizeIterator<Item = Range> {\n        let mut count = 0u32;\n        unsafe {\n            let ptr = ffi::ts_tree_get_changed_ranges(\n                self.0.as_ptr(),\n                other.0.as_ptr(),\n                core::ptr::addr_of_mut!(count),\n            );\n            util::CBufferIter::new(ptr, count as usize).map(Into::into)\n        }\n    }\n\n    /// Get the included ranges that were used to parse the syntax tree.\n    #[doc(alias = \"ts_tree_included_ranges\")]\n    #[must_use]\n    pub fn included_ranges(&self) -> Vec<Range> {\n        let mut count = 0u32;\n        unsafe {\n            let ptr = ffi::ts_tree_included_ranges(self.0.as_ptr(), core::ptr::addr_of_mut!(count));\n            let ranges = slice::from_raw_parts(ptr, count as usize);\n            let result = ranges.iter().copied().map(Into::into).collect();\n            (FREE_FN)(ptr.cast::<c_void>());\n            result\n        }\n    }\n\n    /// Print a graph of the tree to the given file descriptor.\n    /// The graph is formatted in the DOT language. You may want to pipe this\n    /// graph directly to a `dot(1)` process in order to generate SVG\n    /// output.\n    #[doc(alias = \"ts_tree_print_dot_graph\")]\n    #[cfg(not(target_os = \"wasi\"))]\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    pub fn print_dot_graph(\n        &self,\n        #[cfg(unix)] file: &impl AsRawFd,\n        #[cfg(windows)] file: &impl AsRawHandle,\n    ) {\n        #[cfg(unix)]\n        {\n            let fd = file.as_raw_fd();\n            unsafe { ffi::ts_tree_print_dot_graph(self.0.as_ptr(), fd) }\n        }\n\n        #[cfg(windows)]\n        {\n            let handle = file.as_raw_handle();\n            let fd = unsafe { _open_osfhandle(handle as isize, 0) };\n            unsafe { ffi::ts_tree_print_dot_graph(self.0.as_ptr(), fd) }\n        }\n    }\n}\n\nimpl fmt::Debug for Tree {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{{Tree {:?}}}\", self.root_node())\n    }\n}\n\nimpl Drop for Tree {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_tree_delete(self.0.as_ptr()) }\n    }\n}\n\nimpl Clone for Tree {\n    fn clone(&self) -> Self {\n        unsafe { Self(NonNull::new_unchecked(ffi::ts_tree_copy(self.0.as_ptr()))) }\n    }\n}\n\nimpl<'tree> Node<'tree> {\n    fn new(node: ffi::TSNode) -> Option<Self> {\n        (!node.id.is_null()).then_some(Node(node, PhantomData))\n    }\n\n    /// Get a numeric id for this node that is unique.\n    ///\n    /// Within a given syntax tree, no two nodes have the same id. However:\n    ///\n    /// - If a new tree is created based on an older tree, and a node from the old tree is reused in\n    ///   the process, then that node will have the same id in both trees.\n    ///\n    /// - A node not marked as having changes does not guarantee it was reused.\n    ///\n    /// - If a node is marked as having changed in the old tree, it will not be reused.\n    #[must_use]\n    pub fn id(&self) -> usize {\n        self.0.id as usize\n    }\n\n    /// Get this node's type as a numerical id.\n    #[doc(alias = \"ts_node_symbol\")]\n    #[must_use]\n    pub fn kind_id(&self) -> u16 {\n        unsafe { ffi::ts_node_symbol(self.0) }\n    }\n\n    /// Get the node's type as a numerical id as it appears in the grammar\n    /// ignoring aliases.\n    #[doc(alias = \"ts_node_grammar_symbol\")]\n    #[must_use]\n    pub fn grammar_id(&self) -> u16 {\n        unsafe { ffi::ts_node_grammar_symbol(self.0) }\n    }\n\n    /// Get this node's type as a string.\n    #[doc(alias = \"ts_node_type\")]\n    #[must_use]\n    pub fn kind(&self) -> &'static str {\n        unsafe { CStr::from_ptr(ffi::ts_node_type(self.0)) }\n            .to_str()\n            .unwrap()\n    }\n\n    /// Get this node's symbol name as it appears in the grammar ignoring\n    /// aliases as a string.\n    #[doc(alias = \"ts_node_grammar_type\")]\n    #[must_use]\n    pub fn grammar_name(&self) -> &'static str {\n        unsafe { CStr::from_ptr(ffi::ts_node_grammar_type(self.0)) }\n            .to_str()\n            .unwrap()\n    }\n\n    /// Get the [`Language`] that was used to parse this node's syntax tree.\n    #[doc(alias = \"ts_node_language\")]\n    #[must_use]\n    pub fn language(&self) -> LanguageRef {\n        LanguageRef(unsafe { ffi::ts_node_language(self.0) }, PhantomData)\n    }\n\n    /// Check if this node is *named*.\n    ///\n    /// Named nodes correspond to named rules in the grammar, whereas\n    /// *anonymous* nodes correspond to string literals in the grammar.\n    #[doc(alias = \"ts_node_is_named\")]\n    #[must_use]\n    pub fn is_named(&self) -> bool {\n        unsafe { ffi::ts_node_is_named(self.0) }\n    }\n\n    /// Check if this node is *extra*.\n    ///\n    /// Extra nodes represent things like comments, which are not required by the\n    /// grammar, but can appear anywhere.\n    #[doc(alias = \"ts_node_is_extra\")]\n    #[must_use]\n    pub fn is_extra(&self) -> bool {\n        unsafe { ffi::ts_node_is_extra(self.0) }\n    }\n\n    /// Check if this node has been edited.\n    #[doc(alias = \"ts_node_has_changes\")]\n    #[must_use]\n    pub fn has_changes(&self) -> bool {\n        unsafe { ffi::ts_node_has_changes(self.0) }\n    }\n\n    /// Check if this node represents a syntax error or contains any syntax\n    /// errors anywhere within it.\n    #[doc(alias = \"ts_node_has_error\")]\n    #[must_use]\n    pub fn has_error(&self) -> bool {\n        unsafe { ffi::ts_node_has_error(self.0) }\n    }\n\n    /// Check if this node represents a syntax error.\n    ///\n    /// Syntax errors represent parts of the code that could not be incorporated\n    /// into a valid syntax tree.\n    #[doc(alias = \"ts_node_is_error\")]\n    #[must_use]\n    pub fn is_error(&self) -> bool {\n        unsafe { ffi::ts_node_is_error(self.0) }\n    }\n\n    /// Get this node's parse state.\n    #[doc(alias = \"ts_node_parse_state\")]\n    #[must_use]\n    pub fn parse_state(&self) -> u16 {\n        unsafe { ffi::ts_node_parse_state(self.0) }\n    }\n\n    /// Get the parse state after this node.\n    #[doc(alias = \"ts_node_next_parse_state\")]\n    #[must_use]\n    pub fn next_parse_state(&self) -> u16 {\n        unsafe { ffi::ts_node_next_parse_state(self.0) }\n    }\n\n    /// Check if this node is *missing*.\n    ///\n    /// Missing nodes are inserted by the parser in order to recover from\n    /// certain kinds of syntax errors.\n    #[doc(alias = \"ts_node_is_missing\")]\n    #[must_use]\n    pub fn is_missing(&self) -> bool {\n        unsafe { ffi::ts_node_is_missing(self.0) }\n    }\n\n    /// Get the byte offset where this node starts.\n    #[doc(alias = \"ts_node_start_byte\")]\n    #[must_use]\n    pub fn start_byte(&self) -> usize {\n        unsafe { ffi::ts_node_start_byte(self.0) as usize }\n    }\n\n    /// Get the byte offset where this node ends.\n    #[doc(alias = \"ts_node_end_byte\")]\n    #[must_use]\n    pub fn end_byte(&self) -> usize {\n        unsafe { ffi::ts_node_end_byte(self.0) as usize }\n    }\n\n    /// Get the byte range of source code that this node represents.\n    #[must_use]\n    pub fn byte_range(&self) -> core::ops::Range<usize> {\n        self.start_byte()..self.end_byte()\n    }\n\n    /// Get the range of source code that this node represents, both in terms of\n    /// raw bytes and of row/column coordinates.\n    #[must_use]\n    pub fn range(&self) -> Range {\n        Range {\n            start_byte: self.start_byte(),\n            end_byte: self.end_byte(),\n            start_point: self.start_position(),\n            end_point: self.end_position(),\n        }\n    }\n\n    /// Get this node's start position in terms of rows and columns.\n    #[doc(alias = \"ts_node_start_point\")]\n    #[must_use]\n    pub fn start_position(&self) -> Point {\n        let result = unsafe { ffi::ts_node_start_point(self.0) };\n        result.into()\n    }\n\n    /// Get this node's end position in terms of rows and columns.\n    #[doc(alias = \"ts_node_end_point\")]\n    #[must_use]\n    pub fn end_position(&self) -> Point {\n        let result = unsafe { ffi::ts_node_end_point(self.0) };\n        result.into()\n    }\n\n    /// Get the node's child at the given index, where zero represents the first\n    /// child.\n    ///\n    /// This method is fairly fast, but its cost is technically log(i), so if\n    /// you might be iterating over a long list of children, you should use\n    /// [`Node::children`] instead.\n    #[doc(alias = \"ts_node_child\")]\n    #[must_use]\n    pub fn child(&self, i: usize) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_child(self.0, i as u32) })\n    }\n\n    /// Get this node's number of children.\n    #[doc(alias = \"ts_node_child_count\")]\n    #[must_use]\n    pub fn child_count(&self) -> usize {\n        unsafe { ffi::ts_node_child_count(self.0) as usize }\n    }\n\n    /// Get this node's *named* child at the given index.\n    ///\n    /// See also [`Node::is_named`].\n    /// This method is fairly fast, but its cost is technically log(i), so if\n    /// you might be iterating over a long list of children, you should use\n    /// [`Node::named_children`] instead.\n    #[doc(alias = \"ts_node_named_child\")]\n    #[must_use]\n    pub fn named_child(&self, i: usize) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_named_child(self.0, i as u32) })\n    }\n\n    /// Get this node's number of *named* children.\n    ///\n    /// See also [`Node::is_named`].\n    #[doc(alias = \"ts_node_named_child_count\")]\n    #[must_use]\n    pub fn named_child_count(&self) -> usize {\n        unsafe { ffi::ts_node_named_child_count(self.0) as usize }\n    }\n\n    /// Get the first child with the given field name.\n    ///\n    /// If multiple children may have the same field name, access them using\n    /// [`children_by_field_name`](Node::children_by_field_name)\n    #[doc(alias = \"ts_node_child_by_field_name\")]\n    #[must_use]\n    pub fn child_by_field_name(&self, field_name: impl AsRef<[u8]>) -> Option<Self> {\n        let field_name = field_name.as_ref();\n        Self::new(unsafe {\n            ffi::ts_node_child_by_field_name(\n                self.0,\n                field_name.as_ptr().cast::<c_char>(),\n                field_name.len() as u32,\n            )\n        })\n    }\n\n    /// Get this node's child with the given numerical field id.\n    ///\n    /// See also [`child_by_field_name`](Node::child_by_field_name). You can\n    /// convert a field name to an id using [`Language::field_id_for_name`].\n    #[doc(alias = \"ts_node_child_by_field_id\")]\n    #[must_use]\n    pub fn child_by_field_id(&self, field_id: u16) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_child_by_field_id(self.0, field_id) })\n    }\n\n    /// Get the field name of this node's child at the given index.\n    #[doc(alias = \"ts_node_field_name_for_child\")]\n    #[must_use]\n    pub fn field_name_for_child(&self, child_index: u32) -> Option<&'static str> {\n        unsafe {\n            let ptr = ffi::ts_node_field_name_for_child(self.0, child_index);\n            (!ptr.is_null()).then(|| CStr::from_ptr(ptr).to_str().unwrap())\n        }\n    }\n\n    /// Get the field name of this node's named child at the given index.\n    #[must_use]\n    pub fn field_name_for_named_child(&self, named_child_index: u32) -> Option<&'static str> {\n        unsafe {\n            let ptr = ffi::ts_node_field_name_for_named_child(self.0, named_child_index);\n            (!ptr.is_null()).then(|| CStr::from_ptr(ptr).to_str().unwrap())\n        }\n    }\n\n    /// Iterate over this node's children.\n    ///\n    /// A [`TreeCursor`] is used to retrieve the children efficiently. Obtain\n    /// a [`TreeCursor`] by calling [`Tree::walk`] or [`Node::walk`]. To avoid\n    /// unnecessary allocations, you should reuse the same cursor for\n    /// subsequent calls to this method.\n    ///\n    /// If you're walking the tree recursively, you may want to use the\n    /// [`TreeCursor`] APIs directly instead.\n    pub fn children<'cursor>(\n        &self,\n        cursor: &'cursor mut TreeCursor<'tree>,\n    ) -> impl ExactSizeIterator<Item = Node<'tree>> + 'cursor {\n        cursor.reset(*self);\n        cursor.goto_first_child();\n        (0..self.child_count()).map(move |_| {\n            let result = cursor.node();\n            cursor.goto_next_sibling();\n            result\n        })\n    }\n\n    /// Iterate over this node's named children.\n    ///\n    /// See also [`Node::children`].\n    pub fn named_children<'cursor>(\n        &self,\n        cursor: &'cursor mut TreeCursor<'tree>,\n    ) -> impl ExactSizeIterator<Item = Node<'tree>> + 'cursor {\n        cursor.reset(*self);\n        cursor.goto_first_child();\n        (0..self.named_child_count()).map(move |_| {\n            while !cursor.node().is_named() {\n                if !cursor.goto_next_sibling() {\n                    break;\n                }\n            }\n            let result = cursor.node();\n            cursor.goto_next_sibling();\n            result\n        })\n    }\n\n    /// Iterate over this node's children with a given field name.\n    ///\n    /// See also [`Node::children`].\n    pub fn children_by_field_name<'cursor>(\n        &self,\n        field_name: &str,\n        cursor: &'cursor mut TreeCursor<'tree>,\n    ) -> impl Iterator<Item = Node<'tree>> + 'cursor {\n        let field_id = self.language().field_id_for_name(field_name);\n        let mut done = field_id.is_none();\n        if !done {\n            cursor.reset(*self);\n            cursor.goto_first_child();\n        }\n        iter::from_fn(move || {\n            if !done {\n                while cursor.field_id() != field_id {\n                    if !cursor.goto_next_sibling() {\n                        return None;\n                    }\n                }\n                let result = cursor.node();\n                if !cursor.goto_next_sibling() {\n                    done = true;\n                }\n                return Some(result);\n            }\n            None\n        })\n    }\n\n    /// Iterate over this node's children with a given field id.\n    ///\n    /// See also [`Node::children_by_field_name`].\n    pub fn children_by_field_id<'cursor>(\n        &self,\n        field_id: FieldId,\n        cursor: &'cursor mut TreeCursor<'tree>,\n    ) -> impl Iterator<Item = Node<'tree>> + 'cursor {\n        cursor.reset(*self);\n        cursor.goto_first_child();\n        let mut done = false;\n        iter::from_fn(move || {\n            if !done {\n                while cursor.field_id() != Some(field_id) {\n                    if !cursor.goto_next_sibling() {\n                        return None;\n                    }\n                }\n                let result = cursor.node();\n                if !cursor.goto_next_sibling() {\n                    done = true;\n                }\n                return Some(result);\n            }\n            None\n        })\n    }\n\n    /// Get this node's immediate parent.\n    /// Prefer [`child_with_descendant`](Node::child_with_descendant)\n    /// for iterating over this node's ancestors.\n    #[doc(alias = \"ts_node_parent\")]\n    #[must_use]\n    pub fn parent(&self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_parent(self.0) })\n    }\n\n    /// Get the node that contains `descendant`.\n    ///\n    /// Note that this can return `descendant` itself.\n    #[doc(alias = \"ts_node_child_with_descendant\")]\n    #[must_use]\n    pub fn child_with_descendant(&self, descendant: Self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_child_with_descendant(self.0, descendant.0) })\n    }\n\n    /// Get this node's next sibling.\n    #[doc(alias = \"ts_node_next_sibling\")]\n    #[must_use]\n    pub fn next_sibling(&self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_next_sibling(self.0) })\n    }\n\n    /// Get this node's previous sibling.\n    #[doc(alias = \"ts_node_prev_sibling\")]\n    #[must_use]\n    pub fn prev_sibling(&self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_prev_sibling(self.0) })\n    }\n\n    /// Get this node's next named sibling.\n    #[doc(alias = \"ts_node_next_named_sibling\")]\n    #[must_use]\n    pub fn next_named_sibling(&self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_next_named_sibling(self.0) })\n    }\n\n    /// Get this node's previous named sibling.\n    #[doc(alias = \"ts_node_prev_named_sibling\")]\n    #[must_use]\n    pub fn prev_named_sibling(&self) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_prev_named_sibling(self.0) })\n    }\n\n    /// Get this node's first child that contains or starts after the given byte offset.\n    #[doc(alias = \"ts_node_first_child_for_byte\")]\n    #[must_use]\n    pub fn first_child_for_byte(&self, byte: usize) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_first_child_for_byte(self.0, byte as u32) })\n    }\n\n    /// Get this node's first named child that contains or starts after the given byte offset.\n    #[doc(alias = \"ts_node_first_named_child_for_point\")]\n    #[must_use]\n    pub fn first_named_child_for_byte(&self, byte: usize) -> Option<Self> {\n        Self::new(unsafe { ffi::ts_node_first_named_child_for_byte(self.0, byte as u32) })\n    }\n\n    /// Get the node's number of descendants, including one for the node itself.\n    #[doc(alias = \"ts_node_descendant_count\")]\n    #[must_use]\n    pub fn descendant_count(&self) -> usize {\n        unsafe { ffi::ts_node_descendant_count(self.0) as usize }\n    }\n\n    /// Get the smallest node within this node that spans the given byte range.\n    #[doc(alias = \"ts_node_descendant_for_byte_range\")]\n    #[must_use]\n    pub fn descendant_for_byte_range(&self, start: usize, end: usize) -> Option<Self> {\n        Self::new(unsafe {\n            ffi::ts_node_descendant_for_byte_range(self.0, start as u32, end as u32)\n        })\n    }\n\n    /// Get the smallest named node within this node that spans the given byte range.\n    #[doc(alias = \"ts_node_named_descendant_for_byte_range\")]\n    #[must_use]\n    pub fn named_descendant_for_byte_range(&self, start: usize, end: usize) -> Option<Self> {\n        Self::new(unsafe {\n            ffi::ts_node_named_descendant_for_byte_range(self.0, start as u32, end as u32)\n        })\n    }\n\n    /// Get the smallest node within this node that spans the given point range.\n    #[doc(alias = \"ts_node_descendant_for_point_range\")]\n    #[must_use]\n    pub fn descendant_for_point_range(&self, start: Point, end: Point) -> Option<Self> {\n        Self::new(unsafe {\n            ffi::ts_node_descendant_for_point_range(self.0, start.into(), end.into())\n        })\n    }\n\n    /// Get the smallest named node within this node that spans the given point range.\n    #[doc(alias = \"ts_node_named_descendant_for_point_range\")]\n    #[must_use]\n    pub fn named_descendant_for_point_range(&self, start: Point, end: Point) -> Option<Self> {\n        Self::new(unsafe {\n            ffi::ts_node_named_descendant_for_point_range(self.0, start.into(), end.into())\n        })\n    }\n\n    /// Get an S-expression representing the node.\n    #[doc(alias = \"ts_node_string\")]\n    #[must_use]\n    pub fn to_sexp(&self) -> String {\n        let c_string = unsafe { ffi::ts_node_string(self.0) };\n        let result = unsafe { CStr::from_ptr(c_string) }\n            .to_str()\n            .unwrap()\n            .to_string();\n        unsafe { (FREE_FN)(c_string.cast::<c_void>()) };\n        result\n    }\n\n    pub fn utf8_text<'a>(&self, source: &'a [u8]) -> Result<&'a str, str::Utf8Error> {\n        str::from_utf8(&source[self.start_byte()..self.end_byte()])\n    }\n\n    #[must_use]\n    pub fn utf16_text<'a>(&self, source: &'a [u16]) -> &'a [u16] {\n        &source[self.start_byte() / 2..self.end_byte() / 2]\n    }\n\n    /// Create a new [`TreeCursor`] starting from this node.\n    ///\n    /// Note that the given node is considered the root of the cursor,\n    /// and the cursor cannot walk outside this node.\n    #[doc(alias = \"ts_tree_cursor_new\")]\n    #[must_use]\n    pub fn walk(&self) -> TreeCursor<'tree> {\n        TreeCursor(unsafe { ffi::ts_tree_cursor_new(self.0) }, PhantomData)\n    }\n\n    /// Edit this node to keep it in-sync with source code that has been edited.\n    ///\n    /// This function is only rarely needed. When you edit a syntax tree with\n    /// the [`Tree::edit`] method, all of the nodes that you retrieve from\n    /// the tree afterward will already reflect the edit. You only need to\n    /// use [`Node::edit`] when you have a specific [`Node`] instance that\n    /// you want to keep and continue to use after an edit.\n    #[doc(alias = \"ts_node_edit\")]\n    pub fn edit(&mut self, edit: &InputEdit) {\n        let edit = edit.into();\n        unsafe { ffi::ts_node_edit(core::ptr::addr_of_mut!(self.0), &edit) }\n    }\n}\n\nimpl PartialEq for Node<'_> {\n    fn eq(&self, other: &Self) -> bool {\n        core::ptr::eq(self.0.id, other.0.id)\n    }\n}\n\nimpl Eq for Node<'_> {}\n\nimpl hash::Hash for Node<'_> {\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        self.0.id.hash(state);\n        self.0.context[0].hash(state);\n        self.0.context[1].hash(state);\n        self.0.context[2].hash(state);\n        self.0.context[3].hash(state);\n    }\n}\n\nimpl fmt::Debug for Node<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"{{Node {} {} - {}}}\",\n            self.kind(),\n            self.start_position(),\n            self.end_position()\n        )\n    }\n}\n\nimpl fmt::Display for Node<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let sexp = self.to_sexp();\n        if sexp.is_empty() {\n            write!(f, \"\")\n        } else if !f.alternate() {\n            write!(f, \"{sexp}\")\n        } else {\n            write!(f, \"{}\", format_sexp(&sexp, f.width().unwrap_or(0)))\n        }\n    }\n}\n\nimpl<'cursor> TreeCursor<'cursor> {\n    /// Get the tree cursor's current [`Node`].\n    #[doc(alias = \"ts_tree_cursor_current_node\")]\n    #[must_use]\n    pub fn node(&self) -> Node<'cursor> {\n        Node(\n            unsafe { ffi::ts_tree_cursor_current_node(&self.0) },\n            PhantomData,\n        )\n    }\n\n    /// Get the numerical field id of this tree cursor's current node.\n    ///\n    /// See also [`field_name`](TreeCursor::field_name).\n    #[doc(alias = \"ts_tree_cursor_current_field_id\")]\n    #[must_use]\n    pub fn field_id(&self) -> Option<FieldId> {\n        let id = unsafe { ffi::ts_tree_cursor_current_field_id(&self.0) };\n        FieldId::new(id)\n    }\n\n    /// Get the field name of this tree cursor's current node.\n    #[doc(alias = \"ts_tree_cursor_current_field_name\")]\n    #[must_use]\n    pub fn field_name(&self) -> Option<&'static str> {\n        unsafe {\n            let ptr = ffi::ts_tree_cursor_current_field_name(&self.0);\n            (!ptr.is_null()).then(|| CStr::from_ptr(ptr).to_str().unwrap())\n        }\n    }\n\n    /// Get the depth of the cursor's current node relative to the original\n    /// node that the cursor was constructed with.\n    #[doc(alias = \"ts_tree_cursor_current_depth\")]\n    #[must_use]\n    pub fn depth(&self) -> u32 {\n        unsafe { ffi::ts_tree_cursor_current_depth(&self.0) }\n    }\n\n    /// Get the index of the cursor's current node out of all of the\n    /// descendants of the original node that the cursor was constructed with\n    #[doc(alias = \"ts_tree_cursor_current_descendant_index\")]\n    #[must_use]\n    pub fn descendant_index(&self) -> usize {\n        unsafe { ffi::ts_tree_cursor_current_descendant_index(&self.0) as usize }\n    }\n\n    /// Move this cursor to the first child of its current node.\n    ///\n    /// This returns `true` if the cursor successfully moved, and returns\n    /// `false` if there were no children.\n    #[doc(alias = \"ts_tree_cursor_goto_first_child\")]\n    pub fn goto_first_child(&mut self) -> bool {\n        unsafe { ffi::ts_tree_cursor_goto_first_child(&mut self.0) }\n    }\n\n    /// Move this cursor to the last child of its current node.\n    ///\n    /// This returns `true` if the cursor successfully moved, and returns\n    /// `false` if there were no children.\n    ///\n    /// Note that this function may be slower than\n    /// [`goto_first_child`](TreeCursor::goto_first_child) because it needs to\n    /// iterate through all the children to compute the child's position.\n    #[doc(alias = \"ts_tree_cursor_goto_last_child\")]\n    pub fn goto_last_child(&mut self) -> bool {\n        unsafe { ffi::ts_tree_cursor_goto_last_child(&mut self.0) }\n    }\n\n    /// Move this cursor to the parent of its current node.\n    ///\n    /// This returns `true` if the cursor successfully moved, and returns\n    /// `false` if there was no parent node (the cursor was already on the\n    /// root node).\n    ///\n    /// Note that the node the cursor was constructed with is considered the root\n    /// of the cursor, and the cursor cannot walk outside this node.\n    #[doc(alias = \"ts_tree_cursor_goto_parent\")]\n    pub fn goto_parent(&mut self) -> bool {\n        unsafe { ffi::ts_tree_cursor_goto_parent(&mut self.0) }\n    }\n\n    /// Move this cursor to the next sibling of its current node.\n    ///\n    /// This returns `true` if the cursor successfully moved, and returns\n    /// `false` if there was no next sibling node.\n    ///\n    /// Note that the node the cursor was constructed with is considered the root\n    /// of the cursor, and the cursor cannot walk outside this node.\n    #[doc(alias = \"ts_tree_cursor_goto_next_sibling\")]\n    pub fn goto_next_sibling(&mut self) -> bool {\n        unsafe { ffi::ts_tree_cursor_goto_next_sibling(&mut self.0) }\n    }\n\n    /// Move the cursor to the node that is the nth descendant of\n    /// the original node that the cursor was constructed with, where\n    /// zero represents the original node itself.\n    #[doc(alias = \"ts_tree_cursor_goto_descendant\")]\n    pub fn goto_descendant(&mut self, descendant_index: usize) {\n        unsafe { ffi::ts_tree_cursor_goto_descendant(&mut self.0, descendant_index as u32) }\n    }\n\n    /// Move this cursor to the previous sibling of its current node.\n    ///\n    /// This returns `true` if the cursor successfully moved, and returns\n    /// `false` if there was no previous sibling node.\n    ///\n    /// Note, that this function may be slower than\n    /// [`goto_next_sibling`](TreeCursor::goto_next_sibling) due to how node\n    /// positions are stored. In the worst case, this will need to iterate\n    /// through all the children up to the previous sibling node to recalculate\n    /// its position. Also note that the node the cursor was constructed with is\n    /// considered the root of the cursor, and the cursor cannot walk outside this node.\n    #[doc(alias = \"ts_tree_cursor_goto_previous_sibling\")]\n    pub fn goto_previous_sibling(&mut self) -> bool {\n        unsafe { ffi::ts_tree_cursor_goto_previous_sibling(&mut self.0) }\n    }\n\n    /// Move this cursor to the first child of its current node that contains or\n    /// starts after the given byte offset.\n    ///\n    /// This returns the index of the child node if one was found, and returns\n    /// `None` if no such child was found.\n    #[doc(alias = \"ts_tree_cursor_goto_first_child_for_byte\")]\n    pub fn goto_first_child_for_byte(&mut self, index: usize) -> Option<usize> {\n        let result =\n            unsafe { ffi::ts_tree_cursor_goto_first_child_for_byte(&mut self.0, index as u32) };\n        result.try_into().ok()\n    }\n\n    /// Move this cursor to the first child of its current node that contains or\n    /// starts after the given byte offset.\n    ///\n    /// This returns the index of the child node if one was found, and returns\n    /// `None` if no such child was found.\n    #[doc(alias = \"ts_tree_cursor_goto_first_child_for_point\")]\n    pub fn goto_first_child_for_point(&mut self, point: Point) -> Option<usize> {\n        let result =\n            unsafe { ffi::ts_tree_cursor_goto_first_child_for_point(&mut self.0, point.into()) };\n        result.try_into().ok()\n    }\n\n    /// Re-initialize this tree cursor to start at the original node that the\n    /// cursor was constructed with.\n    #[doc(alias = \"ts_tree_cursor_reset\")]\n    pub fn reset(&mut self, node: Node<'cursor>) {\n        unsafe { ffi::ts_tree_cursor_reset(&mut self.0, node.0) };\n    }\n\n    /// Re-initialize a tree cursor to the same position as another cursor.\n    ///\n    /// Unlike [`reset`](TreeCursor::reset), this will not lose parent\n    /// information and allows reusing already created cursors.\n    #[doc(alias = \"ts_tree_cursor_reset_to\")]\n    pub fn reset_to(&mut self, cursor: &Self) {\n        unsafe { ffi::ts_tree_cursor_reset_to(&mut self.0, &cursor.0) };\n    }\n}\n\nimpl Clone for TreeCursor<'_> {\n    fn clone(&self) -> Self {\n        TreeCursor(unsafe { ffi::ts_tree_cursor_copy(&self.0) }, PhantomData)\n    }\n}\n\nimpl Drop for TreeCursor<'_> {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_tree_cursor_delete(&mut self.0) }\n    }\n}\n\nimpl LookaheadIterator {\n    /// Get the current language of the lookahead iterator.\n    #[doc(alias = \"ts_lookahead_iterator_language\")]\n    #[must_use]\n    pub fn language(&self) -> LanguageRef<'_> {\n        LanguageRef(\n            unsafe { ffi::ts_lookahead_iterator_language(self.0.as_ptr()) },\n            PhantomData,\n        )\n    }\n\n    /// Get the current symbol of the lookahead iterator.\n    #[doc(alias = \"ts_lookahead_iterator_current_symbol\")]\n    #[must_use]\n    pub fn current_symbol(&self) -> u16 {\n        unsafe { ffi::ts_lookahead_iterator_current_symbol(self.0.as_ptr()) }\n    }\n\n    /// Get the current symbol name of the lookahead iterator.\n    #[doc(alias = \"ts_lookahead_iterator_current_symbol_name\")]\n    #[must_use]\n    pub fn current_symbol_name(&self) -> &'static str {\n        unsafe {\n            CStr::from_ptr(ffi::ts_lookahead_iterator_current_symbol_name(\n                self.0.as_ptr(),\n            ))\n            .to_str()\n            .unwrap()\n        }\n    }\n\n    /// Reset the lookahead iterator.\n    ///\n    /// This returns `true` if the language was set successfully and `false`\n    /// otherwise.\n    #[doc(alias = \"ts_lookahead_iterator_reset\")]\n    pub fn reset(&mut self, language: &Language, state: u16) -> bool {\n        unsafe { ffi::ts_lookahead_iterator_reset(self.0.as_ptr(), language.0, state) }\n    }\n\n    /// Reset the lookahead iterator to another state.\n    ///\n    /// This returns `true` if the iterator was reset to the given state and\n    /// `false` otherwise.\n    #[doc(alias = \"ts_lookahead_iterator_reset_state\")]\n    pub fn reset_state(&mut self, state: u16) -> bool {\n        unsafe { ffi::ts_lookahead_iterator_reset_state(self.0.as_ptr(), state) }\n    }\n\n    /// Iterate symbol names.\n    pub fn iter_names(&mut self) -> impl Iterator<Item = &'static str> + '_ {\n        LookaheadNamesIterator(self)\n    }\n}\n\nimpl Iterator for LookaheadNamesIterator<'_> {\n    type Item = &'static str;\n\n    #[doc(alias = \"ts_lookahead_iterator_next\")]\n    fn next(&mut self) -> Option<Self::Item> {\n        unsafe { ffi::ts_lookahead_iterator_next(self.0 .0.as_ptr()) }\n            .then(|| self.0.current_symbol_name())\n    }\n}\n\nimpl Iterator for LookaheadIterator {\n    type Item = u16;\n\n    #[doc(alias = \"ts_lookahead_iterator_next\")]\n    fn next(&mut self) -> Option<Self::Item> {\n        // the first symbol is always `0` so we can safely skip it\n        unsafe { ffi::ts_lookahead_iterator_next(self.0.as_ptr()) }.then(|| self.current_symbol())\n    }\n}\n\nimpl Drop for LookaheadIterator {\n    #[doc(alias = \"ts_lookahead_iterator_delete\")]\n    fn drop(&mut self) {\n        unsafe { ffi::ts_lookahead_iterator_delete(self.0.as_ptr()) }\n    }\n}\n\nimpl Query {\n    /// Create a new query from a string containing one or more S-expression\n    /// patterns.\n    ///\n    /// The query is associated with a particular language, and can only be run\n    /// on syntax nodes parsed with that language. References to Queries can be\n    /// shared between multiple threads.\n    pub fn new(language: &Language, source: &str) -> Result<Self, QueryError> {\n        let mut error_offset = 0u32;\n        let mut error_type: ffi::TSQueryError = 0;\n        let bytes = source.as_bytes();\n\n        // Compile the query.\n        let ptr = unsafe {\n            ffi::ts_query_new(\n                language.0,\n                bytes.as_ptr().cast::<c_char>(),\n                bytes.len() as u32,\n                core::ptr::addr_of_mut!(error_offset),\n                core::ptr::addr_of_mut!(error_type),\n            )\n        };\n\n        // On failure, build an error based on the error code and offset.\n        if ptr.is_null() {\n            if error_type == ffi::TSQueryErrorLanguage {\n                return Err(QueryError {\n                    row: 0,\n                    column: 0,\n                    offset: 0,\n                    message: LanguageError {\n                        version: language.abi_version(),\n                    }\n                    .to_string(),\n                    kind: QueryErrorKind::Language,\n                });\n            }\n\n            let offset = error_offset as usize;\n            let mut line_start = 0;\n            let mut row = 0;\n            let mut line_containing_error = None;\n            for line in source.lines() {\n                let line_end = line_start + line.len() + 1;\n                if line_end > offset {\n                    line_containing_error = Some(line);\n                    break;\n                }\n                line_start = line_end;\n                row += 1;\n            }\n            let column = offset - line_start;\n\n            let kind;\n            let message;\n            match error_type {\n                // Error types that report names\n                ffi::TSQueryErrorNodeType | ffi::TSQueryErrorField | ffi::TSQueryErrorCapture => {\n                    let suffix = source.split_at(offset).1;\n                    let in_quotes = offset > 0 && source.as_bytes()[offset - 1] == b'\"';\n                    let mut backslashes = 0;\n                    let end_offset = suffix\n                        .find(|c| {\n                            if in_quotes {\n                                if c == '\"' && backslashes % 2 == 0 {\n                                    true\n                                } else if c == '\\\\' {\n                                    backslashes += 1;\n                                    false\n                                } else {\n                                    backslashes = 0;\n                                    false\n                                }\n                            } else {\n                                !char::is_alphanumeric(c) && c != '_' && c != '-'\n                            }\n                        })\n                        .unwrap_or(suffix.len());\n                    message = suffix.split_at(end_offset).0.to_string();\n                    kind = match error_type {\n                        ffi::TSQueryErrorNodeType => QueryErrorKind::NodeType,\n                        ffi::TSQueryErrorField => QueryErrorKind::Field,\n                        ffi::TSQueryErrorCapture => QueryErrorKind::Capture,\n                        _ => unreachable!(),\n                    };\n                }\n\n                // Error types that report positions\n                _ => {\n                    message = line_containing_error.map_or_else(\n                        || \"Unexpected EOF\".to_string(),\n                        |line| line.to_string() + \"\\n\" + &\" \".repeat(offset - line_start) + \"^\",\n                    );\n                    kind = match error_type {\n                        ffi::TSQueryErrorStructure => QueryErrorKind::Structure,\n                        _ => QueryErrorKind::Syntax,\n                    };\n                }\n            }\n\n            return Err(QueryError {\n                row,\n                column,\n                offset,\n                message,\n                kind,\n            });\n        }\n\n        unsafe { Self::from_raw_parts(ptr, source) }\n    }\n\n    #[doc(hidden)]\n    unsafe fn from_raw_parts(ptr: *mut ffi::TSQuery, source: &str) -> Result<Self, QueryError> {\n        let ptr = {\n            struct TSQueryDrop(*mut ffi::TSQuery);\n            impl Drop for TSQueryDrop {\n                fn drop(&mut self) {\n                    unsafe { ffi::ts_query_delete(self.0) }\n                }\n            }\n            TSQueryDrop(ptr)\n        };\n\n        let string_count = unsafe { ffi::ts_query_string_count(ptr.0) };\n        let capture_count = unsafe { ffi::ts_query_capture_count(ptr.0) };\n        let pattern_count = unsafe { ffi::ts_query_pattern_count(ptr.0) as usize };\n\n        let mut capture_names = Vec::with_capacity(capture_count as usize);\n        let mut capture_quantifiers_vec = Vec::with_capacity(pattern_count as usize);\n        let mut text_predicates_vec = Vec::with_capacity(pattern_count);\n        let mut property_predicates_vec = Vec::with_capacity(pattern_count);\n        let mut property_settings_vec = Vec::with_capacity(pattern_count);\n        let mut general_predicates_vec = Vec::with_capacity(pattern_count);\n\n        // Build a vector of strings to store the capture names.\n        for i in 0..capture_count {\n            unsafe {\n                let mut length = 0u32;\n                let name =\n                    ffi::ts_query_capture_name_for_id(ptr.0, i, core::ptr::addr_of_mut!(length))\n                        .cast::<u8>();\n                let name = slice::from_raw_parts(name, length as usize);\n                let name = str::from_utf8_unchecked(name);\n                capture_names.push(name);\n            }\n        }\n\n        // Build a vector to store capture quantifiers.\n        for i in 0..pattern_count {\n            let mut capture_quantifiers = Vec::with_capacity(capture_count as usize);\n            for j in 0..capture_count {\n                unsafe {\n                    let quantifier = ffi::ts_query_capture_quantifier_for_id(ptr.0, i as u32, j);\n                    capture_quantifiers.push(quantifier.into());\n                }\n            }\n            capture_quantifiers_vec.push(capture_quantifiers.into());\n        }\n\n        // Build a vector of strings to represent literal values used in predicates.\n        let string_values = (0..string_count)\n            .map(|i| unsafe {\n                let mut length = 0u32;\n                let value =\n                    ffi::ts_query_string_value_for_id(ptr.0, i, core::ptr::addr_of_mut!(length))\n                        .cast::<u8>();\n                let value = slice::from_raw_parts(value, length as usize);\n                let value = str::from_utf8_unchecked(value);\n                value\n            })\n            .collect::<Vec<_>>();\n\n        // Build a vector of predicates for each pattern.\n        for i in 0..pattern_count {\n            let predicate_steps = unsafe {\n                let mut length = 0u32;\n                let raw_predicates = ffi::ts_query_predicates_for_pattern(\n                    ptr.0,\n                    i as u32,\n                    core::ptr::addr_of_mut!(length),\n                );\n                (length > 0)\n                    .then(|| slice::from_raw_parts(raw_predicates, length as usize))\n                    .unwrap_or_default()\n            };\n\n            let byte_offset = unsafe { ffi::ts_query_start_byte_for_pattern(ptr.0, i as u32) };\n            let row = source\n                .char_indices()\n                .take_while(|(i, _)| *i < byte_offset as usize)\n                .filter(|(_, c)| *c == '\\n')\n                .count();\n\n            use ffi::TSQueryPredicateStepType as T;\n            const TYPE_DONE: T = ffi::TSQueryPredicateStepTypeDone;\n            const TYPE_CAPTURE: T = ffi::TSQueryPredicateStepTypeCapture;\n            const TYPE_STRING: T = ffi::TSQueryPredicateStepTypeString;\n\n            let mut text_predicates = Vec::new();\n            let mut property_predicates = Vec::new();\n            let mut property_settings = Vec::new();\n            let mut general_predicates = Vec::new();\n            for p in predicate_steps.split(|s| s.type_ == TYPE_DONE) {\n                if p.is_empty() {\n                    continue;\n                }\n\n                if p[0].type_ != TYPE_STRING {\n                    return Err(predicate_error(\n                        row,\n                        format!(\n                            \"Expected predicate to start with a function name. Got @{}.\",\n                            capture_names[p[0].value_id as usize],\n                        ),\n                    ));\n                }\n\n                // Build a predicate for each of the known predicate function names.\n                let operator_name = string_values[p[0].value_id as usize];\n                match operator_name {\n                    \"eq?\" | \"not-eq?\" | \"any-eq?\" | \"any-not-eq?\" => {\n                        if p.len() != 3 {\n                            return Err(predicate_error(\n                                row,\n                                format!(\n                                \"Wrong number of arguments to #eq? predicate. Expected 2, got {}.\",\n                                p.len() - 1\n                            ),\n                            ));\n                        }\n                        if p[1].type_ != TYPE_CAPTURE {\n                            return Err(predicate_error(row, format!(\n                                \"First argument to #eq? predicate must be a capture name. Got literal \\\"{}\\\".\",\n                                string_values[p[1].value_id as usize],\n                            )));\n                        }\n\n                        let is_positive = operator_name == \"eq?\" || operator_name == \"any-eq?\";\n                        let match_all = match operator_name {\n                            \"eq?\" | \"not-eq?\" => true,\n                            \"any-eq?\" | \"any-not-eq?\" => false,\n                            _ => unreachable!(),\n                        };\n                        text_predicates.push(if p[2].type_ == TYPE_CAPTURE {\n                            TextPredicateCapture::EqCapture(\n                                p[1].value_id,\n                                p[2].value_id,\n                                is_positive,\n                                match_all,\n                            )\n                        } else {\n                            TextPredicateCapture::EqString(\n                                p[1].value_id,\n                                string_values[p[2].value_id as usize].to_string().into(),\n                                is_positive,\n                                match_all,\n                            )\n                        });\n                    }\n\n                    \"match?\" | \"not-match?\" | \"any-match?\" | \"any-not-match?\" => {\n                        if p.len() != 3 {\n                            return Err(predicate_error(row, format!(\n                                \"Wrong number of arguments to #match? predicate. Expected 2, got {}.\",\n                                p.len() - 1\n                            )));\n                        }\n                        if p[1].type_ != TYPE_CAPTURE {\n                            return Err(predicate_error(row, format!(\n                                \"First argument to #match? predicate must be a capture name. Got literal \\\"{}\\\".\",\n                                string_values[p[1].value_id as usize],\n                            )));\n                        }\n                        if p[2].type_ == TYPE_CAPTURE {\n                            return Err(predicate_error(row, format!(\n                                \"Second argument to #match? predicate must be a literal. Got capture @{}.\",\n                                capture_names[p[2].value_id as usize],\n                            )));\n                        }\n\n                        let is_positive =\n                            operator_name == \"match?\" || operator_name == \"any-match?\";\n                        let match_all = match operator_name {\n                            \"match?\" | \"not-match?\" => true,\n                            \"any-match?\" | \"any-not-match?\" => false,\n                            _ => unreachable!(),\n                        };\n                        let regex = &string_values[p[2].value_id as usize];\n                        text_predicates.push(TextPredicateCapture::MatchString(\n                            p[1].value_id,\n                            regex::bytes::Regex::new(regex).map_err(|_| {\n                                predicate_error(row, format!(\"Invalid regex '{regex}'\"))\n                            })?,\n                            is_positive,\n                            match_all,\n                        ));\n                    }\n\n                    \"set!\" => property_settings.push(Self::parse_property(\n                        row,\n                        operator_name,\n                        &capture_names,\n                        &string_values,\n                        &p[1..],\n                    )?),\n\n                    \"is?\" | \"is-not?\" => property_predicates.push((\n                        Self::parse_property(\n                            row,\n                            operator_name,\n                            &capture_names,\n                            &string_values,\n                            &p[1..],\n                        )?,\n                        operator_name == \"is?\",\n                    )),\n\n                    \"any-of?\" | \"not-any-of?\" => {\n                        if p.len() < 2 {\n                            return Err(predicate_error(row, format!(\n                                \"Wrong number of arguments to #any-of? predicate. Expected at least 1, got {}.\",\n                                p.len() - 1\n                            )));\n                        }\n                        if p[1].type_ != TYPE_CAPTURE {\n                            return Err(predicate_error(row, format!(\n                                \"First argument to #any-of? predicate must be a capture name. Got literal \\\"{}\\\".\",\n                                string_values[p[1].value_id as usize],\n                            )));\n                        }\n\n                        let is_positive = operator_name == \"any-of?\";\n                        let mut values = Vec::new();\n                        for arg in &p[2..] {\n                            if arg.type_ == TYPE_CAPTURE {\n                                return Err(predicate_error(row, format!(\n                                    \"Arguments to #any-of? predicate must be literals. Got capture @{}.\",\n                                    capture_names[arg.value_id as usize],\n                                )));\n                            }\n                            values.push(string_values[arg.value_id as usize]);\n                        }\n                        text_predicates.push(TextPredicateCapture::AnyString(\n                            p[1].value_id,\n                            values\n                                .iter()\n                                .map(|x| (*x).to_string().into())\n                                .collect::<Vec<_>>()\n                                .into(),\n                            is_positive,\n                        ));\n                    }\n\n                    _ => general_predicates.push(QueryPredicate {\n                        operator: operator_name.to_string().into(),\n                        args: p[1..]\n                            .iter()\n                            .map(|a| {\n                                if a.type_ == TYPE_CAPTURE {\n                                    QueryPredicateArg::Capture(a.value_id)\n                                } else {\n                                    QueryPredicateArg::String(\n                                        string_values[a.value_id as usize].to_string().into(),\n                                    )\n                                }\n                            })\n                            .collect(),\n                    }),\n                }\n            }\n\n            text_predicates_vec.push(text_predicates.into());\n            property_predicates_vec.push(property_predicates.into());\n            property_settings_vec.push(property_settings.into());\n            general_predicates_vec.push(general_predicates.into());\n        }\n\n        let result = Self {\n            ptr: unsafe { NonNull::new_unchecked(ptr.0) },\n            capture_names: capture_names.into(),\n            capture_quantifiers: capture_quantifiers_vec.into(),\n            text_predicates: text_predicates_vec.into(),\n            property_predicates: property_predicates_vec.into(),\n            property_settings: property_settings_vec.into(),\n            general_predicates: general_predicates_vec.into(),\n        };\n\n        core::mem::forget(ptr);\n\n        Ok(result)\n    }\n\n    /// Get the byte offset where the given pattern starts in the query's\n    /// source.\n    #[doc(alias = \"ts_query_start_byte_for_pattern\")]\n    #[must_use]\n    pub fn start_byte_for_pattern(&self, pattern_index: usize) -> usize {\n        assert!(\n            pattern_index < self.text_predicates.len(),\n            \"Pattern index is {pattern_index} but the pattern count is {}\",\n            self.text_predicates.len(),\n        );\n        unsafe {\n            ffi::ts_query_start_byte_for_pattern(self.ptr.as_ptr(), pattern_index as u32) as usize\n        }\n    }\n\n    /// Get the byte offset where the given pattern ends in the query's\n    /// source.\n    #[doc(alias = \"ts_query_end_byte_for_pattern\")]\n    #[must_use]\n    pub fn end_byte_for_pattern(&self, pattern_index: usize) -> usize {\n        assert!(\n            pattern_index < self.text_predicates.len(),\n            \"Pattern index is {pattern_index} but the pattern count is {}\",\n            self.text_predicates.len(),\n        );\n        unsafe {\n            ffi::ts_query_end_byte_for_pattern(self.ptr.as_ptr(), pattern_index as u32) as usize\n        }\n    }\n\n    /// Get the number of patterns in the query.\n    #[doc(alias = \"ts_query_pattern_count\")]\n    #[must_use]\n    pub fn pattern_count(&self) -> usize {\n        unsafe { ffi::ts_query_pattern_count(self.ptr.as_ptr()) as usize }\n    }\n\n    /// Get the names of the captures used in the query.\n    #[must_use]\n    pub const fn capture_names(&self) -> &[&str] {\n        &self.capture_names\n    }\n\n    /// Get the quantifiers of the captures used in the query.\n    #[must_use]\n    pub const fn capture_quantifiers(&self, index: usize) -> &[CaptureQuantifier] {\n        &self.capture_quantifiers[index]\n    }\n\n    /// Get the index for a given capture name.\n    #[must_use]\n    pub fn capture_index_for_name(&self, name: &str) -> Option<u32> {\n        self.capture_names\n            .iter()\n            .position(|n| *n == name)\n            .map(|ix| ix as u32)\n    }\n\n    /// Get the properties that are checked for the given pattern index.\n    ///\n    /// This includes predicates with the operators `is?` and `is-not?`.\n    #[must_use]\n    pub const fn property_predicates(&self, index: usize) -> &[(QueryProperty, bool)] {\n        &self.property_predicates[index]\n    }\n\n    /// Get the properties that are set for the given pattern index.\n    ///\n    /// This includes predicates with the operator `set!`.\n    #[must_use]\n    pub const fn property_settings(&self, index: usize) -> &[QueryProperty] {\n        &self.property_settings[index]\n    }\n\n    /// Get the other user-defined predicates associated with the given index.\n    ///\n    /// This includes predicate with operators other than:\n    /// * `match?`\n    /// * `eq?` and `not-eq?`\n    /// * `is?` and `is-not?`\n    /// * `set!`\n    #[must_use]\n    pub const fn general_predicates(&self, index: usize) -> &[QueryPredicate] {\n        &self.general_predicates[index]\n    }\n\n    /// Disable a certain capture within a query.\n    ///\n    /// This prevents the capture from being returned in matches, and also\n    /// avoids any resource usage associated with recording the capture.\n    #[doc(alias = \"ts_query_disable_capture\")]\n    pub fn disable_capture(&mut self, name: &str) {\n        unsafe {\n            ffi::ts_query_disable_capture(\n                self.ptr.as_ptr(),\n                name.as_bytes().as_ptr().cast::<c_char>(),\n                name.len() as u32,\n            );\n        }\n    }\n\n    /// Disable a certain pattern within a query.\n    ///\n    /// This prevents the pattern from matching, and also avoids any resource\n    /// usage associated with the pattern.\n    #[doc(alias = \"ts_query_disable_pattern\")]\n    pub fn disable_pattern(&mut self, index: usize) {\n        unsafe { ffi::ts_query_disable_pattern(self.ptr.as_ptr(), index as u32) }\n    }\n\n    /// Check if a given pattern within a query has a single root node.\n    #[doc(alias = \"ts_query_is_pattern_rooted\")]\n    #[must_use]\n    pub fn is_pattern_rooted(&self, index: usize) -> bool {\n        unsafe { ffi::ts_query_is_pattern_rooted(self.ptr.as_ptr(), index as u32) }\n    }\n\n    /// Check if a given pattern within a query has a single root node.\n    #[doc(alias = \"ts_query_is_pattern_non_local\")]\n    #[must_use]\n    pub fn is_pattern_non_local(&self, index: usize) -> bool {\n        unsafe { ffi::ts_query_is_pattern_non_local(self.ptr.as_ptr(), index as u32) }\n    }\n\n    /// Check if a given step in a query is 'definite'.\n    ///\n    /// A query step is 'definite' if its parent pattern will be guaranteed to\n    /// match successfully once it reaches the step.\n    #[doc(alias = \"ts_query_is_pattern_guaranteed_at_step\")]\n    #[must_use]\n    pub fn is_pattern_guaranteed_at_step(&self, byte_offset: usize) -> bool {\n        unsafe {\n            ffi::ts_query_is_pattern_guaranteed_at_step(self.ptr.as_ptr(), byte_offset as u32)\n        }\n    }\n\n    fn parse_property(\n        row: usize,\n        function_name: &str,\n        capture_names: &[&str],\n        string_values: &[&str],\n        args: &[ffi::TSQueryPredicateStep],\n    ) -> Result<QueryProperty, QueryError> {\n        if args.is_empty() || args.len() > 3 {\n            return Err(predicate_error(\n                row,\n                format!(\n                    \"Wrong number of arguments to {function_name} predicate. Expected 1 to 3, got {}.\",\n                    args.len(),\n                ),\n            ));\n        }\n\n        let mut capture_id = None;\n        let mut key = None;\n        let mut value = None;\n\n        for arg in args {\n            if arg.type_ == ffi::TSQueryPredicateStepTypeCapture {\n                if capture_id.is_some() {\n                    return Err(predicate_error(\n                        row,\n                        format!(\n                            \"Invalid arguments to {function_name} predicate. Unexpected second capture name @{}\",\n                            capture_names[arg.value_id as usize]\n                        ),\n                    ));\n                }\n                capture_id = Some(arg.value_id as usize);\n            } else if key.is_none() {\n                key = Some(&string_values[arg.value_id as usize]);\n            } else if value.is_none() {\n                value = Some(string_values[arg.value_id as usize]);\n            } else {\n                return Err(predicate_error(\n                    row,\n                    format!(\n                        \"Invalid arguments to {function_name} predicate. Unexpected third argument @{}\",\n                        string_values[arg.value_id as usize]\n                    ),\n                ));\n            }\n        }\n\n        if let Some(key) = key {\n            Ok(QueryProperty::new(key, value, capture_id))\n        } else {\n            Err(predicate_error(\n                row,\n                format!(\"Invalid arguments to {function_name} predicate. Missing key argument\",),\n            ))\n        }\n    }\n}\n\nimpl Default for QueryCursor {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl QueryCursor {\n    /// Create a new cursor for executing a given query.\n    ///\n    /// The cursor stores the state that is needed to iteratively search for\n    /// matches.\n    #[doc(alias = \"ts_query_cursor_new\")]\n    #[must_use]\n    pub fn new() -> Self {\n        Self {\n            ptr: unsafe { NonNull::new_unchecked(ffi::ts_query_cursor_new()) },\n        }\n    }\n\n    /// Return the maximum number of in-progress matches for this cursor.\n    #[doc(alias = \"ts_query_cursor_match_limit\")]\n    #[must_use]\n    pub fn match_limit(&self) -> u32 {\n        unsafe { ffi::ts_query_cursor_match_limit(self.ptr.as_ptr()) }\n    }\n\n    /// Set the maximum number of in-progress matches for this cursor.  The\n    /// limit must be > 0 and <= 65536.\n    #[doc(alias = \"ts_query_cursor_set_match_limit\")]\n    pub fn set_match_limit(&mut self, limit: u32) {\n        unsafe {\n            ffi::ts_query_cursor_set_match_limit(self.ptr.as_ptr(), limit);\n        }\n    }\n\n    /// Set the maximum duration in microseconds that query execution should be allowed to\n    /// take before halting.\n    ///\n    /// If query execution takes longer than this, it will halt early, returning None.\n    #[doc(alias = \"ts_query_cursor_set_timeout_micros\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `matches_with_options` or `captures_with_options` and using a callback\"\n    )]\n    pub fn set_timeout_micros(&mut self, timeout: u64) {\n        unsafe {\n            ffi::ts_query_cursor_set_timeout_micros(self.ptr.as_ptr(), timeout);\n        }\n    }\n\n    /// Get the duration in microseconds that query execution is allowed to take.\n    ///\n    /// This is set via [`set_timeout_micros`](QueryCursor::set_timeout_micros).\n    #[doc(alias = \"ts_query_cursor_timeout_micros\")]\n    #[deprecated(\n        since = \"0.25.0\",\n        note = \"Prefer using `matches_with_options` or `captures_with_options` and using a callback\"\n    )]\n    #[must_use]\n    pub fn timeout_micros(&self) -> u64 {\n        unsafe { ffi::ts_query_cursor_timeout_micros(self.ptr.as_ptr()) }\n    }\n\n    /// Check if, on its last execution, this cursor exceeded its maximum number\n    /// of in-progress matches.\n    #[doc(alias = \"ts_query_cursor_did_exceed_match_limit\")]\n    #[must_use]\n    pub fn did_exceed_match_limit(&self) -> bool {\n        unsafe { ffi::ts_query_cursor_did_exceed_match_limit(self.ptr.as_ptr()) }\n    }\n\n    /// Iterate over all of the matches in the order that they were found.\n    ///\n    /// Each match contains the index of the pattern that matched, and a list of\n    /// captures. Because multiple patterns can match the same set of nodes,\n    /// one match may contain captures that appear *before* some of the\n    /// captures from a previous match.\n    ///\n    /// Iterating over a `QueryMatches` object requires the `StreamingIterator`\n    /// or `StreamingIteratorMut` trait to be in scope. This can be done via\n    /// `use tree_sitter::StreamingIterator` or `use tree_sitter::StreamingIteratorMut`\n    #[doc(alias = \"ts_query_cursor_exec\")]\n    pub fn matches<'query, 'cursor: 'query, 'tree, T: TextProvider<I>, I: AsRef<[u8]>>(\n        &'cursor mut self,\n        query: &'query Query,\n        node: Node<'tree>,\n        text_provider: T,\n    ) -> QueryMatches<'query, 'tree, T, I> {\n        let ptr = self.ptr.as_ptr();\n        unsafe { ffi::ts_query_cursor_exec(ptr, query.ptr.as_ptr(), node.0) };\n        QueryMatches {\n            ptr,\n            query,\n            text_provider,\n            buffer1: Vec::default(),\n            buffer2: Vec::default(),\n            current_match: None,\n            _options: None,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Iterate over all of the matches in the order that they were found, with options.\n    ///\n    /// Each match contains the index of the pattern that matched, and a list of\n    /// captures. Because multiple patterns can match the same set of nodes,\n    /// one match may contain captures that appear *before* some of the\n    /// captures from a previous match.\n    #[doc(alias = \"ts_query_cursor_exec_with_options\")]\n    pub fn matches_with_options<\n        'query,\n        'cursor: 'query,\n        'tree,\n        T: TextProvider<I>,\n        I: AsRef<[u8]>,\n    >(\n        &'cursor mut self,\n        query: &'query Query,\n        node: Node<'tree>,\n        text_provider: T,\n        options: QueryCursorOptions,\n    ) -> QueryMatches<'query, 'tree, T, I> {\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSQueryCursorState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<QueryProgressCallback>()\n                .as_mut()\n                .unwrap();\n            (callback)(&QueryCursorState::from_raw(state))\n        }\n\n        let query_options = options.progress_callback.map(|cb| {\n            QueryCursorOptionsDrop(Box::into_raw(Box::new(ffi::TSQueryCursorOptions {\n                payload: Box::into_raw(Box::new(cb)).cast::<c_void>(),\n                progress_callback: Some(progress),\n            })))\n        });\n\n        let ptr = self.ptr.as_ptr();\n        unsafe {\n            ffi::ts_query_cursor_exec_with_options(\n                ptr,\n                query.ptr.as_ptr(),\n                node.0,\n                query_options.as_ref().map_or(ptr::null_mut(), |q| q.0),\n            );\n        }\n        QueryMatches {\n            ptr,\n            query,\n            text_provider,\n            buffer1: Vec::default(),\n            buffer2: Vec::default(),\n            current_match: None,\n            _options: query_options,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Iterate over all of the individual captures in the order that they\n    /// appear.\n    ///\n    /// This is useful if you don't care about which pattern matched, and just\n    /// want a single, ordered sequence of captures.\n    ///\n    /// Iterating over a `QueryCaptures` object requires the `StreamingIterator`\n    /// or `StreamingIteratorMut` trait to be in scope. This can be done via\n    /// `use tree_sitter::StreamingIterator` or `use tree_sitter::StreamingIteratorMut`\n    #[doc(alias = \"ts_query_cursor_exec\")]\n    pub fn captures<'query, 'cursor: 'query, 'tree, T: TextProvider<I>, I: AsRef<[u8]>>(\n        &'cursor mut self,\n        query: &'query Query,\n        node: Node<'tree>,\n        text_provider: T,\n    ) -> QueryCaptures<'query, 'tree, T, I> {\n        let ptr = self.ptr.as_ptr();\n        unsafe { ffi::ts_query_cursor_exec(ptr, query.ptr.as_ptr(), node.0) };\n        QueryCaptures {\n            ptr,\n            query,\n            text_provider,\n            buffer1: Vec::default(),\n            buffer2: Vec::default(),\n            current_match: None,\n            _options: None,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Iterate over all of the individual captures in the order that they\n    /// appear, with options.\n    ///\n    /// This is useful if you don't care about which pattern matched, and just\n    /// want a single, ordered sequence of captures.\n    #[doc(alias = \"ts_query_cursor_exec\")]\n    pub fn captures_with_options<\n        'query,\n        'cursor: 'query,\n        'tree,\n        T: TextProvider<I>,\n        I: AsRef<[u8]>,\n    >(\n        &'cursor mut self,\n        query: &'query Query,\n        node: Node<'tree>,\n        text_provider: T,\n        options: QueryCursorOptions,\n    ) -> QueryCaptures<'query, 'tree, T, I> {\n        unsafe extern \"C\" fn progress(state: *mut ffi::TSQueryCursorState) -> bool {\n            let callback = (*state)\n                .payload\n                .cast::<QueryProgressCallback>()\n                .as_mut()\n                .unwrap();\n            (callback)(&QueryCursorState::from_raw(state))\n        }\n\n        let query_options = options.progress_callback.map(|cb| {\n            QueryCursorOptionsDrop(Box::into_raw(Box::new(ffi::TSQueryCursorOptions {\n                payload: Box::into_raw(Box::new(cb)).cast::<c_void>(),\n                progress_callback: Some(progress),\n            })))\n        });\n\n        let ptr = self.ptr.as_ptr();\n        unsafe {\n            ffi::ts_query_cursor_exec_with_options(\n                ptr,\n                query.ptr.as_ptr(),\n                node.0,\n                query_options.as_ref().map_or(ptr::null_mut(), |q| q.0),\n            );\n        }\n        QueryCaptures {\n            ptr,\n            query,\n            text_provider,\n            buffer1: Vec::default(),\n            buffer2: Vec::default(),\n            current_match: None,\n            _options: query_options,\n            _phantom: PhantomData,\n        }\n    }\n\n    /// Set the range in which the query will be executed, in terms of byte\n    /// offsets.\n    #[doc(alias = \"ts_query_cursor_set_byte_range\")]\n    pub fn set_byte_range(&mut self, range: ops::Range<usize>) -> &mut Self {\n        unsafe {\n            ffi::ts_query_cursor_set_byte_range(\n                self.ptr.as_ptr(),\n                range.start as u32,\n                range.end as u32,\n            );\n        }\n        self\n    }\n\n    /// Set the range in which the query will be executed, in terms of rows and\n    /// columns.\n    #[doc(alias = \"ts_query_cursor_set_point_range\")]\n    pub fn set_point_range(&mut self, range: ops::Range<Point>) -> &mut Self {\n        unsafe {\n            ffi::ts_query_cursor_set_point_range(\n                self.ptr.as_ptr(),\n                range.start.into(),\n                range.end.into(),\n            );\n        }\n        self\n    }\n\n    /// Set the maximum start depth for a query cursor.\n    ///\n    /// This prevents cursors from exploring children nodes at a certain depth.\n    /// Note if a pattern includes many children, then they will still be\n    /// checked.\n    ///\n    /// The zero max start depth value can be used as a special behavior and\n    /// it helps to destructure a subtree by staying on a node and using\n    /// captures for interested parts. Note that the zero max start depth\n    /// only limit a search depth for a pattern's root node but other nodes\n    /// that are parts of the pattern may be searched at any depth what\n    /// defined by the pattern structure.\n    ///\n    /// Set to `None` to remove the maximum start depth.\n    #[doc(alias = \"ts_query_cursor_set_max_start_depth\")]\n    pub fn set_max_start_depth(&mut self, max_start_depth: Option<u32>) -> &mut Self {\n        unsafe {\n            ffi::ts_query_cursor_set_max_start_depth(\n                self.ptr.as_ptr(),\n                max_start_depth.unwrap_or(u32::MAX),\n            );\n        }\n        self\n    }\n}\n\nimpl<'tree> QueryMatch<'_, 'tree> {\n    #[must_use]\n    pub const fn id(&self) -> u32 {\n        self.id\n    }\n\n    #[doc(alias = \"ts_query_cursor_remove_match\")]\n    pub fn remove(&self) {\n        unsafe { ffi::ts_query_cursor_remove_match(self.cursor, self.id) }\n    }\n\n    pub fn nodes_for_capture_index(\n        &self,\n        capture_ix: u32,\n    ) -> impl Iterator<Item = Node<'tree>> + '_ {\n        self.captures\n            .iter()\n            .filter_map(move |capture| (capture.index == capture_ix).then_some(capture.node))\n    }\n\n    fn new(m: &ffi::TSQueryMatch, cursor: *mut ffi::TSQueryCursor) -> Self {\n        QueryMatch {\n            cursor,\n            id: m.id,\n            pattern_index: m.pattern_index as usize,\n            captures: (m.capture_count > 0)\n                .then(|| unsafe {\n                    slice::from_raw_parts(\n                        m.captures.cast::<QueryCapture<'tree>>(),\n                        m.capture_count as usize,\n                    )\n                })\n                .unwrap_or_default(),\n        }\n    }\n\n    pub fn satisfies_text_predicates<I: AsRef<[u8]>>(\n        &self,\n        query: &Query,\n        buffer1: &mut Vec<u8>,\n        buffer2: &mut Vec<u8>,\n        text_provider: &mut impl TextProvider<I>,\n    ) -> bool {\n        struct NodeText<'a, T> {\n            buffer: &'a mut Vec<u8>,\n            first_chunk: Option<T>,\n        }\n        impl<'a, T: AsRef<[u8]>> NodeText<'a, T> {\n            fn new(buffer: &'a mut Vec<u8>) -> Self {\n                Self {\n                    buffer,\n                    first_chunk: None,\n                }\n            }\n\n            fn get_text(&mut self, chunks: &mut impl Iterator<Item = T>) -> &[u8] {\n                self.first_chunk = chunks.next();\n                if let Some(next_chunk) = chunks.next() {\n                    self.buffer.clear();\n                    self.buffer\n                        .extend_from_slice(self.first_chunk.as_ref().unwrap().as_ref());\n                    self.buffer.extend_from_slice(next_chunk.as_ref());\n                    for chunk in chunks {\n                        self.buffer.extend_from_slice(chunk.as_ref());\n                    }\n                    self.buffer.as_slice()\n                } else if let Some(ref first_chunk) = self.first_chunk {\n                    first_chunk.as_ref()\n                } else {\n                    &[]\n                }\n            }\n        }\n\n        let mut node_text1 = NodeText::new(buffer1);\n        let mut node_text2 = NodeText::new(buffer2);\n\n        query.text_predicates[self.pattern_index]\n            .iter()\n            .all(|predicate| match predicate {\n                TextPredicateCapture::EqCapture(i, j, is_positive, match_all_nodes) => {\n                    let mut nodes_1 = self.nodes_for_capture_index(*i).peekable();\n                    let mut nodes_2 = self.nodes_for_capture_index(*j).peekable();\n                    while nodes_1.peek().is_some() && nodes_2.peek().is_some() {\n                        let node1 = nodes_1.next().unwrap();\n                        let node2 = nodes_2.next().unwrap();\n                        let mut text1 = text_provider.text(node1);\n                        let mut text2 = text_provider.text(node2);\n                        let text1 = node_text1.get_text(&mut text1);\n                        let text2 = node_text2.get_text(&mut text2);\n                        let is_positive_match = text1 == text2;\n                        if is_positive_match != *is_positive && *match_all_nodes {\n                            return false;\n                        }\n                        if is_positive_match == *is_positive && !*match_all_nodes {\n                            return true;\n                        }\n                    }\n                    nodes_1.next().is_none() && nodes_2.next().is_none()\n                }\n                TextPredicateCapture::EqString(i, s, is_positive, match_all_nodes) => {\n                    let nodes = self.nodes_for_capture_index(*i);\n                    for node in nodes {\n                        let mut text = text_provider.text(node);\n                        let text = node_text1.get_text(&mut text);\n                        let is_positive_match = text == s.as_bytes();\n                        if is_positive_match != *is_positive && *match_all_nodes {\n                            return false;\n                        }\n                        if is_positive_match == *is_positive && !*match_all_nodes {\n                            return true;\n                        }\n                    }\n                    true\n                }\n                TextPredicateCapture::MatchString(i, r, is_positive, match_all_nodes) => {\n                    let nodes = self.nodes_for_capture_index(*i);\n                    for node in nodes {\n                        let mut text = text_provider.text(node);\n                        let text = node_text1.get_text(&mut text);\n                        let is_positive_match = r.is_match(text);\n                        if is_positive_match != *is_positive && *match_all_nodes {\n                            return false;\n                        }\n                        if is_positive_match == *is_positive && !*match_all_nodes {\n                            return true;\n                        }\n                    }\n                    true\n                }\n                TextPredicateCapture::AnyString(i, v, is_positive) => {\n                    let nodes = self.nodes_for_capture_index(*i);\n                    for node in nodes {\n                        let mut text = text_provider.text(node);\n                        let text = node_text1.get_text(&mut text);\n                        if (v.iter().any(|s| text == s.as_bytes())) != *is_positive {\n                            return false;\n                        }\n                    }\n                    true\n                }\n            })\n    }\n}\n\nimpl QueryProperty {\n    #[must_use]\n    pub fn new(key: &str, value: Option<&str>, capture_id: Option<usize>) -> Self {\n        Self {\n            capture_id,\n            key: key.to_string().into(),\n            value: value.map(|s| s.to_string().into()),\n        }\n    }\n}\n\n/// Provide a `StreamingIterator` instead of the traditional `Iterator`, as the\n/// underlying object in the C library gets updated on each iteration. Copies would\n/// have their internal state overwritten, leading to Undefined Behavior\nimpl<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> StreamingIterator\n    for QueryMatches<'query, 'tree, T, I>\n{\n    type Item = QueryMatch<'query, 'tree>;\n\n    fn advance(&mut self) {\n        self.current_match = unsafe {\n            loop {\n                let mut m = MaybeUninit::<ffi::TSQueryMatch>::uninit();\n                if ffi::ts_query_cursor_next_match(self.ptr, m.as_mut_ptr()) {\n                    let result = QueryMatch::new(&m.assume_init(), self.ptr);\n                    if result.satisfies_text_predicates(\n                        self.query,\n                        &mut self.buffer1,\n                        &mut self.buffer2,\n                        &mut self.text_provider,\n                    ) {\n                        break Some(result);\n                    }\n                } else {\n                    break None;\n                }\n            }\n        };\n    }\n\n    fn get(&self) -> Option<&Self::Item> {\n        self.current_match.as_ref()\n    }\n}\n\nimpl<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> StreamingIteratorMut\n    for QueryMatches<'query, 'tree, T, I>\n{\n    fn get_mut(&mut self) -> Option<&mut Self::Item> {\n        self.current_match.as_mut()\n    }\n}\n\nimpl<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> StreamingIterator\n    for QueryCaptures<'query, 'tree, T, I>\n{\n    type Item = (QueryMatch<'query, 'tree>, usize);\n\n    fn advance(&mut self) {\n        self.current_match = unsafe {\n            loop {\n                let mut capture_index = 0u32;\n                let mut m = MaybeUninit::<ffi::TSQueryMatch>::uninit();\n                if ffi::ts_query_cursor_next_capture(\n                    self.ptr,\n                    m.as_mut_ptr(),\n                    core::ptr::addr_of_mut!(capture_index),\n                ) {\n                    let result = QueryMatch::new(&m.assume_init(), self.ptr);\n                    if result.satisfies_text_predicates(\n                        self.query,\n                        &mut self.buffer1,\n                        &mut self.buffer2,\n                        &mut self.text_provider,\n                    ) {\n                        break Some((result, capture_index as usize));\n                    }\n                    result.remove();\n                } else {\n                    break None;\n                }\n            }\n        }\n    }\n\n    fn get(&self) -> Option<&Self::Item> {\n        self.current_match.as_ref()\n    }\n}\n\nimpl<'query, 'tree: 'query, T: TextProvider<I>, I: AsRef<[u8]>> StreamingIteratorMut\n    for QueryCaptures<'query, 'tree, T, I>\n{\n    fn get_mut(&mut self) -> Option<&mut Self::Item> {\n        self.current_match.as_mut()\n    }\n}\n\nimpl<T: TextProvider<I>, I: AsRef<[u8]>> QueryMatches<'_, '_, T, I> {\n    #[doc(alias = \"ts_query_cursor_set_byte_range\")]\n    pub fn set_byte_range(&mut self, range: ops::Range<usize>) {\n        unsafe {\n            ffi::ts_query_cursor_set_byte_range(self.ptr, range.start as u32, range.end as u32);\n        }\n    }\n\n    #[doc(alias = \"ts_query_cursor_set_point_range\")]\n    pub fn set_point_range(&mut self, range: ops::Range<Point>) {\n        unsafe {\n            ffi::ts_query_cursor_set_point_range(self.ptr, range.start.into(), range.end.into());\n        }\n    }\n}\n\nimpl<T: TextProvider<I>, I: AsRef<[u8]>> QueryCaptures<'_, '_, T, I> {\n    #[doc(alias = \"ts_query_cursor_set_byte_range\")]\n    pub fn set_byte_range(&mut self, range: ops::Range<usize>) {\n        unsafe {\n            ffi::ts_query_cursor_set_byte_range(self.ptr, range.start as u32, range.end as u32);\n        }\n    }\n\n    #[doc(alias = \"ts_query_cursor_set_point_range\")]\n    pub fn set_point_range(&mut self, range: ops::Range<Point>) {\n        unsafe {\n            ffi::ts_query_cursor_set_point_range(self.ptr, range.start.into(), range.end.into());\n        }\n    }\n}\n\nimpl fmt::Debug for QueryMatch<'_, '_> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"QueryMatch {{ id: {}, pattern_index: {}, captures: {:?} }}\",\n            self.id, self.pattern_index, self.captures\n        )\n    }\n}\n\nimpl<F, R, I> TextProvider<I> for F\nwhere\n    F: FnMut(Node) -> R,\n    R: Iterator<Item = I>,\n    I: AsRef<[u8]>,\n{\n    type I = R;\n\n    fn text(&mut self, node: Node) -> Self::I {\n        (self)(node)\n    }\n}\n\nimpl<'a> TextProvider<&'a [u8]> for &'a [u8] {\n    type I = iter::Once<&'a [u8]>;\n\n    fn text(&mut self, node: Node) -> Self::I {\n        iter::once(&self[node.byte_range()])\n    }\n}\n\nimpl PartialEq for Query {\n    fn eq(&self, other: &Self) -> bool {\n        self.ptr == other.ptr\n    }\n}\n\nimpl Drop for Query {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_query_delete(self.ptr.as_ptr()) }\n    }\n}\n\nimpl Drop for QueryCursor {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_query_cursor_delete(self.ptr.as_ptr()) }\n    }\n}\n\nimpl Point {\n    #[must_use]\n    pub const fn new(row: usize, column: usize) -> Self {\n        Self { row, column }\n    }\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\", self.row, self.column)\n    }\n}\n\nimpl From<Point> for ffi::TSPoint {\n    fn from(val: Point) -> Self {\n        Self {\n            row: val.row as u32,\n            column: val.column as u32,\n        }\n    }\n}\n\nimpl From<ffi::TSPoint> for Point {\n    fn from(point: ffi::TSPoint) -> Self {\n        Self {\n            row: point.row as usize,\n            column: point.column as usize,\n        }\n    }\n}\n\nimpl From<Range> for ffi::TSRange {\n    fn from(val: Range) -> Self {\n        Self {\n            start_byte: val.start_byte as u32,\n            end_byte: val.end_byte as u32,\n            start_point: val.start_point.into(),\n            end_point: val.end_point.into(),\n        }\n    }\n}\n\nimpl From<ffi::TSRange> for Range {\n    fn from(range: ffi::TSRange) -> Self {\n        Self {\n            start_byte: range.start_byte as usize,\n            end_byte: range.end_byte as usize,\n            start_point: range.start_point.into(),\n            end_point: range.end_point.into(),\n        }\n    }\n}\n\nimpl From<&'_ InputEdit> for ffi::TSInputEdit {\n    fn from(val: &'_ InputEdit) -> Self {\n        Self {\n            start_byte: val.start_byte as u32,\n            old_end_byte: val.old_end_byte as u32,\n            new_end_byte: val.new_end_byte as u32,\n            start_point: val.start_position.into(),\n            old_end_point: val.old_end_position.into(),\n            new_end_point: val.new_end_position.into(),\n        }\n    }\n}\n\nimpl<'a> LossyUtf8<'a> {\n    #[must_use]\n    pub const fn new(bytes: &'a [u8]) -> Self {\n        LossyUtf8 {\n            bytes,\n            in_replacement: false,\n        }\n    }\n}\n\nimpl<'a> Iterator for LossyUtf8<'a> {\n    type Item = &'a str;\n\n    fn next(&mut self) -> Option<&'a str> {\n        if self.bytes.is_empty() {\n            return None;\n        }\n        if self.in_replacement {\n            self.in_replacement = false;\n            return Some(\"\\u{fffd}\");\n        }\n        match core::str::from_utf8(self.bytes) {\n            Ok(valid) => {\n                self.bytes = &[];\n                Some(valid)\n            }\n            Err(error) => {\n                if let Some(error_len) = error.error_len() {\n                    let error_start = error.valid_up_to();\n                    if error_start > 0 {\n                        let result =\n                            unsafe { core::str::from_utf8_unchecked(&self.bytes[..error_start]) };\n                        self.bytes = &self.bytes[(error_start + error_len)..];\n                        self.in_replacement = true;\n                        Some(result)\n                    } else {\n                        self.bytes = &self.bytes[error_len..];\n                        Some(\"\\u{fffd}\")\n                    }\n                } else {\n                    None\n                }\n            }\n        }\n    }\n}\n\n#[must_use]\nconst fn predicate_error(row: usize, message: String) -> QueryError {\n    QueryError {\n        kind: QueryErrorKind::Predicate,\n        row,\n        column: 0,\n        offset: 0,\n        message,\n    }\n}\n\nimpl fmt::Display for IncludedRangesError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Incorrect range by index: {}\", self.0)\n    }\n}\n\nimpl fmt::Display for LanguageError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(\n            f,\n            \"Incompatible language version {}. Expected minimum {}, maximum {}\",\n            self.version, MIN_COMPATIBLE_LANGUAGE_VERSION, LANGUAGE_VERSION,\n        )\n    }\n}\n\nimpl fmt::Display for QueryError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let msg = match self.kind {\n            QueryErrorKind::Field => \"Invalid field name \",\n            QueryErrorKind::NodeType => \"Invalid node type \",\n            QueryErrorKind::Capture => \"Invalid capture name \",\n            QueryErrorKind::Predicate => \"Invalid predicate: \",\n            QueryErrorKind::Structure => \"Impossible pattern:\\n\",\n            QueryErrorKind::Syntax => \"Invalid syntax:\\n\",\n            QueryErrorKind::Language => \"\",\n        };\n        if msg.is_empty() {\n            write!(f, \"{}\", self.message)\n        } else {\n            write!(\n                f,\n                \"Query error at {}:{}. {}{}\",\n                self.row + 1,\n                self.column + 1,\n                msg,\n                self.message\n            )\n        }\n    }\n}\n\n#[doc(hidden)]\n#[must_use]\npub fn format_sexp(sexp: &str, initial_indent_level: usize) -> String {\n    let mut indent_level = initial_indent_level;\n    let mut formatted = String::new();\n    let mut has_field = false;\n\n    let mut c_iter = sexp.chars().peekable();\n    let mut s = String::with_capacity(sexp.len());\n    let mut quote = '\\0';\n    let mut saw_paren = false;\n    let mut did_last = false;\n\n    let mut fetch_next_str = |next: &mut String| {\n        next.clear();\n        while let Some(c) = c_iter.next() {\n            if c == '\\'' || c == '\"' {\n                quote = c;\n            } else if c == ' ' || (c == ')' && quote != '\\0') {\n                if let Some(next_c) = c_iter.peek() {\n                    if *next_c == quote {\n                        next.push(c);\n                        next.push(*next_c);\n                        c_iter.next();\n                        quote = '\\0';\n                        continue;\n                    }\n                }\n                break;\n            }\n            if c == ')' {\n                saw_paren = true;\n                break;\n            }\n            next.push(c);\n        }\n\n        // at the end\n        if c_iter.peek().is_none() && next.is_empty() {\n            if saw_paren {\n                // but did we see a ) before ending?\n                saw_paren = false;\n                return Some(());\n            }\n            if !did_last {\n                // but did we account for the end empty string as if we're splitting?\n                did_last = true;\n                return Some(());\n            }\n            return None;\n        }\n        Some(())\n    };\n\n    while fetch_next_str(&mut s).is_some() {\n        if s.is_empty() && indent_level > 0 {\n            // \")\"\n            indent_level -= 1;\n            write!(formatted, \")\").unwrap();\n        } else if s.starts_with('(') {\n            if has_field {\n                has_field = false;\n            } else {\n                if indent_level > 0 {\n                    writeln!(formatted).unwrap();\n                    for _ in 0..indent_level {\n                        write!(formatted, \"  \").unwrap();\n                    }\n                }\n                indent_level += 1;\n            }\n\n            // \"(node_name\"\n            write!(formatted, \"{s}\").unwrap();\n\n            // \"(MISSING node_name\" or \"(UNEXPECTED 'x'\"\n            if s.starts_with(\"(MISSING\") || s.starts_with(\"(UNEXPECTED\") {\n                fetch_next_str(&mut s).unwrap();\n                if s.is_empty() {\n                    while indent_level > 0 {\n                        indent_level -= 1;\n                        write!(formatted, \")\").unwrap();\n                    }\n                } else {\n                    write!(formatted, \" {s}\").unwrap();\n                }\n            }\n        } else if s.ends_with(':') {\n            // \"field:\"\n            writeln!(formatted).unwrap();\n            for _ in 0..indent_level {\n                write!(formatted, \"  \").unwrap();\n            }\n            write!(formatted, \"{s} \").unwrap();\n            has_field = true;\n            indent_level += 1;\n        }\n    }\n\n    formatted\n}\n\npub fn wasm_stdlib_symbols() -> impl Iterator<Item = &'static str> {\n    const WASM_STDLIB_SYMBOLS: &str = include_str!(concat!(env!(\"OUT_DIR\"), \"/stdlib-symbols.txt\"));\n\n    WASM_STDLIB_SYMBOLS\n        .lines()\n        .map(|s| s.trim_matches(|c| c == '\"' || c == ','))\n}\n\nextern \"C\" {\n    fn free(ptr: *mut c_void);\n}\n\nstatic mut FREE_FN: unsafe extern \"C\" fn(ptr: *mut c_void) = free;\n\n/// Sets the memory allocation functions that the core library should use.\n///\n/// # Safety\n///\n/// This function uses FFI and mutates a static global.\n#[doc(alias = \"ts_set_allocator\")]\npub unsafe fn set_allocator(\n    new_malloc: Option<unsafe extern \"C\" fn(size: usize) -> *mut c_void>,\n    new_calloc: Option<unsafe extern \"C\" fn(nmemb: usize, size: usize) -> *mut c_void>,\n    new_realloc: Option<unsafe extern \"C\" fn(ptr: *mut c_void, size: usize) -> *mut c_void>,\n    new_free: Option<unsafe extern \"C\" fn(ptr: *mut c_void)>,\n) {\n    FREE_FN = new_free.unwrap_or(free);\n    ffi::ts_set_allocator(new_malloc, new_calloc, new_realloc, new_free);\n}\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl error::Error for IncludedRangesError {}\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl error::Error for LanguageError {}\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl error::Error for QueryError {}\n\nunsafe impl Send for Language {}\nunsafe impl Sync for Language {}\n\nunsafe impl Send for Node<'_> {}\nunsafe impl Sync for Node<'_> {}\n\nunsafe impl Send for LookaheadIterator {}\nunsafe impl Sync for LookaheadIterator {}\n\nunsafe impl Send for LookaheadNamesIterator<'_> {}\nunsafe impl Sync for LookaheadNamesIterator<'_> {}\n\nunsafe impl Send for Parser {}\nunsafe impl Sync for Parser {}\n\nunsafe impl Send for Query {}\nunsafe impl Sync for Query {}\n\nunsafe impl Send for QueryCursor {}\nunsafe impl Sync for QueryCursor {}\n\nunsafe impl Send for Tree {}\nunsafe impl Sync for Tree {}\n\nunsafe impl Send for TreeCursor<'_> {}\nunsafe impl Sync for TreeCursor<'_> {}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use core::ffi::c_void;\n\nuse super::FREE_FN;\n\n/// A raw pointer and a length, exposed as an iterator.\npub struct CBufferIter<T> {\n    ptr: *mut T,\n    count: usize,\n    i: usize,\n}\n\nimpl<T> CBufferIter<T> {\n    pub const unsafe fn new(ptr: *mut T, count: usize) -> Self {\n        Self { ptr, count, i: 0 }\n    }\n}\n\nimpl<T: Copy> Iterator for CBufferIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let i = self.i;\n        if i >= self.count {\n            None\n        } else {\n            self.i += 1;\n            Some(unsafe { *self.ptr.add(i) })\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let remaining = self.count - self.i;\n        (remaining, Some(remaining))\n    }\n}\n\nimpl<T: Copy> ExactSizeIterator for CBufferIter<T> {}\n\nimpl<T> Drop for CBufferIter<T> {\n    fn drop(&mut self) {\n        if !self.ptr.is_null() {\n            unsafe { (FREE_FN)(self.ptr.cast::<c_void>()) };\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{\n    error,\n    ffi::{CStr, CString},\n    fmt,\n    mem::{self, MaybeUninit},\n    os::raw::c_char,\n};\n\npub use wasmtime_c_api::wasmtime;\n\nuse crate::{ffi, Language, LanguageError, Parser, FREE_FN};\n\n// Force Cargo to include wasmtime-c-api as a dependency of this crate,\n// even though it is only used by the C code.\n#[allow(unused)]\nfn _use_wasmtime() {\n    wasmtime_c_api::wasm_engine_new();\n}\n\n#[repr(C)]\n#[derive(Clone)]\n#[allow(non_camel_case_types)]\npub struct wasm_engine_t {\n    pub(crate) engine: wasmtime::Engine,\n}\n\npub struct WasmStore(*mut ffi::TSWasmStore);\n\nunsafe impl Send for WasmStore {}\nunsafe impl Sync for WasmStore {}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct WasmError {\n    pub kind: WasmErrorKind,\n    pub message: String,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum WasmErrorKind {\n    Parse,\n    Compile,\n    Instantiate,\n    Other,\n}\n\nimpl WasmStore {\n    pub fn new(engine: &wasmtime::Engine) -> Result<Self, WasmError> {\n        unsafe {\n            let mut error = MaybeUninit::<ffi::TSWasmError>::uninit();\n            let store = ffi::ts_wasm_store_new(\n                std::ptr::from_ref::<wasmtime::Engine>(engine)\n                    .cast_mut()\n                    .cast(),\n                error.as_mut_ptr(),\n            );\n            if store.is_null() {\n                Err(WasmError::new(error.assume_init()))\n            } else {\n                Ok(Self(store))\n            }\n        }\n    }\n\n    pub fn load_language(&mut self, name: &str, bytes: &[u8]) -> Result<Language, WasmError> {\n        let name = CString::new(name).unwrap();\n        unsafe {\n            let mut error = MaybeUninit::<ffi::TSWasmError>::uninit();\n            let language = ffi::ts_wasm_store_load_language(\n                self.0,\n                name.as_ptr(),\n                bytes.as_ptr().cast::<c_char>(),\n                bytes.len() as u32,\n                error.as_mut_ptr(),\n            );\n            if language.is_null() {\n                Err(WasmError::new(error.assume_init()))\n            } else {\n                Ok(Language(language))\n            }\n        }\n    }\n\n    #[must_use]\n    pub fn language_count(&self) -> usize {\n        unsafe { ffi::ts_wasm_store_language_count(self.0) }\n    }\n}\n\nimpl WasmError {\n    unsafe fn new(error: ffi::TSWasmError) -> Self {\n        let message = CStr::from_ptr(error.message).to_str().unwrap().to_string();\n        (FREE_FN)(error.message.cast());\n        Self {\n            kind: match error.kind {\n                ffi::TSWasmErrorKindParse => WasmErrorKind::Parse,\n                ffi::TSWasmErrorKindCompile => WasmErrorKind::Compile,\n                ffi::TSWasmErrorKindInstantiate => WasmErrorKind::Instantiate,\n                _ => WasmErrorKind::Other,\n            },\n            message,\n        }\n    }\n}\n\nimpl Language {\n    #[must_use]\n    pub fn is_wasm(&self) -> bool {\n        unsafe { ffi::ts_language_is_wasm(self.0) }\n    }\n}\n\nimpl Parser {\n    pub fn set_wasm_store(&mut self, store: WasmStore) -> Result<(), LanguageError> {\n        unsafe { ffi::ts_parser_set_wasm_store(self.0.as_ptr(), store.0) };\n        mem::forget(store);\n        Ok(())\n    }\n\n    pub fn take_wasm_store(&mut self) -> Option<WasmStore> {\n        let ptr = unsafe { ffi::ts_parser_take_wasm_store(self.0.as_ptr()) };\n        if ptr.is_null() {\n            None\n        } else {\n            Some(WasmStore(ptr))\n        }\n    }\n}\n\nimpl Drop for WasmStore {\n    fn drop(&mut self) {\n        unsafe { ffi::ts_wasm_store_delete(self.0) };\n    }\n}\n\nimpl fmt::Display for WasmError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let kind = match self.kind {\n            WasmErrorKind::Parse => \"Failed to parse wasm\",\n            WasmErrorKind::Compile => \"Failed to compile wasm\",\n            WasmErrorKind::Instantiate => \"Failed to instantiate wasm module\",\n            WasmErrorKind::Other => \"Unknown error\",\n        };\n        write!(f, \"{kind}: {}\", self.message)\n    }\n}\n\nimpl error::Error for WasmError {}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#![cfg_attr(not(any(test, feature = \"use_std\")), no_std)]\n#![doc(html_root_url = \"https://docs.rs/scopeguard/1/\")]\n\n//! A scope guard will run a given closure when it goes out of scope,\n//! even if the code between panics.\n//! (as long as panic doesn't abort)\n//!\n//! # Examples\n//!\n//! ## Hello World\n//!\n//! This example creates a scope guard with an example function:\n//!\n//! ```\n//! extern crate scopeguard;\n//!\n//! fn f() {\n//!     let _guard = scopeguard::guard((), |_| {\n//!         println!(\"Hello Scope Exit!\");\n//!     });\n//!\n//!     // rest of the code here.\n//!\n//!     // Here, at the end of `_guard`'s scope, the guard's closure is called.\n//!     // It is also called if we exit this scope through unwinding instead.\n//! }\n//! # fn main() {\n//! #    f();\n//! # }\n//! ```\n//!\n//! ## `defer!`\n//!\n//! Use the `defer` macro to run an operation at scope exit,\n//! either regular scope exit or during unwinding from a panic.\n//!\n//! ```\n//! #[macro_use(defer)] extern crate scopeguard;\n//!\n//! use std::cell::Cell;\n//!\n//! fn main() {\n//!     // use a cell to observe drops during and after the scope guard is active\n//!     let drop_counter = Cell::new(0);\n//!     {\n//!         // Create a scope guard using `defer!` for the current scope\n//!         defer! {\n//!             drop_counter.set(1 + drop_counter.get());\n//!         }\n//!\n//!         // Do regular operations here in the meantime.\n//!\n//!         // Just before scope exit: it hasn't run yet.\n//!         assert_eq!(drop_counter.get(), 0);\n//!\n//!         // The following scope end is where the defer closure is called\n//!     }\n//!     assert_eq!(drop_counter.get(), 1);\n//! }\n//! ```\n//!\n//! ## Scope Guard with Value\n//!\n//! If the scope guard closure needs to access an outer value that is also\n//! mutated outside of the scope guard, then you may want to use the scope guard\n//! with a value. The guard works like a smart pointer, so the inner value can\n//! be accessed by reference or by mutable reference.\n//!\n//! ### 1. The guard owns a file\n//!\n//! In this example, the scope guard owns a file and ensures pending writes are\n//! synced at scope exit.\n//!\n//! ```\n//! extern crate scopeguard;\n//!\n//! use std::fs::*;\n//! use std::io::{self, Write};\n//! # // Mock file so that we don't actually write a file\n//! # struct MockFile;\n//! # impl MockFile {\n//! #     fn create(_s: &str) -> io::Result<Self> { Ok(MockFile) }\n//! #     fn write_all(&self, _b: &[u8]) -> io::Result<()> { Ok(()) }\n//! #     fn sync_all(&self) -> io::Result<()> { Ok(()) }\n//! # }\n//! # use self::MockFile as File;\n//!\n//! fn try_main() -> io::Result<()> {\n//!     let f = File::create(\"newfile.txt\")?;\n//!     let mut file = scopeguard::guard(f, |f| {\n//!         // ensure we flush file at return or panic\n//!         let _ = f.sync_all();\n//!     });\n//!     // Access the file through the scope guard itself\n//!     file.write_all(b\"test me\\n\").map(|_| ())\n//! }\n//!\n//! fn main() {\n//!     try_main().unwrap();\n//! }\n//!\n//! ```\n//!\n//! ### 2. The guard restores an invariant on scope exit\n//!\n//! ```\n//! extern crate scopeguard;\n//!\n//! use std::mem::ManuallyDrop;\n//! use std::ptr;\n//!\n//! // This function, just for this example, takes the first element\n//! // and inserts it into the assumed sorted tail of the vector.\n//! //\n//! // For optimization purposes we temporarily violate an invariant of the\n//! // Vec, that it owns all of its elements.\n//! //\n//! // The safe approach is to use swap, which means two writes to memory,\n//! // the optimization is to use a hole which uses only one write of memory\n//! // for each position it moves.\n//! //\n//! // We *must* use a scope guard to run this code safely. We\n//! // are running arbitrary user code (comparison operators) that may panic.\n//! // The scope guard ensures we restore the invariant after successful\n//! // exit or during unwinding from panic.\n//! fn insertion_sort_first<T>(v: &mut Vec<T>)\n//!     where T: PartialOrd\n//! {\n//!     struct Hole<'a, T: 'a> {\n//!         v: &'a mut Vec<T>,\n//!         index: usize,\n//!         value: ManuallyDrop<T>,\n//!     }\n//!\n//!     unsafe {\n//!         // Create a moved-from location in the vector, a hole.\n//!         let value = ptr::read(&v[0]);\n//!         let mut hole = Hole { v: v, index: 0, value: ManuallyDrop::new(value) };\n//!\n//!         // Use a scope guard with a value.\n//!         // At scope exit, plug the hole so that the vector is fully\n//!         // initialized again.\n//!         // The scope guard owns the hole, but we can access it through the guard.\n//!         let mut hole_guard = scopeguard::guard(hole, |hole| {\n//!             // plug the hole in the vector with the value that was // taken out\n//!             let index = hole.index;\n//!             ptr::copy_nonoverlapping(&*hole.value, &mut hole.v[index], 1);\n//!         });\n//!\n//!         // run algorithm that moves the hole in the vector here\n//!         // move the hole until it's in a sorted position\n//!         for i in 1..hole_guard.v.len() {\n//!             if *hole_guard.value >= hole_guard.v[i] {\n//!                 // move the element back and the hole forward\n//!                 let index = hole_guard.index;\n//!                 hole_guard.v.swap(index, index + 1);\n//!                 hole_guard.index += 1;\n//!             } else {\n//!                 break;\n//!             }\n//!         }\n//!\n//!         // When the scope exits here, the Vec becomes whole again!\n//!     }\n//! }\n//!\n//! fn main() {\n//!     let string = String::from;\n//!     let mut data = vec![string(\"c\"), string(\"a\"), string(\"b\"), string(\"d\")];\n//!     insertion_sort_first(&mut data);\n//!     assert_eq!(data, vec![\"a\", \"b\", \"c\", \"d\"]);\n//! }\n//!\n//! ```\n//!\n//!\n//! # Crate Features\n//!\n//! - `use_std`\n//!   + Enabled by default. Enables the `OnUnwind` and `OnSuccess` strategies.\n//!   + Disable to use `no_std`.\n//!\n//! # Rust Version\n//!\n//! This version of the crate requires Rust 1.20 or later.\n//!\n//! The scopeguard 1.x release series will use a carefully considered version\n//! upgrade policy, where in a later 1.x version, we will raise the minimum\n//! required Rust version.\n\n#[cfg(not(any(test, feature = \"use_std\")))]\nextern crate core as std;\n\nuse std::fmt;\nuse std::marker::PhantomData;\nuse std::mem::ManuallyDrop;\nuse std::ops::{Deref, DerefMut};\nuse std::ptr;\n\n/// Controls in which cases the associated code should be run\npub trait Strategy {\n    /// Return `true` if the guards associated code should run\n    /// (in the context where this method is called).\n    fn should_run() -> bool;\n}\n\n/// Always run on scope exit.\n///\n/// Always run: on regular exit from a scope or on unwinding from a panic.\n/// Can not run on abort, process exit, and other catastrophic events where\n/// destructors dont run.\n#[derive(Debug)]\npub enum Always {}\n\n/// Run on scope exit through unwinding.\n///\n/// Requires crate feature `use_std`.\n#[cfg(feature = \"use_std\")]\n#[derive(Debug)]\npub enum OnUnwind {}\n\n/// Run on regular scope exit, when not unwinding.\n///\n/// Requires crate feature `use_std`.\n#[cfg(feature = \"use_std\")]\n#[derive(Debug)]\npub enum OnSuccess {}\n\nimpl Strategy for Always {\n    #[inline(always)]\n    fn should_run() -> bool {\n        true\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl Strategy for OnUnwind {\n    #[inline]\n    fn should_run() -> bool {\n        std::thread::panicking()\n    }\n}\n\n#[cfg(feature = \"use_std\")]\nimpl Strategy for OnSuccess {\n    #[inline]\n    fn should_run() -> bool {\n        !std::thread::panicking()\n    }\n}\n\n/// Macro to create a `ScopeGuard` (always run).\n///\n/// The macro takes statements, which are the body of a closure\n/// that will run when the scope is exited.\n#[macro_export]\nmacro_rules! defer {\n    ($($t:tt)*) => {\n        let _guard = $crate::guard((), |()| { $($t)* });\n    };\n}\n\n/// Macro to create a `ScopeGuard` (run on successful scope exit).\n///\n/// The macro takes statements, which are the body of a closure\n/// that will run when the scope is exited.\n///\n/// Requires crate feature `use_std`.\n#[cfg(feature = \"use_std\")]\n#[macro_export]\nmacro_rules! defer_on_success {\n    ($($t:tt)*) => {\n        let _guard = $crate::guard_on_success((), |()| { $($t)* });\n    };\n}\n\n/// Macro to create a `ScopeGuard` (run on unwinding from panic).\n///\n/// The macro takes statements, which are the body of a closure\n/// that will run when the scope is exited.\n///\n/// Requires crate feature `use_std`.\n#[cfg(feature = \"use_std\")]\n#[macro_export]\nmacro_rules! defer_on_unwind {\n    ($($t:tt)*) => {\n        let _guard = $crate::guard_on_unwind((), |()| { $($t)* });\n    };\n}\n\n/// `ScopeGuard` is a scope guard that may own a protected value.\n///\n/// If you place a guard in a local variable, the closure can\n/// run regardless how you leave the scope  through regular return or panic\n/// (except if panic or other code aborts; so as long as destructors run).\n/// It is run only once.\n///\n/// The `S` parameter for [`Strategy`](trait.Strategy.html) determines if\n/// the closure actually runs.\n///\n/// The guard's closure will be called with the held value in the destructor.\n///\n/// The `ScopeGuard` implements `Deref` so that you can access the inner value.\npub struct ScopeGuard<T, F, S = Always>\nwhere\n    F: FnOnce(T),\n    S: Strategy,\n{\n    value: ManuallyDrop<T>,\n    dropfn: ManuallyDrop<F>,\n    // fn(S) -> S is used, so that the S is not taken into account for auto traits.\n    strategy: PhantomData<fn(S) -> S>,\n}\n\nimpl<T, F, S> ScopeGuard<T, F, S>\nwhere\n    F: FnOnce(T),\n    S: Strategy,\n{\n    /// Create a `ScopeGuard` that owns `v` (accessible through deref) and calls\n    /// `dropfn` when its destructor runs.\n    ///\n    /// The `Strategy` decides whether the scope guard's closure should run.\n    #[inline]\n    #[must_use]\n    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {\n        ScopeGuard {\n            value: ManuallyDrop::new(v),\n            dropfn: ManuallyDrop::new(dropfn),\n            strategy: PhantomData,\n        }\n    }\n\n    /// Defuse the guard and extract the value without calling the closure.\n    ///\n    /// ```\n    /// extern crate scopeguard;\n    ///\n    /// use scopeguard::{guard, ScopeGuard};\n    ///\n    /// fn conditional() -> bool { true }\n    ///\n    /// fn main() {\n    ///     let mut guard = guard(Vec::new(), |mut v| v.clear());\n    ///     guard.push(1);\n    ///\n    ///     if conditional() {\n    ///         // a condition maybe makes us decide to\n    ///         // defuse the guard and get back its inner parts\n    ///         let value = ScopeGuard::into_inner(guard);\n    ///     } else {\n    ///         // guard still exists in this branch\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    pub fn into_inner(guard: Self) -> T {\n        // Cannot move out of `Drop`-implementing types,\n        // so `ptr::read` the value and forget the guard.\n        let mut guard = ManuallyDrop::new(guard);\n        unsafe {\n            let value = ptr::read(&*guard.value);\n            // Drop the closure after `value` has been read, so that if the\n            // closure's `drop` function panics, unwinding still tries to drop\n            // `value`.\n            ManuallyDrop::drop(&mut guard.dropfn);\n            value\n        }\n    }\n}\n\n/// Create a new `ScopeGuard` owning `v` and with deferred closure `dropfn`.\n#[inline]\n#[must_use]\npub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>\nwhere\n    F: FnOnce(T),\n{\n    ScopeGuard::with_strategy(v, dropfn)\n}\n\n/// Create a new `ScopeGuard` owning `v` and with deferred closure `dropfn`.\n///\n/// Requires crate feature `use_std`.\n#[cfg(feature = \"use_std\")]\n#[inline]\n#[must_use]\npub fn guard_on_success<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, OnSuccess>\nwhere\n    F: FnOnce(T),\n{\n    ScopeGuard::with_strategy(v, dropfn)\n}\n\n/// Create a new `ScopeGuard` owning `v` and with deferred closure `dropfn`.\n///\n/// Requires crate feature `use_std`.\n///\n/// ## Examples\n///\n/// For performance reasons, or to emulate only run guard on unwind in\n/// no-std environments, we can also use the default guard and simply manually\n/// defuse it at the end of scope like the following example. (The performance\n/// reason would be if the [`OnUnwind`]'s call to [std::thread::panicking()] is\n/// an issue.)\n///\n/// ```\n/// extern crate scopeguard;\n///\n/// use scopeguard::ScopeGuard;\n/// # fn main() {\n/// {\n///     let guard = scopeguard::guard((), |_| {});\n///\n///     // rest of the code here\n///\n///     // we reached the end of scope without unwinding - defuse it\n///     ScopeGuard::into_inner(guard);\n/// }\n/// # }\n/// ```\n#[cfg(feature = \"use_std\")]\n#[inline]\n#[must_use]\npub fn guard_on_unwind<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, OnUnwind>\nwhere\n    F: FnOnce(T),\n{\n    ScopeGuard::with_strategy(v, dropfn)\n}\n\n// ScopeGuard can be Sync even if F isn't because the closure is\n// not accessible from references.\n// The guard does not store any instance of S, so it is also irrelevant.\nunsafe impl<T, F, S> Sync for ScopeGuard<T, F, S>\nwhere\n    T: Sync,\n    F: FnOnce(T),\n    S: Strategy,\n{\n}\n\nimpl<T, F, S> Deref for ScopeGuard<T, F, S>\nwhere\n    F: FnOnce(T),\n    S: Strategy,\n{\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &*self.value\n    }\n}\n\nimpl<T, F, S> DerefMut for ScopeGuard<T, F, S>\nwhere\n    F: FnOnce(T),\n    S: Strategy,\n{\n    fn deref_mut(&mut self) -> &mut T {\n        &mut *self.value\n    }\n}\n\nimpl<T, F, S> Drop for ScopeGuard<T, F, S>\nwhere\n    F: FnOnce(T),\n    S: Strategy,\n{\n    fn drop(&mut self) {\n        // This is OK because the fields are `ManuallyDrop`s\n        // which will not be dropped by the compiler.\n        let (value, dropfn) = unsafe { (ptr::read(&*self.value), ptr::read(&*self.dropfn)) };\n        if S::should_run() {\n            dropfn(value);\n        }\n    }\n}\n\nimpl<T, F, S> fmt::Debug for ScopeGuard<T, F, S>\nwhere\n    T: fmt::Debug,\n    F: FnOnce(T),\n    S: Strategy,\n{\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        f.debug_struct(stringify!(ScopeGuard))\n            .field(\"value\", &*self.value)\n            .finish()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::Cell;\n    use std::panic::catch_unwind;\n    use std::panic::AssertUnwindSafe;\n\n    #[test]\n    fn test_defer() {\n        let drops = Cell::new(0);\n        defer!(drops.set(1000));\n        assert_eq!(drops.get(), 0);\n    }\n\n    #[cfg(feature = \"use_std\")]\n    #[test]\n    fn test_defer_success_1() {\n        let drops = Cell::new(0);\n        {\n            defer_on_success!(drops.set(1));\n            assert_eq!(drops.get(), 0);\n        }\n        assert_eq!(drops.get(), 1);\n    }\n\n    #[cfg(feature = \"use_std\")]\n    #[test]\n    fn test_defer_success_2() {\n        let drops = Cell::new(0);\n        let _ = catch_unwind(AssertUnwindSafe(|| {\n            defer_on_success!(drops.set(1));\n            panic!(\"failure\")\n        }));\n        assert_eq!(drops.get(), 0);\n    }\n\n    #[cfg(feature = \"use_std\")]\n    #[test]\n    fn test_defer_unwind_1() {\n        let drops = Cell::new(0);\n        let _ = catch_unwind(AssertUnwindSafe(|| {\n            defer_on_unwind!(drops.set(1));\n            assert_eq!(drops.get(), 0);\n            panic!(\"failure\")\n        }));\n        assert_eq!(drops.get(), 1);\n    }\n\n    #[cfg(feature = \"use_std\")]\n    #[test]\n    fn test_defer_unwind_2() {\n        let drops = Cell::new(0);\n        {\n            defer_on_unwind!(drops.set(1));\n        }\n        assert_eq!(drops.get(), 0);\n    }\n\n    #[test]\n    fn test_only_dropped_by_closure_when_run() {\n        let value_drops = Cell::new(0);\n        let value = guard((), |()| value_drops.set(1 + value_drops.get()));\n        let closure_drops = Cell::new(0);\n        let guard = guard(value, |_| closure_drops.set(1 + closure_drops.get()));\n        assert_eq!(value_drops.get(), 0);\n        assert_eq!(closure_drops.get(), 0);\n        drop(guard);\n        assert_eq!(value_drops.get(), 1);\n        assert_eq!(closure_drops.get(), 1);\n    }\n\n    #[cfg(feature = \"use_std\")]\n    #[test]\n    fn test_dropped_once_when_not_run() {\n        let value_drops = Cell::new(0);\n        let value = guard((), |()| value_drops.set(1 + value_drops.get()));\n        let captured_drops = Cell::new(0);\n        let captured = guard((), |()| captured_drops.set(1 + captured_drops.get()));\n        let closure_drops = Cell::new(0);\n        let guard = guard_on_unwind(value, |value| {\n            drop(value);\n            drop(captured);\n            closure_drops.set(1 + closure_drops.get())\n        });\n        assert_eq!(value_drops.get(), 0);\n        assert_eq!(captured_drops.get(), 0);\n        assert_eq!(closure_drops.get(), 0);\n        drop(guard);\n        assert_eq!(value_drops.get(), 1);\n        assert_eq!(captured_drops.get(), 1);\n        assert_eq!(closure_drops.get(), 0);\n    }\n\n    #[test]\n    fn test_into_inner() {\n        let dropped = Cell::new(false);\n        let value = guard(42, |_| dropped.set(true));\n        let guard = guard(value, |_| dropped.set(true));\n        let inner = ScopeGuard::into_inner(guard);\n        assert_eq!(dropped.get(), false);\n        assert_eq!(*inner, 42);\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! This module defines a trait that can be used to plug in different Futures executors into\n//! Criterion.rs' async benchmarking support.\n//!\n//! Implementations are provided for:\n//! * Tokio (implemented directly for `tokio::Runtime`)\n//! * Smol\n//! * The Futures crate\n//!\n//! Please note that async benchmarks will have a small amount of measurement overhead relative\n//! to synchronous benchmarks. It is recommended to use synchronous benchmarks where possible, to\n//! improve measurement accuracy.\n\nuse std::future::Future;\n\n/// Plugin trait used to allow benchmarking on multiple different async runtimes.\n///\n/// Smol and Tokio are supported out of the box, as is the current-thread runner from the\n/// Futures crate; it is recommended to use whichever runtime you use in production.\npub trait AsyncExecutor {\n    /// Spawn the given future onto this runtime and block until it's complete, returning the result.\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T;\n}\n\n/// Runs futures on the 'futures' crate's built-in current-thread executor\n#[cfg(feature = \"async_futures\")]\npub struct FuturesExecutor;\n#[cfg(feature = \"async_futures\")]\nimpl AsyncExecutor for FuturesExecutor {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        futures::executor::block_on(future)\n    }\n}\n\n/// Runs futures on the 'smol' crate's global executor\n#[cfg(feature = \"async_smol\")]\npub struct SmolExecutor;\n#[cfg(feature = \"async_smol\")]\nimpl AsyncExecutor for SmolExecutor {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        smol::block_on(future)\n    }\n}\n\n#[cfg(feature = \"async_tokio\")]\nimpl AsyncExecutor for tokio::runtime::Runtime {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        self.block_on(future)\n    }\n}\n#[cfg(feature = \"async_tokio\")]\nimpl AsyncExecutor for &tokio::runtime::Runtime {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        (*self).block_on(future)\n    }\n}\n#[cfg(feature = \"async_tokio\")]\nimpl AsyncExecutor for tokio::runtime::Handle {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        self.block_on(future)\n    }\n}\n#[cfg(feature = \"async_tokio\")]\nimpl AsyncExecutor for &tokio::runtime::Handle {\n    fn block_on<T>(&self, future: impl Future<Output = T>) -> T {\n        (*self).block_on(future)\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::hint::black_box;\nuse std::time::Duration;\nuse std::time::Instant;\n\nuse crate::measurement::{Measurement, WallTime};\nuse crate::BatchSize;\n\n#[cfg(feature = \"async\")]\nuse std::future::Future;\n\n#[cfg(feature = \"async\")]\nuse crate::async_executor::AsyncExecutor;\n\n// ================================== MAINTENANCE NOTE =============================================\n// Any changes made to either Bencher or AsyncBencher will have to be replicated to the other!\n// ================================== MAINTENANCE NOTE =============================================\n\n/// Timer struct used to iterate a benchmarked function and measure the runtime.\n///\n/// This struct provides different timing loops as methods. Each timing loop provides a different\n/// way to time a routine and each has advantages and disadvantages.\n///\n/// * If you want to do the iteration and measurement yourself (eg. passing the iteration count\n///   to a separate process), use [`iter_custom`].\n/// * If your routine requires no per-iteration setup and returns a value with an expensive `drop`\n///   method, use [`iter_with_large_drop`].\n/// * If your routine requires some per-iteration setup that shouldn't be timed, use [`iter_batched`]\n///   or [`iter_batched_ref`]. See [`BatchSize`] for a discussion of batch sizes.\n///   If the setup value implements `Drop` and you don't want to include the `drop` time in the\n///   measurement, use [`iter_batched_ref`], otherwise use [`iter_batched`]. These methods are also\n///   suitable for benchmarking routines which return a value with an expensive `drop` method,\n///   but are more complex than [`iter_with_large_drop`].\n/// * Otherwise, use [`iter`].\n///\n/// [`iter`]: Bencher::iter\n/// [`iter_custom`]: Bencher::iter_custom\n/// [`iter_with_large_drop`]: Bencher::iter_with_large_drop\n/// [`iter_batched`]: Bencher::iter_batched\n/// [`iter_batched_ref`]: Bencher::iter_batched_ref\npub struct Bencher<'a, M: Measurement = WallTime> {\n    pub(crate) iterated: bool,         // Have we iterated this benchmark?\n    pub(crate) iters: u64,             // Number of times to iterate this benchmark\n    pub(crate) value: M::Value,        // The measured value\n    pub(crate) measurement: &'a M,     // Reference to the measurement object\n    pub(crate) elapsed_time: Duration, // How much time did it take to perform the iteration? Used for the warmup period.\n}\nimpl<'a, M: Measurement> Bencher<'a, M> {\n    /// Times a `routine` by executing it many times and timing the total elapsed time.\n    ///\n    /// Prefer this timing loop when `routine` returns a value that doesn't have a destructor.\n    ///\n    /// # Timing model\n    ///\n    /// Note that the `Bencher` also times the time required to destroy the output of `routine()`.\n    /// Therefore prefer this timing loop when the runtime of `mem::drop(O)` is negligible compared\n    /// to the runtime of the `routine`.\n    ///\n    /// ```text\n    /// elapsed = Instant::now + iters * (routine + mem::drop(O) + Range::next)\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    ///\n    /// // The function to benchmark\n    /// fn foo() {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"iter\", move |b| {\n    ///         b.iter(|| foo())\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter<O, R>(&mut self, mut routine: R)\n    where\n        R: FnMut() -> O,\n    {\n        self.iterated = true;\n        let time_start = Instant::now();\n        let start = self.measurement.start();\n        for _ in 0..self.iters {\n            black_box(routine());\n        }\n        self.value = self.measurement.end(start);\n        self.elapsed_time = time_start.elapsed();\n    }\n\n    /// Times a `routine` by executing it many times and relying on `routine` to measure its own execution time.\n    ///\n    /// Prefer this timing loop in cases where `routine` has to do its own measurements to\n    /// get accurate timing information (for example in multi-threaded scenarios where you spawn\n    /// and coordinate with multiple threads).\n    ///\n    /// # Timing model\n    /// Custom, the timing model is whatever is returned as the [`Duration`] from `routine`.\n    ///\n    /// # Example\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    /// use std::time::Instant;\n    ///\n    /// fn foo() {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"iter\", move |b| {\n    ///         b.iter_custom(|iters| {\n    ///             let start = Instant::now();\n    ///             for _i in 0..iters {\n    ///                 std::hint::black_box(foo());\n    ///             }\n    ///             start.elapsed()\n    ///         })\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_custom<R>(&mut self, mut routine: R)\n    where\n        R: FnMut(u64) -> M::Value,\n    {\n        self.iterated = true;\n        let time_start = Instant::now();\n        self.value = routine(self.iters);\n        self.elapsed_time = time_start.elapsed();\n    }\n\n    #[doc(hidden)]\n    pub fn iter_with_setup<I, O, S, R>(&mut self, setup: S, routine: R)\n    where\n        S: FnMut() -> I,\n        R: FnMut(I) -> O,\n    {\n        self.iter_batched(setup, routine, BatchSize::PerIteration);\n    }\n\n    /// Times a `routine` by collecting its output on each iteration. This avoids timing the\n    /// destructor of the value returned by `routine`.\n    ///\n    /// WARNING: This requires `O(iters * mem::size_of::<O>())` of memory, and `iters` is not\n    /// under the control of the caller. If this causes out-of-memory errors, use\n    /// [`iter_batched`](Self::iter_batched) instead.\n    ///\n    /// # Timing model\n    ///\n    /// ``` text\n    /// elapsed = Instant::now + iters * (routine) + Iterator::collect::<Vec<_>>\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    ///\n    /// fn create_vector() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"with_drop\", move |b| {\n    ///         // This will avoid timing the Vec::drop.\n    ///         b.iter_with_large_drop(|| create_vector())\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    pub fn iter_with_large_drop<O, R>(&mut self, mut routine: R)\n    where\n        R: FnMut() -> O,\n    {\n        self.iter_batched(|| (), |_| routine(), BatchSize::SmallInput);\n    }\n\n    /// Times a `routine` that requires some input by generating a batch of input, then timing the\n    /// iteration of the benchmark over the input. See [`BatchSize`] for\n    /// details on choosing the batch size. Use this when the routine must consume its input.\n    ///\n    /// For example, use this loop to benchmark sorting algorithms, because they require unsorted\n    /// data on each iteration.\n    ///\n    /// # Timing model\n    ///\n    /// ```text\n    /// elapsed = (Instant::now * num_batches) + (iters * (routine + O::drop)) + Vec::extend\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\n    ///\n    /// fn create_scrambled_data() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// // The sorting algorithm to test\n    /// fn sort(data: &mut [u64]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     let data = create_scrambled_data();\n    ///\n    ///     c.bench_function(\"with_setup\", move |b| {\n    ///         // This will avoid timing the clone call.\n    ///         b.iter_batched(|| data.clone(), |mut data| sort(&mut data), BatchSize::SmallInput)\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_batched<I, O, S, R>(&mut self, mut setup: S, mut routine: R, size: BatchSize)\n    where\n        S: FnMut() -> I,\n        R: FnMut(I) -> O,\n    {\n        self.iterated = true;\n        let batch_size = size.iters_per_batch(self.iters);\n        assert!(batch_size != 0, \"Batch size must not be zero.\");\n        let time_start = Instant::now();\n        self.value = self.measurement.zero();\n\n        if batch_size == 1 {\n            for _ in 0..self.iters {\n                let input = black_box(setup());\n\n                let start = self.measurement.start();\n                let output = routine(input);\n                let end = self.measurement.end(start);\n                self.value = self.measurement.add(&self.value, &end);\n\n                drop(black_box(output));\n            }\n        } else {\n            let mut iteration_counter = 0;\n\n            while iteration_counter < self.iters {\n                let batch_size = ::std::cmp::min(batch_size, self.iters - iteration_counter);\n\n                let inputs = black_box((0..batch_size).map(|_| setup()).collect::<Vec<_>>());\n                let mut outputs = Vec::with_capacity(batch_size as usize);\n\n                let start = self.measurement.start();\n                outputs.extend(inputs.into_iter().map(&mut routine));\n                let end = self.measurement.end(start);\n                self.value = self.measurement.add(&self.value, &end);\n\n                black_box(outputs);\n\n                iteration_counter += batch_size;\n            }\n        }\n\n        self.elapsed_time = time_start.elapsed();\n    }\n\n    /// Times a `routine` that requires some input by generating a batch of input, then timing the\n    /// iteration of the benchmark over the input. See [`BatchSize`] for\n    /// details on choosing the batch size. Use this when the routine should accept the input by\n    /// mutable reference.\n    ///\n    /// For example, use this loop to benchmark sorting algorithms, because they require unsorted\n    /// data on each iteration.\n    ///\n    /// # Timing model\n    ///\n    /// ```text\n    /// elapsed = (Instant::now * num_batches) + (iters * routine) + Vec::extend\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\n    ///\n    /// fn create_scrambled_data() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// // The sorting algorithm to test\n    /// fn sort(data: &mut [u64]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     let data = create_scrambled_data();\n    ///\n    ///     c.bench_function(\"with_setup\", move |b| {\n    ///         // This will avoid timing the clone call.\n    ///         b.iter_batched_ref(|| data.clone(), |mut data| sort(&mut data), BatchSize::SmallInput)\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_batched_ref<I, O, S, R>(&mut self, mut setup: S, mut routine: R, size: BatchSize)\n    where\n        S: FnMut() -> I,\n        R: FnMut(&mut I) -> O,\n    {\n        self.iterated = true;\n        let batch_size = size.iters_per_batch(self.iters);\n        assert!(batch_size != 0, \"Batch size must not be zero.\");\n        let time_start = Instant::now();\n        self.value = self.measurement.zero();\n\n        if batch_size == 1 {\n            for _ in 0..self.iters {\n                let mut input = black_box(setup());\n\n                let start = self.measurement.start();\n                let output = routine(&mut input);\n                let end = self.measurement.end(start);\n                self.value = self.measurement.add(&self.value, &end);\n\n                drop(black_box(output));\n                drop(black_box(input));\n            }\n        } else {\n            let mut iteration_counter = 0;\n\n            while iteration_counter < self.iters {\n                let batch_size = ::std::cmp::min(batch_size, self.iters - iteration_counter);\n\n                let mut inputs = black_box((0..batch_size).map(|_| setup()).collect::<Vec<_>>());\n                let mut outputs = Vec::with_capacity(batch_size as usize);\n\n                let start = self.measurement.start();\n                outputs.extend(inputs.iter_mut().map(&mut routine));\n                let end = self.measurement.end(start);\n                self.value = self.measurement.add(&self.value, &end);\n\n                black_box(outputs);\n\n                iteration_counter += batch_size;\n            }\n        }\n        self.elapsed_time = time_start.elapsed();\n    }\n\n    // Benchmarks must actually call one of the iter methods. This causes benchmarks to fail loudly\n    // if they don't.\n    pub(crate) fn assert_iterated(&mut self) {\n        assert!(\n            self.iterated,\n            \"Benchmark function must call Bencher::iter or related method.\"\n        );\n        self.iterated = false;\n    }\n\n    /// Convert this bencher into an [`AsyncBencher`], which enables async/await support.\n    #[cfg(feature = \"async\")]\n    pub fn to_async<'b, A: AsyncExecutor>(&'b mut self, runner: A) -> AsyncBencher<'a, 'b, A, M> {\n        AsyncBencher { b: self, runner }\n    }\n}\n\n/// Async/await variant of [`Bencher`].\n#[cfg(feature = \"async\")]\npub struct AsyncBencher<'a, 'b, A: AsyncExecutor, M: Measurement = WallTime> {\n    b: &'b mut Bencher<'a, M>,\n    runner: A,\n}\n#[cfg(feature = \"async\")]\nimpl<'a, 'b, A: AsyncExecutor, M: Measurement> AsyncBencher<'a, 'b, A, M> {\n    /// Times a `routine` by executing it many times and timing the total elapsed time.\n    ///\n    /// Prefer this timing loop when `routine` returns a value that doesn't have a destructor.\n    ///\n    /// # Timing model\n    ///\n    /// Note that the `AsyncBencher` also times the time required to destroy the output of `routine()`.\n    /// Therefore prefer this timing loop when the runtime of `mem::drop(O)` is negligible compared\n    /// to the runtime of the `routine`.\n    ///\n    /// ```text\n    /// elapsed = Instant::now + iters * (routine + mem::drop(O) + Range::next)\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    /// use criterion::async_executor::FuturesExecutor;\n    ///\n    /// // The function to benchmark\n    /// async fn foo() {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"iter\", move |b| {\n    ///         b.to_async(FuturesExecutor).iter(|| async { foo().await } )\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter<O, R, F>(&mut self, mut routine: R)\n    where\n        R: FnMut() -> F,\n        F: Future<Output = O>,\n    {\n        let AsyncBencher { b, runner } = self;\n        runner.block_on(async {\n            b.iterated = true;\n            let time_start = Instant::now();\n            let start = b.measurement.start();\n            for _ in 0..b.iters {\n                black_box(routine().await);\n            }\n            b.value = b.measurement.end(start);\n            b.elapsed_time = time_start.elapsed();\n        });\n    }\n\n    /// Times a `routine` by executing it many times and relying on `routine` to measure its own execution time.\n    ///\n    /// Prefer this timing loop in cases where `routine` has to do its own measurements to\n    /// get accurate timing information (for example in multi-threaded scenarios where you spawn\n    /// and coordinate with multiple threads).\n    ///\n    /// # Timing model\n    /// Custom, the timing model is whatever is returned as the [`Duration`] from `routine`.\n    ///\n    /// # Example\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    /// use criterion::async_executor::FuturesExecutor;\n    /// use std::time::Instant;\n    ///\n    /// async fn foo() {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"iter\", move |b| {\n    ///         b.to_async(FuturesExecutor).iter_custom(|iters| {\n    ///             async move {\n    ///                 let start = Instant::now();\n    ///                 for _i in 0..iters {\n    ///                     std::hint::black_box(foo().await);\n    ///                 }\n    ///                 start.elapsed()\n    ///             }\n    ///         })\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_custom<R, F>(&mut self, mut routine: R)\n    where\n        R: FnMut(u64) -> F,\n        F: Future<Output = M::Value>,\n    {\n        let AsyncBencher { b, runner } = self;\n        runner.block_on(async {\n            b.iterated = true;\n            let time_start = Instant::now();\n            b.value = routine(b.iters).await;\n            b.elapsed_time = time_start.elapsed();\n        })\n    }\n\n    #[doc(hidden)]\n    pub fn iter_with_setup<I, O, S, R, F>(&mut self, setup: S, routine: R)\n    where\n        S: FnMut() -> I,\n        R: FnMut(I) -> F,\n        F: Future<Output = O>,\n    {\n        self.iter_batched(setup, routine, BatchSize::PerIteration);\n    }\n\n    /// Times a `routine` by collecting its output on each iteration. This avoids timing the\n    /// destructor of the value returned by `routine`.\n    ///\n    /// WARNING: This requires `O(iters * mem::size_of::<O>())` of memory, and `iters`\n    /// is not under the control of the caller. If this causes out-of-memory errors, use\n    /// [`iter_batched`](Self::iter_batched) instead.\n    ///\n    /// # Timing model\n    ///\n    /// ``` text\n    /// elapsed = Instant::now + iters * (routine) + Iterator::collect::<Vec<_>>\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    /// use criterion::async_executor::FuturesExecutor;\n    ///\n    /// async fn create_vector() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     c.bench_function(\"with_drop\", move |b| {\n    ///         // This will avoid timing the Vec::drop.\n    ///         b.to_async(FuturesExecutor).iter_with_large_drop(|| async { create_vector().await })\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    pub fn iter_with_large_drop<O, R, F>(&mut self, mut routine: R)\n    where\n        R: FnMut() -> F,\n        F: Future<Output = O>,\n    {\n        self.iter_batched(|| (), |_| routine(), BatchSize::SmallInput);\n    }\n\n    #[doc(hidden)]\n    pub fn iter_with_large_setup<I, O, S, R, F>(&mut self, setup: S, routine: R)\n    where\n        S: FnMut() -> I,\n        R: FnMut(I) -> F,\n        F: Future<Output = O>,\n    {\n        self.iter_batched(setup, routine, BatchSize::NumBatches(1));\n    }\n\n    /// Times a `routine` that requires some input by generating a batch of input, then timing the\n    /// iteration of the benchmark over the input. See [`BatchSize`] for\n    /// details on choosing the batch size. Use this when the routine must consume its input.\n    ///\n    /// For example, use this loop to benchmark sorting algorithms, because they require unsorted\n    /// data on each iteration.\n    ///\n    /// # Timing model\n    ///\n    /// ```text\n    /// elapsed = (Instant::now * num_batches) + (iters * (routine + O::drop)) + Vec::extend\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\n    /// use criterion::async_executor::FuturesExecutor;\n    ///\n    /// fn create_scrambled_data() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// // The sorting algorithm to test\n    /// async fn sort(data: &mut [u64]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     let data = create_scrambled_data();\n    ///\n    ///     c.bench_function(\"with_setup\", move |b| {\n    ///         // This will avoid timing the clone call.\n    ///         b.iter_batched(|| data.clone(), |mut data| async move { sort(&mut data).await }, BatchSize::SmallInput)\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_batched<I, O, S, R, F>(&mut self, mut setup: S, mut routine: R, size: BatchSize)\n    where\n        S: FnMut() -> I,\n        R: FnMut(I) -> F,\n        F: Future<Output = O>,\n    {\n        let AsyncBencher { b, runner } = self;\n        runner.block_on(async {\n            b.iterated = true;\n            let batch_size = size.iters_per_batch(b.iters);\n            assert!(batch_size != 0, \"Batch size must not be zero.\");\n            let time_start = Instant::now();\n            b.value = b.measurement.zero();\n\n            if batch_size == 1 {\n                for _ in 0..b.iters {\n                    let input = black_box(setup());\n\n                    let start = b.measurement.start();\n                    let output = routine(input).await;\n                    let end = b.measurement.end(start);\n                    b.value = b.measurement.add(&b.value, &end);\n\n                    drop(black_box(output));\n                }\n            } else {\n                let mut iteration_counter = 0;\n\n                while iteration_counter < b.iters {\n                    let batch_size = ::std::cmp::min(batch_size, b.iters - iteration_counter);\n\n                    let inputs = black_box((0..batch_size).map(|_| setup()).collect::<Vec<_>>());\n                    let mut outputs = Vec::with_capacity(batch_size as usize);\n\n                    let start = b.measurement.start();\n                    // Can't use .extend here like the sync version does\n                    for input in inputs {\n                        outputs.push(routine(input).await);\n                    }\n                    let end = b.measurement.end(start);\n                    b.value = b.measurement.add(&b.value, &end);\n\n                    black_box(outputs);\n\n                    iteration_counter += batch_size;\n                }\n            }\n\n            b.elapsed_time = time_start.elapsed();\n        })\n    }\n\n    /// Times a `routine` that requires some input by generating a batch of input, then timing the\n    /// iteration of the benchmark over the input. See [`BatchSize`] for\n    /// details on choosing the batch size. Use this when the routine should accept the input by\n    /// mutable reference.\n    ///\n    /// For example, use this loop to benchmark sorting algorithms, because they require unsorted\n    /// data on each iteration.\n    ///\n    /// # Timing model\n    ///\n    /// ```text\n    /// elapsed = (Instant::now * num_batches) + (iters * routine) + Vec::extend\n    /// ```\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\n    /// use criterion::async_executor::FuturesExecutor;\n    ///\n    /// fn create_scrambled_data() -> Vec<u64> {\n    ///     # vec![]\n    ///     // ...\n    /// }\n    ///\n    /// // The sorting algorithm to test\n    /// async fn sort(data: &mut [u64]) {\n    ///     // ...\n    /// }\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     let data = create_scrambled_data();\n    ///\n    ///     c.bench_function(\"with_setup\", move |b| {\n    ///         // This will avoid timing the clone call.\n    ///         b.iter_batched(|| data.clone(), |mut data| async move { sort(&mut data).await }, BatchSize::SmallInput)\n    ///     });\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    ///\n    #[inline(never)]\n    pub fn iter_batched_ref<I, O, S, R, F>(&mut self, mut setup: S, mut routine: R, size: BatchSize)\n    where\n        S: FnMut() -> I,\n        R: FnMut(&mut I) -> F,\n        F: Future<Output = O>,\n    {\n        let AsyncBencher { b, runner } = self;\n        runner.block_on(async {\n            b.iterated = true;\n            let batch_size = size.iters_per_batch(b.iters);\n            assert!(batch_size != 0, \"Batch size must not be zero.\");\n            let time_start = Instant::now();\n            b.value = b.measurement.zero();\n\n            if batch_size == 1 {\n                for _ in 0..b.iters {\n                    let mut input = black_box(setup());\n\n                    let start = b.measurement.start();\n                    let output = routine(&mut input).await;\n                    let end = b.measurement.end(start);\n                    b.value = b.measurement.add(&b.value, &end);\n\n                    drop(black_box(output));\n                    drop(black_box(input));\n                }\n            } else {\n                let mut iteration_counter = 0;\n\n                while iteration_counter < b.iters {\n                    let batch_size = ::std::cmp::min(batch_size, b.iters - iteration_counter);\n\n                    let inputs = black_box((0..batch_size).map(|_| setup()).collect::<Vec<_>>());\n                    let mut outputs = Vec::with_capacity(batch_size as usize);\n\n                    let start = b.measurement.start();\n                    // Can't use .extend here like the sync version does\n                    for mut input in inputs {\n                        outputs.push(routine(&mut input).await);\n                    }\n                    let end = b.measurement.end(start);\n                    b.value = b.measurement.add(&b.value, &end);\n\n                    black_box(outputs);\n\n                    iteration_counter += batch_size;\n                }\n            }\n            b.elapsed_time = time_start.elapsed();\n        });\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::{PlotConfiguration, SamplingMode};\nuse std::time::Duration;\n\n// TODO: Move the benchmark config stuff to a separate module for easier use.\n\n/// Struct containing all of the configuration options for a benchmark.\npub struct BenchmarkConfig {\n    pub confidence_level: f64,\n    pub measurement_time: Duration,\n    pub noise_threshold: f64,\n    pub nresamples: usize,\n    pub sample_size: usize,\n    pub significance_level: f64,\n    pub warm_up_time: Duration,\n    pub sampling_mode: SamplingMode,\n    pub quick_mode: bool,\n}\n\n/// Struct representing a partially-complete per-benchmark configuration.\n#[derive(Clone, Default)]\npub(crate) struct PartialBenchmarkConfig {\n    pub(crate) confidence_level: Option<f64>,\n    pub(crate) measurement_time: Option<Duration>,\n    pub(crate) noise_threshold: Option<f64>,\n    pub(crate) nresamples: Option<usize>,\n    pub(crate) sample_size: Option<usize>,\n    pub(crate) significance_level: Option<f64>,\n    pub(crate) warm_up_time: Option<Duration>,\n    pub(crate) sampling_mode: Option<SamplingMode>,\n    pub(crate) quick_mode: Option<bool>,\n    pub(crate) plot_config: PlotConfiguration,\n}\n\nimpl PartialBenchmarkConfig {\n    pub(crate) fn to_complete(&self, defaults: &BenchmarkConfig) -> BenchmarkConfig {\n        BenchmarkConfig {\n            confidence_level: self.confidence_level.unwrap_or(defaults.confidence_level),\n            measurement_time: self.measurement_time.unwrap_or(defaults.measurement_time),\n            noise_threshold: self.noise_threshold.unwrap_or(defaults.noise_threshold),\n            nresamples: self.nresamples.unwrap_or(defaults.nresamples),\n            sample_size: self.sample_size.unwrap_or(defaults.sample_size),\n            significance_level: self\n                .significance_level\n                .unwrap_or(defaults.significance_level),\n            warm_up_time: self.warm_up_time.unwrap_or(defaults.warm_up_time),\n            sampling_mode: self.sampling_mode.unwrap_or(defaults.sampling_mode),\n            quick_mode: self.quick_mode.unwrap_or(defaults.quick_mode),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::analysis;\nuse crate::benchmark::PartialBenchmarkConfig;\nuse crate::connection::OutgoingMessage;\nuse crate::measurement::Measurement;\nuse crate::report::BenchmarkId as InternalBenchmarkId;\nuse crate::report::Report;\nuse crate::report::ReportContext;\nuse crate::routine::{Function, Routine};\nuse crate::{Bencher, Criterion, Mode, PlotConfiguration, SamplingMode, Throughput};\nuse std::time::Duration;\n\n/// Structure used to group together a set of related benchmarks, along with custom configuration\n/// settings for groups of benchmarks. All benchmarks performed using a benchmark group will be\n/// grouped together in the final report.\n///\n/// # Examples:\n///\n/// ```no_run\n/// use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};\n/// use std::time::Duration;\n///\n/// fn bench_simple(c: &mut Criterion) {\n///     let mut group = c.benchmark_group(\"My Group\");\n///\n///     // Now we can perform benchmarks with this group\n///     group.bench_function(\"Bench 1\", |b| b.iter(|| 1 ));\n///     group.bench_function(\"Bench 2\", |b| b.iter(|| 2 ));\n///    \n///     // It's recommended to call group.finish() explicitly at the end, but if you don't it will\n///     // be called automatically when the group is dropped.\n///     group.finish();\n/// }\n///\n/// fn bench_nested(c: &mut Criterion) {\n///     let mut group = c.benchmark_group(\"My Second Group\");\n///     // We can override the configuration on a per-group level\n///     group.measurement_time(Duration::from_secs(1));\n///\n///     // We can also use loops to define multiple benchmarks, even over multiple dimensions.\n///     for x in 0..3 {\n///         for y in 0..3 {\n///             let point = (x, y);\n///             let parameter_string = format!(\"{} * {}\", x, y);\n///             group.bench_with_input(BenchmarkId::new(\"Multiply\", parameter_string), &point,\n///                 |b, (p_x, p_y)| b.iter(|| p_x * p_y));\n///         }\n///     }\n///    \n///     group.finish();\n/// }\n///\n/// fn bench_throughput(c: &mut Criterion) {\n///     let mut group = c.benchmark_group(\"Summation\");\n///     \n///     for size in [1024, 2048, 4096].iter() {\n///         // Generate input of an appropriate size...\n///         let input = vec![1u64, *size];\n///\n///         // We can use the throughput function to tell Criterion.rs how large the input is\n///         // so it can calculate the overall throughput of the function. If we wanted, we could\n///         // even change the benchmark configuration for different inputs (eg. to reduce the\n///         // number of samples for extremely large and slow inputs) or even different functions.\n///         group.throughput(Throughput::Elements(*size as u64));\n///\n///         group.bench_with_input(BenchmarkId::new(\"sum\", *size), &input,\n///             |b, i| b.iter(|| i.iter().sum::<u64>()));\n///         group.bench_with_input(BenchmarkId::new(\"fold\", *size), &input,\n///             |b, i| b.iter(|| i.iter().fold(0u64, |a, b| a + b)));\n///     }\n///\n///     group.finish();\n/// }\n///\n/// criterion_group!(benches, bench_simple, bench_nested, bench_throughput);\n/// criterion_main!(benches);\n/// ```\npub struct BenchmarkGroup<'a, M: Measurement> {\n    criterion: &'a mut Criterion<M>,\n    group_name: String,\n    all_ids: Vec<InternalBenchmarkId>,\n    any_matched: bool,\n    partial_config: PartialBenchmarkConfig,\n    throughput: Option<Throughput>,\n}\nimpl<'a, M: Measurement> BenchmarkGroup<'a, M> {\n    /// Changes the size of the sample for this benchmark\n    ///\n    /// A bigger sample should yield more accurate results if paired with a sufficiently large\n    /// measurement time.\n    ///\n    /// Sample size must be at least 10.\n    ///\n    /// # Panics\n    ///\n    /// Panics if n < 10.\n    pub fn sample_size(&mut self, n: usize) -> &mut Self {\n        assert!(n >= 10);\n\n        self.partial_config.sample_size = Some(n);\n        self\n    }\n\n    /// Changes the warm up time for this benchmark\n    ///\n    /// # Panics\n    ///\n    /// Panics if the input duration is zero\n    pub fn warm_up_time(&mut self, dur: Duration) -> &mut Self {\n        assert!(dur.as_nanos() > 0);\n\n        self.partial_config.warm_up_time = Some(dur);\n        self\n    }\n\n    /// Changes the target measurement time for this benchmark group.\n    ///\n    /// Criterion will attempt to spent approximately this amount of time measuring each\n    /// benchmark on a best-effort basis. If it is not possible to perform the measurement in\n    /// the requested time (eg. because each iteration of the benchmark is long) then Criterion\n    /// will spend as long as is needed to collect the desired number of samples. With a longer\n    /// time, the measurement will become more resilient to interference from other programs.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the input duration is zero\n    pub fn measurement_time(&mut self, dur: Duration) -> &mut Self {\n        assert!(dur.as_nanos() > 0);\n\n        self.partial_config.measurement_time = Some(dur);\n        self\n    }\n\n    /// Changes the number of resamples for this benchmark group\n    ///\n    /// Number of resamples to use for the\n    /// [bootstrap](http://en.wikipedia.org/wiki/Bootstrapping_(statistics)#Case_resampling)\n    ///\n    /// A larger number of resamples reduces the random sampling errors which are inherent to the\n    /// bootstrap method, but also increases the analysis time.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of resamples is set to zero\n    pub fn nresamples(&mut self, n: usize) -> &mut Self {\n        assert!(n > 0);\n        if n <= 1000 {\n            eprintln!(\"\\nWarning: It is not recommended to reduce nresamples below 1000.\");\n        }\n\n        self.partial_config.nresamples = Some(n);\n        self\n    }\n\n    /// Changes the noise threshold for benchmarks in this group. The noise threshold\n    /// is used to filter out small changes in performance from one run to the next, even if they\n    /// are statistically significant. Sometimes benchmarking the same code twice will result in\n    /// small but statistically significant differences solely because of noise. This provides a way\n    /// to filter out some of these false positives at the cost of making it harder to detect small\n    /// changes to the true performance of the benchmark.\n    ///\n    /// The default is 0.01, meaning that changes smaller than 1% will be ignored.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the threshold is set to a negative value\n    pub fn noise_threshold(&mut self, threshold: f64) -> &mut Self {\n        assert!(threshold >= 0.0);\n\n        self.partial_config.noise_threshold = Some(threshold);\n        self\n    }\n\n    /// Changes the confidence level for benchmarks in this group. The confidence\n    /// level is the desired probability that the true runtime lies within the estimated\n    /// [confidence interval](https://en.wikipedia.org/wiki/Confidence_interval). The default is\n    /// 0.95, meaning that the confidence interval should capture the true value 95% of the time.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the confidence level is set to a value outside the `(0, 1)` range\n    pub fn confidence_level(&mut self, cl: f64) -> &mut Self {\n        assert!(cl > 0.0 && cl < 1.0);\n        if cl < 0.5 {\n            eprintln!(\"\\nWarning: It is not recommended to reduce confidence level below 0.5.\");\n        }\n\n        self.partial_config.confidence_level = Some(cl);\n        self\n    }\n\n    /// Changes the [significance level](https://en.wikipedia.org/wiki/Statistical_significance)\n    /// for benchmarks in this group. This is used to perform a\n    /// [hypothesis test](https://en.wikipedia.org/wiki/Statistical_hypothesis_testing) to see if\n    /// the measurements from this run are different from the measured performance of the last run.\n    /// The significance level is the desired probability that two measurements of identical code\n    /// will be considered 'different' due to noise in the measurements. The default value is 0.05,\n    /// meaning that approximately 5% of identical benchmarks will register as different due to\n    /// noise.\n    ///\n    /// This presents a trade-off. By setting the significance level closer to 0.0, you can increase\n    /// the statistical robustness against noise, but it also weakens Criterion.rs' ability to\n    /// detect small but real changes in the performance. By setting the significance level\n    /// closer to 1.0, Criterion.rs will be more able to detect small true changes, but will also\n    /// report more spurious differences.\n    ///\n    /// See also the noise threshold setting.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the significance level is set to a value outside the `(0, 1)` range\n    pub fn significance_level(&mut self, sl: f64) -> &mut Self {\n        assert!(sl > 0.0 && sl < 1.0);\n\n        self.partial_config.significance_level = Some(sl);\n        self\n    }\n\n    /// Changes the plot configuration for this benchmark group.\n    pub fn plot_config(&mut self, new_config: PlotConfiguration) -> &mut Self {\n        self.partial_config.plot_config = new_config;\n        self\n    }\n\n    /// Set the input size for this benchmark group. Used for reporting the\n    /// throughput.\n    pub fn throughput(&mut self, throughput: Throughput) -> &mut Self {\n        self.throughput = Some(throughput);\n        self\n    }\n\n    /// Set the sampling mode for this benchmark group.\n    pub fn sampling_mode(&mut self, new_mode: SamplingMode) -> &mut Self {\n        self.partial_config.sampling_mode = Some(new_mode);\n        self\n    }\n\n    pub(crate) fn new(criterion: &mut Criterion<M>, group_name: String) -> BenchmarkGroup<'_, M> {\n        BenchmarkGroup {\n            criterion,\n            group_name,\n            all_ids: vec![],\n            any_matched: false,\n            partial_config: PartialBenchmarkConfig::default(),\n            throughput: None,\n        }\n    }\n\n    /// Benchmark the given parameterless function inside this benchmark group.\n    pub fn bench_function<ID: IntoBenchmarkId, F>(&mut self, id: ID, mut f: F) -> &mut Self\n    where\n        F: FnMut(&mut Bencher<'_, M>),\n    {\n        self.run_bench(id.into_benchmark_id(), &(), |b, _| f(b));\n        self\n    }\n\n    /// Benchmark the given parameterized function inside this benchmark group.\n    pub fn bench_with_input<ID: IntoBenchmarkId, F, I>(\n        &mut self,\n        id: ID,\n        input: &I,\n        f: F,\n    ) -> &mut Self\n    where\n        F: FnMut(&mut Bencher<'_, M>, &I),\n        I: ?Sized,\n    {\n        self.run_bench(id.into_benchmark_id(), input, f);\n        self\n    }\n\n    fn run_bench<F, I>(&mut self, id: BenchmarkId, input: &I, f: F)\n    where\n        F: FnMut(&mut Bencher<'_, M>, &I),\n        I: ?Sized,\n    {\n        let config = self.partial_config.to_complete(&self.criterion.config);\n        let report_context = ReportContext {\n            output_directory: self.criterion.output_directory.clone(),\n            plot_config: self.partial_config.plot_config.clone(),\n        };\n\n        let mut id = InternalBenchmarkId::new(\n            self.group_name.clone(),\n            id.function_name,\n            id.parameter,\n            self.throughput.clone(),\n        );\n\n        assert!(\n            !self.all_ids.contains(&id),\n            \"Benchmark IDs must be unique within a group. Encountered duplicated benchmark ID {}\",\n            &id\n        );\n\n        id.ensure_directory_name_unique(&self.criterion.all_directories);\n        self.criterion\n            .all_directories\n            .insert(id.as_directory_name().to_owned());\n        id.ensure_title_unique(&self.criterion.all_titles);\n        self.criterion.all_titles.insert(id.as_title().to_owned());\n\n        let do_run = self.criterion.filter_matches(id.id());\n        self.any_matched |= do_run;\n        let mut func = Function::new(f);\n\n        match &self.criterion.mode {\n            Mode::Benchmark => {\n                if let Some(conn) = &self.criterion.connection {\n                    if do_run {\n                        conn.send(&OutgoingMessage::BeginningBenchmark { id: (&id).into() })\n                            .unwrap();\n                    } else {\n                        conn.send(&OutgoingMessage::SkippingBenchmark { id: (&id).into() })\n                            .unwrap();\n                    }\n                }\n                if do_run {\n                    analysis::common(\n                        &id,\n                        &mut func,\n                        &config,\n                        self.criterion,\n                        &report_context,\n                        input,\n                        self.throughput.clone(),\n                    );\n                }\n            }\n            Mode::List(_) => {\n                if do_run {\n                    println!(\"{}: benchmark\", id);\n                }\n            }\n            Mode::Test => {\n                if do_run {\n                    // In test mode, run the benchmark exactly once, then exit.\n                    self.criterion.report.test_start(&id, &report_context);\n                    func.test(&self.criterion.measurement, input);\n                    self.criterion.report.test_pass(&id, &report_context);\n                }\n            }\n            &Mode::Profile(duration) => {\n                if do_run {\n                    func.profile(\n                        &self.criterion.measurement,\n                        &id,\n                        self.criterion,\n                        &report_context,\n                        duration,\n                        input,\n                    );\n                }\n            }\n        }\n\n        self.all_ids.push(id);\n    }\n\n    /// Consume the benchmark group and generate the summary reports for the group.\n    ///\n    /// It is recommended to call this explicitly, but if you forget it will be called when the\n    /// group is dropped.\n    pub fn finish(self) {\n        ::std::mem::drop(self);\n    }\n}\nimpl<'a, M: Measurement> Drop for BenchmarkGroup<'a, M> {\n    fn drop(&mut self) {\n        // I don't really like having a bunch of non-trivial code in drop, but this is the only way\n        // to really write linear types like this in Rust...\n        if let Some(conn) = &mut self.criterion.connection {\n            conn.send(&OutgoingMessage::FinishedBenchmarkGroup {\n                group: &self.group_name,\n            })\n            .unwrap();\n\n            conn.serve_value_formatter(self.criterion.measurement.formatter())\n                .unwrap();\n        }\n\n        if self.all_ids.len() > 1 && self.any_matched && self.criterion.mode.is_benchmark() {\n            let report_context = ReportContext {\n                output_directory: self.criterion.output_directory.clone(),\n                plot_config: self.partial_config.plot_config.clone(),\n            };\n\n            self.criterion.report.summarize(\n                &report_context,\n                &self.all_ids,\n                self.criterion.measurement.formatter(),\n            );\n        }\n        if self.any_matched && !self.criterion.mode.is_terse() {\n            self.criterion.report.group_separator();\n        }\n    }\n}\n\n/// Simple structure representing an ID for a benchmark. The ID must be unique within a benchmark\n/// group.\n#[derive(Clone, Eq, PartialEq, Hash)]\npub struct BenchmarkId {\n    pub(crate) function_name: Option<String>,\n    pub(crate) parameter: Option<String>,\n}\nimpl BenchmarkId {\n    /// Construct a new benchmark ID from a string function name and a parameter value.\n    ///\n    /// Note that the parameter value need not be the same as the parameter passed to your\n    /// actual benchmark. For instance, you might have a benchmark that takes a 1MB string as\n    /// input. It would be impractical to embed the whole string in the benchmark ID, so instead\n    /// your parameter value might be a descriptive string like \"1MB Alphanumeric\".\n    ///\n    /// # Examples\n    /// ```\n    /// # use criterion::{BenchmarkId, Criterion};\n    /// // A basic benchmark ID is typically constructed from a constant string and a simple\n    /// // parameter\n    /// let basic_id = BenchmarkId::new(\"my_id\", 5);\n    ///\n    /// // The function name can be a string\n    /// let function_name = \"test_string\".to_string();\n    /// let string_id = BenchmarkId::new(function_name, 12);\n    ///\n    /// // Benchmark IDs are passed to benchmark groups:\n    /// let mut criterion = Criterion::default();\n    /// let mut group = criterion.benchmark_group(\"My Group\");\n    /// // Generate a very large input\n    /// let input : String = ::std::iter::repeat(\"X\").take(1024 * 1024).collect();\n    ///\n    /// // Note that we don't have to use the input as the parameter in the ID\n    /// group.bench_with_input(BenchmarkId::new(\"Test long string\", \"1MB X's\"), &input, |b, i| {\n    ///     b.iter(|| i.len())\n    /// });\n    /// ```\n    pub fn new<S: Into<String>, P: ::std::fmt::Display>(\n        function_name: S,\n        parameter: P,\n    ) -> BenchmarkId {\n        BenchmarkId {\n            function_name: Some(function_name.into()),\n            parameter: Some(format!(\"{}\", parameter)),\n        }\n    }\n\n    /// Construct a new benchmark ID from just a parameter value. Use this when benchmarking a\n    /// single function with a variety of different inputs.\n    pub fn from_parameter<P: ::std::fmt::Display>(parameter: P) -> BenchmarkId {\n        BenchmarkId {\n            function_name: None,\n            parameter: Some(format!(\"{}\", parameter)),\n        }\n    }\n\n    pub(crate) fn no_function() -> BenchmarkId {\n        BenchmarkId {\n            function_name: None,\n            parameter: None,\n        }\n    }\n\n    pub(crate) fn no_function_with_input<P: ::std::fmt::Display>(parameter: P) -> BenchmarkId {\n        BenchmarkId {\n            function_name: None,\n            parameter: Some(format!(\"{}\", parameter)),\n        }\n    }\n}\n\nmod private {\n    pub trait Sealed {}\n    impl Sealed for super::BenchmarkId {}\n    impl<S: Into<String>> Sealed for S {}\n}\n\n/// Sealed trait which allows users to automatically convert strings to benchmark IDs.\npub trait IntoBenchmarkId: private::Sealed {\n    fn into_benchmark_id(self) -> BenchmarkId;\n}\nimpl IntoBenchmarkId for BenchmarkId {\n    fn into_benchmark_id(self) -> BenchmarkId {\n        self\n    }\n}\nimpl<S: Into<String>> IntoBenchmarkId for S {\n    fn into_benchmark_id(self) -> BenchmarkId {\n        let function_name = self.into();\n        assert!(\n            !function_name.is_empty(),\n            \"Function name must not be empty.\"\n        );\n\n        BenchmarkId {\n            function_name: Some(function_name),\n            parameter: None,\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::report::BenchmarkId as InternalBenchmarkId;\nuse crate::Throughput;\nuse serde::{Deserialize, Serialize};\nuse std::cell::RefCell;\nuse std::convert::TryFrom;\nuse std::io::{Read, Write};\nuse std::mem::size_of;\nuse std::net::TcpStream;\n\n#[derive(Debug)]\npub enum MessageError {\n    Deserialization(ciborium::de::Error<std::io::Error>),\n    Serialization(ciborium::ser::Error<std::io::Error>),\n    Io(std::io::Error),\n}\nimpl From<ciborium::de::Error<std::io::Error>> for MessageError {\n    fn from(other: ciborium::de::Error<std::io::Error>) -> Self {\n        MessageError::Deserialization(other)\n    }\n}\nimpl From<ciborium::ser::Error<std::io::Error>> for MessageError {\n    fn from(other: ciborium::ser::Error<std::io::Error>) -> Self {\n        MessageError::Serialization(other)\n    }\n}\nimpl From<std::io::Error> for MessageError {\n    fn from(other: std::io::Error) -> Self {\n        MessageError::Io(other)\n    }\n}\nimpl std::fmt::Display for MessageError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            MessageError::Deserialization(error) => write!(\n                f,\n                \"Failed to deserialize message to Criterion.rs benchmark:\\n{}\",\n                error\n            ),\n            MessageError::Serialization(error) => write!(\n                f,\n                \"Failed to serialize message to Criterion.rs benchmark:\\n{}\",\n                error\n            ),\n            MessageError::Io(error) => write!(\n                f,\n                \"Failed to read or write message to Criterion.rs benchmark:\\n{}\",\n                error\n            ),\n        }\n    }\n}\nimpl std::error::Error for MessageError {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            MessageError::Deserialization(err) => Some(err),\n            MessageError::Serialization(err) => Some(err),\n            MessageError::Io(err) => Some(err),\n        }\n    }\n}\n\nconst RUNNER_MAGIC_NUMBER: &str = \"cargo-criterion\";\nconst RUNNER_HELLO_SIZE: usize = RUNNER_MAGIC_NUMBER.len() // magic number\n    + (size_of::<u8>() * 3); // version number\n\nconst BENCHMARK_MAGIC_NUMBER: &str = \"Criterion\";\nconst BENCHMARK_HELLO_SIZE: usize = BENCHMARK_MAGIC_NUMBER.len() // magic number\n    + (size_of::<u8>() * 3) // version number\n    + size_of::<u16>() // protocol version\n    + size_of::<u16>(); // protocol format\nconst PROTOCOL_VERSION: u16 = 1;\nconst PROTOCOL_FORMAT: u16 = 1;\n\n#[derive(Debug)]\nstruct InnerConnection {\n    socket: TcpStream,\n    receive_buffer: Vec<u8>,\n    send_buffer: Vec<u8>,\n    // runner_version: [u8; 3],\n}\nimpl InnerConnection {\n    pub fn new(mut socket: TcpStream) -> Result<Self, std::io::Error> {\n        // read the runner-hello\n        let mut hello_buf = [0u8; RUNNER_HELLO_SIZE];\n        socket.read_exact(&mut hello_buf)?;\n        assert_eq!(\n            &hello_buf[0..RUNNER_MAGIC_NUMBER.len()],\n            RUNNER_MAGIC_NUMBER.as_bytes(),\n            \"Not connected to cargo-criterion.\"\n        );\n\n        let i = RUNNER_MAGIC_NUMBER.len();\n        let runner_version = [hello_buf[i], hello_buf[i + 1], hello_buf[i + 2]];\n\n        info!(\"Runner version: {:?}\", runner_version);\n\n        // now send the benchmark-hello\n        let mut hello_buf = [0u8; BENCHMARK_HELLO_SIZE];\n        hello_buf[0..BENCHMARK_MAGIC_NUMBER.len()]\n            .copy_from_slice(BENCHMARK_MAGIC_NUMBER.as_bytes());\n        let mut i = BENCHMARK_MAGIC_NUMBER.len();\n        hello_buf[i] = env!(\"CARGO_PKG_VERSION_MAJOR\").parse().unwrap();\n        hello_buf[i + 1] = env!(\"CARGO_PKG_VERSION_MINOR\").parse().unwrap();\n        hello_buf[i + 2] = env!(\"CARGO_PKG_VERSION_PATCH\").parse().unwrap();\n        i += 3;\n        hello_buf[i..i + 2].clone_from_slice(&PROTOCOL_VERSION.to_be_bytes());\n        i += 2;\n        hello_buf[i..i + 2].clone_from_slice(&PROTOCOL_FORMAT.to_be_bytes());\n\n        socket.write_all(&hello_buf)?;\n\n        Ok(InnerConnection {\n            socket,\n            receive_buffer: vec![],\n            send_buffer: vec![],\n            // runner_version,\n        })\n    }\n\n    #[allow(dead_code)]\n    pub fn recv(&mut self) -> Result<IncomingMessage, MessageError> {\n        let mut length_buf = [0u8; 4];\n        self.socket.read_exact(&mut length_buf)?;\n        let length = u32::from_be_bytes(length_buf);\n        self.receive_buffer.resize(length as usize, 0u8);\n        self.socket.read_exact(&mut self.receive_buffer)?;\n        let value = ciborium::de::from_reader(&self.receive_buffer[..])?;\n        Ok(value)\n    }\n\n    pub fn send(&mut self, message: &OutgoingMessage) -> Result<(), MessageError> {\n        self.send_buffer.truncate(0);\n        ciborium::ser::into_writer(message, &mut self.send_buffer)?;\n        let size = u32::try_from(self.send_buffer.len()).unwrap();\n        let length_buf = size.to_be_bytes();\n        self.socket.write_all(&length_buf)?;\n        self.socket.write_all(&self.send_buffer)?;\n        Ok(())\n    }\n}\n\n/// This is really just a holder to allow us to send messages through a shared reference to the\n/// connection.\n#[derive(Debug)]\npub struct Connection {\n    inner: RefCell<InnerConnection>,\n}\nimpl Connection {\n    pub fn new(socket: TcpStream) -> Result<Self, std::io::Error> {\n        Ok(Connection {\n            inner: RefCell::new(InnerConnection::new(socket)?),\n        })\n    }\n\n    #[allow(dead_code)]\n    pub fn recv(&self) -> Result<IncomingMessage, MessageError> {\n        self.inner.borrow_mut().recv()\n    }\n\n    pub fn send(&self, message: &OutgoingMessage) -> Result<(), MessageError> {\n        self.inner.borrow_mut().send(message)\n    }\n\n    pub fn serve_value_formatter(\n        &self,\n        formatter: &dyn crate::measurement::ValueFormatter,\n    ) -> Result<(), MessageError> {\n        loop {\n            let response = match self.recv()? {\n                IncomingMessage::FormatValue { value } => OutgoingMessage::FormattedValue {\n                    value: formatter.format_value(value),\n                },\n                IncomingMessage::FormatThroughput { value, throughput } => {\n                    OutgoingMessage::FormattedValue {\n                        value: formatter.format_throughput(&throughput, value),\n                    }\n                }\n                IncomingMessage::ScaleValues {\n                    typical_value,\n                    mut values,\n                } => {\n                    let unit = formatter.scale_values(typical_value, &mut values);\n                    OutgoingMessage::ScaledValues {\n                        unit,\n                        scaled_values: values,\n                    }\n                }\n                IncomingMessage::ScaleThroughputs {\n                    typical_value,\n                    throughput,\n                    mut values,\n                } => {\n                    let unit = formatter.scale_throughputs(typical_value, &throughput, &mut values);\n                    OutgoingMessage::ScaledValues {\n                        unit,\n                        scaled_values: values,\n                    }\n                }\n                IncomingMessage::ScaleForMachines { mut values } => {\n                    let unit = formatter.scale_for_machines(&mut values);\n                    OutgoingMessage::ScaledValues {\n                        unit,\n                        scaled_values: values,\n                    }\n                }\n                IncomingMessage::Continue => break,\n                _ => panic!(),\n            };\n            self.send(&response)?;\n        }\n        Ok(())\n    }\n}\n\n/// Enum defining the messages we can receive\n#[derive(Debug, Deserialize)]\npub enum IncomingMessage {\n    // Value formatter requests\n    FormatValue {\n        value: f64,\n    },\n    FormatThroughput {\n        value: f64,\n        throughput: Throughput,\n    },\n    ScaleValues {\n        typical_value: f64,\n        values: Vec<f64>,\n    },\n    ScaleThroughputs {\n        typical_value: f64,\n        values: Vec<f64>,\n        throughput: Throughput,\n    },\n    ScaleForMachines {\n        values: Vec<f64>,\n    },\n    Continue,\n\n    __Other,\n}\n\n/// Enum defining the messages we can send\n#[derive(Debug, Serialize)]\npub enum OutgoingMessage<'a> {\n    BeginningBenchmarkGroup {\n        group: &'a str,\n    },\n    FinishedBenchmarkGroup {\n        group: &'a str,\n    },\n    BeginningBenchmark {\n        id: RawBenchmarkId,\n    },\n    SkippingBenchmark {\n        id: RawBenchmarkId,\n    },\n    Warmup {\n        id: RawBenchmarkId,\n        nanos: f64,\n    },\n    MeasurementStart {\n        id: RawBenchmarkId,\n        sample_count: u64,\n        estimate_ns: f64,\n        iter_count: u64,\n    },\n    MeasurementComplete {\n        id: RawBenchmarkId,\n        iters: &'a [f64],\n        times: &'a [f64],\n        plot_config: PlotConfiguration,\n        sampling_method: SamplingMethod,\n        benchmark_config: BenchmarkConfig,\n    },\n    // value formatter responses\n    FormattedValue {\n        value: String,\n    },\n    ScaledValues {\n        scaled_values: Vec<f64>,\n        unit: &'a str,\n    },\n}\n\n// Also define serializable variants of certain things, either to avoid leaking\n// serializability into the public interface or because the serialized form\n// is a bit different from the regular one.\n\n#[derive(Debug, Serialize)]\npub struct RawBenchmarkId {\n    group_id: String,\n    function_id: Option<String>,\n    value_str: Option<String>,\n    throughput: Vec<Throughput>,\n}\nimpl From<&InternalBenchmarkId> for RawBenchmarkId {\n    fn from(other: &InternalBenchmarkId) -> RawBenchmarkId {\n        RawBenchmarkId {\n            group_id: other.group_id.clone(),\n            function_id: other.function_id.clone(),\n            value_str: other.value_str.clone(),\n            throughput: other.throughput.iter().cloned().collect(),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub enum AxisScale {\n    Linear,\n    Logarithmic,\n}\nimpl From<crate::AxisScale> for AxisScale {\n    fn from(other: crate::AxisScale) -> Self {\n        match other {\n            crate::AxisScale::Linear => AxisScale::Linear,\n            crate::AxisScale::Logarithmic => AxisScale::Logarithmic,\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct PlotConfiguration {\n    summary_scale: AxisScale,\n}\nimpl From<&crate::PlotConfiguration> for PlotConfiguration {\n    fn from(other: &crate::PlotConfiguration) -> Self {\n        PlotConfiguration {\n            summary_scale: other.summary_scale.into(),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\nstruct Duration {\n    secs: u64,\n    nanos: u32,\n}\nimpl From<std::time::Duration> for Duration {\n    fn from(other: std::time::Duration) -> Self {\n        Duration {\n            secs: other.as_secs(),\n            nanos: other.subsec_nanos(),\n        }\n    }\n}\n\n#[derive(Debug, Serialize)]\npub struct BenchmarkConfig {\n    confidence_level: f64,\n    measurement_time: Duration,\n    noise_threshold: f64,\n    nresamples: usize,\n    sample_size: usize,\n    significance_level: f64,\n    warm_up_time: Duration,\n}\nimpl From<&crate::benchmark::BenchmarkConfig> for BenchmarkConfig {\n    fn from(other: &crate::benchmark::BenchmarkConfig) -> Self {\n        BenchmarkConfig {\n            confidence_level: other.confidence_level,\n            measurement_time: other.measurement_time.into(),\n            noise_threshold: other.noise_threshold,\n            nresamples: other.nresamples,\n            sample_size: other.sample_size,\n            significance_level: other.significance_level,\n            warm_up_time: other.warm_up_time.into(),\n        }\n    }\n}\n\n/// Currently not used; defined for forwards compatibility with cargo-criterion.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum SamplingMethod {\n    Linear,\n    Flat,\n}\nimpl From<crate::ActualSamplingMode> for SamplingMethod {\n    fn from(other: crate::ActualSamplingMode) -> Self {\n        match other {\n            crate::ActualSamplingMode::Flat => SamplingMethod::Flat,\n            crate::ActualSamplingMode::Linear => SamplingMethod::Linear,\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use {\n    crate::{\n        error::Result,\n        measurement::ValueFormatter,\n        report::{BenchmarkId, MeasurementData, Report, ReportContext},\n        Throughput,\n    },\n    csv::Writer,\n    serde::Serialize,\n    std::{io::Write, path::Path},\n};\n\n#[derive(Serialize)]\nstruct CsvRow<'a> {\n    group: &'a str,\n    function: Option<&'a str>,\n    value: Option<&'a str>,\n    throughput_num: Option<&'a str>,\n    throughput_type: Option<&'a str>,\n    sample_measured_value: f64,\n    unit: &'static str,\n    iteration_count: u64,\n}\n\nstruct CsvReportWriter<W: Write> {\n    writer: Writer<W>,\n}\nimpl<W: Write> CsvReportWriter<W> {\n    fn write_data(\n        &mut self,\n        id: &BenchmarkId,\n        data: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) -> Result<()> {\n        let mut data_scaled: Vec<f64> = data.sample_times().as_ref().into();\n        let unit = formatter.scale_for_machines(&mut data_scaled);\n        let group = id.group_id.as_str();\n        let function = id.function_id.as_deref();\n        let value = id.value_str.as_deref();\n        let (throughput_num, throughput_type) = match id.throughput {\n            Some(Throughput::Bytes(bytes)) => (Some(format!(\"{}\", bytes)), Some(\"bytes\")),\n            Some(Throughput::BytesDecimal(bytes)) => (Some(format!(\"{}\", bytes)), Some(\"bytes\")),\n            Some(Throughput::Elements(elems)) => (Some(format!(\"{}\", elems)), Some(\"elements\")),\n            Some(Throughput::ElementsAndBytes { elements, bytes }) => (\n                Some(format!(\"{}/{}\", elements, bytes)),\n                Some(\"elements/bytes\"),\n            ),\n            Some(Throughput::Bits(bits)) => (Some(format!(\"{}\", bits)), Some(\"bits\")),\n            None => (None, None),\n        };\n        let throughput_num = throughput_num.as_deref();\n\n        for (count, measured_value) in data.iter_counts().iter().zip(data_scaled) {\n            let row = CsvRow {\n                group,\n                function,\n                value,\n                throughput_num,\n                throughput_type,\n                sample_measured_value: measured_value,\n                unit,\n                iteration_count: (*count) as u64,\n            };\n            self.writer.serialize(row)?;\n        }\n        Ok(())\n    }\n}\n\npub struct FileCsvReport;\nimpl FileCsvReport {\n    fn write_file(\n        &self,\n        path: &Path,\n        id: &BenchmarkId,\n        measurements: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) -> Result<()> {\n        let writer = Writer::from_path(path)?;\n        let mut writer = CsvReportWriter { writer };\n        writer.write_data(id, measurements, formatter)?;\n        Ok(())\n    }\n}\n\nimpl Report for FileCsvReport {\n    fn measurement_complete(\n        &self,\n        id: &BenchmarkId,\n        context: &ReportContext,\n        measurements: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) {\n        let mut path = context.output_directory.clone();\n        path.push(id.as_directory_name());\n        path.push(\"new\");\n        path.push(\"raw.csv\");\n        log_if_err!(self.write_file(&path, id, measurements, formatter));\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[cfg(feature = \"csv_output\")]\nuse csv::Error as CsvError;\nuse serde_json::Error as SerdeError;\nuse std::error::Error as StdError;\nuse std::fmt;\nuse std::io;\nuse std::path::PathBuf;\n\n#[allow(clippy::enum_variant_names)]\n#[derive(Debug)]\npub enum Error {\n    AccessError {\n        path: PathBuf,\n        inner: io::Error,\n    },\n    CopyError {\n        from: PathBuf,\n        to: PathBuf,\n        inner: io::Error,\n    },\n    SerdeError {\n        path: PathBuf,\n        inner: SerdeError,\n    },\n    #[cfg(feature = \"csv_output\")]\n    /// This API requires the following crate features to be activated: `csv_output`\n    CsvError(CsvError),\n}\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::AccessError { path, inner } => {\n                write!(f, \"Failed to access file {:?}: {}\", path, inner)\n            }\n            Error::CopyError { from, to, inner } => {\n                write!(f, \"Failed to copy file {:?} to {:?}: {}\", from, to, inner)\n            }\n            Error::SerdeError { path, inner } => write!(\n                f,\n                \"Failed to read or write file {:?} due to serialization error: {}\",\n                path, inner\n            ),\n            #[cfg(feature = \"csv_output\")]\n            Error::CsvError(inner) => write!(f, \"CSV error: {}\", inner),\n        }\n    }\n}\nimpl StdError for Error {\n    fn description(&self) -> &str {\n        match self {\n            Error::AccessError { .. } => \"AccessError\",\n            Error::CopyError { .. } => \"CopyError\",\n            Error::SerdeError { .. } => \"SerdeError\",\n            #[cfg(feature = \"csv_output\")]\n            Error::CsvError(_) => \"CsvError\",\n        }\n    }\n\n    fn cause(&self) -> Option<&dyn StdError> {\n        match self {\n            Error::AccessError { inner, .. } => Some(inner),\n            Error::CopyError { inner, .. } => Some(inner),\n            Error::SerdeError { inner, .. } => Some(inner),\n            #[cfg(feature = \"csv_output\")]\n            Error::CsvError(inner) => Some(inner),\n        }\n    }\n}\n\n#[cfg(feature = \"csv_output\")]\nimpl From<CsvError> for Error {\n    fn from(other: CsvError) -> Error {\n        Error::CsvError(other)\n    }\n}\n\npub type Result<T> = ::std::result::Result<T, Error>;\n\npub(crate) fn log_error(e: &Error) {\n    error!(\"error: {}\", e);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::stats::Distribution;\n\n#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd, Deserialize, Serialize, Debug)]\npub enum Statistic {\n    Mean,\n    Median,\n    MedianAbsDev,\n    Slope,\n    StdDev,\n    Typical,\n}\n\nimpl fmt::Display for Statistic {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Statistic::Mean => f.pad(\"mean\"),\n            Statistic::Median => f.pad(\"median\"),\n            Statistic::MedianAbsDev => f.pad(\"MAD\"),\n            Statistic::Slope => f.pad(\"slope\"),\n            Statistic::StdDev => f.pad(\"SD\"),\n            Statistic::Typical => f.pad(\"typical\"),\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Deserialize, Serialize, Debug)]\npub struct ConfidenceInterval {\n    pub confidence_level: f64,\n    pub lower_bound: f64,\n    pub upper_bound: f64,\n}\n\n#[derive(Clone, PartialEq, Deserialize, Serialize, Debug)]\npub struct Estimate {\n    /// The confidence interval for this estimate\n    pub confidence_interval: ConfidenceInterval,\n    /// The value of this estimate\n    pub point_estimate: f64,\n    /// The standard error of this estimate\n    pub standard_error: f64,\n}\n\npub fn build_estimates(\n    distributions: &Distributions,\n    points: &PointEstimates,\n    cl: f64,\n) -> Estimates {\n    let to_estimate = |point_estimate, distribution: &Distribution<f64>| {\n        let (lb, ub) = distribution.confidence_interval(cl);\n\n        Estimate {\n            confidence_interval: ConfidenceInterval {\n                confidence_level: cl,\n                lower_bound: lb,\n                upper_bound: ub,\n            },\n            point_estimate,\n            standard_error: distribution.std_dev(None),\n        }\n    };\n\n    Estimates {\n        mean: to_estimate(points.mean, &distributions.mean),\n        median: to_estimate(points.median, &distributions.median),\n        median_abs_dev: to_estimate(points.median_abs_dev, &distributions.median_abs_dev),\n        slope: None,\n        std_dev: to_estimate(points.std_dev, &distributions.std_dev),\n    }\n}\n\npub fn build_change_estimates(\n    distributions: &ChangeDistributions,\n    points: &ChangePointEstimates,\n    cl: f64,\n) -> ChangeEstimates {\n    let to_estimate = |point_estimate, distribution: &Distribution<f64>| {\n        let (lb, ub) = distribution.confidence_interval(cl);\n\n        Estimate {\n            confidence_interval: ConfidenceInterval {\n                confidence_level: cl,\n                lower_bound: lb,\n                upper_bound: ub,\n            },\n            point_estimate,\n            standard_error: distribution.std_dev(None),\n        }\n    };\n\n    ChangeEstimates {\n        mean: to_estimate(points.mean, &distributions.mean),\n        median: to_estimate(points.median, &distributions.median),\n    }\n}\n\npub struct PointEstimates {\n    pub mean: f64,\n    pub median: f64,\n    pub median_abs_dev: f64,\n    pub std_dev: f64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Estimates {\n    pub mean: Estimate,\n    pub median: Estimate,\n    pub median_abs_dev: Estimate,\n    pub slope: Option<Estimate>,\n    pub std_dev: Estimate,\n}\nimpl Estimates {\n    pub fn typical(&self) -> &Estimate {\n        self.slope.as_ref().unwrap_or(&self.mean)\n    }\n    pub fn get(&self, stat: Statistic) -> Option<&Estimate> {\n        match stat {\n            Statistic::Mean => Some(&self.mean),\n            Statistic::Median => Some(&self.median),\n            Statistic::MedianAbsDev => Some(&self.median_abs_dev),\n            Statistic::Slope => self.slope.as_ref(),\n            Statistic::StdDev => Some(&self.std_dev),\n            Statistic::Typical => Some(self.typical()),\n        }\n    }\n}\n\npub struct Distributions {\n    pub mean: Distribution<f64>,\n    pub median: Distribution<f64>,\n    pub median_abs_dev: Distribution<f64>,\n    pub slope: Option<Distribution<f64>>,\n    pub std_dev: Distribution<f64>,\n}\nimpl Distributions {\n    pub fn typical(&self) -> &Distribution<f64> {\n        self.slope.as_ref().unwrap_or(&self.mean)\n    }\n    pub fn get(&self, stat: Statistic) -> Option<&Distribution<f64>> {\n        match stat {\n            Statistic::Mean => Some(&self.mean),\n            Statistic::Median => Some(&self.median),\n            Statistic::MedianAbsDev => Some(&self.median_abs_dev),\n            Statistic::Slope => self.slope.as_ref(),\n            Statistic::StdDev => Some(&self.std_dev),\n            Statistic::Typical => Some(self.typical()),\n        }\n    }\n}\n\npub struct ChangePointEstimates {\n    pub mean: f64,\n    pub median: f64,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ChangeEstimates {\n    pub mean: Estimate,\n    pub median: Estimate,\n}\nimpl ChangeEstimates {\n    pub fn get(&self, stat: Statistic) -> &Estimate {\n        match stat {\n            Statistic::Mean => &self.mean,\n            Statistic::Median => &self.median,\n            _ => panic!(\"Unexpected statistic\"),\n        }\n    }\n}\n\npub struct ChangeDistributions {\n    pub mean: Distribution<f64>,\n    pub median: Distribution<f64>,\n}\nimpl ChangeDistributions {\n    pub fn get(&self, stat: Statistic) -> &Distribution<f64> {\n        match stat {\n            Statistic::Mean => &self.mean,\n            Statistic::Median => &self.median,\n            _ => panic!(\"Unexpected statistic\"),\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "pub fn change(pct: f64, signed: bool) -> String {\n    if signed {\n        format!(\"{:>+6}%\", signed_short(pct * 1e2))\n    } else {\n        format!(\"{:>6}%\", short(pct * 1e2))\n    }\n}\n\npub fn time(ns: f64) -> String {\n    if ns < 1.0 {\n        format!(\"{:>6} ps\", short(ns * 1e3))\n    } else if ns < 10f64.powi(3) {\n        format!(\"{:>6} ns\", short(ns))\n    } else if ns < 10f64.powi(6) {\n        format!(\"{:>6} s\", short(ns / 1e3))\n    } else if ns < 10f64.powi(9) {\n        format!(\"{:>6} ms\", short(ns / 1e6))\n    } else {\n        format!(\"{:>6} s\", short(ns / 1e9))\n    }\n}\n\npub fn short(n: f64) -> String {\n    if n < 10.0 {\n        format!(\"{:.4}\", n)\n    } else if n < 100.0 {\n        format!(\"{:.3}\", n)\n    } else if n < 1000.0 {\n        format!(\"{:.2}\", n)\n    } else if n < 10000.0 {\n        format!(\"{:.1}\", n)\n    } else {\n        format!(\"{:.0}\", n)\n    }\n}\n\nfn signed_short(n: f64) -> String {\n    let n_abs = n.abs();\n\n    let sign = if n >= 0.0 { '+' } else { '\\u{2212}' };\n    if n_abs < 10.0 {\n        format!(\"{}{:.4}\", sign, n_abs)\n    } else if n_abs < 100.0 {\n        format!(\"{}{:.3}\", sign, n_abs)\n    } else if n_abs < 1000.0 {\n        format!(\"{}{:.2}\", sign, n_abs)\n    } else if n_abs < 10000.0 {\n        format!(\"{}{:.1}\", sign, n_abs)\n    } else {\n        format!(\"{}{:.0}\", sign, n_abs)\n    }\n}\n\npub fn iter_count(iterations: u64) -> String {\n    if iterations < 10_000 {\n        format!(\"{} iterations\", iterations)\n    } else if iterations < 1_000_000 {\n        format!(\"{:.0}k iterations\", (iterations as f64) / 1000.0)\n    } else if iterations < 10_000_000 {\n        format!(\"{:.1}M iterations\", (iterations as f64) / (1000.0 * 1000.0))\n    } else if iterations < 1_000_000_000 {\n        format!(\"{:.0}M iterations\", (iterations as f64) / (1000.0 * 1000.0))\n    } else if iterations < 10_000_000_000 {\n        format!(\n            \"{:.1}B iterations\",\n            (iterations as f64) / (1000.0 * 1000.0 * 1000.0)\n        )\n    } else {\n        format!(\n            \"{:.0}B iterations\",\n            (iterations as f64) / (1000.0 * 1000.0 * 1000.0)\n        )\n    }\n}\n\n/// Format a number with thousands separators.\n// Based on the corresponding libtest functionality, see\n// https://github.com/rust-lang/rust/blob/557359f92512ca88b62a602ebda291f17a953002/library/test/src/bench.rs#L87-L109\nfn thousands_sep(mut n: u64, sep: char) -> String {\n    use std::fmt::Write;\n    let mut output = String::new();\n    let mut trailing = false;\n    for &pow in &[9, 6, 3, 0] {\n        let base = 10_u64.pow(pow);\n        if pow == 0 || trailing || n / base != 0 {\n            if !trailing {\n                write!(output, \"{}\", n / base).unwrap();\n            } else {\n                write!(output, \"{:03}\", n / base).unwrap();\n            }\n            if pow != 0 {\n                output.push(sep);\n            }\n            trailing = true;\n        }\n        n %= base;\n    }\n\n    output\n}\n\n/// Format a value as an integer, including thousands-separators.\npub fn integer(n: f64) -> String {\n    thousands_sep(n as u64, ',')\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn short_max_len() {\n        let mut float = 1.0;\n        while float < 999_999.9 {\n            let string = short(float);\n            println!(\"{}\", string);\n            assert!(string.len() <= 6);\n            float *= 2.0;\n        }\n    }\n\n    #[test]\n    fn signed_short_max_len() {\n        let mut float = -1.0;\n        while float > -999_999.9 {\n            let string = signed_short(float);\n            println!(\"{}\", string);\n            assert!(string.chars().count() <= 7);\n            float *= 2.0;\n        }\n    }\n\n    #[test]\n    fn integer_thousands_sep() {\n        let n = 140352319.0;\n        assert_eq!(integer(n), \"140,352,319\");\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use serde::de::DeserializeOwned;\nuse serde::Serialize;\nuse std::ffi::OsStr;\nuse std::fs::{self, File};\nuse std::path::Path;\nuse walkdir::{DirEntry, WalkDir};\n\nuse crate::error::{Error, Result};\nuse crate::report::BenchmarkId;\n\npub fn load<A, P>(path: &P) -> Result<A>\nwhere\n    A: DeserializeOwned,\n    P: AsRef<Path> + ?Sized,\n{\n    let path = path.as_ref();\n    let string = std::fs::read_to_string(path).map_err(|inner| Error::AccessError {\n        inner,\n        path: path.to_owned(),\n    })?;\n    let result: A = serde_json::from_str(string.as_str()).map_err(|inner| Error::SerdeError {\n        inner,\n        path: path.to_owned(),\n    })?;\n\n    Ok(result)\n}\n\npub fn is_dir<P>(path: &P) -> bool\nwhere\n    P: AsRef<Path>,\n{\n    let path: &Path = path.as_ref();\n    path.is_dir()\n}\n\npub fn mkdirp<P>(path: &P) -> Result<()>\nwhere\n    P: AsRef<Path>,\n{\n    fs::create_dir_all(path.as_ref()).map_err(|inner| Error::AccessError {\n        inner,\n        path: path.as_ref().to_owned(),\n    })\n}\n\npub fn cp(from: &Path, to: &Path) -> Result<()> {\n    fs::copy(from, to).map_err(|inner| Error::CopyError {\n        inner,\n        from: from.to_owned(),\n        to: to.to_owned(),\n    })?;\n    Ok(())\n}\n\npub fn save<D, P>(data: &D, path: &P) -> Result<()>\nwhere\n    D: Serialize,\n    P: AsRef<Path>,\n{\n    let buf = serde_json::to_string(&data).map_err(|inner| Error::SerdeError {\n        path: path.as_ref().to_owned(),\n        inner,\n    })?;\n    save_string(&buf, path)\n}\n\npub fn save_string<P>(data: &str, path: &P) -> Result<()>\nwhere\n    P: AsRef<Path>,\n{\n    use std::io::Write;\n\n    File::create(path)\n        .and_then(|mut f| f.write_all(data.as_bytes()))\n        .map_err(|inner| Error::AccessError {\n            inner,\n            path: path.as_ref().to_owned(),\n        })?;\n\n    Ok(())\n}\n\npub fn list_existing_benchmarks<P>(directory: &P) -> Result<Vec<BenchmarkId>>\nwhere\n    P: AsRef<Path>,\n{\n    fn is_benchmark(entry: &DirEntry) -> bool {\n        // Look for benchmark.json files inside folders named \"new\" (because we want to ignore\n        // the baselines)\n        entry.file_name() == OsStr::new(\"benchmark.json\")\n            && entry.path().parent().unwrap().file_name().unwrap() == OsStr::new(\"new\")\n    }\n\n    let mut ids = vec![];\n\n    for entry in WalkDir::new(directory)\n        .into_iter()\n        // Ignore errors.\n        .filter_map(::std::result::Result::ok)\n        .filter(is_benchmark)\n    {\n        let id: BenchmarkId = load(entry.path())?;\n        ids.push(id);\n    }\n\n    Ok(ids)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::univariate::kde::kernel::Gaussian;\nuse crate::stats::univariate::kde::{Bandwidth, Kde};\nuse crate::stats::univariate::Sample;\n\npub fn sweep(\n    sample: &Sample<f64>,\n    npoints: usize,\n    range: Option<(f64, f64)>,\n) -> (Box<[f64]>, Box<[f64]>) {\n    let (xs, ys, _) = sweep_and_estimate(sample, npoints, range, sample[0]);\n    (xs, ys)\n}\n\npub fn sweep_and_estimate(\n    sample: &Sample<f64>,\n    npoints: usize,\n    range: Option<(f64, f64)>,\n    point_to_estimate: f64,\n) -> (Box<[f64]>, Box<[f64]>, f64) {\n    let x_min = sample.min();\n    let x_max = sample.max();\n\n    let kde = Kde::new(sample, Gaussian, Bandwidth::Silverman);\n    let h = kde.bandwidth();\n\n    let (start, end) = match range {\n        Some((start, end)) => (start, end),\n        None => (x_min - 3. * h, x_max + 3. * h),\n    };\n\n    let mut xs: Vec<f64> = Vec::with_capacity(npoints);\n    let step_size = (end - start) / (npoints - 1) as f64;\n    for n in 0..npoints {\n        xs.push(start + (step_size * n as f64));\n    }\n\n    let ys = kde.map(&xs);\n    let point_estimate = kde.estimate(point_to_estimate);\n\n    (xs.into_boxed_slice(), ys, point_estimate)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! A statistics-driven micro-benchmarking library written in Rust.\n//!\n//! This crate is a microbenchmarking library which aims to provide strong\n//! statistical confidence in detecting and estimating the size of performance\n//! improvements and regressions, while also being easy to use.\n//!\n//! See\n//! [the user guide](https://criterion-rs.github.io/book/index.html)\n//! for examples as well as details on the measurement and analysis process,\n//! and the output.\n//!\n//! ## Features:\n//! * Collects detailed statistics, providing strong confidence that changes\n//!   to performance are real, not measurement noise.\n//! * Produces detailed charts, providing thorough understanding of your code's\n//!   performance behavior.\n\n#![warn(clippy::doc_markdown, missing_docs)]\n#![warn(bare_trait_objects)]\n#![allow(\n        clippy::just_underscores_and_digits, // Used in the stats code\n        clippy::transmute_ptr_to_ptr, // Used in the stats code\n)]\n\n#[cfg(all(feature = \"rayon\", target_arch = \"wasm32\"))]\ncompile_error!(\"Rayon cannot be used when targeting wasi32. Try disabling default features.\");\n\nuse {\n    regex::Regex,\n    serde::{Deserialize, Serialize},\n};\n\n// Needs to be declared before other modules\n// in order to be usable there.\n#[macro_use]\nmod macros_private;\n#[macro_use]\nmod analysis;\nmod benchmark;\n#[macro_use]\nmod benchmark_group;\npub mod async_executor;\nmod bencher;\nmod connection;\n#[cfg(feature = \"csv_output\")]\nmod csv_report;\nmod error;\nmod estimate;\nmod format;\nmod fs;\nmod html;\nmod kde;\nmod macros;\npub mod measurement;\nmod plot;\npub mod profiler;\nmod report;\nmod routine;\nmod stats;\n\nuse std::{\n    cell::RefCell,\n    collections::HashSet,\n    env,\n    io::{stdout, IsTerminal},\n    net::TcpStream,\n    path::{Path, PathBuf},\n    process::Command,\n    sync::{Mutex, MutexGuard},\n    time::Duration,\n};\n\nuse {\n    criterion_plot::{Version, VersionError},\n    std::sync::OnceLock,\n};\n\n#[cfg(feature = \"plotters\")]\nuse crate::plot::PlottersBackend;\nuse crate::{\n    benchmark::BenchmarkConfig,\n    connection::{Connection, OutgoingMessage},\n    html::Html,\n    measurement::{Measurement, WallTime},\n    plot::{Gnuplot, Plotter},\n    profiler::{ExternalProfiler, Profiler},\n    report::{BencherReport, CliReport, CliVerbosity, Report, ReportContext, Reports},\n};\n\n#[cfg(feature = \"async\")]\npub use crate::bencher::AsyncBencher;\npub use crate::{\n    bencher::Bencher,\n    benchmark_group::{BenchmarkGroup, BenchmarkId},\n};\n\nfn gnuplot_version() -> &'static Result<Version, VersionError> {\n    static GNUPLOT_VERSION: OnceLock<Result<Version, VersionError>> = OnceLock::new();\n\n    GNUPLOT_VERSION.get_or_init(criterion_plot::version)\n}\n\nfn default_plotting_backend() -> &'static PlottingBackend {\n    static DEFAULT_PLOTTING_BACKEND: OnceLock<PlottingBackend> = OnceLock::new();\n\n    DEFAULT_PLOTTING_BACKEND.get_or_init(|| match gnuplot_version() {\n        Ok(_) => PlottingBackend::Gnuplot,\n        #[cfg(feature = \"plotters\")]\n        Err(e) => {\n            match e {\n                VersionError::Exec(_) => eprintln!(\"Gnuplot not found, using plotters backend\"),\n                e => eprintln!(\n                    \"Gnuplot not found or not usable, using plotters backend\\n{}\",\n                    e\n                ),\n            };\n            PlottingBackend::Plotters\n        }\n        #[cfg(not(feature = \"plotters\"))]\n        Err(_) => PlottingBackend::None,\n    })\n}\n\nfn cargo_criterion_connection() -> &'static Option<Mutex<Connection>> {\n    static CARGO_CRITERION_CONNECTION: OnceLock<Option<Mutex<Connection>>> = OnceLock::new();\n\n    CARGO_CRITERION_CONNECTION.get_or_init(|| match std::env::var(\"CARGO_CRITERION_PORT\") {\n        Ok(port_str) => {\n            let port: u16 = port_str.parse().ok()?;\n            let stream = TcpStream::connect((\"localhost\", port)).ok()?;\n            Some(Mutex::new(Connection::new(stream).ok()?))\n        }\n        Err(_) => None,\n    })\n}\n\nfn default_output_directory() -> &'static PathBuf {\n    static DEFAULT_OUTPUT_DIRECTORY: OnceLock<PathBuf> = OnceLock::new();\n\n    DEFAULT_OUTPUT_DIRECTORY.get_or_init(|| {\n        // Set criterion home to (in descending order of preference):\n        // - $CRITERION_HOME (cargo-criterion sets this, but other users could as well)\n        // - $CARGO_TARGET_DIR/criterion\n        // - the cargo target dir from `cargo metadata`\n        // - ./target/criterion\n        if let Some(value) = env::var_os(\"CRITERION_HOME\") {\n            PathBuf::from(value)\n        } else if let Some(path) = cargo_target_directory() {\n            path.join(\"criterion\")\n        } else {\n            PathBuf::from(\"target/criterion\")\n        }\n    })\n}\n\nfn debug_enabled() -> bool {\n    static DEBUG_ENABLED: OnceLock<bool> = OnceLock::new();\n\n    *DEBUG_ENABLED.get_or_init(|| std::env::var_os(\"CRITERION_DEBUG\").is_some())\n}\n\n/// A function that is opaque to the optimizer, used to prevent the compiler from\n/// optimizing away computations in a benchmark.\n#[deprecated(note = \"use `std::hint::black_box()` instead\")]\npub fn black_box<T>(dummy: T) -> T {\n    std::hint::black_box(dummy)\n}\n\n/// Argument to [`Bencher::iter_batched`] and [`Bencher::iter_batched_ref`] which controls the\n/// batch size.\n///\n/// Generally speaking, almost all benchmarks should use `SmallInput`. If the input or the result\n/// of the benchmark routine is large enough that `SmallInput` causes out-of-memory errors,\n/// `LargeInput` can be used to reduce memory usage at the cost of increasing the measurement\n/// overhead. If the input or the result is extremely large (or if it holds some\n/// limited external resource like a file handle), `PerIteration` will set the number of iterations\n/// per batch to exactly one. `PerIteration` can increase the measurement overhead substantially\n/// and should be avoided wherever possible.\n///\n/// Each value lists an estimate of the measurement overhead. This is intended as a rough guide\n/// to assist in choosing an option, it should not be relied upon. In particular, it is not valid\n/// to subtract the listed overhead from the measurement and assume that the result represents the\n/// true runtime of a function. The actual measurement overhead for your specific benchmark depends\n/// on the details of the function you're benchmarking and the hardware and operating\n/// system running the benchmark.\n///\n/// With that said, if the runtime of your function is small relative to the measurement overhead\n/// it will be difficult to take accurate measurements. In this situation, the best option is to use\n/// [`Bencher::iter`] which has next-to-zero measurement overhead.\n#[derive(Debug, Eq, PartialEq, Copy, Hash, Clone)]\npub enum BatchSize {\n    /// `SmallInput` indicates that the input to the benchmark routine (the value returned from\n    /// the setup routine) is small enough that millions of values can be safely held in memory.\n    /// Always prefer `SmallInput` unless the benchmark is using too much memory.\n    ///\n    /// In testing, the maximum measurement overhead from benchmarking with `SmallInput` is on the\n    /// order of 500 picoseconds. This is presented as a rough guide; your results may vary.\n    SmallInput,\n\n    /// `LargeInput` indicates that the input to the benchmark routine or the value returned from\n    /// that routine is large. This will reduce the memory usage but increase the measurement\n    /// overhead.\n    ///\n    /// In testing, the maximum measurement overhead from benchmarking with `LargeInput` is on the\n    /// order of 750 picoseconds. This is presented as a rough guide; your results may vary.\n    LargeInput,\n\n    /// `PerIteration` indicates that the input to the benchmark routine or the value returned from\n    /// that routine is extremely large or holds some limited resource, such that holding many values\n    /// in memory at once is infeasible. This provides the worst measurement overhead, but the\n    /// lowest memory usage.\n    ///\n    /// In testing, the maximum measurement overhead from benchmarking with `PerIteration` is on the\n    /// order of 350 nanoseconds or 350,000 picoseconds. This is presented as a rough guide; your\n    /// results may vary.\n    PerIteration,\n\n    /// `NumBatches` will attempt to divide the iterations up into a given number of batches.\n    /// A larger number of batches (and thus smaller batches) will reduce memory usage but increase\n    /// measurement overhead. This allows the user to choose their own tradeoff between memory usage\n    /// and measurement overhead, but care must be taken in tuning the number of batches. Most\n    /// benchmarks should use `SmallInput` or `LargeInput` instead.\n    NumBatches(u64),\n\n    /// `NumIterations` fixes the batch size to a constant number, specified by the user. This\n    /// allows the user to choose their own tradeoff between overhead and memory usage, but care must\n    /// be taken in tuning the batch size. In general, the measurement overhead of `NumIterations`\n    /// will be larger than that of `NumBatches`. Most benchmarks should use `SmallInput` or\n    /// `LargeInput` instead.\n    NumIterations(u64),\n\n    #[doc(hidden)]\n    __NonExhaustive,\n}\nimpl BatchSize {\n    /// Convert to a number of iterations per batch.\n    ///\n    /// We try to do a constant number of batches regardless of the number of iterations in this\n    /// sample. If the measurement overhead is roughly constant regardless of the number of\n    /// iterations the analysis of the results later will have an easier time separating the\n    /// measurement overhead from the benchmark time.\n    fn iters_per_batch(self, iters: u64) -> u64 {\n        match self {\n            BatchSize::SmallInput => (iters + 10 - 1) / 10,\n            BatchSize::LargeInput => (iters + 1000 - 1) / 1000,\n            BatchSize::PerIteration => 1,\n            BatchSize::NumBatches(batches) => (iters + batches - 1) / batches,\n            BatchSize::NumIterations(size) => size,\n            BatchSize::__NonExhaustive => panic!(\"__NonExhaustive is not a valid BatchSize.\"),\n        }\n    }\n}\n\n/// Baseline describes how the `baseline_directory` is handled.\n#[derive(Debug, Clone, Copy)]\npub enum Baseline {\n    /// `CompareLenient` compares against a previous saved version of the baseline.\n    /// If a previous baseline does not exist, the benchmark is run as normal but no comparison occurs.\n    CompareLenient,\n    /// `CompareStrict` compares against a previous saved version of the baseline.\n    /// If a previous baseline does not exist, a panic occurs.\n    CompareStrict,\n    /// `Save` writes the benchmark results to the baseline directory,\n    /// overwriting any results that were previously there.\n    Save,\n    /// `Discard` benchmark results.\n    Discard,\n}\n\n/// Enum used to select the plotting backend.\n///\n/// See [`Criterion::plotting_backend`].\n#[derive(Debug, Clone, Copy)]\npub enum PlottingBackend {\n    /// Plotting backend which uses the external `gnuplot` command to render plots. This is the\n    /// default if the `gnuplot` command is installed.\n    Gnuplot,\n    /// Plotting backend which uses the Rust 'Plotters' library. This is the default if `gnuplot`\n    /// is not installed.\n    Plotters,\n    /// Null plotting backend which outputs nothing,\n    None,\n}\nimpl PlottingBackend {\n    fn create_plotter(&self) -> Option<Box<dyn Plotter>> {\n        match self {\n            PlottingBackend::Gnuplot => Some(Box::<Gnuplot>::default()),\n            #[cfg(feature = \"plotters\")]\n            PlottingBackend::Plotters => Some(Box::<PlottersBackend>::default()),\n            #[cfg(not(feature = \"plotters\"))]\n            PlottingBackend::Plotters => panic!(\"Criterion was built without plotters support.\"),\n            PlottingBackend::None => None,\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\n/// Enum representing the execution mode.\npub(crate) enum Mode {\n    /// Run benchmarks normally.\n    Benchmark,\n    /// List all benchmarks but do not run them.\n    List(ListFormat),\n    /// Run benchmarks once to verify that they work, but otherwise do not measure them.\n    Test,\n    /// Iterate benchmarks for a given length of time but do not analyze or report on them.\n    Profile(Duration),\n}\nimpl Mode {\n    pub fn is_benchmark(&self) -> bool {\n        matches!(self, Mode::Benchmark)\n    }\n\n    pub fn is_terse(&self) -> bool {\n        matches!(self, Mode::List(ListFormat::Terse))\n    }\n}\n\n#[derive(Debug, Default, Clone)]\n/// Enum representing the list format.\npub(crate) enum ListFormat {\n    /// The regular, default format.\n    #[default]\n    Pretty,\n    /// The terse format, where nothing other than the name of the test and \": benchmark\" at the end\n    /// is printed out.\n    Terse,\n}\n\n/// Benchmark filtering support.\n#[derive(Clone, Debug)]\npub enum BenchmarkFilter {\n    /// Run all benchmarks.\n    AcceptAll,\n    /// Run benchmarks matching this regex.\n    Regex(Regex),\n    /// Run the benchmark matching this string exactly.\n    Exact(String),\n    /// Do not run any benchmarks.\n    RejectAll,\n}\n\n/// The benchmark manager\n///\n/// `Criterion` lets you configure and execute benchmarks\n///\n/// Each benchmark consists of four phases:\n///\n/// - **Warm-up**: The routine is repeatedly executed, to let the CPU/OS/JIT/interpreter adapt to\n///   the new load\n/// - **Measurement**: The routine is repeatedly executed, and timing information is collected into\n///   a sample\n/// - **Analysis**: The sample is analyzed and distilled into meaningful statistics that get\n///   reported to stdout, stored in files, and plotted\n/// - **Comparison**: The current sample is compared with the sample obtained in the previous\n///   benchmark.\npub struct Criterion<M: Measurement = WallTime> {\n    config: BenchmarkConfig,\n    filter: BenchmarkFilter,\n    report: Reports,\n    output_directory: PathBuf,\n    baseline_directory: String,\n    baseline: Baseline,\n    load_baseline: Option<String>,\n    all_directories: HashSet<String>,\n    all_titles: HashSet<String>,\n    measurement: M,\n    profiler: Box<RefCell<dyn Profiler>>,\n    connection: Option<MutexGuard<'static, Connection>>,\n    mode: Mode,\n}\n\n/// Returns the Cargo target directory, possibly calling `cargo metadata` to\n/// figure it out.\nfn cargo_target_directory() -> Option<PathBuf> {\n    #[derive(Deserialize)]\n    struct Metadata {\n        target_directory: PathBuf,\n    }\n\n    env::var_os(\"CARGO_TARGET_DIR\")\n        .map(PathBuf::from)\n        .or_else(|| {\n            let output = Command::new(env::var_os(\"CARGO\")?)\n                .args([\"metadata\", \"--format-version\", \"1\"])\n                .output()\n                .ok()?;\n            let metadata: Metadata = serde_json::from_slice(&output.stdout).ok()?;\n            Some(metadata.target_directory)\n        })\n}\n\nimpl Default for Criterion {\n    /// Creates a benchmark manager with the following default settings:\n    ///\n    /// - Sample size: 100 measurements\n    /// - Warm-up time: 3 s\n    /// - Measurement time: 5 s\n    /// - Bootstrap size: 100 000 resamples\n    /// - Noise threshold: 0.01 (1%)\n    /// - Confidence level: 0.95\n    /// - Significance level: 0.05\n    /// - Plotting: enabled, using gnuplot if available or plotters if gnuplot is not available\n    /// - No filter\n    fn default() -> Criterion {\n        let reports = Reports {\n            cli_enabled: true,\n            cli: CliReport::new(false, false, CliVerbosity::Normal),\n            bencher_enabled: false,\n            bencher: BencherReport,\n            html: default_plotting_backend().create_plotter().map(Html::new),\n            csv_enabled: cfg!(feature = \"csv_output\"),\n        };\n\n        let mut criterion = Criterion {\n            config: BenchmarkConfig {\n                confidence_level: 0.95,\n                measurement_time: Duration::from_secs(5),\n                noise_threshold: 0.01,\n                nresamples: 100_000,\n                sample_size: 100,\n                significance_level: 0.05,\n                warm_up_time: Duration::from_secs(3),\n                sampling_mode: SamplingMode::Auto,\n                quick_mode: false,\n            },\n            filter: BenchmarkFilter::AcceptAll,\n            report: reports,\n            baseline_directory: \"base\".to_owned(),\n            baseline: Baseline::Save,\n            load_baseline: None,\n            output_directory: default_output_directory().clone(),\n            all_directories: HashSet::new(),\n            all_titles: HashSet::new(),\n            measurement: WallTime,\n            profiler: Box::new(RefCell::new(ExternalProfiler)),\n            connection: cargo_criterion_connection()\n                .as_ref()\n                .map(|mtx| mtx.lock().unwrap()),\n            mode: Mode::Benchmark,\n        };\n\n        if criterion.connection.is_some() {\n            // disable all reports when connected to cargo-criterion; it will do the reporting.\n            criterion.report.cli_enabled = false;\n            criterion.report.bencher_enabled = false;\n            criterion.report.csv_enabled = false;\n            criterion.report.html = None;\n        }\n        criterion\n    }\n}\n\nimpl<M: Measurement> Criterion<M> {\n    /// Changes the measurement for the benchmarks run with this runner. See the\n    /// [`Measurement`] trait for more details\n    pub fn with_measurement<M2: Measurement>(self, m: M2) -> Criterion<M2> {\n        // Can't use struct update syntax here because they're technically different types.\n        Criterion {\n            config: self.config,\n            filter: self.filter,\n            report: self.report,\n            baseline_directory: self.baseline_directory,\n            baseline: self.baseline,\n            load_baseline: self.load_baseline,\n            output_directory: self.output_directory,\n            all_directories: self.all_directories,\n            all_titles: self.all_titles,\n            measurement: m,\n            profiler: self.profiler,\n            connection: self.connection,\n            mode: self.mode,\n        }\n    }\n\n    #[must_use]\n    /// Changes the internal profiler for benchmarks run with this runner. See\n    /// the [`Profiler`] trait for more details.\n    pub fn with_profiler<P: Profiler + 'static>(self, p: P) -> Criterion<M> {\n        Criterion {\n            profiler: Box::new(RefCell::new(p)),\n            ..self\n        }\n    }\n\n    #[must_use]\n    /// Set the [plotting backend]. By default, Criterion will use `gnuplot` if available,\n    /// or `plotters` if not.\n    ///\n    /// Panics if `backend` is [`PlottingBackend::Gnuplot`] and `gnuplot` is not available.\n    ///\n    /// [plotting backend]: PlottingBackend\n    pub fn plotting_backend(mut self, backend: PlottingBackend) -> Criterion<M> {\n        if let PlottingBackend::Gnuplot = backend {\n            assert!(\n                !gnuplot_version().is_err(),\n                \"Gnuplot plotting backend was requested, but gnuplot is not available. \\\n                To continue, either install Gnuplot or allow Criterion.rs to fall back \\\n                to using plotters.\"\n            );\n        }\n\n        self.report.html = backend.create_plotter().map(Html::new);\n        self\n    }\n\n    #[must_use]\n    /// Changes the default size of the sample for benchmarks run with this runner.\n    ///\n    /// A bigger sample should yield more accurate results if paired with a sufficiently large\n    /// measurement time.\n    ///\n    /// Sample size must be at least 10.\n    ///\n    /// # Panics\n    ///\n    /// Panics if n < 10\n    pub fn sample_size(mut self, n: usize) -> Criterion<M> {\n        assert!(n >= 10);\n\n        self.config.sample_size = n;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default warm up time for benchmarks run with this runner.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the input duration is zero\n    pub fn warm_up_time(mut self, dur: Duration) -> Criterion<M> {\n        assert!(dur.as_nanos() > 0);\n\n        self.config.warm_up_time = dur;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default measurement time for benchmarks run with this runner.\n    ///\n    /// With a longer time, the measurement will become more resilient to transitory peak loads\n    /// caused by external programs\n    ///\n    /// **Note**: If the measurement time is too \"low\", Criterion will automatically increase it\n    ///\n    /// # Panics\n    ///\n    /// Panics if the input duration in zero\n    pub fn measurement_time(mut self, dur: Duration) -> Criterion<M> {\n        assert!(dur.as_nanos() > 0);\n\n        self.config.measurement_time = dur;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default number of resamples for benchmarks run with this runner.\n    ///\n    /// Number of resamples to use for the\n    /// [bootstrap](http://en.wikipedia.org/wiki/Bootstrapping_(statistics)#Case_resampling)\n    ///\n    /// A larger number of resamples reduces the random sampling errors, which are inherent to the\n    /// bootstrap method, but also increases the analysis time\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of resamples is set to zero\n    pub fn nresamples(mut self, n: usize) -> Criterion<M> {\n        assert!(n > 0);\n        if n <= 1000 {\n            eprintln!(\"\\nWarning: It is not recommended to reduce nresamples below 1000.\");\n        }\n\n        self.config.nresamples = n;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default noise threshold for benchmarks run with this runner. The noise threshold\n    /// is used to filter out small changes in performance, even if they are statistically\n    /// significant. Sometimes benchmarking the same code twice will result in small but\n    /// statistically significant differences solely because of noise. This provides a way to filter\n    /// out some of these false positives at the cost of making it harder to detect small changes\n    /// to the true performance of the benchmark.\n    ///\n    /// The default is 0.01, meaning that changes smaller than 1% will be ignored.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the threshold is set to a negative value\n    pub fn noise_threshold(mut self, threshold: f64) -> Criterion<M> {\n        assert!(threshold >= 0.0);\n\n        self.config.noise_threshold = threshold;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default confidence level for benchmarks run with this runner. The confidence\n    /// level is the desired probability that the true runtime lies within the estimated\n    /// [confidence interval](https://en.wikipedia.org/wiki/Confidence_interval). The default is\n    /// 0.95, meaning that the confidence interval should capture the true value 95% of the time.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the confidence level is set to a value outside the `(0, 1)` range\n    pub fn confidence_level(mut self, cl: f64) -> Criterion<M> {\n        assert!(cl > 0.0 && cl < 1.0);\n        if cl < 0.5 {\n            eprintln!(\"\\nWarning: It is not recommended to reduce confidence level below 0.5.\");\n        }\n\n        self.config.confidence_level = cl;\n        self\n    }\n\n    #[must_use]\n    /// Changes the default [significance level](https://en.wikipedia.org/wiki/Statistical_significance)\n    /// for benchmarks run with this runner. This is used to perform a\n    /// [hypothesis test](https://en.wikipedia.org/wiki/Statistical_hypothesis_testing) to see if\n    /// the measurements from this run are different from the measured performance of the last run.\n    /// The significance level is the desired probability that two measurements of identical code\n    /// will be considered 'different' due to noise in the measurements. The default value is 0.05,\n    /// meaning that approximately 5% of identical benchmarks will register as different due to\n    /// noise.\n    ///\n    /// This presents a trade-off. By setting the significance level closer to 0.0, you can increase\n    /// the statistical robustness against noise, but it also weakens Criterion.rs' ability to\n    /// detect small but real changes in the performance. By setting the significance level\n    /// closer to 1.0, Criterion.rs will be more able to detect small true changes, but will also\n    /// report more spurious differences.\n    ///\n    /// See also the noise threshold setting.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the significance level is set to a value outside the `(0, 1)` range\n    pub fn significance_level(mut self, sl: f64) -> Criterion<M> {\n        assert!(sl > 0.0 && sl < 1.0);\n\n        self.config.significance_level = sl;\n        self\n    }\n\n    #[must_use]\n    /// Enables plotting\n    pub fn with_plots(mut self) -> Criterion<M> {\n        // If running under cargo-criterion then don't re-enable the reports; let it do the reporting.\n        if self.connection.is_none() && self.report.html.is_none() {\n            let default_backend = default_plotting_backend().create_plotter();\n            if let Some(backend) = default_backend {\n                self.report.html = Some(Html::new(backend));\n            } else {\n                panic!(\"Cannot find a default plotting backend!\");\n            }\n        }\n        self\n    }\n\n    #[must_use]\n    /// Disables plotting\n    pub fn without_plots(mut self) -> Criterion<M> {\n        self.report.html = None;\n        self\n    }\n\n    #[must_use]\n    /// Names an explicit baseline and enables overwriting the previous results.\n    pub fn save_baseline(mut self, baseline: String) -> Criterion<M> {\n        self.baseline_directory = baseline;\n        self.baseline = Baseline::Save;\n        self\n    }\n\n    #[must_use]\n    /// Names an explicit baseline and disables overwriting the previous results.\n    pub fn retain_baseline(mut self, baseline: String, strict: bool) -> Criterion<M> {\n        self.baseline_directory = baseline;\n        self.baseline = if strict {\n            Baseline::CompareStrict\n        } else {\n            Baseline::CompareLenient\n        };\n        self\n    }\n\n    #[must_use]\n    /// Filters the benchmarks. Only benchmarks with names that contain the\n    /// given string will be executed.\n    ///\n    /// This overwrites [`Self::with_benchmark_filter`].\n    pub fn with_filter<S: Into<String>>(mut self, filter: S) -> Criterion<M> {\n        let filter_text = filter.into();\n        let filter = Regex::new(&filter_text).unwrap_or_else(|err| {\n            panic!(\n                \"Unable to parse '{}' as a regular expression: {}\",\n                filter_text, err\n            )\n        });\n        self.filter = BenchmarkFilter::Regex(filter);\n\n        self\n    }\n\n    /// Only run benchmarks specified by the given filter.\n    ///\n    /// This overwrites [`Self::with_filter`].\n    pub fn with_benchmark_filter(mut self, filter: BenchmarkFilter) -> Criterion<M> {\n        self.filter = filter;\n\n        self\n    }\n\n    #[must_use]\n    /// Override whether the CLI output will be colored or not. Usually you would use the `--color`\n    /// CLI argument, but this is available for programmmatic use as well.\n    pub fn with_output_color(mut self, enabled: bool) -> Criterion<M> {\n        self.report.cli.enable_text_coloring = enabled;\n        self\n    }\n\n    /// Set the output directory (currently for testing only)\n    #[must_use]\n    #[doc(hidden)]\n    pub fn output_directory(mut self, path: &Path) -> Criterion<M> {\n        path.clone_into(&mut self.output_directory);\n\n        self\n    }\n\n    /// Set the profile time (currently for testing only)\n    #[must_use]\n    #[doc(hidden)]\n    pub fn profile_time(mut self, profile_time: Option<Duration>) -> Criterion<M> {\n        match profile_time {\n            Some(time) => self.mode = Mode::Profile(time),\n            None => self.mode = Mode::Benchmark,\n        }\n\n        self\n    }\n\n    /// Generate the final summary at the end of a run.\n    #[doc(hidden)]\n    pub fn final_summary(&self) {\n        if !self.mode.is_benchmark() {\n            return;\n        }\n\n        let report_context = ReportContext {\n            output_directory: self.output_directory.clone(),\n            plot_config: PlotConfiguration::default(),\n        };\n\n        self.report.final_summary(&report_context);\n    }\n\n    /// Configure this criterion struct based on the command-line arguments to\n    /// this process.\n    #[must_use]\n    #[allow(clippy::cognitive_complexity)]\n    pub fn configure_from_args(mut self) -> Criterion<M> {\n        use clap::{value_parser, Arg, Command};\n        let matches = Command::new(\"Criterion Benchmark\")\n            .arg(Arg::new(\"FILTER\")\n                .help(\"Skip benchmarks whose names do not contain FILTER.\")\n                .index(1))\n            .arg(Arg::new(\"color\")\n                .short('c')\n                .long(\"color\")\n                .alias(\"colour\")\n                .value_parser([\"auto\", \"always\", \"never\"])\n                .default_value(\"auto\")\n                .help(\"Configure coloring of output. always = always colorize output, never = never colorize output, auto = colorize output if output is a tty and compiled for unix.\"))\n            .arg(Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .num_args(0)\n                .help(\"Print additional statistical information.\"))\n            .arg(Arg::new(\"quiet\")\n                .long(\"quiet\")\n                .num_args(0)\n                .conflicts_with(\"verbose\")\n                .help(\"Print only the benchmark results.\"))\n            .arg(Arg::new(\"noplot\")\n                .short('n')\n                .long(\"noplot\")\n                .num_args(0)\n                .help(\"Disable plot and HTML generation.\"))\n            .arg(Arg::new(\"save-baseline\")\n                .short('s')\n                .long(\"save-baseline\")\n                .default_value(\"base\")\n                .help(\"Save results under a named baseline.\"))\n            .arg(Arg::new(\"discard-baseline\")\n                .long(\"discard-baseline\")\n                .num_args(0)\n                .conflicts_with_all([\"save-baseline\", \"baseline\", \"baseline-lenient\"])\n                .help(\"Discard benchmark results.\"))\n            .arg(Arg::new(\"baseline\")\n                .short('b')\n                .long(\"baseline\")\n                .conflicts_with_all([\"save-baseline\", \"baseline-lenient\"])\n                .help(\"Compare to a named baseline. If any benchmarks do not have the specified baseline this command fails.\"))\n            .arg(Arg::new(\"baseline-lenient\")\n                .long(\"baseline-lenient\")\n                .conflicts_with_all([\"save-baseline\", \"baseline\"])\n                .help(\"Compare to a named baseline. If any benchmarks do not have the specified baseline then just those benchmarks are not compared against the baseline while every other benchmark is compared against the baseline.\"))\n            .arg(Arg::new(\"list\")\n                .long(\"list\")\n                .num_args(0)\n                .help(\"List all benchmarks\")\n                .conflicts_with_all([\"test\", \"profile-time\"]))\n            .arg(Arg::new(\"format\")\n                .long(\"format\")\n                .value_parser([\"pretty\", \"terse\"])\n                .default_value(\"pretty\")\n                // Note that libtest's --format also works during test execution, but criterion\n                // doesn't support that at the moment.\n                .help(\"Output formatting\"))\n            .arg(Arg::new(\"ignored\")\n                .long(\"ignored\")\n                .num_args(0)\n                .help(\"List or run ignored benchmarks (currently means skip all benchmarks)\"))\n            .arg(Arg::new(\"exact\")\n                .long(\"exact\")\n                .num_args(0)\n                .help(\"Run benchmarks that exactly match the provided filter\"))\n            .arg(Arg::new(\"profile-time\")\n                .long(\"profile-time\")\n                .value_parser(value_parser!(f64))\n                .help(\"Iterate each benchmark for approximately the given number of seconds, doing no analysis and without storing the results. Useful for running the benchmarks in a profiler.\")\n                .conflicts_with_all([\"test\", \"list\"]))\n            .arg(Arg::new(\"load-baseline\")\n                 .long(\"load-baseline\")\n                 .conflicts_with(\"profile-time\")\n                 .requires(\"baseline\")\n                 .help(\"Load a previous baseline instead of sampling new data.\"))\n            .arg(Arg::new(\"sample-size\")\n                .long(\"sample-size\")\n                .value_parser(value_parser!(usize))\n                .help(format!(\"Changes the default size of the sample for this run. [default: {}]\", self.config.sample_size)))\n            .arg(Arg::new(\"warm-up-time\")\n                .long(\"warm-up-time\")\n                .value_parser(value_parser!(f64))\n                .help(format!(\"Changes the default warm up time for this run. [default: {}]\", self.config.warm_up_time.as_secs())))\n            .arg(Arg::new(\"measurement-time\")\n                .long(\"measurement-time\")\n                .value_parser(value_parser!(f64))\n                .help(format!(\"Changes the default measurement time for this run. [default: {}]\", self.config.measurement_time.as_secs())))\n            .arg(Arg::new(\"nresamples\")\n                .long(\"nresamples\")\n                .value_parser(value_parser!(usize))\n                .help(format!(\"Changes the default number of resamples for this run. [default: {}]\", self.config.nresamples)))\n            .arg(Arg::new(\"noise-threshold\")\n                .long(\"noise-threshold\")\n                .value_parser(value_parser!(f64))\n                .help(format!(\"Changes the default noise threshold for this run. [default: {}]\", self.config.noise_threshold)))\n            .arg(Arg::new(\"confidence-level\")\n                .long(\"confidence-level\")\n                .value_parser(value_parser!(f64))\n                .help(format!(\"Changes the default confidence level for this run. [default: {}]\", self.config.confidence_level)))\n            .arg(Arg::new(\"significance-level\")\n                .long(\"significance-level\")\n                .value_parser(value_parser!(f64))\n                .help(format!(\"Changes the default significance level for this run. [default: {}]\", self.config.significance_level)))\n            .arg(Arg::new(\"quick\")\n                .long(\"quick\")\n                .num_args(0)\n                .conflicts_with(\"sample-size\")\n                .help(format!(\"Benchmark only until the significance level has been reached [default: {}]\", self.config.quick_mode)))\n            .arg(Arg::new(\"test\")\n                .hide(true)\n                .long(\"test\")\n                .num_args(0)\n                .help(\"Run the benchmarks once, to verify that they execute successfully, but do not measure or report the results.\")\n                .conflicts_with_all([\"list\", \"profile-time\"]))\n            .arg(Arg::new(\"bench\")\n                .hide(true)\n                .long(\"bench\")\n                .num_args(0))\n            .arg(Arg::new(\"plotting-backend\")\n                 .long(\"plotting-backend\")\n                 .value_parser([\"gnuplot\", \"plotters\"])\n                 .help(\"Set the plotting backend. By default, Criterion.rs will use the gnuplot backend if gnuplot is available, or the plotters backend if it isn't.\"))\n            .arg(Arg::new(\"output-format\")\n                .long(\"output-format\")\n                .value_parser([\"criterion\", \"bencher\"])\n                .default_value(\"criterion\")\n                .help(\"Change the CLI output format. By default, Criterion.rs will use its own format. If output format is set to 'bencher', Criterion.rs will print output in a format that resembles the 'bencher' crate.\"))\n            .arg(Arg::new(\"nocapture\")\n                .long(\"nocapture\")\n                .num_args(0)\n                .hide(true)\n                .help(\"Ignored, but added for compatibility with libtest.\"))\n            .arg(Arg::new(\"show-output\")\n                .long(\"show-output\")\n                .num_args(0)\n                .hide(true)\n                .help(\"Ignored, but added for compatibility with libtest.\"))\n            .arg(Arg::new(\"include-ignored\")\n                .long(\"include-ignored\")\n                .num_args(0)\n                .hide(true)\n                .help(\"Ignored, but added for compatibility with libtest.\"))\n            .arg(Arg::new(\"version\")\n                .hide(true)\n                .short('V')\n                .long(\"version\")\n                .num_args(0))\n            .after_help(\"\nThis executable is a Criterion.rs benchmark.\nSee https://github.com/criterion-rs/criterion.rs for more details.\n\nTo enable debug output, define the environment variable CRITERION_DEBUG.\nCriterion.rs will output more debug information and will save the gnuplot\nscripts alongside the generated plots.\n\nTo test that the benchmarks work, run `cargo test --benches`\n\nNOTE: If you see an 'unrecognized option' error using any of the options above, see:\nhttps://criterion-rs.github.io/book/faq.html\n\")\n            .get_matches();\n\n        if self.connection.is_some() {\n            if let Some(color) = matches.get_one::<String>(\"color\") {\n                if color != \"auto\" {\n                    eprintln!(\"Warning: --color will be ignored when running with cargo-criterion. Use `cargo criterion --color {} -- <args>` instead.\", color);\n                }\n            }\n            if matches.get_flag(\"verbose\") {\n                eprintln!(\"Warning: --verbose will be ignored when running with cargo-criterion. Use `cargo criterion --output-format verbose -- <args>` instead.\");\n            }\n            if matches.get_flag(\"noplot\") {\n                eprintln!(\"Warning: --noplot will be ignored when running with cargo-criterion. Use `cargo criterion --plotting-backend disabled -- <args>` instead.\");\n            }\n            if let Some(backend) = matches.get_one::<String>(\"plotting-backend\") {\n                eprintln!(\"Warning: --plotting-backend will be ignored when running with cargo-criterion. Use `cargo criterion --plotting-backend {} -- <args>` instead.\", backend);\n            }\n            if let Some(format) = matches.get_one::<String>(\"output-format\") {\n                if format != \"criterion\" {\n                    eprintln!(\"Warning: --output-format will be ignored when running with cargo-criterion. Use `cargo criterion --output-format {} -- <args>` instead.\", format);\n                }\n            }\n\n            if matches.contains_id(\"baseline\")\n                || matches\n                    .get_one::<String>(\"save-baseline\")\n                    .is_some_and(|base| base != \"base\")\n                || matches.contains_id(\"load-baseline\")\n            {\n                eprintln!(\"Error: baselines are not supported when running with cargo-criterion.\");\n                std::process::exit(1);\n            }\n        }\n\n        let bench = matches.get_flag(\"bench\");\n        let test = matches.get_flag(\"test\");\n        let test_mode = match (bench, test) {\n            (true, true) => true,   // cargo bench -- --test should run tests\n            (true, false) => false, // cargo bench should run benchmarks\n            (false, _) => true,     // cargo test --benches should run tests\n        };\n\n        self.mode = if matches.get_flag(\"list\") {\n            let list_format = match matches\n                .get_one::<String>(\"format\")\n                .expect(\"a default value was provided for this\")\n                .as_str()\n            {\n                \"pretty\" => ListFormat::Pretty,\n                \"terse\" => ListFormat::Terse,\n                other => unreachable!(\n                    \"unrecognized value for --format that isn't part of possible-values: {}\",\n                    other\n                ),\n            };\n            Mode::List(list_format)\n        } else if test_mode {\n            Mode::Test\n        } else if let Some(&num_seconds) = matches.get_one(\"profile-time\") {\n            if num_seconds < 1.0 {\n                eprintln!(\"Profile time must be at least one second.\");\n                std::process::exit(1);\n            }\n\n            Mode::Profile(Duration::from_secs_f64(num_seconds))\n        } else {\n            Mode::Benchmark\n        };\n\n        // This is kind of a hack, but disable the connection to the runner if we're not benchmarking.\n        if !self.mode.is_benchmark() {\n            self.connection = None;\n        }\n\n        let filter = if matches.get_flag(\"ignored\") {\n            // --ignored overwrites any name-based filters passed in.\n            BenchmarkFilter::RejectAll\n        } else if let Some(filter) = matches.get_one::<String>(\"FILTER\") {\n            if matches.get_flag(\"exact\") {\n                BenchmarkFilter::Exact(filter.to_owned())\n            } else {\n                let regex = Regex::new(filter).unwrap_or_else(|err| {\n                    panic!(\n                        \"Unable to parse '{}' as a regular expression: {}\",\n                        filter, err\n                    )\n                });\n                BenchmarkFilter::Regex(regex)\n            }\n        } else {\n            BenchmarkFilter::AcceptAll\n        };\n        self = self.with_benchmark_filter(filter);\n\n        match matches.get_one(\"plotting-backend\").map(String::as_str) {\n            // Use plotting_backend() here to re-use the panic behavior if Gnuplot is not available.\n            Some(\"gnuplot\") => self = self.plotting_backend(PlottingBackend::Gnuplot),\n            Some(\"plotters\") => self = self.plotting_backend(PlottingBackend::Plotters),\n            Some(val) => panic!(\"Unexpected plotting backend '{}'\", val),\n            None => {}\n        }\n\n        if matches.get_flag(\"noplot\") {\n            self = self.without_plots();\n        }\n\n        if let Some(dir) = matches.get_one::<String>(\"save-baseline\") {\n            self.baseline = Baseline::Save;\n            dir.clone_into(&mut self.baseline_directory);\n        }\n        if matches.get_flag(\"discard-baseline\") {\n            self.baseline = Baseline::Discard;\n        }\n        if let Some(dir) = matches.get_one::<String>(\"baseline\") {\n            self.baseline = Baseline::CompareStrict;\n            dir.clone_into(&mut self.baseline_directory);\n        }\n        if let Some(dir) = matches.get_one::<String>(\"baseline-lenient\") {\n            self.baseline = Baseline::CompareLenient;\n            dir.clone_into(&mut self.baseline_directory);\n        }\n\n        if self.connection.is_some() {\n            // disable all reports when connected to cargo-criterion; it will do the reporting.\n            self.report.cli_enabled = false;\n            self.report.bencher_enabled = false;\n            self.report.csv_enabled = false;\n            self.report.html = None;\n        } else {\n            match matches.get_one(\"output-format\").map(String::as_str) {\n                Some(\"bencher\") => {\n                    self.report.bencher_enabled = true;\n                    self.report.cli_enabled = false;\n                }\n                _ => {\n                    let verbose = matches.get_flag(\"verbose\");\n                    let verbosity = if verbose {\n                        CliVerbosity::Verbose\n                    } else if matches.get_flag(\"quiet\") {\n                        CliVerbosity::Quiet\n                    } else {\n                        CliVerbosity::Normal\n                    };\n                    let stdout_isatty = stdout().is_terminal();\n                    let mut enable_text_overwrite = stdout_isatty && !verbose && !debug_enabled();\n                    let enable_text_coloring;\n                    match matches.get_one(\"color\").map(String::as_str) {\n                        Some(\"always\") => {\n                            enable_text_coloring = true;\n                        }\n                        Some(\"never\") => {\n                            enable_text_coloring = false;\n                            enable_text_overwrite = false;\n                        }\n                        _ => enable_text_coloring = stdout_isatty,\n                    };\n                    self.report.bencher_enabled = false;\n                    self.report.cli_enabled = true;\n                    self.report.cli =\n                        CliReport::new(enable_text_overwrite, enable_text_coloring, verbosity);\n                }\n            };\n        }\n\n        if let Some(dir) = matches.get_one::<String>(\"load-baseline\") {\n            self.load_baseline = Some(dir.to_owned());\n        }\n\n        if let Some(&num_size) = matches.get_one(\"sample-size\") {\n            assert!(num_size >= 10);\n            self.config.sample_size = num_size;\n        }\n        if let Some(&num_seconds) = matches.get_one(\"warm-up-time\") {\n            let dur = std::time::Duration::from_secs_f64(num_seconds);\n            assert!(dur.as_nanos() > 0);\n\n            self.config.warm_up_time = dur;\n        }\n        if let Some(&num_seconds) = matches.get_one(\"measurement-time\") {\n            let dur = std::time::Duration::from_secs_f64(num_seconds);\n            assert!(dur.as_nanos() > 0);\n\n            self.config.measurement_time = dur;\n        }\n        if let Some(&num_resamples) = matches.get_one(\"nresamples\") {\n            assert!(num_resamples > 0);\n\n            self.config.nresamples = num_resamples;\n        }\n        if let Some(&num_noise_threshold) = matches.get_one(\"noise-threshold\") {\n            assert!(num_noise_threshold > 0.0);\n\n            self.config.noise_threshold = num_noise_threshold;\n        }\n        if let Some(&num_confidence_level) = matches.get_one(\"confidence-level\") {\n            assert!(num_confidence_level > 0.0 && num_confidence_level < 1.0);\n\n            self.config.confidence_level = num_confidence_level;\n        }\n        if let Some(&num_significance_level) = matches.get_one(\"significance-level\") {\n            assert!(num_significance_level > 0.0 && num_significance_level < 1.0);\n\n            self.config.significance_level = num_significance_level;\n        }\n\n        if matches.get_flag(\"quick\") {\n            self.config.quick_mode = true;\n        }\n\n        self\n    }\n\n    fn filter_matches(&self, id: &str) -> bool {\n        match &self.filter {\n            BenchmarkFilter::AcceptAll => true,\n            BenchmarkFilter::Regex(regex) => regex.is_match(id),\n            BenchmarkFilter::Exact(exact) => id == exact,\n            BenchmarkFilter::RejectAll => false,\n        }\n    }\n\n    /// Returns true iff we should save the benchmark results in\n    /// json files on the local disk.\n    fn should_save_baseline(&self) -> bool {\n        self.connection.is_none()\n            && self.load_baseline.is_none()\n            && !matches!(self.baseline, Baseline::Discard)\n    }\n\n    /// Return a benchmark group. All benchmarks performed using a benchmark group will be\n    /// grouped together in the final report.\n    ///\n    /// # Examples:\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    ///\n    /// fn bench_simple(c: &mut Criterion) {\n    ///     let mut group = c.benchmark_group(\"My Group\");\n    ///\n    ///     // Now we can perform benchmarks with this group\n    ///     group.bench_function(\"Bench 1\", |b| b.iter(|| 1 ));\n    ///     group.bench_function(\"Bench 2\", |b| b.iter(|| 2 ));\n    ///\n    ///     group.finish();\n    /// }\n    /// criterion_group!(benches, bench_simple);\n    /// criterion_main!(benches);\n    /// ```\n    /// # Panics:\n    /// Panics if the group name is empty\n    pub fn benchmark_group<S: Into<String>>(&mut self, group_name: S) -> BenchmarkGroup<'_, M> {\n        let group_name = group_name.into();\n        assert!(!group_name.is_empty(), \"Group name must not be empty.\");\n\n        if let Some(conn) = &self.connection {\n            conn.send(&OutgoingMessage::BeginningBenchmarkGroup { group: &group_name })\n                .unwrap();\n        }\n\n        BenchmarkGroup::new(self, group_name)\n    }\n}\nimpl<M> Criterion<M>\nwhere\n    M: Measurement + 'static,\n{\n    /// Benchmarks a function. For comparing multiple functions, see\n    /// [`benchmark_group`](Self::benchmark_group).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, Criterion};\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     // Setup (construct data, allocate memory, etc)\n    ///     c.bench_function(\n    ///         \"function_name\",\n    ///         |b| b.iter(|| {\n    ///             // Code to benchmark goes here\n    ///         }),\n    ///     );\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    pub fn bench_function<F>(&mut self, id: &str, f: F) -> &mut Criterion<M>\n    where\n        F: FnMut(&mut Bencher<'_, M>),\n    {\n        self.benchmark_group(id)\n            .bench_function(BenchmarkId::no_function(), f);\n        self\n    }\n\n    /// Benchmarks a function with an input. For comparing multiple functions or multiple inputs,\n    /// see [`benchmark_group`](Self::benchmark_group).\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\n    ///\n    /// fn bench(c: &mut Criterion) {\n    ///     // Setup (construct data, allocate memory, etc)\n    ///     let input = 5u64;\n    ///     c.bench_with_input(\n    ///         BenchmarkId::new(\"function_name\", input), &input,\n    ///         |b, i| b.iter(|| {\n    ///             // Code to benchmark using input `i` goes here\n    ///         }),\n    ///     );\n    /// }\n    ///\n    /// criterion_group!(benches, bench);\n    /// criterion_main!(benches);\n    /// ```\n    pub fn bench_with_input<F, I>(&mut self, id: BenchmarkId, input: &I, f: F) -> &mut Criterion<M>\n    where\n        F: FnMut(&mut Bencher<'_, M>, &I),\n    {\n        // It's possible to use BenchmarkId::from_parameter to create a benchmark ID with no function\n        // name. That's intended for use with BenchmarkGroups where the function name isn't necessary,\n        // but here it is.\n        let group_name = id.function_name.expect(\n            \"Cannot use BenchmarkId::from_parameter with Criterion::bench_with_input. \\\n                 Consider using a BenchmarkGroup or BenchmarkId::new instead.\",\n        );\n        // Guaranteed safe because external callers can't create benchmark IDs without a parameter\n        let parameter = id.parameter.unwrap();\n        self.benchmark_group(group_name).bench_with_input(\n            BenchmarkId::no_function_with_input(parameter),\n            input,\n            f,\n        );\n        self\n    }\n}\n\n/// Enum representing different ways of measuring the throughput of benchmarked code.\n/// If the throughput setting is configured for a benchmark then the estimated throughput will\n/// be reported as well as the time per iteration.\n// TODO: Remove serialize/deserialize from the public API.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub enum Throughput {\n    /// Measure throughput in terms of bits/second. The value should be the number of bits\n    /// processed by one iteration of the benchmarked code. Typically, this would be the number of\n    /// bits transferred by a networking function.\n    Bits(u64),\n\n    /// Measure throughput in terms of bytes/second. The value should be the number of bytes\n    /// processed by one iteration of the benchmarked code. Typically, this would be the length of\n    /// an input string or `&[u8]`.\n    Bytes(u64),\n\n    /// Equivalent to Bytes, but the value will be reported in terms of\n    /// kilobytes (1000 bytes) per second instead of kibibytes (1024 bytes) per\n    /// second, megabytes instead of mibibytes, and gigabytes instead of gibibytes.\n    BytesDecimal(u64),\n\n    /// Measure throughput in terms of elements/second. The value should be the number of elements\n    /// processed by one iteration of the benchmarked code. Typically, this would be the size of a\n    /// collection, but could also be the number of lines of input text or the number of values to\n    /// parse.\n    Elements(u64),\n\n    /// Measure throughput in terms of both elements/second and bytes/second. Typically,\n    /// this would be used if you have a collection of rows where `elements` would be the length of\n    /// the collection and `bytes` would be the total size of the collection if you're processing\n    /// the entire collection in one iteration. This will make sure the report simultaneously\n    /// includes on the rows/s and MB/s that data processing is able to achieve.\n    /// The elements are considered the \"primary\" throughput being reported on (i.e. what will appear\n    /// in the BenchmarkId).\n    ElementsAndBytes {\n        /// The value should be the number of elements processed by one iteration of the benchmarked code.\n        /// Typically, this would be the size of a collection, but could also be the number of lines of\n        /// input text or the number of values to parse.\n        elements: u64,\n        /// The value should be the number of bytes processed by one iteration of the benchmarked code.\n        /// Typically, this would be the length of an input string or `&[u8]`.\n        bytes: u64,\n    },\n}\n\n/// Axis scaling type. Specified via [`PlotConfiguration::summary_scale`].\n#[derive(Debug, Default, Clone, Copy)]\npub enum AxisScale {\n    /// Axes scale linearly\n    #[default]\n    Linear,\n\n    /// Axes scale logarithmically\n    Logarithmic,\n}\n\n/// Contains the configuration options for the plots generated by a particular benchmark\n/// or benchmark group.\n///\n/// ```rust\n/// use self::criterion::{Bencher, Criterion, PlotConfiguration, AxisScale};\n///\n/// let plot_config = PlotConfiguration::default()\n///     .summary_scale(AxisScale::Logarithmic);\n///\n/// // Using Criterion::default() for simplicity; normally you'd use the macros.\n/// let mut criterion = Criterion::default();\n/// let mut benchmark_group = criterion.benchmark_group(\"Group name\");\n/// benchmark_group.plot_config(plot_config);\n/// // Use benchmark group\n/// ```\n#[derive(Debug, Default, Clone)]\npub struct PlotConfiguration {\n    summary_scale: AxisScale,\n}\n\nimpl PlotConfiguration {\n    #[must_use]\n    /// Set the axis scale ([linear] or [logarithmic]) for the summary plots.\n    ///\n    /// Typically, you would set this to logarithmic if benchmarking over a\n    /// range of inputs which scale exponentially. Defaults to [`AxisScale::Linear`].\n    ///\n    /// [linear]: AxisScale::Linear\n    /// [logarithmic]: AxisScale::Logarithmic\n    pub fn summary_scale(mut self, new_scale: AxisScale) -> PlotConfiguration {\n        self.summary_scale = new_scale;\n        self\n    }\n}\n\n/// This enum allows the user to control how Criterion.rs chooses the iteration count when sampling.\n/// The default is `Auto`, which will choose a method automatically based on the iteration time during\n/// the warm-up phase.\n#[derive(Debug, Default, Clone, Copy)]\npub enum SamplingMode {\n    /// Criterion.rs should choose a sampling method automatically. This is the default, and is\n    /// recommended for most users and most benchmarks.\n    #[default]\n    Auto,\n\n    /// Scale the iteration count in each sample linearly. This is suitable for most benchmarks,\n    /// but it tends to require many iterations which can make it very slow for very long benchmarks.\n    Linear,\n\n    /// Keep the iteration count the same for all samples. This is not recommended, as it affects\n    /// the statistics that Criterion.rs can compute. However, it requires fewer iterations than\n    /// the `Linear` method and therefore is more suitable for very long-running benchmarks where\n    /// benchmark execution time is more of a problem and statistical precision is less important.\n    Flat,\n}\n\nimpl SamplingMode {\n    pub(crate) fn choose_sampling_mode(\n        &self,\n        warmup_mean_execution_time: f64,\n        sample_count: u64,\n        target_time: f64,\n    ) -> ActualSamplingMode {\n        match self {\n            SamplingMode::Linear => ActualSamplingMode::Linear,\n            SamplingMode::Flat => ActualSamplingMode::Flat,\n            SamplingMode::Auto => {\n                // Estimate execution time with linear sampling\n                let total_runs = sample_count * (sample_count + 1) / 2;\n                let d =\n                    (target_time / warmup_mean_execution_time / total_runs as f64).ceil() as u64;\n                let expected_ns = total_runs as f64 * d as f64 * warmup_mean_execution_time;\n\n                if expected_ns > (2.0 * target_time) {\n                    ActualSamplingMode::Flat\n                } else {\n                    ActualSamplingMode::Linear\n                }\n            }\n        }\n    }\n}\n\n/// Enum to represent the sampling mode without Auto.\n#[derive(Debug, Clone, Copy, Serialize, Deserialize)]\npub(crate) enum ActualSamplingMode {\n    Linear,\n    Flat,\n}\n\nimpl ActualSamplingMode {\n    pub(crate) fn iteration_counts(\n        &self,\n        warmup_mean_execution_time: f64,\n        sample_count: u64,\n        target_time: &Duration,\n    ) -> Vec<u64> {\n        match self {\n            ActualSamplingMode::Linear => {\n                let n = sample_count;\n                let met = warmup_mean_execution_time;\n                let m_ns = target_time.as_nanos();\n                // Solve: [d + 2*d + 3*d + ... + n*d] * met = m_ns\n                let total_runs = n * (n + 1) / 2;\n                let d = ((m_ns as f64 / met / total_runs as f64).ceil() as u64).max(1);\n                let expected_ns = total_runs as f64 * d as f64 * met;\n\n                if d == 1 {\n                    let recommended_sample_size =\n                        ActualSamplingMode::recommend_linear_sample_size(m_ns as f64, met);\n                    let actual_time = Duration::from_nanos(expected_ns as u64);\n                    eprint!(\"\\nWarning: Unable to complete {} samples in {:.1?}. You may wish to increase target time to {:.1?}\",\n                            n, target_time, actual_time);\n\n                    if recommended_sample_size != n {\n                        eprintln!(\n                            \", enable flat sampling, or reduce sample count to {}.\",\n                            recommended_sample_size\n                        );\n                    } else {\n                        eprintln!(\" or enable flat sampling.\");\n                    }\n                }\n\n                (1..(n + 1)).map(|a| a * d).collect::<Vec<u64>>()\n            }\n            ActualSamplingMode::Flat => {\n                let n = sample_count;\n                let met = warmup_mean_execution_time;\n                let m_ns = target_time.as_nanos() as f64;\n                let time_per_sample = m_ns / (n as f64);\n                // This is pretty simplistic; we could do something smarter to fit into the allotted time.\n                let iterations_per_sample = ((time_per_sample / met).ceil() as u64).max(1);\n\n                let expected_ns = met * (iterations_per_sample * n) as f64;\n\n                if iterations_per_sample == 1 {\n                    let recommended_sample_size =\n                        ActualSamplingMode::recommend_flat_sample_size(m_ns, met);\n                    let actual_time = Duration::from_nanos(expected_ns as u64);\n                    eprint!(\"\\nWarning: Unable to complete {} samples in {:.1?}. You may wish to increase target time to {:.1?}\",\n                            n, target_time, actual_time);\n\n                    if recommended_sample_size != n {\n                        eprintln!(\", or reduce sample count to {}.\", recommended_sample_size);\n                    } else {\n                        eprintln!(\".\");\n                    }\n                }\n\n                vec![iterations_per_sample; n as usize]\n            }\n        }\n    }\n\n    fn is_linear(&self) -> bool {\n        matches!(self, ActualSamplingMode::Linear)\n    }\n\n    fn recommend_linear_sample_size(target_time: f64, met: f64) -> u64 {\n        // Some math shows that n(n+1)/2 * d * met = target_time. d = 1, so it can be ignored.\n        // This leaves n(n+1) = (2*target_time)/met, or n^2 + n - (2*target_time)/met = 0\n        // Which can be solved with the quadratic formula. Since A and B are constant 1,\n        // this simplifies to sample_size = (-1 +- sqrt(1 - 4C))/2, where C = (2*target_time)/met.\n        // We don't care about the negative solution. Experimentation shows that this actually tends to\n        // result in twice the desired execution time (probably because of the ceil used to calculate\n        // d) so instead I use c = target_time/met.\n        let c = target_time / met;\n        let sample_size = (-1.0 + (4.0 * c).sqrt()) / 2.0;\n        let sample_size = sample_size as u64;\n\n        // Round down to the nearest 10 to give a margin and avoid excessive precision\n        let sample_size = (sample_size / 10) * 10;\n\n        // Clamp it to be at least 10, since criterion.rs doesn't allow sample sizes smaller than 10.\n        if sample_size < 10 {\n            10\n        } else {\n            sample_size\n        }\n    }\n\n    fn recommend_flat_sample_size(target_time: f64, met: f64) -> u64 {\n        let sample_size = (target_time / met) as u64;\n\n        // Round down to the nearest 10 to give a margin and avoid excessive precision\n        let sample_size = (sample_size / 10) * 10;\n\n        // Clamp it to be at least 10, since criterion.rs doesn't allow sample sizes smaller than 10.\n        if sample_size < 10 {\n            10\n        } else {\n            sample_size\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub(crate) struct SavedSample {\n    sampling_mode: ActualSamplingMode,\n    iters: Vec<f64>,\n    times: Vec<f64>,\n}\n\n/// Custom-test-framework runner. Should not be called directly.\n#[doc(hidden)]\npub fn runner(benches: &[&dyn Fn()]) {\n    for bench in benches {\n        bench();\n    }\n    Criterion::default().configure_from_args().final_summary();\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Contains macros which together define a benchmark harness that can be used\n//! in place of the standard benchmark harness. This allows the user to run\n//! Criterion.rs benchmarks with `cargo bench`.\n\n/// Macro used to define a function group for the benchmark harness; see the\n/// [`criterion_main!`](crate::criterion_main) macro for more details.\n///\n/// This is used to define a function group; a collection of functions to call with a common\n/// Criterion configuration. Accepts two forms which can be seen below.\n///\n/// Note that the group name given here is not important, it must simply be\n/// unique. Note also that this macro is not related to the\n/// [`Criterion::benchmark_group`](crate::Criterion::benchmark_group)  function\n/// or the [`BenchmarkGroup`](crate::BenchmarkGroup) type.\n///\n/// # Examples:\n///\n/// Complete form:\n///\n/// ```\n/// # use criterion::{criterion_group, Criterion};\n/// # fn bench_method1(c: &mut Criterion) {\n/// # }\n/// #\n/// # fn bench_method2(c: &mut Criterion) {\n/// # }\n/// #\n/// criterion_group!{\n///     name = benches;\n///     config = Criterion::default();\n///     targets = bench_method1, bench_method2\n/// }\n/// #\n/// # fn main() {}\n/// ```\n///\n/// In this form, all of the options are clearly spelled out. This expands to\n/// a function named `benches`, which uses the given config expression to create\n/// an instance of the [`Criterion`](crate::Criterion) struct. This is then\n/// passed by mutable reference to the targets.\n///\n/// Compact Form:\n///\n/// ```\n/// # use criterion::{criterion_group, Criterion};\n/// # fn bench_method1(c: &mut Criterion) {\n/// # }\n/// #\n/// # fn bench_method2(c: &mut Criterion) {\n/// # }\n/// #\n/// criterion_group!(benches, bench_method1, bench_method2);\n/// #\n/// # fn main() {}\n/// ```\n/// In this form, the first parameter is the name of the group and subsequent\n/// parameters are the target methods. The Criterion struct will be created using\n/// the `Criterion::default()` function. If you wish to customize the\n/// configuration, use the complete form and provide your own configuration\n/// function.\n#[macro_export]\nmacro_rules! criterion_group {\n    (name = $name:ident; config = $config:expr; targets = $( $target:path ),+ $(,)*) => {\n        #[doc=\"The function which runs the benchmarks.\"]\n        pub fn $name() {\n            let mut criterion: $crate::Criterion<_> = $config\n                .configure_from_args();\n            $(\n                $target(&mut criterion);\n            )+\n        }\n    };\n    ($name:ident, $( $target:path ),+ $(,)*) => {\n        $crate::criterion_group!{\n            name = $name;\n            config = $crate::Criterion::default();\n            targets = $( $target ),+\n        }\n    }\n}\n\n/// Macro which expands to a benchmark harness.\n///\n/// Currently, using Criterion.rs requires disabling the benchmark harness\n/// generated automatically by rustc. This can be done like so:\n///\n/// ```toml\n/// [[bench]]\n/// name = \"my_bench\"\n/// harness = false\n/// ```\n///\n/// In this case, `my_bench` must be a rust file inside the 'benches' directory,\n/// like so:\n///\n/// `benches/my_bench.rs`\n///\n/// Since we've disabled the default benchmark harness, we need to add our own:\n///\n/// ```no_run\n/// use criterion::{criterion_group, criterion_main, Criterion};\n/// fn bench_method1(c: &mut Criterion) {\n/// }\n///\n/// fn bench_method2(c: &mut Criterion) {\n/// }\n///\n/// criterion_group!(benches, bench_method1, bench_method2);\n/// criterion_main!(benches);\n/// ```\n///\n/// The `criterion_main` macro expands to a `main` function which runs all of the\n/// benchmarks in the given groups.\n///\n#[macro_export]\nmacro_rules! criterion_main {\n    ( $( $group:path ),+ $(,)* ) => {\n        fn main() {\n            $(\n                $group();\n            )+\n\n            $crate::Criterion::default()\n                .configure_from_args()\n                .final_summary();\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Private macro used for error handling.\n\n/// Logs an error, ignores an `Ok` value.\nmacro_rules! log_if_err {\n    ($x:expr) => {\n        let closure = || {\n            try_else_return!($x);\n        };\n        closure();\n    };\n}\n\n/// Matches a result, returning the `Ok` value in case of success,\n/// exits the calling function otherwise.\n/// A closure which returns the return value for the function can\n/// be passed as second parameter.\nmacro_rules! try_else_return {\n    ($x:expr) => {\n        try_else_return!($x, || {})\n    };\n    ($x:expr, $el:expr) => {\n        match $x {\n            Ok(x) => x,\n            Err(e) => {\n                crate::error::log_error(&e);\n                let closure = $el;\n                return closure();\n            }\n        }\n    };\n}\n\n/// Print an error message to stdout. Format is the same as println! or format!\nmacro_rules! error {\n    ($($arg:tt)*) => (\n        println!(\"Criterion.rs ERROR: {}\", &format!($($arg)*))\n    )\n}\n\n/// Print a debug message to stdout. Format is the same as println! or format!\nmacro_rules! info {\n    ($($arg:tt)*) => (\n        if $crate::debug_enabled() {\n            println!(\"Criterion.rs DEBUG: {}\", &format!($($arg)*))\n        }\n    )\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! This module defines a set of traits that can be used to plug different measurements (eg.\n//! Unix's Processor Time, CPU or GPU performance counters, etc.) into Criterion.rs. It also\n//! includes the [`WallTime`] struct which defines the default wall-clock time measurement.\n\nuse crate::format::short;\nuse crate::Throughput;\nuse std::time::{Duration, Instant};\n\n/// Trait providing functions to format measured values to string so that they can be displayed on\n/// the command line or in the reports. The functions of this trait take measured values in f64\n/// form; implementors can assume that the values are of the same scale as those produced by the\n/// associated [`Measurement`] (eg. if your measurement produces values in nanoseconds, the\n/// values passed to the formatter will be in nanoseconds).\n///\n/// Implementors are encouraged to format the values in a way that is intuitive for humans and\n/// uses the SI prefix system. For example, the format used by [`WallTime`] can display the value\n/// in units ranging from picoseconds to seconds depending on the magnitude of the elapsed time\n/// in nanoseconds.\npub trait ValueFormatter {\n    /// Format the value (with appropriate unit) and return it as a string.\n    fn format_value(&self, value: f64) -> String {\n        let mut values = [value];\n        let unit = self.scale_values(value, &mut values);\n        format!(\"{:>6} {}\", short(values[0]), unit)\n    }\n\n    /// Format the value as a throughput measurement. The value represents the measurement value;\n    /// the implementor will have to calculate bytes per second, iterations per cycle, etc.\n    fn format_throughput(&self, throughput: &Throughput, value: f64) -> String {\n        let mut values = [value];\n        let unit = self.scale_throughputs(value, throughput, &mut values);\n        format!(\"{:>6} {}\", short(values[0]), unit)\n    }\n\n    /// Scale the given values to some appropriate unit and return the unit string.\n    ///\n    /// The given typical value should be used to choose the unit. This function may be called\n    /// multiple times with different datasets; the typical value will remain the same to ensure\n    /// that the units remain consistent within a graph. The typical value will not be NaN.\n    /// Values will not contain NaN as input, and the transformed values must not contain NaN.\n    fn scale_values(&self, typical_value: f64, values: &mut [f64]) -> &'static str;\n\n    /// Convert the given measured values into throughput numbers based on the given throughput\n    /// value, scale them to some appropriate unit, and return the unit string.\n    ///\n    /// The given typical value should be used to choose the unit. This function may be called\n    /// multiple times with different datasets; the typical value will remain the same to ensure\n    /// that the units remain consistent within a graph. The typical value will not be NaN.\n    /// Values will not contain NaN as input, and the transformed values must not contain NaN.\n    fn scale_throughputs(\n        &self,\n        typical_value: f64,\n        throughput: &Throughput,\n        values: &mut [f64],\n    ) -> &'static str;\n\n    /// Scale the values and return a unit string designed for machines.\n    ///\n    /// For example, this is used for the CSV file output. Implementations should modify the given\n    /// values slice to apply the desired scaling (if any) and return a string representing the unit\n    /// the modified values are in.\n    fn scale_for_machines(&self, values: &mut [f64]) -> &'static str;\n}\n\n/// Trait for all types which define something Criterion.rs can measure. The only measurement\n/// currently provided is [`WallTime`], but third party crates or benchmarks may define more.\n///\n/// This trait defines two core methods, `start` and `end`. `start` is called at the beginning of\n/// a measurement to produce some intermediate value (for example, the wall-clock time at the start\n/// of that set of iterations) and `end` is called at the end of the measurement with the value\n/// returned by `start`.\n///\npub trait Measurement {\n    /// This type represents an intermediate value for the measurements. It will be produced by the\n    /// start function and passed to the end function. An example might be the wall-clock time as\n    /// of the `start` call.\n    type Intermediate;\n\n    /// This type is the measured value. An example might be the elapsed wall-clock time between the\n    /// `start` and `end` calls.\n    type Value;\n\n    /// Criterion.rs will call this before iterating the benchmark.\n    fn start(&self) -> Self::Intermediate;\n\n    /// Criterion.rs will call this after iterating the benchmark to get the measured value.\n    fn end(&self, i: Self::Intermediate) -> Self::Value;\n\n    /// Combine two values. Criterion.rs sometimes needs to perform measurements in multiple batches\n    /// of iterations, so the value from one batch must be added to the sum of the previous batches.\n    fn add(&self, v1: &Self::Value, v2: &Self::Value) -> Self::Value;\n\n    /// Return a \"zero\" value for the Value type which can be added to another value.\n    fn zero(&self) -> Self::Value;\n\n    /// Converts the measured value to f64 so that it can be used in statistical analysis.\n    fn to_f64(&self, value: &Self::Value) -> f64;\n\n    /// Return a trait-object reference to the value formatter for this measurement.\n    fn formatter(&self) -> &dyn ValueFormatter;\n}\n\npub(crate) struct DurationFormatter;\nimpl DurationFormatter {\n    fn bytes_per_second(&self, bytes: f64, typical: f64, values: &mut [f64]) -> &'static str {\n        let bytes_per_second = bytes * (1e9 / typical);\n        let (denominator, unit) = if bytes_per_second < 1024.0 {\n            (1.0, \"  B/s\")\n        } else if bytes_per_second < 1024.0 * 1024.0 {\n            (1024.0, \"KiB/s\")\n        } else if bytes_per_second < 1024.0 * 1024.0 * 1024.0 {\n            (1024.0 * 1024.0, \"MiB/s\")\n        } else {\n            (1024.0 * 1024.0 * 1024.0, \"GiB/s\")\n        };\n\n        for val in values {\n            let bytes_per_second = bytes * (1e9 / *val);\n            *val = bytes_per_second / denominator;\n        }\n\n        unit\n    }\n\n    fn bytes_per_second_decimal(\n        &self,\n        bytes: f64,\n        typical: f64,\n        values: &mut [f64],\n    ) -> &'static str {\n        let bytes_per_second = bytes * (1e9 / typical);\n        let (denominator, unit) = if bytes_per_second < 1000.0 {\n            (1.0, \"  B/s\")\n        } else if bytes_per_second < 1000.0 * 1000.0 {\n            (1000.0, \"KB/s\")\n        } else if bytes_per_second < 1000.0 * 1000.0 * 1000.0 {\n            (1000.0 * 1000.0, \"MB/s\")\n        } else {\n            (1000.0 * 1000.0 * 1000.0, \"GB/s\")\n        };\n\n        for val in values {\n            let bytes_per_second = bytes * (1e9 / *val);\n            *val = bytes_per_second / denominator;\n        }\n\n        unit\n    }\n\n    fn elements_per_second(&self, elems: f64, typical: f64, values: &mut [f64]) -> &'static str {\n        let elems_per_second = elems * (1e9 / typical);\n        let (denominator, unit) = if elems_per_second < 1000.0 {\n            (1.0, \" elem/s\")\n        } else if elems_per_second < 1000.0 * 1000.0 {\n            (1000.0, \"Kelem/s\")\n        } else if elems_per_second < 1000.0 * 1000.0 * 1000.0 {\n            (1000.0 * 1000.0, \"Melem/s\")\n        } else {\n            (1000.0 * 1000.0 * 1000.0, \"Gelem/s\")\n        };\n\n        for val in values {\n            let elems_per_second = elems * (1e9 / *val);\n            *val = elems_per_second / denominator;\n        }\n\n        unit\n    }\n\n    fn bits_per_second(&self, bits: f64, typical: f64, values: &mut [f64]) -> &'static str {\n        let bits_per_second = bits * (1e9 / typical);\n        let (denominator, unit) = if bits_per_second < 1000.0 {\n            (1.0, \"  b/s\")\n        } else if bits_per_second < 1000.0 * 1000.0 {\n            (1000.0, \"Kb/s\")\n        } else if bits_per_second < 1000.0 * 1000.0 * 1000.0 {\n            (1000.0 * 1000.0, \"Mb/s\")\n        } else {\n            (1000.0 * 1000.0 * 1000.0, \"Gb/s\")\n        };\n\n        for val in values {\n            let bits_per_second = bits * (1e9 / *val);\n            *val = bits_per_second / denominator;\n        }\n\n        unit\n    }\n}\nimpl ValueFormatter for DurationFormatter {\n    fn scale_throughputs(\n        &self,\n        typical: f64,\n        throughput: &Throughput,\n        values: &mut [f64],\n    ) -> &'static str {\n        match *throughput {\n            Throughput::Bits(bits) => self.bits_per_second(bits as f64, typical, values),\n            Throughput::Bytes(bytes) => self.bytes_per_second(bytes as f64, typical, values),\n            Throughput::BytesDecimal(bytes) => {\n                self.bytes_per_second_decimal(bytes as f64, typical, values)\n            }\n            Throughput::Elements(elems) => self.elements_per_second(elems as f64, typical, values),\n            // The caller should be formatting the bytes and elements separately.\n            Throughput::ElementsAndBytes { elements, bytes: _ } => {\n                self.elements_per_second(elements as f64, typical, values)\n            }\n        }\n    }\n\n    fn scale_values(&self, ns: f64, values: &mut [f64]) -> &'static str {\n        let (factor, unit) = if ns < 10f64.powi(0) {\n            (10f64.powi(3), \"ps\")\n        } else if ns < 10f64.powi(3) {\n            (10f64.powi(0), \"ns\")\n        } else if ns < 10f64.powi(6) {\n            (10f64.powi(-3), \"s\")\n        } else if ns < 10f64.powi(9) {\n            (10f64.powi(-6), \"ms\")\n        } else {\n            (10f64.powi(-9), \"s\")\n        };\n\n        for val in values {\n            *val *= factor;\n        }\n\n        unit\n    }\n\n    fn scale_for_machines(&self, _values: &mut [f64]) -> &'static str {\n        // no scaling is needed\n        \"ns\"\n    }\n}\n\n/// `WallTime` is the default measurement in Criterion.rs. It measures the elapsed time from the\n/// beginning of a series of iterations to the end.\npub struct WallTime;\nimpl Measurement for WallTime {\n    type Intermediate = Instant;\n    type Value = Duration;\n\n    fn start(&self) -> Self::Intermediate {\n        Instant::now()\n    }\n    fn end(&self, i: Self::Intermediate) -> Self::Value {\n        i.elapsed()\n    }\n    fn add(&self, v1: &Self::Value, v2: &Self::Value) -> Self::Value {\n        *v1 + *v2\n    }\n    fn zero(&self) -> Self::Value {\n        Duration::from_secs(0)\n    }\n    fn to_f64(&self, val: &Self::Value) -> f64 {\n        val.as_nanos() as f64\n    }\n    fn formatter(&self) -> &dyn ValueFormatter {\n        &DurationFormatter\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! This module provides an extension trait which allows in-process profilers\n//! to be hooked into the `--profile-time` argument at compile-time. Users of\n//! out-of-process profilers such as perf don't need to do anything special.\n\nuse std::path::Path;\n\n/// Extension trait for external crates to implement which provides start/stop\n/// hooks when profiling (but not when benchmarking) functions.\npub trait Profiler {\n    /// This function is called when Criterion.rs starts profiling a particular\n    /// benchmark. It provides the stringified benchmark ID and\n    /// a path to a directory where the profiler can store its data.\n    fn start_profiling(&mut self, benchmark_id: &str, benchmark_dir: &Path);\n\n    /// This function is called after Criterion.rs stops profiling a particular\n    /// benchmark. The benchmark ID and directory are the same as in the call\n    /// to [`start_profiling`](Self::start_profiling), provided for convenience.\n    fn stop_profiling(&mut self, benchmark_id: &str, benchmark_dir: &Path);\n}\n\n/// Dummy profiler implementation, representing cases where the profiler is\n/// an external process (eg. perftools, etc.) which do not require start/stop\n/// hooks. This implementation does nothing and is used as the default.\npub struct ExternalProfiler;\nimpl Profiler for ExternalProfiler {\n    fn start_profiling(&mut self, _benchmark_id: &str, _benchmark_dir: &Path) {}\n    fn stop_profiling(&mut self, _benchmark_id: &str, _benchmark_dir: &Path) {}\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "#[cfg(feature = \"csv_output\")]\nuse crate::csv_report::FileCsvReport;\nuse crate::stats::bivariate::regression::Slope;\nuse crate::stats::univariate::outliers::tukey::LabeledSample;\nuse crate::{html::Html, stats::bivariate::Data};\n\nuse crate::estimate::{ChangeDistributions, ChangeEstimates, Distributions, Estimate, Estimates};\nuse crate::format;\nuse crate::measurement::ValueFormatter;\nuse crate::stats::univariate::Sample;\nuse crate::stats::Distribution;\nuse crate::{PlotConfiguration, Throughput};\nuse anes::{Attribute, ClearLine, Color, ResetAttributes, SetAttribute, SetForegroundColor};\nuse serde::{Deserialize, Serialize};\nuse std::cmp;\nuse std::collections::HashSet;\nuse std::fmt;\nuse std::io::stderr;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\n\nconst MAX_DIRECTORY_NAME_LEN: usize = 64;\nconst MAX_TITLE_LEN: usize = 100;\n\npub(crate) struct ComparisonData {\n    pub p_value: f64,\n    pub t_distribution: Distribution<f64>,\n    pub t_value: f64,\n    pub relative_estimates: ChangeEstimates,\n    pub relative_distributions: ChangeDistributions,\n    pub significance_threshold: f64,\n    pub noise_threshold: f64,\n    pub base_iter_counts: Vec<f64>,\n    pub base_sample_times: Vec<f64>,\n    pub base_avg_times: Vec<f64>,\n    pub base_estimates: Estimates,\n}\n\npub(crate) struct MeasurementData<'a> {\n    pub data: Data<'a, f64, f64>,\n    pub avg_times: LabeledSample<'a, f64>,\n    pub absolute_estimates: Estimates,\n    pub distributions: Distributions,\n    pub comparison: Option<ComparisonData>,\n    pub throughput: Option<Throughput>,\n}\nimpl<'a> MeasurementData<'a> {\n    pub fn iter_counts(&self) -> &Sample<f64> {\n        self.data.x()\n    }\n\n    #[cfg(feature = \"csv_output\")]\n    pub fn sample_times(&self) -> &Sample<f64> {\n        self.data.y()\n    }\n}\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq)]\npub enum ValueType {\n    Bytes,\n    Elements,\n    Bits,\n    Value,\n}\n\n#[derive(Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct BenchmarkId {\n    pub group_id: String,\n    pub function_id: Option<String>,\n    pub value_str: Option<String>,\n    pub throughput: Option<Throughput>,\n    full_id: String,\n    directory_name: String,\n    title: String,\n}\n\nfn truncate_to_character_boundary(s: &mut String, max_len: usize) {\n    let mut boundary = cmp::min(max_len, s.len());\n    while !s.is_char_boundary(boundary) {\n        boundary -= 1;\n    }\n    s.truncate(boundary);\n}\n\npub fn make_filename_safe(string: &str) -> String {\n    let mut string = string.replace(\n        &['?', '\"', '/', '\\\\', '*', '<', '>', ':', '|', '^'][..],\n        \"_\",\n    );\n\n    // Truncate to last character boundary before max length...\n    truncate_to_character_boundary(&mut string, MAX_DIRECTORY_NAME_LEN);\n\n    if cfg!(target_os = \"windows\") {\n        {\n            string = string\n                // On Windows, spaces in the end of the filename are ignored and will be trimmed.\n                //\n                // Without trimming ourselves, creating a directory `dir ` will silently create\n                // `dir` instead, but then operations on files like `dir /file` will fail.\n                //\n                // Also note that it's important to do this *after* trimming to MAX_DIRECTORY_NAME_LEN,\n                // otherwise it can trim again to a name with a trailing space.\n                .trim_end()\n                // On Windows, file names are not case-sensitive, so lowercase everything.\n                .to_lowercase();\n        }\n    }\n\n    string\n}\n\nimpl BenchmarkId {\n    pub fn new(\n        group_id: String,\n        function_id: Option<String>,\n        value_str: Option<String>,\n        throughput: Option<Throughput>,\n    ) -> BenchmarkId {\n        let full_id = match (&function_id, &value_str) {\n            (Some(func), Some(val)) => format!(\"{}/{}/{}\", group_id, func, val),\n            (Some(func), &None) => format!(\"{}/{}\", group_id, func),\n            (&None, Some(val)) => format!(\"{}/{}\", group_id, val),\n            (&None, &None) => group_id.clone(),\n        };\n\n        let mut title = full_id.clone();\n        truncate_to_character_boundary(&mut title, MAX_TITLE_LEN);\n        if title != full_id {\n            title.push_str(\"...\");\n        }\n\n        let directory_name = match (&function_id, &value_str) {\n            (Some(func), Some(val)) => format!(\n                \"{}/{}/{}\",\n                make_filename_safe(&group_id),\n                make_filename_safe(func),\n                make_filename_safe(val)\n            ),\n            (Some(func), &None) => format!(\n                \"{}/{}\",\n                make_filename_safe(&group_id),\n                make_filename_safe(func)\n            ),\n            (&None, Some(val)) => format!(\n                \"{}/{}\",\n                make_filename_safe(&group_id),\n                make_filename_safe(val)\n            ),\n            (&None, &None) => make_filename_safe(&group_id),\n        };\n\n        BenchmarkId {\n            group_id,\n            function_id,\n            value_str,\n            throughput,\n            full_id,\n            directory_name,\n            title,\n        }\n    }\n\n    pub fn id(&self) -> &str {\n        &self.full_id\n    }\n\n    pub fn as_title(&self) -> &str {\n        &self.title\n    }\n\n    pub fn as_directory_name(&self) -> &str {\n        &self.directory_name\n    }\n\n    pub fn as_number(&self) -> Option<f64> {\n        match self.throughput {\n            Some(Throughput::Bits(n))\n            | Some(Throughput::Bytes(n))\n            | Some(Throughput::BytesDecimal(n))\n            | Some(Throughput::Elements(n)) => Some(n as f64),\n            Some(Throughput::ElementsAndBytes { elements, bytes: _ }) => Some(elements as f64),\n            None => self\n                .value_str\n                .as_ref()\n                .and_then(|string| string.parse::<f64>().ok()),\n        }\n    }\n\n    pub fn value_type(&self) -> Option<ValueType> {\n        match self.throughput {\n            Some(Throughput::Bits(_)) => Some(ValueType::Bits),\n            Some(Throughput::Bytes(_)) => Some(ValueType::Bytes),\n            Some(Throughput::BytesDecimal(_)) => Some(ValueType::Bytes),\n            Some(Throughput::Elements(_)) => Some(ValueType::Elements),\n            Some(Throughput::ElementsAndBytes {\n                elements: _,\n                bytes: _,\n            }) => Some(ValueType::Elements),\n            None => self\n                .value_str\n                .as_ref()\n                .and_then(|string| string.parse::<f64>().ok())\n                .map(|_| ValueType::Value),\n        }\n    }\n\n    pub fn ensure_directory_name_unique(&mut self, existing_directories: &HashSet<String>) {\n        if !existing_directories.contains(self.as_directory_name()) {\n            return;\n        }\n\n        let mut counter = 2;\n        loop {\n            let new_dir_name = format!(\"{}_{}\", self.as_directory_name(), counter);\n            if !existing_directories.contains(&new_dir_name) {\n                self.directory_name = new_dir_name;\n                return;\n            }\n            counter += 1;\n        }\n    }\n\n    pub fn ensure_title_unique(&mut self, existing_titles: &HashSet<String>) {\n        if !existing_titles.contains(self.as_title()) {\n            return;\n        }\n\n        let mut counter = 2;\n        loop {\n            let new_title = format!(\"{} #{}\", self.as_title(), counter);\n            if !existing_titles.contains(&new_title) {\n                self.title = new_title;\n                return;\n            }\n            counter += 1;\n        }\n    }\n}\nimpl fmt::Display for BenchmarkId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(self.as_title())\n    }\n}\nimpl fmt::Debug for BenchmarkId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fn format_opt(opt: &Option<String>) -> String {\n            match *opt {\n                Some(ref string) => format!(\"\\\"{}\\\"\", string),\n                None => \"None\".to_owned(),\n            }\n        }\n\n        write!(\n            f,\n            \"BenchmarkId {{ group_id: \\\"{}\\\", function_id: {}, value_str: {}, throughput: {:?} }}\",\n            self.group_id,\n            format_opt(&self.function_id),\n            format_opt(&self.value_str),\n            self.throughput,\n        )\n    }\n}\n\npub struct ReportContext {\n    pub output_directory: PathBuf,\n    pub plot_config: PlotConfiguration,\n}\nimpl ReportContext {\n    pub fn report_path<P: AsRef<Path> + ?Sized>(&self, id: &BenchmarkId, file_name: &P) -> PathBuf {\n        let mut path = self.output_directory.clone();\n        path.push(id.as_directory_name());\n        path.push(\"report\");\n        path.push(file_name);\n        path\n    }\n}\n\npub(crate) trait Report {\n    fn test_start(&self, _id: &BenchmarkId, _context: &ReportContext) {}\n    fn test_pass(&self, _id: &BenchmarkId, _context: &ReportContext) {}\n\n    fn benchmark_start(&self, _id: &BenchmarkId, _context: &ReportContext) {}\n    fn profile(&self, _id: &BenchmarkId, _context: &ReportContext, _profile_ns: f64) {}\n    fn warmup(&self, _id: &BenchmarkId, _context: &ReportContext, _warmup_ns: f64) {}\n    fn terminated(&self, _id: &BenchmarkId, _context: &ReportContext) {}\n    fn analysis(&self, _id: &BenchmarkId, _context: &ReportContext) {}\n    fn measurement_start(\n        &self,\n        _id: &BenchmarkId,\n        _context: &ReportContext,\n        _sample_count: u64,\n        _estimate_ns: f64,\n        _iter_count: u64,\n    ) {\n    }\n    fn measurement_complete(\n        &self,\n        _id: &BenchmarkId,\n        _context: &ReportContext,\n        _measurements: &MeasurementData<'_>,\n        _formatter: &dyn ValueFormatter,\n    ) {\n    }\n    fn summarize(\n        &self,\n        _context: &ReportContext,\n        _all_ids: &[BenchmarkId],\n        _formatter: &dyn ValueFormatter,\n    ) {\n    }\n    fn final_summary(&self, _context: &ReportContext) {}\n    fn group_separator(&self) {}\n}\n\npub(crate) struct Reports {\n    pub(crate) cli_enabled: bool,\n    pub(crate) cli: CliReport,\n    pub(crate) bencher_enabled: bool,\n    pub(crate) bencher: BencherReport,\n    pub(crate) csv_enabled: bool,\n    pub(crate) html: Option<Html>,\n}\nmacro_rules! reports_impl {\n    (fn $name:ident(&self, $($argn:ident: $argt:ty),*)) => {\n        fn $name(&self, $($argn: $argt),* ) {\n            if self.cli_enabled {\n                self.cli.$name($($argn),*);\n            }\n            if self.bencher_enabled {\n                self.bencher.$name($($argn),*);\n            }\n            #[cfg(feature = \"csv_output\")]\n            if self.csv_enabled {\n                FileCsvReport.$name($($argn),*);\n            }\n            if let Some(reporter) = &self.html {\n                reporter.$name($($argn),*);\n            }\n        }\n    };\n}\n\nimpl Report for Reports {\n    reports_impl!(fn test_start(&self, id: &BenchmarkId, context: &ReportContext));\n    reports_impl!(fn test_pass(&self, id: &BenchmarkId, context: &ReportContext));\n    reports_impl!(fn benchmark_start(&self, id: &BenchmarkId, context: &ReportContext));\n    reports_impl!(fn profile(&self, id: &BenchmarkId, context: &ReportContext, profile_ns: f64));\n    reports_impl!(fn warmup(&self, id: &BenchmarkId, context: &ReportContext, warmup_ns: f64));\n    reports_impl!(fn terminated(&self, id: &BenchmarkId, context: &ReportContext));\n    reports_impl!(fn analysis(&self, id: &BenchmarkId, context: &ReportContext));\n    reports_impl!(fn measurement_start(\n        &self,\n        id: &BenchmarkId,\n        context: &ReportContext,\n        sample_count: u64,\n        estimate_ns: f64,\n        iter_count: u64\n    ));\n    reports_impl!(\n    fn measurement_complete(\n        &self,\n        id: &BenchmarkId,\n        context: &ReportContext,\n        measurements: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter\n    ));\n    reports_impl!(\n    fn summarize(\n        &self,\n        context: &ReportContext,\n        all_ids: &[BenchmarkId],\n        formatter: &dyn ValueFormatter\n    ));\n\n    reports_impl!(fn final_summary(&self, context: &ReportContext));\n    reports_impl!(fn group_separator(&self, ));\n}\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq)]\npub(crate) enum CliVerbosity {\n    Quiet,\n    Normal,\n    Verbose,\n}\n\npub(crate) struct CliReport {\n    pub enable_text_overwrite: bool,\n    pub enable_text_coloring: bool,\n    pub verbosity: CliVerbosity,\n}\nimpl CliReport {\n    pub fn new(\n        enable_text_overwrite: bool,\n        enable_text_coloring: bool,\n        verbosity: CliVerbosity,\n    ) -> CliReport {\n        CliReport {\n            enable_text_overwrite,\n            enable_text_coloring,\n            verbosity,\n        }\n    }\n\n    fn text_overwrite(&self) {\n        if self.enable_text_overwrite {\n            eprint!(\"\\r{}\", ClearLine::All);\n        }\n    }\n\n    // Passing a String is the common case here.\n    #[allow(clippy::needless_pass_by_value)]\n    fn print_overwritable(&self, s: String) {\n        if self.enable_text_overwrite {\n            eprint!(\"{}\", s);\n            stderr().flush().unwrap();\n        } else {\n            eprintln!(\"{}\", s);\n        }\n    }\n\n    fn with_color(&self, color: Color, s: &str) -> String {\n        if self.enable_text_coloring {\n            format!(\"{}{}{}\", SetForegroundColor(color), s, ResetAttributes)\n        } else {\n            String::from(s)\n        }\n    }\n\n    fn green(&self, s: &str) -> String {\n        self.with_color(Color::DarkGreen, s)\n    }\n\n    fn yellow(&self, s: &str) -> String {\n        self.with_color(Color::DarkYellow, s)\n    }\n\n    fn red(&self, s: &str) -> String {\n        self.with_color(Color::DarkRed, s)\n    }\n\n    fn bold(&self, s: String) -> String {\n        if self.enable_text_coloring {\n            format!(\"{}{}{}\", SetAttribute(Attribute::Bold), s, ResetAttributes)\n        } else {\n            s\n        }\n    }\n\n    fn faint(&self, s: String) -> String {\n        if self.enable_text_coloring {\n            format!(\"{}{}{}\", SetAttribute(Attribute::Faint), s, ResetAttributes)\n        } else {\n            s\n        }\n    }\n\n    pub fn outliers(&self, sample: &LabeledSample<'_, f64>) {\n        let (los, lom, _, him, his) = sample.count();\n        let noutliers = los + lom + him + his;\n        let sample_size = sample.len();\n\n        if noutliers == 0 {\n            return;\n        }\n\n        let percent = |n: usize| 100. * n as f64 / sample_size as f64;\n\n        println!(\n            \"{}\",\n            self.yellow(&format!(\n                \"Found {} outliers among {} measurements ({:.2}%)\",\n                noutliers,\n                sample_size,\n                percent(noutliers)\n            ))\n        );\n\n        let print = |n, label| {\n            if n != 0 {\n                println!(\"  {} ({:.2}%) {}\", n, percent(n), label);\n            }\n        };\n\n        print(los, \"low severe\");\n        print(lom, \"low mild\");\n        print(him, \"high mild\");\n        print(his, \"high severe\");\n    }\n}\nimpl Report for CliReport {\n    fn test_start(&self, id: &BenchmarkId, _: &ReportContext) {\n        println!(\"Testing {}\", id);\n    }\n    fn test_pass(&self, _: &BenchmarkId, _: &ReportContext) {\n        println!(\"Success\");\n    }\n\n    fn benchmark_start(&self, id: &BenchmarkId, _: &ReportContext) {\n        self.print_overwritable(format!(\"Benchmarking {}\", id));\n    }\n\n    fn profile(&self, id: &BenchmarkId, _: &ReportContext, warmup_ns: f64) {\n        self.text_overwrite();\n        self.print_overwritable(format!(\n            \"Benchmarking {}: Profiling for {}\",\n            id,\n            format::time(warmup_ns)\n        ));\n    }\n\n    fn warmup(&self, id: &BenchmarkId, _: &ReportContext, warmup_ns: f64) {\n        self.text_overwrite();\n        self.print_overwritable(format!(\n            \"Benchmarking {}: Warming up for {}\",\n            id,\n            format::time(warmup_ns)\n        ));\n    }\n\n    fn terminated(&self, id: &BenchmarkId, _: &ReportContext) {\n        self.text_overwrite();\n        println!(\"Benchmarking {}: Complete (Analysis Disabled)\", id);\n    }\n\n    fn analysis(&self, id: &BenchmarkId, _: &ReportContext) {\n        self.text_overwrite();\n        self.print_overwritable(format!(\"Benchmarking {}: Analyzing\", id));\n    }\n\n    fn measurement_start(\n        &self,\n        id: &BenchmarkId,\n        _: &ReportContext,\n        sample_count: u64,\n        estimate_ns: f64,\n        iter_count: u64,\n    ) {\n        self.text_overwrite();\n        let iter_string = if matches!(self.verbosity, CliVerbosity::Verbose) {\n            format!(\"{} iterations\", iter_count)\n        } else {\n            format::iter_count(iter_count)\n        };\n\n        self.print_overwritable(format!(\n            \"Benchmarking {}: Collecting {} samples in estimated {} ({})\",\n            id,\n            sample_count,\n            format::time(estimate_ns),\n            iter_string\n        ));\n    }\n\n    fn measurement_complete(\n        &self,\n        id: &BenchmarkId,\n        _: &ReportContext,\n        meas: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) {\n        self.text_overwrite();\n\n        let typical_estimate = &meas.absolute_estimates.typical();\n\n        {\n            let mut id = id.as_title().to_owned();\n\n            if id.len() > 23 {\n                println!(\"{}\", self.green(&id));\n                id.clear();\n            }\n            let id_len = id.len();\n\n            println!(\n                \"{}{}time:   [{} {} {}]\",\n                self.green(&id),\n                \" \".repeat(24 - id_len),\n                self.faint(\n                    formatter.format_value(typical_estimate.confidence_interval.lower_bound)\n                ),\n                self.bold(formatter.format_value(typical_estimate.point_estimate)),\n                self.faint(\n                    formatter.format_value(typical_estimate.confidence_interval.upper_bound)\n                )\n            );\n        }\n\n        for ref throughput in measurement_throughputs(meas) {\n            println!(\n                \"{}thrpt:  [{} {} {}]\",\n                \" \".repeat(24),\n                self.faint(formatter.format_throughput(\n                    throughput,\n                    typical_estimate.confidence_interval.upper_bound\n                )),\n                self.bold(formatter.format_throughput(throughput, typical_estimate.point_estimate)),\n                self.faint(formatter.format_throughput(\n                    throughput,\n                    typical_estimate.confidence_interval.lower_bound\n                )),\n            );\n        }\n\n        if !matches!(self.verbosity, CliVerbosity::Quiet) {\n            if let Some(ref comp) = meas.comparison {\n                let different_mean = comp.p_value < comp.significance_threshold;\n                let mean_est = &comp.relative_estimates.mean;\n                let point_estimate = mean_est.point_estimate;\n                let mut point_estimate_str = format::change(point_estimate, true);\n                // The change in throughput is related to the change in timing. Reducing the timing by\n                // 50% increases the throughput by 100%.\n                let to_thrpt_estimate = |ratio: f64| 1.0 / (1.0 + ratio) - 1.0;\n                let mut thrpt_point_estimate_str =\n                    format::change(to_thrpt_estimate(point_estimate), true);\n                let explanation_str: String;\n\n                if !different_mean {\n                    explanation_str = \"No change in performance detected.\".to_owned();\n                } else {\n                    let comparison = compare_to_threshold(mean_est, comp.noise_threshold);\n                    match comparison {\n                        ComparisonResult::Improved => {\n                            point_estimate_str = self.green(&self.bold(point_estimate_str));\n                            thrpt_point_estimate_str =\n                                self.green(&self.bold(thrpt_point_estimate_str));\n                            explanation_str =\n                                format!(\"Performance has {}.\", self.green(\"improved\"));\n                        }\n                        ComparisonResult::Regressed => {\n                            point_estimate_str = self.red(&self.bold(point_estimate_str));\n                            thrpt_point_estimate_str =\n                                self.red(&self.bold(thrpt_point_estimate_str));\n                            explanation_str = format!(\"Performance has {}.\", self.red(\"regressed\"));\n                        }\n                        ComparisonResult::NonSignificant => {\n                            explanation_str = \"Change within noise threshold.\".to_owned();\n                        }\n                    }\n                }\n\n                if meas.throughput.is_some() {\n                    println!(\"{}change:\", \" \".repeat(17));\n\n                    println!(\n                        \"{}time:   [{} {} {}] (p = {:.2} {} {:.2})\",\n                        \" \".repeat(24),\n                        self.faint(format::change(\n                            mean_est.confidence_interval.lower_bound,\n                            true\n                        )),\n                        point_estimate_str,\n                        self.faint(format::change(\n                            mean_est.confidence_interval.upper_bound,\n                            true\n                        )),\n                        comp.p_value,\n                        if different_mean { \"<\" } else { \">\" },\n                        comp.significance_threshold\n                    );\n                    println!(\n                        \"{}thrpt:  [{} {} {}]\",\n                        \" \".repeat(24),\n                        self.faint(format::change(\n                            to_thrpt_estimate(mean_est.confidence_interval.upper_bound),\n                            true\n                        )),\n                        thrpt_point_estimate_str,\n                        self.faint(format::change(\n                            to_thrpt_estimate(mean_est.confidence_interval.lower_bound),\n                            true\n                        )),\n                    );\n                } else {\n                    println!(\n                        \"{}change: [{} {} {}] (p = {:.2} {} {:.2})\",\n                        \" \".repeat(24),\n                        self.faint(format::change(\n                            mean_est.confidence_interval.lower_bound,\n                            true\n                        )),\n                        point_estimate_str,\n                        self.faint(format::change(\n                            mean_est.confidence_interval.upper_bound,\n                            true\n                        )),\n                        comp.p_value,\n                        if different_mean { \"<\" } else { \">\" },\n                        comp.significance_threshold\n                    );\n                }\n\n                println!(\"{}{}\", \" \".repeat(24), explanation_str);\n            }\n        }\n\n        if !matches!(self.verbosity, CliVerbosity::Quiet) {\n            self.outliers(&meas.avg_times);\n        }\n\n        if matches!(self.verbosity, CliVerbosity::Verbose) {\n            let format_short_estimate = |estimate: &Estimate| -> String {\n                format!(\n                    \"[{} {}]\",\n                    formatter.format_value(estimate.confidence_interval.lower_bound),\n                    formatter.format_value(estimate.confidence_interval.upper_bound)\n                )\n            };\n\n            let data = &meas.data;\n            if let Some(slope_estimate) = meas.absolute_estimates.slope.as_ref() {\n                println!(\n                    \"{:<7}{} {:<15}[{:0.7} {:0.7}]\",\n                    \"slope\",\n                    format_short_estimate(slope_estimate),\n                    \"R^2\",\n                    Slope(slope_estimate.confidence_interval.lower_bound).r_squared(data),\n                    Slope(slope_estimate.confidence_interval.upper_bound).r_squared(data),\n                );\n            }\n            println!(\n                \"{:<7}{} {:<15}{}\",\n                \"mean\",\n                format_short_estimate(&meas.absolute_estimates.mean),\n                \"std. dev.\",\n                format_short_estimate(&meas.absolute_estimates.std_dev),\n            );\n            println!(\n                \"{:<7}{} {:<15}{}\",\n                \"median\",\n                format_short_estimate(&meas.absolute_estimates.median),\n                \"med. abs. dev.\",\n                format_short_estimate(&meas.absolute_estimates.median_abs_dev),\n            );\n        }\n    }\n\n    fn group_separator(&self) {\n        println!();\n    }\n}\n\npub struct BencherReport;\nimpl Report for BencherReport {\n    fn measurement_start(\n        &self,\n        id: &BenchmarkId,\n        _context: &ReportContext,\n        _sample_count: u64,\n        _estimate_ns: f64,\n        _iter_count: u64,\n    ) {\n        print!(\"test {} ... \", id);\n    }\n\n    fn measurement_complete(\n        &self,\n        _id: &BenchmarkId,\n        _: &ReportContext,\n        meas: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) {\n        let mut values = [\n            meas.absolute_estimates.median.point_estimate,\n            meas.absolute_estimates.std_dev.point_estimate,\n        ];\n        let unit = formatter.scale_for_machines(&mut values);\n\n        println!(\n            \"bench: {:>11} {}/iter (+/- {})\",\n            format::integer(values[0]),\n            unit,\n            format::integer(values[1])\n        );\n    }\n\n    fn group_separator(&self) {\n        println!();\n    }\n}\n\nenum ComparisonResult {\n    Improved,\n    Regressed,\n    NonSignificant,\n}\n\nfn compare_to_threshold(estimate: &Estimate, noise: f64) -> ComparisonResult {\n    let ci = &estimate.confidence_interval;\n    let lb = ci.lower_bound;\n    let ub = ci.upper_bound;\n\n    if lb < -noise && ub < -noise {\n        ComparisonResult::Improved\n    } else if lb > noise && ub > noise {\n        ComparisonResult::Regressed\n    } else {\n        ComparisonResult::NonSignificant\n    }\n}\n\nfn measurement_throughputs(mes: &MeasurementData<'_>) -> Vec<Throughput> {\n    mes.throughput\n        .as_ref()\n        .map(|t| match t {\n            Throughput::ElementsAndBytes { elements, bytes } => {\n                vec![Throughput::Elements(*elements), Throughput::Bytes(*bytes)]\n            }\n            _ => vec![t.clone()],\n        })\n        .unwrap_or(vec![])\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_make_filename_safe_replaces_characters() {\n        let input = \"?/\\\\*\\\"\";\n        let safe = make_filename_safe(input);\n        assert_eq!(\"_____\", &safe);\n    }\n\n    #[test]\n    fn test_make_filename_safe_truncates_long_strings() {\n        let input = \"this is a very long string. it is too long to be safe as a directory name, and so it needs to be truncated. what a long string this is.\";\n        let safe = make_filename_safe(input);\n        assert!(input.len() > MAX_DIRECTORY_NAME_LEN);\n        assert_eq!(&input[0..MAX_DIRECTORY_NAME_LEN], &safe);\n    }\n\n    #[test]\n    fn test_make_filename_safe_respects_character_boundaries() {\n        let input = \"\";\n        let safe = make_filename_safe(input);\n        assert!(safe.len() < MAX_DIRECTORY_NAME_LEN);\n    }\n\n    #[test]\n    fn test_benchmark_id_make_directory_name_unique() {\n        let existing_id = BenchmarkId::new(\n            \"group\".to_owned(),\n            Some(\"function\".to_owned()),\n            Some(\"value\".to_owned()),\n            None,\n        );\n        let mut directories = HashSet::new();\n        directories.insert(existing_id.as_directory_name().to_owned());\n\n        let mut new_id = existing_id.clone();\n        new_id.ensure_directory_name_unique(&directories);\n        assert_eq!(\"group/function/value_2\", new_id.as_directory_name());\n        directories.insert(new_id.as_directory_name().to_owned());\n\n        new_id = existing_id;\n        new_id.ensure_directory_name_unique(&directories);\n        assert_eq!(\"group/function/value_3\", new_id.as_directory_name());\n        directories.insert(new_id.as_directory_name().to_owned());\n    }\n    #[test]\n    fn test_benchmark_id_make_long_directory_name_unique() {\n        let long_name = (0..MAX_DIRECTORY_NAME_LEN).map(|_| 'a').collect::<String>();\n        let existing_id = BenchmarkId::new(long_name, None, None, None);\n        let mut directories = HashSet::new();\n        directories.insert(existing_id.as_directory_name().to_owned());\n\n        let mut new_id = existing_id.clone();\n        new_id.ensure_directory_name_unique(&directories);\n        assert_ne!(existing_id.as_directory_name(), new_id.as_directory_name());\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use {\n    crate::{\n        benchmark::BenchmarkConfig,\n        connection::OutgoingMessage,\n        measurement::Measurement,\n        report::{BenchmarkId, Report, ReportContext},\n        ActualSamplingMode, Bencher, Criterion,\n    },\n    std::{hint::black_box, marker::PhantomData, time::Duration},\n};\n\n/// PRIVATE\npub(crate) trait Routine<M: Measurement, T: ?Sized> {\n    /// PRIVATE\n    fn bench(&mut self, m: &M, iters: &[u64], parameter: &T) -> Vec<f64>;\n    /// PRIVATE\n    fn warm_up(&mut self, m: &M, how_long: Duration, parameter: &T) -> (u64, u64);\n\n    /// PRIVATE\n    fn test(&mut self, m: &M, parameter: &T) {\n        self.bench(m, &[1u64], parameter);\n    }\n\n    /// Iterates the benchmarked function for a fixed length of time, but takes no measurements.\n    /// This keeps the overall benchmark suite runtime constant-ish even when running under a\n    /// profiler with an unknown amount of overhead. Since no measurements are taken, it also\n    /// reduces the amount of time the execution spends in Criterion.rs code, which should help\n    /// show the performance of the benchmarked code more clearly as well.\n    fn profile(\n        &mut self,\n        measurement: &M,\n        id: &BenchmarkId,\n        criterion: &Criterion<M>,\n        report_context: &ReportContext,\n        time: Duration,\n        parameter: &T,\n    ) {\n        criterion\n            .report\n            .profile(id, report_context, time.as_nanos() as f64);\n\n        let mut profile_path = report_context.output_directory.clone();\n        if crate::cargo_criterion_connection().is_some() {\n            // If connected to cargo-criterion, generate a cargo-criterion-style path.\n            // This is kind of a hack.\n            profile_path.push(\"profile\");\n            profile_path.push(id.as_directory_name());\n        } else {\n            profile_path.push(id.as_directory_name());\n            profile_path.push(\"profile\");\n        }\n        criterion\n            .profiler\n            .borrow_mut()\n            .start_profiling(id.id(), &profile_path);\n\n        let time = time.as_nanos() as u64;\n\n        // TODO: Some profilers will show the two batches of iterations as\n        // being different code-paths even though they aren't really.\n\n        // Get the warmup time for one second\n        let (wu_elapsed, wu_iters) = self.warm_up(measurement, Duration::from_secs(1), parameter);\n        if wu_elapsed < time {\n            // Initial guess for the mean execution time\n            let met = wu_elapsed as f64 / wu_iters as f64;\n\n            // Guess how many iterations will be required for the remaining time\n            let remaining = (time - wu_elapsed) as f64;\n\n            let iters = remaining / met;\n            let iters = iters as u64;\n\n            self.bench(measurement, &[iters], parameter);\n        }\n\n        criterion\n            .profiler\n            .borrow_mut()\n            .stop_profiling(id.id(), &profile_path);\n\n        criterion.report.terminated(id, report_context);\n    }\n\n    fn sample(\n        &mut self,\n        measurement: &M,\n        id: &BenchmarkId,\n        config: &BenchmarkConfig,\n        criterion: &Criterion<M>,\n        report_context: &ReportContext,\n        parameter: &T,\n    ) -> (ActualSamplingMode, Box<[f64]>, Box<[f64]>) {\n        if config.quick_mode {\n            let minimum_bench_duration = Duration::from_millis(100);\n            let maximum_bench_duration = config.measurement_time; // default: 5 seconds\n            let target_rel_stdev = config.significance_level; // default: 5%, 0.05\n\n            use std::time::Instant;\n            let time_start = Instant::now();\n\n            let sq = |val| val * val;\n            let mut n = 1;\n            let mut t_prev = *self.bench(measurement, &[n], parameter).first().unwrap();\n\n            // Early exit for extremely long running benchmarks:\n            if time_start.elapsed() > maximum_bench_duration {\n                let iters = vec![n as f64, n as f64].into_boxed_slice();\n                // prevent plotting bug where KDE estimation results in NaN when all values are equal because\n                // the stddev is 0.\n                let elapsed = vec![t_prev, t_prev.next_up()].into_boxed_slice();\n                return (ActualSamplingMode::Flat, iters, elapsed);\n            }\n\n            // Main data collection loop.\n            loop {\n                let t_now = *self\n                    .bench(measurement, &[n * 2], parameter)\n                    .first()\n                    .unwrap();\n                let t = (t_prev + 2. * t_now) / 5.;\n                let stdev = (sq(t_prev - t) + sq(t_now - 2. * t)).sqrt();\n                // println!(\"Sample: {} {:.2}\", n, stdev / t);\n                let elapsed = time_start.elapsed();\n                if (stdev < target_rel_stdev * t && elapsed > minimum_bench_duration)\n                    || elapsed > maximum_bench_duration\n                {\n                    let iters = vec![n as f64, (n * 2) as f64].into_boxed_slice();\n                    let elapsed = vec![t_prev, t_now].into_boxed_slice();\n                    return (ActualSamplingMode::Linear, iters, elapsed);\n                }\n                n *= 2;\n                t_prev = t_now;\n            }\n        }\n        let wu = config.warm_up_time;\n        let m_ns = config.measurement_time.as_nanos();\n\n        criterion\n            .report\n            .warmup(id, report_context, wu.as_nanos() as f64);\n\n        if let Some(conn) = &criterion.connection {\n            conn.send(&OutgoingMessage::Warmup {\n                id: id.into(),\n                nanos: wu.as_nanos() as f64,\n            })\n            .unwrap();\n        }\n\n        let (wu_elapsed, wu_iters) = self.warm_up(measurement, wu, parameter);\n        if crate::debug_enabled() {\n            println!(\n                \"\\nCompleted {} iterations in {} nanoseconds, estimated execution time is {} ns\",\n                wu_iters,\n                wu_elapsed,\n                wu_elapsed as f64 / wu_iters as f64\n            );\n        }\n\n        // Initial guess for the mean execution time\n        let met = wu_elapsed as f64 / wu_iters as f64;\n\n        let n = config.sample_size as u64;\n\n        let actual_sampling_mode = config\n            .sampling_mode\n            .choose_sampling_mode(met, n, m_ns as f64);\n\n        let m_iters = actual_sampling_mode.iteration_counts(met, n, &config.measurement_time);\n\n        let expected_ns = m_iters\n            .iter()\n            .copied()\n            .map(|count| count as f64 * met)\n            .sum();\n\n        // Use saturating_add to handle overflow.\n        let mut total_iters = 0u64;\n        for count in m_iters.iter().copied() {\n            total_iters = total_iters.saturating_add(count);\n        }\n\n        criterion\n            .report\n            .measurement_start(id, report_context, n, expected_ns, total_iters);\n\n        if let Some(conn) = &criterion.connection {\n            conn.send(&OutgoingMessage::MeasurementStart {\n                id: id.into(),\n                sample_count: n,\n                estimate_ns: expected_ns,\n                iter_count: total_iters,\n            })\n            .unwrap();\n        }\n\n        let m_elapsed = self.bench(measurement, &m_iters, parameter);\n\n        let m_iters_f: Vec<f64> = m_iters.iter().map(|&x| x as f64).collect();\n\n        (\n            actual_sampling_mode,\n            m_iters_f.into_boxed_slice(),\n            m_elapsed.into_boxed_slice(),\n        )\n    }\n}\n\npub struct Function<M: Measurement, F, T>\nwhere\n    F: FnMut(&mut Bencher<'_, M>, &T),\n    T: ?Sized,\n{\n    f: F,\n    // TODO: Is there some way to remove these?\n    _phantom: PhantomData<T>,\n    _phamtom2: PhantomData<M>,\n}\nimpl<M: Measurement, F, T> Function<M, F, T>\nwhere\n    F: FnMut(&mut Bencher<'_, M>, &T),\n    T: ?Sized,\n{\n    pub fn new(f: F) -> Function<M, F, T> {\n        Function {\n            f,\n            _phantom: PhantomData,\n            _phamtom2: PhantomData,\n        }\n    }\n}\n\nimpl<M: Measurement, F, T> Routine<M, T> for Function<M, F, T>\nwhere\n    F: FnMut(&mut Bencher<'_, M>, &T),\n    T: ?Sized,\n{\n    fn bench(&mut self, m: &M, iters: &[u64], parameter: &T) -> Vec<f64> {\n        let f = &mut self.f;\n\n        let mut b = Bencher {\n            iterated: false,\n            iters: 0,\n            value: m.zero(),\n            measurement: m,\n            elapsed_time: Duration::from_millis(0),\n        };\n\n        let mut results = Vec::with_capacity(iters.len());\n        results.resize(iters.len(), 0.0);\n        for (i, iters) in iters.iter().enumerate() {\n            #[cfg(any(target_family = \"unix\", target_family = \"windows\"))]\n            {\n                // Intentionally vary the stack allocation size to reduce measurement bias from\n                // memory alignment and cache effects.\n                // The shift can go up to a full page size suitable for the system.\n                alloca::with_alloca(\n                    i % page_size::get(), /* how many bytes we want to allocate */\n                    |_shifting_stack_space: &mut [core::mem::MaybeUninit<u8>] /* stack allocated slice itself */| {\n                        b.iters = *iters;\n                        (*f)(&mut b, black_box(parameter));\n                        b.assert_iterated();\n                        results[i] = m.to_f64(&b.value);\n                    },\n                );\n            }\n            #[cfg(not(any(target_family = \"unix\", target_family = \"windows\")))]\n            {\n                b.iters = *iters;\n                (*f)(&mut b, black_box(parameter));\n                b.assert_iterated();\n                results[i] = m.to_f64(&b.value);\n            }\n        }\n        results\n    }\n\n    fn warm_up(&mut self, m: &M, how_long: Duration, parameter: &T) -> (u64, u64) {\n        let f = &mut self.f;\n        let mut b = Bencher {\n            iterated: false,\n            iters: 1,\n            value: m.zero(),\n            measurement: m,\n            elapsed_time: Duration::from_millis(0),\n        };\n\n        let mut total_iters = 0;\n        let mut elapsed_time = Duration::from_millis(0);\n        loop {\n            (*f)(&mut b, black_box(parameter));\n\n            b.assert_iterated();\n\n            total_iters += b.iters;\n            elapsed_time += b.elapsed_time;\n            if elapsed_time > how_long {\n                return (elapsed_time.as_nanos() as u64, total_iters);\n            }\n\n            b.iters = b.iters.wrapping_mul(2);\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::univariate::Sample;\nuse crate::stats::univariate::{self, mixed};\nuse crate::stats::Distribution;\n\nuse crate::benchmark::BenchmarkConfig;\nuse crate::error::Result;\nuse crate::estimate::{\n    build_change_estimates, ChangeDistributions, ChangeEstimates, ChangePointEstimates, Estimates,\n};\nuse crate::measurement::Measurement;\nuse crate::report::BenchmarkId;\nuse crate::{fs, Criterion, SavedSample};\n\n// Common comparison procedure\n#[allow(clippy::type_complexity)]\npub(crate) fn common<M: Measurement>(\n    id: &BenchmarkId,\n    avg_times: &Sample<f64>,\n    config: &BenchmarkConfig,\n    criterion: &Criterion<M>,\n) -> Result<(\n    f64,\n    Distribution<f64>,\n    ChangeEstimates,\n    ChangeDistributions,\n    Vec<f64>,\n    Vec<f64>,\n    Vec<f64>,\n    Estimates,\n)> {\n    let mut sample_file = criterion.output_directory.clone();\n    sample_file.push(id.as_directory_name());\n    sample_file.push(&criterion.baseline_directory);\n    sample_file.push(\"sample.json\");\n    let sample: SavedSample = fs::load(&sample_file)?;\n    let SavedSample { iters, times, .. } = sample;\n\n    let mut estimates_file = criterion.output_directory.clone();\n    estimates_file.push(id.as_directory_name());\n    estimates_file.push(&criterion.baseline_directory);\n    estimates_file.push(\"estimates.json\");\n    let base_estimates: Estimates = fs::load(&estimates_file)?;\n\n    let base_avg_times: Vec<f64> = iters\n        .iter()\n        .zip(times.iter())\n        .map(|(iters, elapsed)| elapsed / iters)\n        .collect();\n    let base_avg_time_sample = Sample::new(&base_avg_times);\n\n    let mut change_dir = criterion.output_directory.clone();\n    change_dir.push(id.as_directory_name());\n    change_dir.push(\"change\");\n    fs::mkdirp(&change_dir)?;\n    let (t_statistic, t_distribution) = t_test(avg_times, base_avg_time_sample, config);\n\n    let (estimates, relative_distributions) =\n        estimates(id, avg_times, base_avg_time_sample, config, criterion);\n    Ok((\n        t_statistic,\n        t_distribution,\n        estimates,\n        relative_distributions,\n        iters,\n        times,\n        base_avg_times.clone(),\n        base_estimates,\n    ))\n}\n\n// Performs a two sample t-test\nfn t_test(\n    avg_times: &Sample<f64>,\n    base_avg_times: &Sample<f64>,\n    config: &BenchmarkConfig,\n) -> (f64, Distribution<f64>) {\n    let nresamples = config.nresamples;\n\n    let t_statistic = avg_times.t(base_avg_times);\n    let t_distribution = elapsed!(\n        \"Bootstrapping the T distribution\",\n        mixed::bootstrap(avg_times, base_avg_times, nresamples, |a, b| (a.t(b),))\n    )\n    .0;\n\n    // HACK: Filter out non-finite numbers, which can happen sometimes when sample size is very small.\n    // Downstream code doesn't like non-finite values here.\n    let t_distribution = Distribution::from(\n        t_distribution\n            .iter()\n            .filter(|a| a.is_finite())\n            .cloned()\n            .collect::<Vec<_>>()\n            .into_boxed_slice(),\n    );\n\n    (t_statistic, t_distribution)\n}\n\n// Estimates the relative change in the statistics of the population\nfn estimates<M: Measurement>(\n    id: &BenchmarkId,\n    avg_times: &Sample<f64>,\n    base_avg_times: &Sample<f64>,\n    config: &BenchmarkConfig,\n    criterion: &Criterion<M>,\n) -> (ChangeEstimates, ChangeDistributions) {\n    fn stats(a: &Sample<f64>, b: &Sample<f64>) -> (f64, f64) {\n        (\n            a.mean() / b.mean() - 1.,\n            a.percentiles().median() / b.percentiles().median() - 1.,\n        )\n    }\n\n    let cl = config.confidence_level;\n    let nresamples = config.nresamples;\n\n    let (dist_mean, dist_median) = elapsed!(\n        \"Bootstrapping the relative statistics\",\n        univariate::bootstrap(avg_times, base_avg_times, nresamples, stats)\n    );\n\n    let distributions = ChangeDistributions {\n        mean: dist_mean,\n        median: dist_median,\n    };\n\n    let (mean, median) = stats(avg_times, base_avg_times);\n    let points = ChangePointEstimates { mean, median };\n\n    let estimates = build_change_estimates(&distributions, &points, cl);\n\n    {\n        log_if_err!({\n            let mut estimates_path = criterion.output_directory.clone();\n            estimates_path.push(id.as_directory_name());\n            estimates_path.push(\"change\");\n            estimates_path.push(\"estimates.json\");\n            fs::save(&estimates, &estimates_path)\n        });\n    }\n    (estimates, distributions)\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::path::Path;\n\nuse crate::stats::bivariate::regression::Slope;\nuse crate::stats::bivariate::Data;\nuse crate::stats::univariate::outliers::tukey;\nuse crate::stats::univariate::Sample;\nuse crate::stats::{Distribution, Tails};\n\nuse crate::benchmark::BenchmarkConfig;\nuse crate::connection::OutgoingMessage;\nuse crate::estimate::{\n    build_estimates, ConfidenceInterval, Distributions, Estimate, Estimates, PointEstimates,\n};\nuse crate::fs;\nuse crate::measurement::Measurement;\nuse crate::report::{BenchmarkId, Report, ReportContext};\nuse crate::routine::Routine;\nuse crate::{Baseline, Criterion, SavedSample, Throughput};\n\nmacro_rules! elapsed {\n    ($msg:expr, $block:expr) => {{\n        let start = ::std::time::Instant::now();\n        let out = $block;\n        let elapsed = &start.elapsed();\n\n        info!(\n            \"{} took {}\",\n            $msg,\n            crate::format::time(elapsed.as_nanos() as f64)\n        );\n\n        out\n    }};\n}\n\nmod compare;\n\n// Common analysis procedure\npub(crate) fn common<M: Measurement, T: ?Sized>(\n    id: &BenchmarkId,\n    routine: &mut dyn Routine<M, T>,\n    config: &BenchmarkConfig,\n    criterion: &Criterion<M>,\n    report_context: &ReportContext,\n    parameter: &T,\n    throughput: Option<Throughput>,\n) {\n    criterion.report.benchmark_start(id, report_context);\n\n    if let Baseline::CompareStrict = criterion.baseline {\n        if !base_dir_exists(\n            id,\n            &criterion.baseline_directory,\n            &criterion.output_directory,\n        ) {\n            panic!(\n                \"Baseline '{base}' must exist before comparison is allowed; try --save-baseline {base}\",\n                base=criterion.baseline_directory,\n            );\n        }\n    }\n\n    let (sampling_mode, iters, times);\n    if let Some(baseline) = &criterion.load_baseline {\n        let mut sample_path = criterion.output_directory.clone();\n        sample_path.push(id.as_directory_name());\n        sample_path.push(baseline);\n        sample_path.push(\"sample.json\");\n        let loaded = fs::load::<SavedSample, _>(&sample_path);\n\n        match loaded {\n            Err(err) => panic!(\n                \"Baseline '{base}' must exist before it can be loaded; try --save-baseline {base}. Error: {err}\",\n                base = baseline, err = err\n            ),\n            Ok(samples) => {\n                sampling_mode = samples.sampling_mode;\n                iters = samples.iters.into_boxed_slice();\n                times = samples.times.into_boxed_slice();\n            }\n        }\n    } else {\n        let sample = routine.sample(\n            &criterion.measurement,\n            id,\n            config,\n            criterion,\n            report_context,\n            parameter,\n        );\n        sampling_mode = sample.0;\n        iters = sample.1;\n        times = sample.2;\n\n        if let Some(conn) = &criterion.connection {\n            conn.send(&OutgoingMessage::MeasurementComplete {\n                id: id.into(),\n                iters: &iters,\n                times: &times,\n                plot_config: (&report_context.plot_config).into(),\n                sampling_method: sampling_mode.into(),\n                benchmark_config: config.into(),\n            })\n            .unwrap();\n\n            conn.serve_value_formatter(criterion.measurement.formatter())\n                .unwrap();\n            return;\n        }\n    }\n\n    criterion.report.analysis(id, report_context);\n\n    if times.contains(&0.0) {\n        error!(\n            \"At least one measurement of benchmark {} took zero time per \\\n            iteration. This should not be possible. If using iter_custom, please verify \\\n            that your routine is correctly measured.\",\n            id.as_title()\n        );\n        return;\n    }\n\n    let avg_times = iters\n        .iter()\n        .zip(times.iter())\n        .map(|(&iters, &elapsed)| elapsed / iters)\n        .collect::<Vec<f64>>();\n    let avg_times = Sample::new(&avg_times);\n\n    if criterion.should_save_baseline() {\n        log_if_err!({\n            let mut new_dir = criterion.output_directory.clone();\n            new_dir.push(id.as_directory_name());\n            new_dir.push(\"new\");\n            fs::mkdirp(&new_dir)\n        });\n    }\n\n    let data = Data::new(&iters, &times);\n    let labeled_sample = tukey::classify(avg_times);\n    if criterion.should_save_baseline() {\n        log_if_err!({\n            let mut tukey_file = criterion.output_directory.to_owned();\n            tukey_file.push(id.as_directory_name());\n            tukey_file.push(\"new\");\n            tukey_file.push(\"tukey.json\");\n            fs::save(&labeled_sample.fences(), &tukey_file)\n        });\n    }\n    let (mut distributions, mut estimates) = estimates(avg_times, config);\n    if sampling_mode.is_linear() {\n        let (distribution, slope) = regression(&data, config);\n\n        estimates.slope = Some(slope);\n        distributions.slope = Some(distribution);\n    }\n\n    if criterion.should_save_baseline() {\n        log_if_err!({\n            let mut sample_file = criterion.output_directory.clone();\n            sample_file.push(id.as_directory_name());\n            sample_file.push(\"new\");\n            sample_file.push(\"sample.json\");\n            fs::save(\n                &SavedSample {\n                    sampling_mode,\n                    iters: data.x().as_ref().to_vec(),\n                    times: data.y().as_ref().to_vec(),\n                },\n                &sample_file,\n            )\n        });\n        log_if_err!({\n            let mut estimates_file = criterion.output_directory.clone();\n            estimates_file.push(id.as_directory_name());\n            estimates_file.push(\"new\");\n            estimates_file.push(\"estimates.json\");\n            fs::save(&estimates, &estimates_file)\n        });\n    }\n\n    let compare_data = if base_dir_exists(\n        id,\n        &criterion.baseline_directory,\n        &criterion.output_directory,\n    ) {\n        let result = compare::common(id, avg_times, config, criterion);\n        match result {\n            Ok((\n                t_value,\n                t_distribution,\n                relative_estimates,\n                relative_distributions,\n                base_iter_counts,\n                base_sample_times,\n                base_avg_times,\n                base_estimates,\n            )) => {\n                let p_value = t_distribution.p_value(t_value, &Tails::Two);\n                Some(crate::report::ComparisonData {\n                    p_value,\n                    t_distribution,\n                    t_value,\n                    relative_estimates,\n                    relative_distributions,\n                    significance_threshold: config.significance_level,\n                    noise_threshold: config.noise_threshold,\n                    base_iter_counts,\n                    base_sample_times,\n                    base_avg_times,\n                    base_estimates,\n                })\n            }\n            Err(e) => {\n                crate::error::log_error(&e);\n                None\n            }\n        }\n    } else {\n        None\n    };\n\n    let measurement_data = crate::report::MeasurementData {\n        data: Data::new(&iters, &times),\n        avg_times: labeled_sample,\n        absolute_estimates: estimates,\n        distributions,\n        comparison: compare_data,\n        throughput,\n    };\n\n    criterion.report.measurement_complete(\n        id,\n        report_context,\n        &measurement_data,\n        criterion.measurement.formatter(),\n    );\n\n    if criterion.should_save_baseline() {\n        log_if_err!({\n            let mut benchmark_file = criterion.output_directory.clone();\n            benchmark_file.push(id.as_directory_name());\n            benchmark_file.push(\"new\");\n            benchmark_file.push(\"benchmark.json\");\n            fs::save(&id, &benchmark_file)\n        });\n    }\n\n    if criterion.connection.is_none() {\n        if let Baseline::Save = criterion.baseline {\n            copy_new_dir_to_base(\n                id.as_directory_name(),\n                &criterion.baseline_directory,\n                &criterion.output_directory,\n            );\n        }\n    }\n}\n\nfn base_dir_exists(id: &BenchmarkId, baseline: &str, output_directory: &Path) -> bool {\n    let mut base_dir = output_directory.to_owned();\n    base_dir.push(id.as_directory_name());\n    base_dir.push(baseline);\n    base_dir.exists()\n}\n\n// Performs a simple linear regression on the sample\nfn regression(\n    data: &Data<'_, f64, f64>,\n    config: &BenchmarkConfig,\n) -> (Distribution<f64>, Estimate) {\n    let cl = config.confidence_level;\n\n    let distribution = elapsed!(\n        \"Bootstrapped linear regression\",\n        data.bootstrap(config.nresamples, |d| (Slope::fit(&d).0,))\n    )\n    .0;\n\n    let point = Slope::fit(data);\n    let (lb, ub) = distribution.confidence_interval(config.confidence_level);\n    let se = distribution.std_dev(None);\n\n    (\n        distribution,\n        Estimate {\n            confidence_interval: ConfidenceInterval {\n                confidence_level: cl,\n                lower_bound: lb,\n                upper_bound: ub,\n            },\n            point_estimate: point.0,\n            standard_error: se,\n        },\n    )\n}\n\n// Estimates the statistics of the population from the sample\nfn estimates(avg_times: &Sample<f64>, config: &BenchmarkConfig) -> (Distributions, Estimates) {\n    fn stats(sample: &Sample<f64>) -> (f64, f64, f64, f64) {\n        let mean = sample.mean();\n        let std_dev = sample.std_dev(Some(mean));\n        let median = sample.percentiles().median();\n        let mad = sample.median_abs_dev(Some(median));\n\n        (mean, std_dev, median, mad)\n    }\n\n    let cl = config.confidence_level;\n    let nresamples = config.nresamples;\n\n    let (mean, std_dev, median, mad) = stats(avg_times);\n    let points = PointEstimates {\n        mean,\n        median,\n        std_dev,\n        median_abs_dev: mad,\n    };\n\n    let (dist_mean, dist_stddev, dist_median, dist_mad) = elapsed!(\n        \"Bootstrapping the absolute statistics.\",\n        avg_times.bootstrap(nresamples, stats)\n    );\n\n    let distributions = Distributions {\n        mean: dist_mean,\n        slope: None,\n        median: dist_median,\n        median_abs_dev: dist_mad,\n        std_dev: dist_stddev,\n    };\n\n    let estimates = build_estimates(&distributions, &points, cl);\n\n    (distributions, estimates)\n}\n\nfn copy_new_dir_to_base(id: &str, baseline: &str, output_directory: &Path) {\n    let root_dir = Path::new(output_directory).join(id);\n    let base_dir = root_dir.join(baseline);\n    let new_dir = root_dir.join(\"new\");\n\n    if !new_dir.exists() {\n        return;\n    };\n    if !base_dir.exists() {\n        try_else_return!(fs::mkdirp(&base_dir));\n    }\n\n    // TODO: consider using walkdir or similar to generically copy.\n    try_else_return!(fs::cp(\n        &new_dir.join(\"estimates.json\"),\n        &base_dir.join(\"estimates.json\")\n    ));\n    try_else_return!(fs::cp(\n        &new_dir.join(\"sample.json\"),\n        &base_dir.join(\"sample.json\")\n    ));\n    try_else_return!(fs::cp(\n        &new_dir.join(\"tukey.json\"),\n        &base_dir.join(\"tukey.json\")\n    ));\n    try_else_return!(fs::cp(\n        &new_dir.join(\"benchmark.json\"),\n        &base_dir.join(\"benchmark.json\")\n    ));\n    #[cfg(feature = \"csv_output\")]\n    try_else_return!(fs::cp(&new_dir.join(\"raw.csv\"), &base_dir.join(\"raw.csv\")));\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::report::{make_filename_safe, BenchmarkId, MeasurementData, Report, ReportContext};\nuse crate::stats::bivariate::regression::Slope;\n\nuse crate::estimate::Estimate;\nuse crate::format;\nuse crate::fs;\nuse crate::measurement::ValueFormatter;\nuse crate::plot::{LinePlotConfig, PlotContext, PlotData, Plotter};\nuse crate::SavedSample;\nuse criterion_plot::Size;\nuse serde::Serialize;\nuse std::cell::RefCell;\nuse std::cmp::Ordering;\nuse std::collections::{BTreeSet, HashMap};\nuse std::path::{Path, PathBuf};\nuse tinytemplate::TinyTemplate;\n\nconst THUMBNAIL_SIZE: Option<Size> = Some(Size(450, 300));\n\nfn debug_context<S: Serialize>(path: &Path, context: &S) {\n    if crate::debug_enabled() {\n        let mut context_path = PathBuf::from(path);\n        context_path.set_extension(\"json\");\n        println!(\"Writing report context to {:?}\", context_path);\n        let result = fs::save(context, &context_path);\n        if let Err(e) = result {\n            error!(\"Failed to write report context debug output: {}\", e);\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct Context {\n    title: String,\n    confidence: String,\n\n    thumbnail_width: usize,\n    thumbnail_height: usize,\n\n    slope: Option<ConfidenceInterval>,\n    r2: ConfidenceInterval,\n    mean: ConfidenceInterval,\n    std_dev: ConfidenceInterval,\n    median: ConfidenceInterval,\n    mad: ConfidenceInterval,\n    throughput: Option<ConfidenceInterval>,\n\n    additional_plots: Vec<Plot>,\n\n    comparison: Option<Comparison>,\n}\n\n#[derive(Serialize)]\nstruct IndividualBenchmark {\n    name: String,\n    path: String,\n    regression_exists: bool,\n}\nimpl IndividualBenchmark {\n    fn from_id(\n        output_directory: &Path,\n        path_prefix: &str,\n        id: &BenchmarkId,\n    ) -> IndividualBenchmark {\n        let mut regression_path = PathBuf::from(output_directory);\n        regression_path.push(id.as_directory_name());\n        regression_path.push(\"report\");\n        regression_path.push(\"regression.svg\");\n\n        IndividualBenchmark {\n            name: id.as_title().to_owned(),\n            path: format!(\"{}/{}\", path_prefix, id.as_directory_name()),\n            regression_exists: regression_path.is_file(),\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct SummaryContext {\n    group_id: String,\n\n    thumbnail_width: usize,\n    thumbnail_height: usize,\n\n    violin_plot: Option<String>,\n    line_chart: Option<String>,\n    line_throughput_chart: Option<String>,\n\n    benchmarks: Vec<IndividualBenchmark>,\n}\n\n#[derive(Serialize)]\nstruct ConfidenceInterval {\n    lower: String,\n    upper: String,\n    point: String,\n}\n\n#[derive(Serialize)]\nstruct Plot {\n    name: String,\n    url: String,\n}\nimpl Plot {\n    fn new(name: &str, url: &str) -> Plot {\n        Plot {\n            name: name.to_owned(),\n            url: url.to_owned(),\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct Comparison {\n    p_value: String,\n    inequality: String,\n    significance_level: String,\n    explanation: String,\n\n    change: ConfidenceInterval,\n    thrpt_change: Option<ConfidenceInterval>,\n    additional_plots: Vec<Plot>,\n}\n\nfn if_exists(output_directory: &Path, path: &Path) -> Option<String> {\n    let report_path = path.join(\"report/index.html\");\n    if PathBuf::from(output_directory).join(&report_path).is_file() {\n        Some(report_path.to_string_lossy().to_string())\n    } else {\n        None\n    }\n}\n#[derive(Serialize, Debug)]\nstruct ReportLink<'a> {\n    name: &'a str,\n    path: Option<String>,\n}\nimpl<'a> ReportLink<'a> {\n    // TODO: Would be nice if I didn't have to keep making these components filename-safe.\n    fn group(output_directory: &Path, group_id: &'a str) -> ReportLink<'a> {\n        let path = PathBuf::from(make_filename_safe(group_id));\n\n        ReportLink {\n            name: group_id,\n            path: if_exists(output_directory, &path),\n        }\n    }\n\n    fn function(output_directory: &Path, group_id: &str, function_id: &'a str) -> ReportLink<'a> {\n        let mut path = PathBuf::from(make_filename_safe(group_id));\n        path.push(make_filename_safe(function_id));\n\n        ReportLink {\n            name: function_id,\n            path: if_exists(output_directory, &path),\n        }\n    }\n\n    fn value(output_directory: &Path, group_id: &str, value_str: &'a str) -> ReportLink<'a> {\n        let mut path = PathBuf::from(make_filename_safe(group_id));\n        path.push(make_filename_safe(value_str));\n\n        ReportLink {\n            name: value_str,\n            path: if_exists(output_directory, &path),\n        }\n    }\n\n    fn individual(output_directory: &Path, id: &'a BenchmarkId) -> ReportLink<'a> {\n        let path = PathBuf::from(id.as_directory_name());\n        ReportLink {\n            name: id.as_title(),\n            path: if_exists(output_directory, &path),\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct BenchmarkValueGroup<'a> {\n    value: Option<ReportLink<'a>>,\n    benchmarks: Vec<ReportLink<'a>>,\n}\n\n#[derive(Serialize)]\nstruct BenchmarkGroup<'a> {\n    group_report: ReportLink<'a>,\n\n    function_ids: Option<Vec<ReportLink<'a>>>,\n    values: Option<Vec<ReportLink<'a>>>,\n\n    individual_links: Vec<BenchmarkValueGroup<'a>>,\n}\nimpl<'a> BenchmarkGroup<'a> {\n    fn new(output_directory: &Path, ids: &[&'a BenchmarkId]) -> BenchmarkGroup<'a> {\n        let group_id = &ids[0].group_id;\n        let group_report = ReportLink::group(output_directory, group_id);\n\n        let mut function_ids = Vec::with_capacity(ids.len());\n        let mut values = Vec::with_capacity(ids.len());\n        let mut individual_links = HashMap::with_capacity(ids.len());\n\n        for id in ids.iter() {\n            let function_id = id.function_id.as_deref();\n            let value = id.value_str.as_deref();\n\n            let individual_link = ReportLink::individual(output_directory, id);\n\n            function_ids.push(function_id);\n            values.push(value);\n\n            individual_links.insert((function_id, value), individual_link);\n        }\n\n        fn parse_opt(os: &Option<&str>) -> Option<f64> {\n            os.and_then(|s| s.parse::<f64>().ok())\n        }\n\n        // If all of the value strings can be parsed into a number, sort/dedupe\n        // numerically. Otherwise sort lexicographically.\n        if values.iter().all(|os| parse_opt(os).is_some()) {\n            values.sort_unstable_by(|v1, v2| {\n                let num1 = parse_opt(v1);\n                let num2 = parse_opt(v2);\n\n                num1.partial_cmp(&num2).unwrap_or(Ordering::Less)\n            });\n            values.dedup_by_key(|os| parse_opt(os).unwrap());\n        } else {\n            values.sort_unstable();\n            values.dedup();\n        }\n\n        // Sort and dedupe functions by name.\n        function_ids.sort_unstable();\n        function_ids.dedup();\n\n        let mut value_groups = Vec::with_capacity(values.len());\n        for value in values.iter() {\n            let row = function_ids\n                .iter()\n                .filter_map(|f| individual_links.remove(&(*f, *value)))\n                .collect::<Vec<_>>();\n            value_groups.push(BenchmarkValueGroup {\n                value: value.map(|s| ReportLink::value(output_directory, group_id, s)),\n                benchmarks: row,\n            });\n        }\n\n        let function_ids = function_ids\n            .into_iter()\n            .map(|os| os.map(|s| ReportLink::function(output_directory, group_id, s)))\n            .collect::<Option<Vec<_>>>();\n        let values = values\n            .into_iter()\n            .map(|os| os.map(|s| ReportLink::value(output_directory, group_id, s)))\n            .collect::<Option<Vec<_>>>();\n\n        BenchmarkGroup {\n            group_report,\n            function_ids,\n            values,\n            individual_links: value_groups,\n        }\n    }\n}\n\n#[derive(Serialize)]\nstruct IndexContext<'a> {\n    groups: Vec<BenchmarkGroup<'a>>,\n}\n\npub struct Html {\n    templates: TinyTemplate<'static>,\n    plotter: RefCell<Box<dyn Plotter>>,\n}\nimpl Html {\n    pub(crate) fn new(plotter: Box<dyn Plotter>) -> Html {\n        let mut templates = TinyTemplate::new();\n        templates\n            .add_template(\"report_link\", include_str!(\"report_link.html.tt\"))\n            .expect(\"Unable to parse report_link template.\");\n        templates\n            .add_template(\"index\", include_str!(\"index.html.tt\"))\n            .expect(\"Unable to parse index template.\");\n        templates\n            .add_template(\"benchmark_report\", include_str!(\"benchmark_report.html.tt\"))\n            .expect(\"Unable to parse benchmark_report template\");\n        templates\n            .add_template(\"summary_report\", include_str!(\"summary_report.html.tt\"))\n            .expect(\"Unable to parse summary_report template\");\n\n        let plotter = RefCell::new(plotter);\n        Html { templates, plotter }\n    }\n}\nimpl Report for Html {\n    fn measurement_complete(\n        &self,\n        id: &BenchmarkId,\n        report_context: &ReportContext,\n        measurements: &MeasurementData<'_>,\n        formatter: &dyn ValueFormatter,\n    ) {\n        try_else_return!({\n            let mut report_dir = report_context.output_directory.clone();\n            report_dir.push(id.as_directory_name());\n            report_dir.push(\"report\");\n            fs::mkdirp(&report_dir)\n        });\n\n        let typical_estimate = &measurements.absolute_estimates.typical();\n\n        let time_interval = |est: &Estimate| -> ConfidenceInterval {\n            ConfidenceInterval {\n                lower: formatter.format_value(est.confidence_interval.lower_bound),\n                point: formatter.format_value(est.point_estimate),\n                upper: formatter.format_value(est.confidence_interval.upper_bound),\n            }\n        };\n\n        let data = measurements.data;\n\n        elapsed! {\n            \"Generating plots\",\n            self.generate_plots(id, report_context, formatter, measurements)\n        }\n\n        let mut additional_plots = vec![\n            Plot::new(\"Typical\", \"typical.svg\"),\n            Plot::new(\"Mean\", \"mean.svg\"),\n            Plot::new(\"Std. Dev.\", \"SD.svg\"),\n            Plot::new(\"Median\", \"median.svg\"),\n            Plot::new(\"MAD\", \"MAD.svg\"),\n        ];\n        if measurements.absolute_estimates.slope.is_some() {\n            additional_plots.push(Plot::new(\"Slope\", \"slope.svg\"));\n        }\n\n        let throughput = measurements\n            .throughput\n            .as_ref()\n            .map(|thr| ConfidenceInterval {\n                lower: formatter\n                    .format_throughput(thr, typical_estimate.confidence_interval.upper_bound),\n                upper: formatter\n                    .format_throughput(thr, typical_estimate.confidence_interval.lower_bound),\n                point: formatter.format_throughput(thr, typical_estimate.point_estimate),\n            });\n\n        let context = Context {\n            title: id.as_title().to_owned(),\n            confidence: format!(\n                \"{:.2}\",\n                typical_estimate.confidence_interval.confidence_level\n            ),\n\n            thumbnail_width: THUMBNAIL_SIZE.unwrap().0,\n            thumbnail_height: THUMBNAIL_SIZE.unwrap().1,\n\n            slope: measurements\n                .absolute_estimates\n                .slope\n                .as_ref()\n                .map(time_interval),\n            mean: time_interval(&measurements.absolute_estimates.mean),\n            median: time_interval(&measurements.absolute_estimates.median),\n            mad: time_interval(&measurements.absolute_estimates.median_abs_dev),\n            std_dev: time_interval(&measurements.absolute_estimates.std_dev),\n            throughput,\n\n            r2: ConfidenceInterval {\n                lower: format!(\n                    \"{:0.7}\",\n                    Slope(typical_estimate.confidence_interval.lower_bound).r_squared(&data)\n                ),\n                upper: format!(\n                    \"{:0.7}\",\n                    Slope(typical_estimate.confidence_interval.upper_bound).r_squared(&data)\n                ),\n                point: format!(\n                    \"{:0.7}\",\n                    Slope(typical_estimate.point_estimate).r_squared(&data)\n                ),\n            },\n\n            additional_plots,\n\n            comparison: self.comparison(measurements),\n        };\n\n        let mut report_path = report_context.output_directory.clone();\n        report_path.push(id.as_directory_name());\n        report_path.push(\"report\");\n        report_path.push(\"index.html\");\n        debug_context(&report_path, &context);\n\n        let text = self\n            .templates\n            .render(\"benchmark_report\", &context)\n            .expect(\"Failed to render benchmark report template\");\n        try_else_return!(fs::save_string(&text, &report_path));\n    }\n\n    fn summarize(\n        &self,\n        context: &ReportContext,\n        all_ids: &[BenchmarkId],\n        formatter: &dyn ValueFormatter,\n    ) {\n        let all_ids = all_ids\n            .iter()\n            .filter(|id| {\n                let id_dir = context.output_directory.join(id.as_directory_name());\n                fs::is_dir(&id_dir)\n            })\n            .collect::<Vec<_>>();\n        if all_ids.is_empty() {\n            return;\n        }\n\n        let group_id = all_ids[0].group_id.clone();\n\n        let data = self.load_summary_data(&context.output_directory, &all_ids);\n\n        let mut function_ids = BTreeSet::new();\n        let mut value_strs = Vec::with_capacity(all_ids.len());\n        for id in all_ids {\n            if let Some(ref function_id) = id.function_id {\n                function_ids.insert(function_id);\n            }\n            if let Some(ref value_str) = id.value_str {\n                value_strs.push(value_str);\n            }\n        }\n\n        fn try_parse(s: &str) -> Option<f64> {\n            s.parse::<f64>().ok()\n        }\n\n        // If all of the value strings can be parsed into a number, sort/dedupe\n        // numerically. Otherwise sort lexicographically.\n        if value_strs.iter().all(|os| try_parse(os).is_some()) {\n            value_strs.sort_unstable_by(|v1, v2| {\n                let num1 = try_parse(v1);\n                let num2 = try_parse(v2);\n\n                num1.partial_cmp(&num2).unwrap_or(Ordering::Less)\n            });\n            value_strs.dedup_by_key(|os| try_parse(os).unwrap());\n        } else {\n            value_strs.sort_unstable();\n            value_strs.dedup();\n        }\n\n        for function_id in function_ids {\n            let samples_with_function: Vec<_> = data\n                .iter()\n                .by_ref()\n                .filter(|&&(id, _)| id.function_id.as_ref() == Some(function_id))\n                .collect();\n\n            if samples_with_function.len() > 1 {\n                let subgroup_id =\n                    BenchmarkId::new(group_id.clone(), Some(function_id.clone()), None, None);\n\n                self.generate_summary(\n                    &subgroup_id,\n                    &samples_with_function,\n                    context,\n                    formatter,\n                    false,\n                );\n            }\n        }\n\n        for value_str in value_strs {\n            let samples_with_value: Vec<_> = data\n                .iter()\n                .by_ref()\n                .filter(|&&(id, _)| id.value_str.as_ref() == Some(value_str))\n                .collect();\n\n            if samples_with_value.len() > 1 {\n                let subgroup_id =\n                    BenchmarkId::new(group_id.clone(), None, Some(value_str.clone()), None);\n\n                self.generate_summary(&subgroup_id, &samples_with_value, context, formatter, false);\n            }\n        }\n\n        let mut all_data = data.iter().by_ref().collect::<Vec<_>>();\n        // First sort the ids/data by value.\n        // If all of the value strings can be parsed into a number, sort/dedupe\n        // numerically. Otherwise sort lexicographically.\n        let all_values_numeric = all_data\n            .iter()\n            .all(|(id, _)| id.value_str.as_deref().and_then(try_parse).is_some());\n        if all_values_numeric {\n            all_data.sort_unstable_by(|(a, _), (b, _)| {\n                let num1 = a.value_str.as_deref().and_then(try_parse);\n                let num2 = b.value_str.as_deref().and_then(try_parse);\n\n                num1.partial_cmp(&num2).unwrap_or(Ordering::Less)\n            });\n        } else {\n            all_data.sort_unstable_by_key(|(id, _)| id.value_str.as_ref());\n        }\n        // Next, sort the ids/data by function name. This results in a sorting priority of\n        // function name, then value. This one has to be a stable sort.\n        all_data.sort_by_key(|(id, _)| id.function_id.as_ref());\n\n        self.generate_summary(\n            &BenchmarkId::new(group_id, None, None, None),\n            &all_data,\n            context,\n            formatter,\n            true,\n        );\n        self.plotter.borrow_mut().wait();\n    }\n\n    fn final_summary(&self, report_context: &ReportContext) {\n        let output_directory = &report_context.output_directory;\n        if !fs::is_dir(&output_directory) {\n            return;\n        }\n\n        let mut found_ids = try_else_return!(fs::list_existing_benchmarks(&output_directory));\n        found_ids.sort_unstable_by_key(|id| id.id().to_owned());\n\n        // Group IDs by group id\n        let mut id_groups: HashMap<&str, Vec<&BenchmarkId>> = HashMap::new();\n        for id in found_ids.iter() {\n            id_groups.entry(&id.group_id).or_default().push(id);\n        }\n\n        let mut groups = id_groups\n            .into_values()\n            .map(|group| BenchmarkGroup::new(output_directory, &group))\n            .collect::<Vec<BenchmarkGroup<'_>>>();\n        groups.sort_unstable_by_key(|g| g.group_report.name);\n\n        try_else_return!(fs::mkdirp(&output_directory.join(\"report\")));\n\n        let report_path = output_directory.join(\"report\").join(\"index.html\");\n\n        let context = IndexContext { groups };\n\n        debug_context(&report_path, &context);\n\n        let text = self\n            .templates\n            .render(\"index\", &context)\n            .expect(\"Failed to render index template\");\n        try_else_return!(fs::save_string(&text, &report_path,));\n    }\n}\nimpl Html {\n    fn comparison(&self, measurements: &MeasurementData<'_>) -> Option<Comparison> {\n        if let Some(ref comp) = measurements.comparison {\n            let different_mean = comp.p_value < comp.significance_threshold;\n            let mean_est = &comp.relative_estimates.mean;\n            let explanation_str: String;\n\n            if !different_mean {\n                explanation_str = \"No change in performance detected.\".to_owned();\n            } else {\n                let comparison = compare_to_threshold(mean_est, comp.noise_threshold);\n                match comparison {\n                    ComparisonResult::Improved => {\n                        explanation_str = \"Performance has improved.\".to_owned();\n                    }\n                    ComparisonResult::Regressed => {\n                        explanation_str = \"Performance has regressed.\".to_owned();\n                    }\n                    ComparisonResult::NonSignificant => {\n                        explanation_str = \"Change within noise threshold.\".to_owned();\n                    }\n                }\n            }\n\n            let comp = Comparison {\n                p_value: format!(\"{:.2}\", comp.p_value),\n                inequality: (if different_mean { \"<\" } else { \">\" }).to_owned(),\n                significance_level: format!(\"{:.2}\", comp.significance_threshold),\n                explanation: explanation_str,\n\n                change: ConfidenceInterval {\n                    point: format::change(mean_est.point_estimate, true),\n                    lower: format::change(mean_est.confidence_interval.lower_bound, true),\n                    upper: format::change(mean_est.confidence_interval.upper_bound, true),\n                },\n\n                thrpt_change: measurements.throughput.as_ref().map(|_| {\n                    let to_thrpt_estimate = |ratio: f64| 1.0 / (1.0 + ratio) - 1.0;\n                    ConfidenceInterval {\n                        point: format::change(to_thrpt_estimate(mean_est.point_estimate), true),\n                        lower: format::change(\n                            to_thrpt_estimate(mean_est.confidence_interval.lower_bound),\n                            true,\n                        ),\n                        upper: format::change(\n                            to_thrpt_estimate(mean_est.confidence_interval.upper_bound),\n                            true,\n                        ),\n                    }\n                }),\n\n                additional_plots: vec![\n                    Plot::new(\"Change in mean\", \"change/mean.svg\"),\n                    Plot::new(\"Change in median\", \"change/median.svg\"),\n                    Plot::new(\"T-Test\", \"change/t-test.svg\"),\n                ],\n            };\n            Some(comp)\n        } else {\n            None\n        }\n    }\n\n    fn generate_plots(\n        &self,\n        id: &BenchmarkId,\n        context: &ReportContext,\n        formatter: &dyn ValueFormatter,\n        measurements: &MeasurementData<'_>,\n    ) {\n        let plot_ctx = PlotContext {\n            id,\n            context,\n            size: None,\n            is_thumbnail: false,\n        };\n\n        let plot_data = PlotData {\n            measurements,\n            formatter,\n            comparison: None,\n        };\n\n        let plot_ctx_small = plot_ctx.thumbnail(true).size(THUMBNAIL_SIZE);\n\n        self.plotter.borrow_mut().pdf(plot_ctx, plot_data);\n        self.plotter.borrow_mut().pdf(plot_ctx_small, plot_data);\n        if measurements.absolute_estimates.slope.is_some() {\n            self.plotter.borrow_mut().regression(plot_ctx, plot_data);\n            self.plotter\n                .borrow_mut()\n                .regression(plot_ctx_small, plot_data);\n        } else {\n            self.plotter\n                .borrow_mut()\n                .iteration_times(plot_ctx, plot_data);\n            self.plotter\n                .borrow_mut()\n                .iteration_times(plot_ctx_small, plot_data);\n        }\n\n        self.plotter\n            .borrow_mut()\n            .abs_distributions(plot_ctx, plot_data);\n\n        if let Some(ref comp) = measurements.comparison {\n            try_else_return!({\n                let mut change_dir = context.output_directory.clone();\n                change_dir.push(id.as_directory_name());\n                change_dir.push(\"report\");\n                change_dir.push(\"change\");\n                fs::mkdirp(&change_dir)\n            });\n\n            try_else_return!({\n                let mut both_dir = context.output_directory.clone();\n                both_dir.push(id.as_directory_name());\n                both_dir.push(\"report\");\n                both_dir.push(\"both\");\n                fs::mkdirp(&both_dir)\n            });\n\n            let comp_data = plot_data.comparison(comp);\n\n            self.plotter.borrow_mut().pdf(plot_ctx, comp_data);\n            self.plotter.borrow_mut().pdf(plot_ctx_small, comp_data);\n            if measurements.absolute_estimates.slope.is_some()\n                && comp.base_estimates.slope.is_some()\n            {\n                self.plotter.borrow_mut().regression(plot_ctx, comp_data);\n                self.plotter\n                    .borrow_mut()\n                    .regression(plot_ctx_small, comp_data);\n            } else {\n                self.plotter\n                    .borrow_mut()\n                    .iteration_times(plot_ctx, comp_data);\n                self.plotter\n                    .borrow_mut()\n                    .iteration_times(plot_ctx_small, comp_data);\n            }\n            self.plotter.borrow_mut().t_test(plot_ctx, comp_data);\n            self.plotter\n                .borrow_mut()\n                .rel_distributions(plot_ctx, comp_data);\n        }\n\n        self.plotter.borrow_mut().wait();\n    }\n\n    fn load_summary_data<'a>(\n        &self,\n        output_directory: &Path,\n        all_ids: &[&'a BenchmarkId],\n    ) -> Vec<(&'a BenchmarkId, Vec<f64>)> {\n        all_ids\n            .iter()\n            .filter_map(|id| {\n                let entry = output_directory.join(id.as_directory_name()).join(\"new\");\n\n                let SavedSample { iters, times, .. } =\n                    try_else_return!(fs::load(&entry.join(\"sample.json\")), || None);\n                let avg_times = iters\n                    .into_iter()\n                    .zip(times)\n                    .map(|(iters, time)| time / iters)\n                    .collect::<Vec<_>>();\n\n                Some((*id, avg_times))\n            })\n            .collect::<Vec<_>>()\n    }\n\n    fn generate_summary(\n        &self,\n        id: &BenchmarkId,\n        data: &[&(&BenchmarkId, Vec<f64>)],\n        report_context: &ReportContext,\n        formatter: &dyn ValueFormatter,\n        full_summary: bool,\n    ) {\n        let plot_ctx = PlotContext {\n            id,\n            context: report_context,\n            size: None,\n            is_thumbnail: false,\n        };\n\n        try_else_return!(\n            {\n                let mut report_dir = report_context.output_directory.clone();\n                report_dir.push(id.as_directory_name());\n                report_dir.push(\"report\");\n                fs::mkdirp(&report_dir)\n            },\n            || {}\n        );\n\n        self.plotter.borrow_mut().violin(plot_ctx, formatter, data);\n\n        let value_types: Vec<_> = data.iter().map(|&&(id, _)| id.value_type()).collect();\n        let mut line_path = None;\n        let mut line_throughput_path = None;\n\n        if value_types.iter().all(|x| x == &value_types[0]) {\n            if let Some(value_type) = value_types[0] {\n                let values: Vec<_> = data.iter().map(|&&(id, _)| id.as_number()).collect();\n                if values.iter().any(|x| x != &values[0]) {\n                    self.plotter.borrow_mut().line_comparison(\n                        LinePlotConfig::time(),\n                        plot_ctx,\n                        formatter,\n                        data,\n                        value_type,\n                    );\n                    line_path = Some(plot_ctx.line_comparison_path());\n\n                    // value_types being all equal implies throughput types being all equal\n                    if data[0].0.throughput.is_some() {\n                        self.plotter.borrow_mut().line_comparison(\n                            LinePlotConfig::throughput(),\n                            plot_ctx,\n                            formatter,\n                            data,\n                            value_type,\n                        );\n                        line_throughput_path = Some(plot_ctx.line_throughput_comparison_path());\n                    }\n                }\n            }\n        }\n\n        let path_prefix = if full_summary { \"../..\" } else { \"../../..\" };\n        let benchmarks = data\n            .iter()\n            .map(|&&(id, _)| {\n                IndividualBenchmark::from_id(&report_context.output_directory, path_prefix, id)\n            })\n            .collect();\n\n        let context = SummaryContext {\n            group_id: id.as_title().to_owned(),\n\n            thumbnail_width: THUMBNAIL_SIZE.unwrap().0,\n            thumbnail_height: THUMBNAIL_SIZE.unwrap().1,\n\n            violin_plot: Some(plot_ctx.violin_path().to_string_lossy().into_owned()),\n            line_chart: line_path.map(|p| p.to_string_lossy().into_owned()),\n            line_throughput_chart: line_throughput_path.map(|p| p.to_string_lossy().into_owned()),\n\n            benchmarks,\n        };\n\n        let mut report_path = report_context.output_directory.clone();\n        report_path.push(id.as_directory_name());\n        report_path.push(\"report\");\n        report_path.push(\"index.html\");\n        debug_context(&report_path, &context);\n\n        let text = self\n            .templates\n            .render(\"summary_report\", &context)\n            .expect(\"Failed to render summary report template\");\n        try_else_return!(fs::save_string(&text, &report_path,), || {});\n    }\n}\n\nenum ComparisonResult {\n    Improved,\n    Regressed,\n    NonSignificant,\n}\n\nfn compare_to_threshold(estimate: &Estimate, noise: f64) -> ComparisonResult {\n    let ci = &estimate.confidence_interval;\n    let lb = ci.lower_bound;\n    let ub = ci.upper_bound;\n\n    if lb < -noise && ub < -noise {\n        ComparisonResult::Improved\n    } else if lb > noise && ub > noise {\n        ComparisonResult::Regressed\n    } else {\n        ComparisonResult::NonSignificant\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "mod gnuplot_backend;\n#[cfg(feature = \"plotters\")]\nmod plotters_backend;\n\npub(crate) use gnuplot_backend::Gnuplot;\n#[cfg(feature = \"plotters\")]\npub(crate) use plotters_backend::PlottersBackend;\n\nuse {\n    crate::{\n        estimate::Statistic,\n        measurement::ValueFormatter,\n        report::{BenchmarkId, ComparisonData, MeasurementData, ReportContext, ValueType},\n        Throughput,\n    },\n    std::path::PathBuf,\n};\n\nconst REPORT_STATS: [Statistic; 7] = [\n    Statistic::Typical,\n    Statistic::Slope,\n    Statistic::Mean,\n    Statistic::Median,\n    Statistic::MedianAbsDev,\n    Statistic::MedianAbsDev,\n    Statistic::StdDev,\n];\nconst CHANGE_STATS: [Statistic; 2] = [Statistic::Mean, Statistic::Median];\n#[derive(Clone, Copy)]\npub(crate) struct PlotContext<'a> {\n    pub(crate) id: &'a BenchmarkId,\n    pub(crate) context: &'a ReportContext,\n    pub(crate) size: Option<(usize, usize)>,\n    pub(crate) is_thumbnail: bool,\n}\n\nimpl<'a> PlotContext<'a> {\n    pub fn size(mut self, s: Option<criterion_plot::Size>) -> PlotContext<'a> {\n        if let Some(s) = s {\n            self.size = Some((s.0, s.1));\n        }\n        self\n    }\n\n    pub fn thumbnail(mut self, value: bool) -> PlotContext<'a> {\n        self.is_thumbnail = value;\n        self\n    }\n\n    pub fn line_comparison_path(&self) -> PathBuf {\n        let mut path = self.context.output_directory.clone();\n        path.push(self.id.as_directory_name());\n        path.push(\"report\");\n        path.push(\"lines.svg\");\n        path\n    }\n\n    pub fn line_throughput_comparison_path(&self) -> PathBuf {\n        let mut path = self.context.output_directory.clone();\n        path.push(self.id.as_directory_name());\n        path.push(\"report\");\n        path.push(\"lines_throughput.svg\");\n        path\n    }\n\n    pub fn violin_path(&self) -> PathBuf {\n        let mut path = self.context.output_directory.clone();\n        path.push(self.id.as_directory_name());\n        path.push(\"report\");\n        path.push(\"violin.svg\");\n        path\n    }\n}\n\n#[derive(Clone, Copy)]\npub(crate) struct PlotData<'a> {\n    pub(crate) formatter: &'a dyn ValueFormatter,\n    pub(crate) measurements: &'a MeasurementData<'a>,\n    pub(crate) comparison: Option<&'a ComparisonData>,\n}\n\nimpl<'a> PlotData<'a> {\n    pub fn comparison(mut self, comp: &'a ComparisonData) -> PlotData<'a> {\n        self.comparison = Some(comp);\n        self\n    }\n}\n\n#[derive(Clone, Copy)]\npub(crate) struct LinePlotConfig {\n    label: &'static str,\n    scale: fn(&dyn ValueFormatter, &BenchmarkId, f64, &BenchmarkId, &mut [f64]) -> &'static str,\n    path: fn(&PlotContext<'_>) -> PathBuf,\n}\n\nimpl LinePlotConfig {\n    pub fn time() -> Self {\n        Self {\n            label: \"time\",\n            scale: |formatter, _, max, _, vals| formatter.scale_values(max, vals),\n            path: |ctx| ctx.line_comparison_path(),\n        }\n    }\n\n    pub fn throughput() -> Self {\n        Self {\n            label: \"throughput\",\n            scale: |formatter, max_id, max, id, vals| {\n                // Scale values to be in line with max_id throughput\n                let from = id\n                    .throughput\n                    .as_ref()\n                    .expect(\"Throughput chart expects throughput to be defined\");\n                let to = max_id.throughput.as_ref().unwrap();\n\n                let (from_bytes, to_bytes) = match (from, to) {\n                    (Throughput::Bits(from), Throughput::Bits(to)) => (from, to),\n                    (Throughput::Bytes(from), Throughput::Bytes(to)) => (from, to),\n                    (Throughput::BytesDecimal(from), Throughput::BytesDecimal(to)) => (from, to),\n                    (Throughput::Elements(from), Throughput::Elements(to)) => (from, to),\n                    (\n                        Throughput::ElementsAndBytes {\n                            elements: _,\n                            bytes: from,\n                        },\n                        Throughput::ElementsAndBytes {\n                            elements: _,\n                            bytes: to,\n                        },\n                    ) => (from, to),\n                    _ => unreachable!(\"throughput types expected to be equal\"),\n                };\n\n                let mul = *to_bytes as f64 / *from_bytes as f64;\n\n                for val in vals.iter_mut() {\n                    *val *= mul;\n                }\n\n                formatter.scale_throughputs(max, to, vals)\n            },\n            path: |ctx| ctx.line_throughput_comparison_path(),\n        }\n    }\n}\n\npub(crate) trait Plotter {\n    fn pdf(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn regression(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn iteration_times(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn abs_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn rel_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn line_comparison(\n        &mut self,\n        line_config: LinePlotConfig,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n        value_type: ValueType,\n    );\n\n    fn violin(\n        &mut self,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    );\n\n    fn t_test(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>);\n\n    fn wait(&mut self);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Float trait\n\nuse cast::From;\nuse num_traits::float;\n\n/// This is an extension of `num_traits::float::Float` that adds safe\n/// casting and Sync + Send. Once `num_traits` has these features this\n/// can be removed.\npub trait Float:\n    float::Float + From<usize, Output = Self> + From<f32, Output = Self> + Sync + Send\n{\n}\n\nimpl Float for f32 {}\nimpl Float for f64 {}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use oorandom::Rand64;\nuse std::cell::RefCell;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub type Rng = Rand64;\n\nthread_local! {\n    static SEED_RAND: RefCell<Rand64> = RefCell::new(Rand64::new(\n        SystemTime::now().duration_since(UNIX_EPOCH)\n            .expect(\"Time went backwards\")\n            .as_millis()\n    ));\n}\n\npub fn new_rng() -> Rng {\n    SEED_RAND.with(|r| {\n        let mut r = r.borrow_mut();\n        let seed = ((r.rand_u64() as u128) << 64) | (r.rand_u64() as u128);\n        Rand64::new(seed)\n    })\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use rand::distributions::Standard;\nuse rand::prelude::*;\n\npub fn vec<T>(size: usize, start: usize) -> Option<Vec<T>>\nwhere\n    Standard: Distribution<T>,\n{\n    if size > start + 2 {\n        let mut rng = StdRng::from_entropy();\n\n        Some((0..size).map(|_| rng.gen()).collect())\n    } else {\n        None\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Helper traits for tupling/untupling\n\nuse crate::stats::Distribution;\n\n/// Any tuple: `(A, B, ..)`\npub trait Tuple: Sized {\n    /// A tuple of distributions associated with this tuple\n    type Distributions: TupledDistributions<Item = Self>;\n\n    /// A tuple of vectors associated with this tuple\n    type Builder: TupledDistributionsBuilder<Item = Self>;\n}\n\n/// A tuple of distributions: `(Distribution<A>, Distribution<B>, ..)`\npub trait TupledDistributions: Sized {\n    /// A tuple that can be pushed/inserted into the tupled distributions\n    type Item: Tuple<Distributions = Self>;\n}\n\n/// A tuple of vecs used to build distributions.\npub trait TupledDistributionsBuilder: Sized {\n    /// A tuple that can be pushed/inserted into the tupled distributions\n    type Item: Tuple<Builder = Self>;\n\n    /// Creates a new tuple of vecs\n    fn new(size: usize) -> Self;\n\n    /// Push one element into each of the vecs\n    fn push(&mut self, tuple: Self::Item);\n\n    /// Append one tuple of vecs to this one, leaving the vecs in the other tuple empty\n    fn extend(&mut self, other: &mut Self);\n\n    /// Convert the tuple of vectors into a tuple of distributions\n    fn complete(self) -> <Self::Item as Tuple>::Distributions;\n}\n\nimpl<A> Tuple for (A,)\nwhere\n    A: Copy,\n{\n    type Distributions = (Distribution<A>,);\n    type Builder = (Vec<A>,);\n}\n\nimpl<A> TupledDistributions for (Distribution<A>,)\nwhere\n    A: Copy,\n{\n    type Item = (A,);\n}\nimpl<A> TupledDistributionsBuilder for (Vec<A>,)\nwhere\n    A: Copy,\n{\n    type Item = (A,);\n\n    fn new(size: usize) -> (Vec<A>,) {\n        (Vec::with_capacity(size),)\n    }\n\n    fn push(&mut self, tuple: (A,)) {\n        (self.0).push(tuple.0);\n    }\n\n    fn extend(&mut self, other: &mut (Vec<A>,)) {\n        (self.0).append(&mut other.0);\n    }\n\n    fn complete(self) -> (Distribution<A>,) {\n        (Distribution(self.0.into_boxed_slice()),)\n    }\n}\n\nimpl<A, B> Tuple for (A, B)\nwhere\n    A: Copy,\n    B: Copy,\n{\n    type Distributions = (Distribution<A>, Distribution<B>);\n    type Builder = (Vec<A>, Vec<B>);\n}\n\nimpl<A, B> TupledDistributions for (Distribution<A>, Distribution<B>)\nwhere\n    A: Copy,\n    B: Copy,\n{\n    type Item = (A, B);\n}\nimpl<A, B> TupledDistributionsBuilder for (Vec<A>, Vec<B>)\nwhere\n    A: Copy,\n    B: Copy,\n{\n    type Item = (A, B);\n\n    fn new(size: usize) -> (Vec<A>, Vec<B>) {\n        (Vec::with_capacity(size), Vec::with_capacity(size))\n    }\n\n    fn push(&mut self, tuple: (A, B)) {\n        (self.0).push(tuple.0);\n        (self.1).push(tuple.1);\n    }\n\n    fn extend(&mut self, other: &mut (Vec<A>, Vec<B>)) {\n        (self.0).append(&mut other.0);\n        (self.1).append(&mut other.1);\n    }\n\n    fn complete(self) -> (Distribution<A>, Distribution<B>) {\n        (\n            Distribution(self.0.into_boxed_slice()),\n            Distribution(self.1.into_boxed_slice()),\n        )\n    }\n}\n\nimpl<A, B, C> Tuple for (A, B, C)\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n{\n    type Distributions = (Distribution<A>, Distribution<B>, Distribution<C>);\n    type Builder = (Vec<A>, Vec<B>, Vec<C>);\n}\n\nimpl<A, B, C> TupledDistributions for (Distribution<A>, Distribution<B>, Distribution<C>)\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n{\n    type Item = (A, B, C);\n}\nimpl<A, B, C> TupledDistributionsBuilder for (Vec<A>, Vec<B>, Vec<C>)\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n{\n    type Item = (A, B, C);\n\n    fn new(size: usize) -> (Vec<A>, Vec<B>, Vec<C>) {\n        (\n            Vec::with_capacity(size),\n            Vec::with_capacity(size),\n            Vec::with_capacity(size),\n        )\n    }\n\n    fn push(&mut self, tuple: (A, B, C)) {\n        (self.0).push(tuple.0);\n        (self.1).push(tuple.1);\n        (self.2).push(tuple.2);\n    }\n\n    fn extend(&mut self, other: &mut (Vec<A>, Vec<B>, Vec<C>)) {\n        (self.0).append(&mut other.0);\n        (self.1).append(&mut other.1);\n        (self.2).append(&mut other.2);\n    }\n\n    fn complete(self) -> (Distribution<A>, Distribution<B>, Distribution<C>) {\n        (\n            Distribution(self.0.into_boxed_slice()),\n            Distribution(self.1.into_boxed_slice()),\n            Distribution(self.2.into_boxed_slice()),\n        )\n    }\n}\n\nimpl<A, B, C, D> Tuple for (A, B, C, D)\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n    D: Copy,\n{\n    type Distributions = (\n        Distribution<A>,\n        Distribution<B>,\n        Distribution<C>,\n        Distribution<D>,\n    );\n    type Builder = (Vec<A>, Vec<B>, Vec<C>, Vec<D>);\n}\n\nimpl<A, B, C, D> TupledDistributions\n    for (\n        Distribution<A>,\n        Distribution<B>,\n        Distribution<C>,\n        Distribution<D>,\n    )\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n    D: Copy,\n{\n    type Item = (A, B, C, D);\n}\nimpl<A, B, C, D> TupledDistributionsBuilder for (Vec<A>, Vec<B>, Vec<C>, Vec<D>)\nwhere\n    A: Copy,\n    B: Copy,\n    C: Copy,\n    D: Copy,\n{\n    type Item = (A, B, C, D);\n\n    fn new(size: usize) -> (Vec<A>, Vec<B>, Vec<C>, Vec<D>) {\n        (\n            Vec::with_capacity(size),\n            Vec::with_capacity(size),\n            Vec::with_capacity(size),\n            Vec::with_capacity(size),\n        )\n    }\n\n    fn push(&mut self, tuple: (A, B, C, D)) {\n        (self.0).push(tuple.0);\n        (self.1).push(tuple.1);\n        (self.2).push(tuple.2);\n        (self.3).push(tuple.3);\n    }\n\n    fn extend(&mut self, other: &mut (Vec<A>, Vec<B>, Vec<C>, Vec<D>)) {\n        (self.0).append(&mut other.0);\n        (self.1).append(&mut other.1);\n        (self.2).append(&mut other.2);\n        (self.3).append(&mut other.3);\n    }\n\n    fn complete(\n        self,\n    ) -> (\n        Distribution<A>,\n        Distribution<B>,\n        Distribution<C>,\n        Distribution<D>,\n    ) {\n        (\n            Distribution(self.0.into_boxed_slice()),\n            Distribution(self.1.into_boxed_slice()),\n            Distribution(self.2.into_boxed_slice()),\n            Distribution(self.3.into_boxed_slice()),\n        )\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::Distribution;\nuse criterion_plot::prelude::*;\n\nuse super::*;\nuse crate::estimate::Estimate;\nuse crate::estimate::Statistic;\nuse crate::kde;\nuse crate::report::{ComparisonData, MeasurementData, ReportContext};\n\nfn abs_distribution(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    statistic: Statistic,\n    distribution: &Distribution<f64>,\n    estimate: &Estimate,\n    size: Option<Size>,\n) -> Child {\n    let ci = &estimate.confidence_interval;\n    let typical = ci.upper_bound;\n    let mut ci_values = [ci.lower_bound, ci.upper_bound, estimate.point_estimate];\n    let unit = formatter.scale_values(typical, &mut ci_values);\n    let (lb, ub, point) = (ci_values[0], ci_values[1], ci_values[2]);\n\n    let start = lb - (ub - lb) / 9.;\n    let end = ub + (ub - lb) / 9.;\n    let mut scaled_xs: Vec<f64> = distribution.iter().cloned().collect();\n    let _ = formatter.scale_values(typical, &mut scaled_xs);\n    let scaled_xs_sample = Sample::new(&scaled_xs);\n    let (kde_xs, ys) = kde::sweep(scaled_xs_sample, KDE_POINTS, Some((start, end)));\n\n    // interpolate between two points of the KDE sweep to find the Y position at the point estimate.\n    let n_point = kde_xs\n        .iter()\n        .position(|&x| x >= point)\n        .unwrap_or(kde_xs.len() - 1)\n        .max(1); // Must be at least the second element or this will panic\n    let slope = (ys[n_point] - ys[n_point - 1]) / (kde_xs[n_point] - kde_xs[n_point - 1]);\n    let y_point = ys[n_point - 1] + (slope * (point - kde_xs[n_point - 1]));\n\n    let zero = iter::repeat(0);\n\n    let start = kde_xs\n        .iter()\n        .enumerate()\n        .find(|&(_, &x)| x >= lb)\n        .unwrap()\n        .0;\n    let end = kde_xs\n        .iter()\n        .enumerate()\n        .rev()\n        .find(|&(_, &x)| x <= ub)\n        .unwrap()\n        .0;\n    let len = end - start;\n\n    let kde_xs_sample = Sample::new(&kde_xs);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .set(Title(format!(\n            \"{}: {}\",\n            gnuplot_escape(id.as_title()),\n            statistic\n        )))\n        .configure(Axis::BottomX, |a| {\n            a.set(Label(format!(\"Average time ({})\", unit)))\n                .set(Range::Limits(kde_xs_sample.min(), kde_xs_sample.max()))\n        })\n        .configure(Axis::LeftY, |a| a.set(Label(\"Density (a.u.)\")))\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Outside(Vertical::Top, Horizontal::Right))\n        })\n        .plot(\n            Lines {\n                x: &*kde_xs,\n                y: &*ys,\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(Label(\"Bootstrap distribution\"))\n                    .set(LineType::Solid)\n            },\n        )\n        .plot(\n            FilledCurve {\n                x: kde_xs.iter().skip(start).take(len),\n                y1: ys.iter().skip(start),\n                y2: zero,\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"Confidence interval\"))\n                    .set(Opacity(0.25))\n            },\n        )\n        .plot(\n            Lines {\n                x: &[point, point],\n                y: &[0., y_point],\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(Label(\"Point estimate\"))\n                    .set(LineType::Dash)\n            },\n        );\n\n    let path = context.report_path(id, &format!(\"{}.svg\", statistic));\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn abs_distributions(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Vec<Child> {\n    crate::plot::REPORT_STATS\n        .iter()\n        .filter_map(|stat| {\n            measurements.distributions.get(*stat).and_then(|dist| {\n                measurements\n                    .absolute_estimates\n                    .get(*stat)\n                    .map(|est| (*stat, dist, est))\n            })\n        })\n        .map(|(statistic, distribution, estimate)| {\n            abs_distribution(\n                id,\n                context,\n                formatter,\n                statistic,\n                distribution,\n                estimate,\n                size,\n            )\n        })\n        .collect::<Vec<_>>()\n}\n\nfn rel_distribution(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    statistic: Statistic,\n    distribution: &Distribution<f64>,\n    estimate: &Estimate,\n    noise_threshold: f64,\n    size: Option<Size>,\n) -> Child {\n    let ci = &estimate.confidence_interval;\n    let (lb, ub) = (ci.lower_bound, ci.upper_bound);\n\n    let start = lb - (ub - lb) / 9.;\n    let end = ub + (ub - lb) / 9.;\n    let (xs, ys) = kde::sweep(distribution, KDE_POINTS, Some((start, end)));\n    let xs_ = Sample::new(&xs);\n\n    // interpolate between two points of the KDE sweep to find the Y position at the point estimate.\n    let point = estimate.point_estimate;\n    let n_point = xs\n        .iter()\n        .position(|&x| x >= point)\n        .unwrap_or(ys.len() - 1)\n        .max(1);\n    let slope = (ys[n_point] - ys[n_point - 1]) / (xs[n_point] - xs[n_point - 1]);\n    let y_point = ys[n_point - 1] + (slope * (point - xs[n_point - 1]));\n\n    let one = iter::repeat(1);\n    let zero = iter::repeat(0);\n\n    let start = xs.iter().enumerate().find(|&(_, &x)| x >= lb).unwrap().0;\n    let end = xs\n        .iter()\n        .enumerate()\n        .rev()\n        .find(|&(_, &x)| x <= ub)\n        .unwrap()\n        .0;\n    let len = end - start;\n\n    let x_min = xs_.min();\n    let x_max = xs_.max();\n\n    let (fc_start, fc_end) = if noise_threshold < x_min || -noise_threshold > x_max {\n        let middle = (x_min + x_max) / 2.;\n\n        (middle, middle)\n    } else {\n        (\n            if -noise_threshold < x_min {\n                x_min\n            } else {\n                -noise_threshold\n            },\n            if noise_threshold > x_max {\n                x_max\n            } else {\n                noise_threshold\n            },\n        )\n    };\n\n    let mut figure = Figure::new();\n\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::LeftY, |a| a.set(Label(\"Density (a.u.)\")))\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Outside(Vertical::Top, Horizontal::Right))\n        })\n        .set(Title(format!(\n            \"{}: {}\",\n            gnuplot_escape(id.as_title()),\n            statistic\n        )))\n        .configure(Axis::BottomX, |a| {\n            a.set(Label(\"Relative change (%)\"))\n                .set(Range::Limits(x_min * 100., x_max * 100.))\n                .set(ScaleFactor(100.))\n        })\n        .plot(Lines { x: &*xs, y: &*ys }, |c| {\n            c.set(DARK_BLUE)\n                .set(LINEWIDTH)\n                .set(Label(\"Bootstrap distribution\"))\n                .set(LineType::Solid)\n        })\n        .plot(\n            FilledCurve {\n                x: xs.iter().skip(start).take(len),\n                y1: ys.iter().skip(start),\n                y2: zero.clone(),\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"Confidence interval\"))\n                    .set(Opacity(0.25))\n            },\n        )\n        .plot(\n            Lines {\n                x: &[point, point],\n                y: &[0., y_point],\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(Label(\"Point estimate\"))\n                    .set(LineType::Dash)\n            },\n        )\n        .plot(\n            FilledCurve {\n                x: &[fc_start, fc_end],\n                y1: one,\n                y2: zero,\n            },\n            |c| {\n                c.set(Axes::BottomXRightY)\n                    .set(DARK_RED)\n                    .set(Label(\"Noise threshold\"))\n                    .set(Opacity(0.1))\n            },\n        );\n\n    let path = context.report_path(id, &format!(\"change/{}.svg\", statistic));\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn rel_distributions(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    _measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Vec<Child> {\n    crate::plot::CHANGE_STATS\n        .iter()\n        .map(|&statistic| {\n            rel_distribution(\n                id,\n                context,\n                statistic,\n                comparison.relative_distributions.get(statistic),\n                comparison.relative_estimates.get(statistic),\n                comparison.noise_threshold,\n                size,\n            )\n        })\n        .collect::<Vec<_>>()\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion_plot::prelude::*;\n\nuse super::*;\nuse crate::report::{ComparisonData, MeasurementData, ReportContext};\n\nfn iteration_times_figure(\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Figure {\n    let data = &measurements.avg_times;\n    let max_avg_time = data.max();\n    let mut scaled_y: Vec<_> = data.iter().map(|(f, _)| f).collect();\n    let unit = formatter.scale_values(max_avg_time, &mut scaled_y);\n    let scaled_y = Sample::new(&scaled_y);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.configure(Grid::Major, |g| g.show()).set(Label(\"Sample\"))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(format!(\"Average Iteration Time ({})\", unit)))\n        })\n        .plot(\n            Points {\n                x: 1..(data.len() + 1),\n                y: scaled_y.as_ref(),\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(PointSize(0.5))\n                    .set(PointType::FilledCircle)\n            },\n        );\n    figure\n}\n\npub(crate) fn iteration_times(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = iteration_times_figure(formatter, measurements, size);\n    figure.set(Title(gnuplot_escape(id.as_title())));\n    figure.configure(Key, |k| {\n        k.set(Justification::Left)\n            .set(Order::SampleText)\n            .set(Position::Inside(Vertical::Top, Horizontal::Left))\n    });\n\n    let path = context.report_path(id, \"iteration_times.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn iteration_times_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = iteration_times_figure(formatter, measurements, size);\n    figure.configure(Key, |k| k.hide());\n\n    let path = context.report_path(id, \"iteration_times_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\nfn iteration_times_comparison_figure(\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Figure {\n    let current_data = &measurements.avg_times;\n    let base_data = &comparison.base_avg_times;\n\n    let mut all_data: Vec<f64> = current_data.iter().map(|(f, _)| f).collect();\n    all_data.extend_from_slice(base_data);\n\n    let typical_value = Sample::new(&all_data).max();\n    let unit = formatter.scale_values(typical_value, &mut all_data);\n\n    let (scaled_current_y, scaled_base_y) = all_data.split_at(current_data.len());\n    let scaled_current_y = Sample::new(scaled_current_y);\n    let scaled_base_y = Sample::new(scaled_base_y);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.configure(Grid::Major, |g| g.show()).set(Label(\"Sample\"))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(format!(\"Average Iteration Time ({})\", unit)))\n        })\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Inside(Vertical::Top, Horizontal::Left))\n        })\n        .plot(\n            Points {\n                x: 1..(current_data.len() + 1),\n                y: scaled_base_y.as_ref(),\n            },\n            |c| {\n                c.set(DARK_RED)\n                    .set(Label(\"Base\"))\n                    .set(PointSize(0.5))\n                    .set(PointType::FilledCircle)\n            },\n        )\n        .plot(\n            Points {\n                x: 1..(current_data.len() + 1),\n                y: scaled_current_y.as_ref(),\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"Current\"))\n                    .set(PointSize(0.5))\n                    .set(PointType::FilledCircle)\n            },\n        );\n    figure\n}\n\npub(crate) fn iteration_times_comparison(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = iteration_times_comparison_figure(formatter, measurements, comparison, size);\n    figure.set(Title(gnuplot_escape(id.as_title())));\n\n    let path = context.report_path(id, \"both/iteration_times.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn iteration_times_comparison_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = iteration_times_comparison_figure(formatter, measurements, comparison, size);\n    figure.configure(Key, |k| k.hide());\n\n    let path = context.report_path(id, \"relative_iteration_times_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::iter;\nuse std::path::Path;\nuse std::process::Child;\n\nuse crate::stats::univariate::Sample;\nuse criterion_plot::prelude::*;\n\nmod distributions;\nmod iteration_times;\nmod pdf;\nmod regression;\nmod summary;\nmod t_test;\nuse self::distributions::*;\nuse self::iteration_times::*;\nuse self::pdf::*;\nuse self::regression::*;\nuse self::summary::*;\nuse self::t_test::*;\n\nuse crate::measurement::ValueFormatter;\nuse crate::report::{BenchmarkId, ValueType};\nuse crate::stats::bivariate::Data;\n\nuse super::{LinePlotConfig, PlotContext, PlotData, Plotter};\nuse crate::format;\n\nfn gnuplot_escape(string: &str) -> String {\n    string.replace('_', \"\\\\_\").replace('\\'', \"''\")\n}\n\nstatic DEFAULT_FONT: &str = \"Helvetica\";\nstatic KDE_POINTS: usize = 500;\nstatic SIZE: Size = Size(1280, 720);\n\nconst LINEWIDTH: LineWidth = LineWidth(2.);\nconst POINT_SIZE: PointSize = PointSize(0.75);\n\nconst DARK_BLUE: Color = Color::Rgb(31, 120, 180);\nconst DARK_ORANGE: Color = Color::Rgb(255, 127, 0);\nconst DARK_RED: Color = Color::Rgb(227, 26, 28);\n\nfn debug_script(path: &Path, figure: &Figure) {\n    if crate::debug_enabled() {\n        let mut script_path = path.to_path_buf();\n        script_path.set_extension(\"gnuplot\");\n        info!(\"Writing gnuplot script to {:?}\", script_path);\n        let result = figure.save(script_path.as_path());\n        if let Err(e) = result {\n            error!(\"Failed to write debug output: {}\", e);\n        }\n    }\n}\n\n#[derive(Default)]\npub(crate) struct Gnuplot {\n    process_list: Vec<Child>,\n}\n\nimpl Plotter for Gnuplot {\n    fn pdf(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        self.process_list.push(if ctx.is_thumbnail {\n            if let Some(cmp) = data.comparison {\n                pdf_comparison_small(\n                    ctx.id,\n                    ctx.context,\n                    data.formatter,\n                    data.measurements,\n                    cmp,\n                    size,\n                )\n            } else {\n                pdf_small(ctx.id, ctx.context, data.formatter, data.measurements, size)\n            }\n        } else if let Some(cmp) = data.comparison {\n            pdf_comparison(\n                ctx.id,\n                ctx.context,\n                data.formatter,\n                data.measurements,\n                cmp,\n                size,\n            )\n        } else {\n            pdf(ctx.id, ctx.context, data.formatter, data.measurements, size)\n        });\n    }\n\n    fn regression(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        self.process_list.push(if ctx.is_thumbnail {\n            if let Some(cmp) = data.comparison {\n                let base_data = Data::new(&cmp.base_iter_counts, &cmp.base_sample_times);\n                regression_comparison_small(\n                    ctx.id,\n                    ctx.context,\n                    data.formatter,\n                    data.measurements,\n                    cmp,\n                    &base_data,\n                    size,\n                )\n            } else {\n                regression_small(ctx.id, ctx.context, data.formatter, data.measurements, size)\n            }\n        } else if let Some(cmp) = data.comparison {\n            let base_data = Data::new(&cmp.base_iter_counts, &cmp.base_sample_times);\n            regression_comparison(\n                ctx.id,\n                ctx.context,\n                data.formatter,\n                data.measurements,\n                cmp,\n                &base_data,\n                size,\n            )\n        } else {\n            regression(ctx.id, ctx.context, data.formatter, data.measurements, size)\n        });\n    }\n\n    fn iteration_times(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        self.process_list.push(if ctx.is_thumbnail {\n            if let Some(cmp) = data.comparison {\n                iteration_times_comparison_small(\n                    ctx.id,\n                    ctx.context,\n                    data.formatter,\n                    data.measurements,\n                    cmp,\n                    size,\n                )\n            } else {\n                iteration_times_small(ctx.id, ctx.context, data.formatter, data.measurements, size)\n            }\n        } else if let Some(cmp) = data.comparison {\n            iteration_times_comparison(\n                ctx.id,\n                ctx.context,\n                data.formatter,\n                data.measurements,\n                cmp,\n                size,\n            )\n        } else {\n            iteration_times(ctx.id, ctx.context, data.formatter, data.measurements, size)\n        });\n    }\n\n    fn abs_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        self.process_list.extend(abs_distributions(\n            ctx.id,\n            ctx.context,\n            data.formatter,\n            data.measurements,\n            size,\n        ));\n    }\n\n    fn rel_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        if let Some(cmp) = data.comparison {\n            self.process_list.extend(rel_distributions(\n                ctx.id,\n                ctx.context,\n                data.measurements,\n                cmp,\n                size,\n            ));\n        } else {\n            error!(\"Comparison data is not provided for a relative distribution figure\");\n        }\n    }\n\n    fn t_test(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let size = ctx.size.map(|(w, h)| Size(w, h));\n        if let Some(cmp) = data.comparison {\n            self.process_list\n                .push(t_test(ctx.id, ctx.context, data.measurements, cmp, size));\n        } else {\n            error!(\"Comparison data is not provided for t_test plot\");\n        }\n    }\n\n    fn line_comparison(\n        &mut self,\n        line_config: LinePlotConfig,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n        value_type: ValueType,\n    ) {\n        let path = (line_config.path)(&ctx);\n        self.process_list.push(line_comparison(\n            line_config,\n            formatter,\n            ctx.id.as_title(),\n            all_curves,\n            &path,\n            value_type,\n            ctx.context.plot_config.summary_scale,\n        ));\n    }\n\n    fn violin(\n        &mut self,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    ) {\n        let violin_path = ctx.violin_path();\n\n        self.process_list.push(violin(\n            formatter,\n            ctx.id.as_title(),\n            all_curves,\n            &violin_path,\n            ctx.context.plot_config.summary_scale,\n        ));\n    }\n\n    fn wait(&mut self) {\n        let start = std::time::Instant::now();\n        let child_count = self.process_list.len();\n        for child in self.process_list.drain(..) {\n            match child.wait_with_output() {\n                Ok(ref out) if out.status.success() => {}\n                Ok(out) => error!(\"Error in Gnuplot: {}\", String::from_utf8_lossy(&out.stderr)),\n                Err(e) => error!(\"Got IO error while waiting for Gnuplot to complete: {}\", e),\n            }\n        }\n        let elapsed = &start.elapsed();\n        info!(\n            \"Waiting for {} gnuplot processes took {}\",\n            child_count,\n            format::time(elapsed.as_nanos() as f64)\n        );\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::*;\nuse crate::kde;\nuse crate::report::{ComparisonData, MeasurementData, ReportContext};\n\npub(crate) fn pdf(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let avg_times = &measurements.avg_times;\n    let typical = avg_times.max();\n    let mut scaled_avg_times: Vec<f64> = (avg_times as &Sample<f64>).iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_avg_times);\n    let scaled_avg_times = Sample::new(&scaled_avg_times);\n\n    let mean = scaled_avg_times.mean();\n\n    let iter_counts = measurements.iter_counts();\n    let &max_iters = iter_counts\n        .iter()\n        .max_by_key(|&&iters| iters as u64)\n        .unwrap();\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n    let y_scale = 10f64.powi(-exponent);\n\n    let y_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let (xs, ys) = kde::sweep(scaled_avg_times, KDE_POINTS, None);\n    let (lost, lomt, himt, hist) = avg_times.fences();\n    let mut fences = [lost, lomt, himt, hist];\n    let _ = formatter.scale_values(typical, &mut fences);\n    let [lost, lomt, himt, hist] = fences;\n\n    let vertical = &[0., max_iters];\n    let zeros = iter::repeat(0);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            let xs_ = Sample::new(&xs);\n            a.set(Label(format!(\"Average time ({})\", unit)))\n                .set(Range::Limits(xs_.min(), xs_.max()))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.set(Label(y_label))\n                .set(Range::Limits(0., max_iters * y_scale))\n                .set(ScaleFactor(y_scale))\n        })\n        .configure(Axis::RightY, |a| a.set(Label(\"Density (a.u.)\")))\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Outside(Vertical::Top, Horizontal::Right))\n        })\n        .plot(\n            FilledCurve {\n                x: &*xs,\n                y1: &*ys,\n                y2: zeros,\n            },\n            |c| {\n                c.set(Axes::BottomXRightY)\n                    .set(DARK_BLUE)\n                    .set(Label(\"PDF\"))\n                    .set(Opacity(0.25))\n            },\n        )\n        .plot(\n            Lines {\n                x: &[mean, mean],\n                y: vertical,\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(LineType::Dash)\n                    .set(Label(\"Mean\"))\n            },\n        )\n        .plot(\n            Points {\n                x: avg_times\n                    .iter()\n                    .zip(scaled_avg_times.iter())\n                    .filter_map(\n                        |((_, label), t)| {\n                            if label.is_outlier() {\n                                None\n                            } else {\n                                Some(t)\n                            }\n                        },\n                    ),\n                y: avg_times\n                    .iter()\n                    .zip(iter_counts.iter())\n                    .filter_map(\n                        |((_, label), i)| {\n                            if label.is_outlier() {\n                                None\n                            } else {\n                                Some(i)\n                            }\n                        },\n                    ),\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"\\\"Clean\\\" sample\"))\n                    .set(PointType::FilledCircle)\n                    .set(POINT_SIZE)\n            },\n        )\n        .plot(\n            Points {\n                x: avg_times\n                    .iter()\n                    .zip(scaled_avg_times.iter())\n                    .filter_map(\n                        |((_, label), t)| {\n                            if label.is_mild() {\n                                Some(t)\n                            } else {\n                                None\n                            }\n                        },\n                    ),\n                y: avg_times\n                    .iter()\n                    .zip(iter_counts.iter())\n                    .filter_map(\n                        |((_, label), i)| {\n                            if label.is_mild() {\n                                Some(i)\n                            } else {\n                                None\n                            }\n                        },\n                    ),\n            },\n            |c| {\n                c.set(DARK_ORANGE)\n                    .set(Label(\"Mild outliers\"))\n                    .set(POINT_SIZE)\n                    .set(PointType::FilledCircle)\n            },\n        )\n        .plot(\n            Points {\n                x: avg_times\n                    .iter()\n                    .zip(scaled_avg_times.iter())\n                    .filter_map(\n                        |((_, label), t)| {\n                            if label.is_severe() {\n                                Some(t)\n                            } else {\n                                None\n                            }\n                        },\n                    ),\n                y: avg_times\n                    .iter()\n                    .zip(iter_counts.iter())\n                    .filter_map(\n                        |((_, label), i)| {\n                            if label.is_severe() {\n                                Some(i)\n                            } else {\n                                None\n                            }\n                        },\n                    ),\n            },\n            |c| {\n                c.set(DARK_RED)\n                    .set(Label(\"Severe outliers\"))\n                    .set(POINT_SIZE)\n                    .set(PointType::FilledCircle)\n            },\n        )\n        .plot(\n            Lines {\n                x: &[lomt, lomt],\n                y: vertical,\n            },\n            |c| c.set(DARK_ORANGE).set(LINEWIDTH).set(LineType::Dash),\n        )\n        .plot(\n            Lines {\n                x: &[himt, himt],\n                y: vertical,\n            },\n            |c| c.set(DARK_ORANGE).set(LINEWIDTH).set(LineType::Dash),\n        )\n        .plot(\n            Lines {\n                x: &[lost, lost],\n                y: vertical,\n            },\n            |c| c.set(DARK_RED).set(LINEWIDTH).set(LineType::Dash),\n        )\n        .plot(\n            Lines {\n                x: &[hist, hist],\n                y: vertical,\n            },\n            |c| c.set(DARK_RED).set(LINEWIDTH).set(LineType::Dash),\n        );\n    figure.set(Title(gnuplot_escape(id.as_title())));\n\n    let path = context.report_path(id, \"pdf.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn pdf_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let avg_times = &*measurements.avg_times;\n    let typical = avg_times.max();\n    let mut scaled_avg_times: Vec<f64> = (avg_times as &Sample<f64>).iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_avg_times);\n    let scaled_avg_times = Sample::new(&scaled_avg_times);\n    let mean = scaled_avg_times.mean();\n\n    let (xs, ys, mean_y) = kde::sweep_and_estimate(scaled_avg_times, KDE_POINTS, None, mean);\n    let xs_ = Sample::new(&xs);\n    let ys_ = Sample::new(&ys);\n\n    let y_limit = ys_.max() * 1.1;\n    let zeros = iter::repeat(0);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.set(Label(format!(\"Average time ({})\", unit)))\n                .set(Range::Limits(xs_.min(), xs_.max()))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.set(Label(\"Density (a.u.)\"))\n                .set(Range::Limits(0., y_limit))\n        })\n        .configure(Axis::RightY, |a| a.hide())\n        .configure(Key, |k| k.hide())\n        .plot(\n            FilledCurve {\n                x: &*xs,\n                y1: &*ys,\n                y2: zeros,\n            },\n            |c| {\n                c.set(Axes::BottomXRightY)\n                    .set(DARK_BLUE)\n                    .set(Label(\"PDF\"))\n                    .set(Opacity(0.25))\n            },\n        )\n        .plot(\n            Lines {\n                x: &[mean, mean],\n                y: &[0., mean_y],\n            },\n            |c| c.set(DARK_BLUE).set(LINEWIDTH).set(Label(\"Mean\")),\n        );\n\n    let path = context.report_path(id, \"pdf_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\nfn pdf_comparison_figure(\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Figure {\n    let base_avg_times = Sample::new(&comparison.base_avg_times);\n    let typical = base_avg_times.max().max(measurements.avg_times.max());\n    let mut scaled_base_avg_times: Vec<f64> = comparison.base_avg_times.clone();\n    let unit = formatter.scale_values(typical, &mut scaled_base_avg_times);\n    let scaled_base_avg_times = Sample::new(&scaled_base_avg_times);\n\n    let mut scaled_new_avg_times: Vec<f64> = (&measurements.avg_times as &Sample<f64>)\n        .iter()\n        .cloned()\n        .collect();\n    let _ = formatter.scale_values(typical, &mut scaled_new_avg_times);\n    let scaled_new_avg_times = Sample::new(&scaled_new_avg_times);\n\n    let base_mean = scaled_base_avg_times.mean();\n    let new_mean = scaled_new_avg_times.mean();\n\n    let (base_xs, base_ys, base_y_mean) =\n        kde::sweep_and_estimate(scaled_base_avg_times, KDE_POINTS, None, base_mean);\n    let (xs, ys, y_mean) =\n        kde::sweep_and_estimate(scaled_new_avg_times, KDE_POINTS, None, new_mean);\n\n    let zeros = iter::repeat(0);\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.set(Label(format!(\"Average time ({})\", unit)))\n        })\n        .configure(Axis::LeftY, |a| a.set(Label(\"Density (a.u.)\")))\n        .configure(Axis::RightY, |a| a.hide())\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Outside(Vertical::Top, Horizontal::Right))\n        })\n        .plot(\n            FilledCurve {\n                x: &*base_xs,\n                y1: &*base_ys,\n                y2: zeros.clone(),\n            },\n            |c| c.set(DARK_RED).set(Label(\"Base PDF\")).set(Opacity(0.5)),\n        )\n        .plot(\n            Lines {\n                x: &[base_mean, base_mean],\n                y: &[0., base_y_mean],\n            },\n            |c| c.set(DARK_RED).set(Label(\"Base Mean\")).set(LINEWIDTH),\n        )\n        .plot(\n            FilledCurve {\n                x: &*xs,\n                y1: &*ys,\n                y2: zeros,\n            },\n            |c| c.set(DARK_BLUE).set(Label(\"New PDF\")).set(Opacity(0.5)),\n        )\n        .plot(\n            Lines {\n                x: &[new_mean, new_mean],\n                y: &[0., y_mean],\n            },\n            |c| c.set(DARK_BLUE).set(Label(\"New Mean\")).set(LINEWIDTH),\n        );\n    figure\n}\n\npub(crate) fn pdf_comparison(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = pdf_comparison_figure(formatter, measurements, comparison, size);\n    figure.set(Title(gnuplot_escape(id.as_title())));\n    let path = context.report_path(id, \"both/pdf.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn pdf_comparison_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = pdf_comparison_figure(formatter, measurements, comparison, size);\n    figure.configure(Key, |k| k.hide());\n    let path = context.report_path(id, \"relative_pdf_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::bivariate::regression::Slope;\nuse criterion_plot::prelude::*;\n\nuse super::*;\nuse crate::report::{ComparisonData, MeasurementData, ReportContext};\n\nuse crate::estimate::{ConfidenceInterval, Estimate};\n\nfn regression_figure(\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Figure {\n    let slope_estimate = measurements.absolute_estimates.slope.as_ref().unwrap();\n    let slope_dist = measurements.distributions.slope.as_ref().unwrap();\n    let (lb, ub) =\n        slope_dist.confidence_interval(slope_estimate.confidence_interval.confidence_level);\n\n    let data = &measurements.data;\n    let (max_iters, typical) = (data.x().max(), data.y().max());\n    let mut scaled_y: Vec<f64> = data.y().iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_y);\n    let scaled_y = Sample::new(&scaled_y);\n\n    let point_estimate = Slope::fit(&measurements.data).0;\n    let mut scaled_points = [point_estimate * max_iters, lb * max_iters, ub * max_iters];\n    let _ = formatter.scale_values(typical, &mut scaled_points);\n    let [point, lb, ub] = scaled_points;\n\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n    let x_scale = 10f64.powi(-exponent);\n\n    let x_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(x_label))\n                .set(ScaleFactor(x_scale))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(format!(\"Total sample time ({})\", unit)))\n        })\n        .plot(\n            Points {\n                x: data.x().as_ref(),\n                y: scaled_y.as_ref(),\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"Sample\"))\n                    .set(PointSize(0.5))\n                    .set(PointType::FilledCircle)\n            },\n        )\n        .plot(\n            Lines {\n                x: &[0., max_iters],\n                y: &[0., point],\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(Label(\"Linear regression\"))\n                    .set(LineType::Solid)\n            },\n        )\n        .plot(\n            FilledCurve {\n                x: &[0., max_iters],\n                y1: &[0., lb],\n                y2: &[0., ub],\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(Label(\"Confidence interval\"))\n                    .set(Opacity(0.25))\n            },\n        );\n    figure\n}\n\npub(crate) fn regression(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = regression_figure(formatter, measurements, size);\n    figure.set(Title(gnuplot_escape(id.as_title())));\n    figure.configure(Key, |k| {\n        k.set(Justification::Left)\n            .set(Order::SampleText)\n            .set(Position::Inside(Vertical::Top, Horizontal::Left))\n    });\n\n    let path = context.report_path(id, \"regression.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn regression_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure = regression_figure(formatter, measurements, size);\n    figure.configure(Key, |k| k.hide());\n\n    let path = context.report_path(id, \"regression_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\nfn regression_comparison_figure(\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    base_data: &Data<'_, f64, f64>,\n    size: Option<Size>,\n) -> Figure {\n    let data = &measurements.data;\n    let max_iters = base_data.x().max().max(data.x().max());\n    let typical = base_data.y().max().max(data.y().max());\n\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n    let x_scale = 10f64.powi(-exponent);\n\n    let x_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let Estimate {\n        confidence_interval:\n            ConfidenceInterval {\n                lower_bound: base_lb,\n                upper_bound: base_ub,\n                ..\n            },\n        point_estimate: base_point,\n        ..\n    } = comparison.base_estimates.slope.as_ref().unwrap();\n\n    let Estimate {\n        confidence_interval:\n            ConfidenceInterval {\n                lower_bound: lb,\n                upper_bound: ub,\n                ..\n            },\n        point_estimate: point,\n        ..\n    } = measurements.absolute_estimates.slope.as_ref().unwrap();\n\n    let mut points = [\n        base_lb * max_iters,\n        base_point * max_iters,\n        base_ub * max_iters,\n        lb * max_iters,\n        point * max_iters,\n        ub * max_iters,\n    ];\n    let unit = formatter.scale_values(typical, &mut points);\n    let [base_lb, base_point, base_ub, lb, point, ub] = points;\n\n    let mut figure = Figure::new();\n    figure\n        .set(Font(DEFAULT_FONT))\n        .set(size.unwrap_or(SIZE))\n        .configure(Axis::BottomX, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(x_label))\n                .set(ScaleFactor(x_scale))\n        })\n        .configure(Axis::LeftY, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .set(Label(format!(\"Total sample time ({})\", unit)))\n        })\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Inside(Vertical::Top, Horizontal::Left))\n        })\n        .plot(\n            FilledCurve {\n                x: &[0., max_iters],\n                y1: &[0., base_lb],\n                y2: &[0., base_ub],\n            },\n            |c| c.set(DARK_RED).set(Opacity(0.25)),\n        )\n        .plot(\n            FilledCurve {\n                x: &[0., max_iters],\n                y1: &[0., lb],\n                y2: &[0., ub],\n            },\n            |c| c.set(DARK_BLUE).set(Opacity(0.25)),\n        )\n        .plot(\n            Lines {\n                x: &[0., max_iters],\n                y: &[0., base_point],\n            },\n            |c| {\n                c.set(DARK_RED)\n                    .set(LINEWIDTH)\n                    .set(Label(\"Base sample\"))\n                    .set(LineType::Solid)\n            },\n        )\n        .plot(\n            Lines {\n                x: &[0., max_iters],\n                y: &[0., point],\n            },\n            |c| {\n                c.set(DARK_BLUE)\n                    .set(LINEWIDTH)\n                    .set(Label(\"New sample\"))\n                    .set(LineType::Solid)\n            },\n        );\n    figure\n}\n\npub(crate) fn regression_comparison(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    base_data: &Data<'_, f64, f64>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure =\n        regression_comparison_figure(formatter, measurements, comparison, base_data, size);\n    figure.set(Title(gnuplot_escape(id.as_title())));\n\n    let path = context.report_path(id, \"both/regression.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}\n\npub(crate) fn regression_comparison_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    base_data: &Data<'_, f64, f64>,\n    size: Option<Size>,\n) -> Child {\n    let mut figure =\n        regression_comparison_figure(formatter, measurements, comparison, base_data, size);\n    figure.configure(Key, |k| k.hide());\n\n    let path = context.report_path(id, \"relative_regression_small.svg\");\n    debug_script(&path, &figure);\n    figure.set(Output(path)).draw().unwrap()\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use {\n    super::{\n        debug_script, gnuplot_escape, DARK_BLUE, DEFAULT_FONT, KDE_POINTS, LINEWIDTH, POINT_SIZE,\n        SIZE,\n    },\n    crate::{\n        kde,\n        measurement::ValueFormatter,\n        plot::LinePlotConfig,\n        report::{BenchmarkId, ValueType},\n        stats::univariate::Sample,\n        AxisScale,\n    },\n    criterion_plot::prelude::*,\n    itertools::Itertools,\n    std::{\n        cmp::Ordering,\n        path::{Path, PathBuf},\n        process::Child,\n    },\n};\n\nconst NUM_COLORS: usize = 8;\nstatic COMPARISON_COLORS: [Color; NUM_COLORS] = [\n    Color::Rgb(178, 34, 34),\n    Color::Rgb(46, 139, 87),\n    Color::Rgb(0, 139, 139),\n    Color::Rgb(255, 215, 0),\n    Color::Rgb(0, 0, 139),\n    Color::Rgb(220, 20, 60),\n    Color::Rgb(139, 0, 139),\n    Color::Rgb(0, 255, 127),\n];\n\nimpl AxisScale {\n    fn to_gnuplot(self) -> Scale {\n        match self {\n            AxisScale::Linear => Scale::Linear,\n            AxisScale::Logarithmic => Scale::Logarithmic,\n        }\n    }\n}\n\n#[allow(clippy::explicit_counter_loop)]\npub(crate) fn line_comparison(\n    line_cfg: LinePlotConfig,\n    formatter: &dyn ValueFormatter,\n    title: &str,\n    all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    path: &Path,\n    value_type: ValueType,\n    axis_scale: AxisScale,\n) -> Child {\n    let path = PathBuf::from(path);\n    let mut f = Figure::new();\n\n    let input_suffix = match value_type {\n        ValueType::Bytes => \" Size (Bytes)\",\n        ValueType::Elements => \" Size (Elements)\",\n        ValueType::Bits => \" Size (Bits)\",\n        ValueType::Value => \"\",\n    };\n\n    f.set(Font(DEFAULT_FONT))\n        .set(SIZE)\n        .configure(Key, |k| {\n            k.set(Justification::Left)\n                .set(Order::SampleText)\n                .set(Position::Outside(Vertical::Top, Horizontal::Right))\n        })\n        .set(Title(format!(\"{}: Comparison\", gnuplot_escape(title))))\n        .configure(Axis::BottomX, |a| {\n            a.set(Label(format!(\"Input{}\", input_suffix)))\n                .set(axis_scale.to_gnuplot())\n        });\n\n    let mut i = 0;\n\n    let (max_id, max) = all_curves\n        .iter()\n        .map(|&(id, data)| (*id, Sample::new(data).mean()))\n        .fold(None, |prev: Option<(&BenchmarkId, f64)>, next| match prev {\n            Some(prev) if prev.1 >= next.1 => Some(prev),\n            _ => Some(next),\n        })\n        .unwrap();\n\n    let mut max_formatted = [max];\n    let unit = (line_cfg.scale)(formatter, max_id, max, max_id, &mut max_formatted);\n\n    f.configure(Axis::LeftY, |a| {\n        a.configure(Grid::Major, |g| g.show())\n            .configure(Grid::Minor, |g| g.hide())\n            .set(Label(format!(\"Average {} ({})\", line_cfg.label, unit)))\n            .set(axis_scale.to_gnuplot())\n    });\n\n    // This assumes the curves are sorted. It also assumes that the benchmark IDs all have numeric\n    // values or throughputs and that value is sensible (ie. not a mix of bytes and elements\n    // or whatnot)\n    for (key, group) in &all_curves.iter().chunk_by(|&&&(id, _)| &id.function_id) {\n        let mut tuples: Vec<_> = group\n            .map(|&&(id, ref sample)| {\n                // Unwrap is fine here because it will only fail if the assumptions above are not true\n                // ie. programmer error.\n                let x = id.as_number().unwrap();\n                let mut y = [Sample::new(sample).mean()];\n\n                (line_cfg.scale)(formatter, max_id, max, id, &mut y);\n\n                (x, y[0])\n            })\n            .collect();\n        tuples.sort_by(|&(ax, _), &(bx, _)| ax.partial_cmp(&bx).unwrap_or(Ordering::Less));\n        let (xs, ys): (Vec<_>, Vec<_>) = tuples.into_iter().unzip();\n\n        let function_name = key.as_ref().map(|string| gnuplot_escape(string));\n\n        f.plot(Lines { x: &xs, y: &ys }, |c| {\n            if let Some(name) = function_name {\n                c.set(Label(name));\n            }\n            c.set(LINEWIDTH)\n                .set(LineType::Solid)\n                .set(COMPARISON_COLORS[i % NUM_COLORS])\n        })\n        .plot(Points { x: &xs, y: &ys }, |p| {\n            p.set(PointType::FilledCircle)\n                .set(POINT_SIZE)\n                .set(COMPARISON_COLORS[i % NUM_COLORS])\n        });\n\n        i += 1;\n    }\n\n    debug_script(&path, &f);\n    f.set(Output(path)).draw().unwrap()\n}\n\npub fn violin(\n    formatter: &dyn ValueFormatter,\n    title: &str,\n    all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    path: &Path,\n    axis_scale: AxisScale,\n) -> Child {\n    let path = PathBuf::from(&path);\n    let all_curves_vec = all_curves.iter().rev().cloned().collect::<Vec<_>>();\n    let all_curves: &[&(&BenchmarkId, Vec<f64>)] = &all_curves_vec;\n\n    let kdes = all_curves\n        .iter()\n        .map(|&(_, sample)| {\n            let (x, mut y) = kde::sweep(Sample::new(sample), KDE_POINTS, None);\n            let y_max = Sample::new(&y).max();\n            for y in y.iter_mut() {\n                *y /= y_max;\n            }\n\n            (x, y)\n        })\n        .collect::<Vec<_>>();\n    let mut xs = kdes.iter().flat_map(|(x, _)| x.iter()).filter(|&&x| x > 0.);\n    let (mut min, mut max) = {\n        let &first = xs.next().unwrap();\n        (first, first)\n    };\n    for &e in xs {\n        if e < min {\n            min = e;\n        } else if e > max {\n            max = e;\n        }\n    }\n    let mut one = [1.0];\n    // Scale the X axis units. Use the middle as a \"typical value\". E.g. if\n    // it is 0.002 s then this function will decide that milliseconds are an\n    // appropriate unit. It will multiple `one` by 1000, and return \"ms\".\n    let unit = formatter.scale_values((min + max) / 2.0, &mut one);\n\n    let tics = || (0..).map(|x| (f64::from(x)) + 0.5);\n    let size = Size(1280, 200 + (25 * all_curves.len()));\n    let mut f = Figure::new();\n    f.set(Font(DEFAULT_FONT))\n        .set(size)\n        .set(Title(format!(\"{}: Violin plot\", gnuplot_escape(title))))\n        .configure(Axis::BottomX, |a| {\n            a.configure(Grid::Major, |g| g.show())\n                .configure(Grid::Minor, |g| g.hide())\n                .set(Range::Limits(0., max * one[0]))\n                .set(Label(format!(\"Average time ({})\", unit)))\n                .set(axis_scale.to_gnuplot())\n        })\n        .configure(Axis::LeftY, |a| {\n            a.set(Label(\"Input\"))\n                .set(Range::Limits(0., all_curves.len() as f64))\n                .set(TicLabels {\n                    positions: tics(),\n                    labels: all_curves\n                        .iter()\n                        .map(|&&(id, _)| gnuplot_escape(id.as_title())),\n                })\n        });\n\n    let mut is_first = true;\n    for (i, (x, y)) in kdes.iter().enumerate() {\n        let i = i as f64 + 0.5;\n        let y1: Vec<_> = y.iter().map(|&y| i + y * 0.45).collect();\n        let y2: Vec<_> = y.iter().map(|&y| i - y * 0.45).collect();\n\n        let x: Vec<_> = x.iter().map(|&x| x * one[0]).collect();\n\n        f.plot(FilledCurve { x, y1, y2 }, |c| {\n            if is_first {\n                is_first = false;\n\n                c.set(DARK_BLUE).set(Label(\"PDF\"))\n            } else {\n                c.set(DARK_BLUE)\n            }\n        });\n    }\n    debug_script(&path, &f);\n    f.set(Output(path)).draw().unwrap()\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::*;\nuse crate::estimate::Estimate;\nuse crate::estimate::Statistic;\nuse crate::report::ReportContext;\nuse crate::stats::Distribution;\n\nfn abs_distribution(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    statistic: Statistic,\n    distribution: &Distribution<f64>,\n    estimate: &Estimate,\n    size: Option<(u32, u32)>,\n) {\n    let ci = &estimate.confidence_interval;\n    let typical = ci.upper_bound;\n    let mut ci_values = [ci.lower_bound, ci.upper_bound, estimate.point_estimate];\n    let unit = formatter.scale_values(typical, &mut ci_values);\n    let (lb, ub, point) = (ci_values[0], ci_values[1], ci_values[2]);\n\n    let start = lb - (ub - lb) / 9.;\n    let end = ub + (ub - lb) / 9.;\n    let mut scaled_xs: Vec<f64> = distribution.iter().cloned().collect();\n    let _ = formatter.scale_values(typical, &mut scaled_xs);\n    let scaled_xs_sample = Sample::new(&scaled_xs);\n    let (kde_xs, ys) = kde::sweep(scaled_xs_sample, KDE_POINTS, Some((start, end)));\n\n    // interpolate between two points of the KDE sweep to find the Y position at the point estimate.\n    let n_point = kde_xs\n        .iter()\n        .position(|&x| x >= point)\n        .unwrap_or(kde_xs.len() - 1)\n        .max(1); // Must be at least the second element or this will panic\n    let slope = (ys[n_point] - ys[n_point - 1]) / (kde_xs[n_point] - kde_xs[n_point - 1]);\n    let y_point = ys[n_point - 1] + (slope * (point - kde_xs[n_point - 1]));\n\n    let start = kde_xs\n        .iter()\n        .enumerate()\n        .find(|&(_, &x)| x >= lb)\n        .unwrap()\n        .0;\n    let end = kde_xs\n        .iter()\n        .enumerate()\n        .rev()\n        .find(|&(_, &x)| x <= ub)\n        .unwrap()\n        .0;\n    let len = end - start;\n\n    let kde_xs_sample = Sample::new(&kde_xs);\n\n    let path = context.report_path(id, &format!(\"{}.svg\", statistic));\n    let root_area = SVGBackend::new(&path, size.unwrap_or(SIZE)).into_drawing_area();\n\n    let x_range = plotters::data::fitting_range(kde_xs_sample.iter());\n    let mut y_range = plotters::data::fitting_range(ys.iter());\n\n    y_range.end *= 1.1;\n\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .caption(\n            format!(\"{}:{}\", id.as_title(), statistic),\n            (DEFAULT_FONT, 20),\n        )\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_range, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .x_desc(format!(\"Average time ({})\", unit))\n        .y_desc(\"Density (a.u.)\")\n        .x_label_formatter(&|&v| pretty_print_float(v, true))\n        .y_label_formatter(&|&v| pretty_print_float(v, true))\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(LineSeries::new(\n            kde_xs.iter().zip(ys.iter()).map(|(&x, &y)| (x, y)),\n            DARK_BLUE,\n        ))\n        .unwrap()\n        .label(\"Bootstrap distribution\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    chart\n        .draw_series(AreaSeries::new(\n            kde_xs\n                .iter()\n                .zip(ys.iter())\n                .skip(start)\n                .take(len)\n                .map(|(&x, &y)| (x, y)),\n            0.0,\n            DARK_BLUE.mix(0.25).filled().stroke_width(3),\n        ))\n        .unwrap()\n        .label(\"Confidence interval\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_BLUE.mix(0.25).filled())\n        });\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(point, 0.0), (point, y_point)],\n            DARK_BLUE.filled().stroke_width(3),\n        )))\n        .unwrap()\n        .label(\"Point estimate\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    chart\n        .configure_series_labels()\n        .position(SeriesLabelPosition::UpperRight)\n        .draw()\n        .unwrap();\n}\n\npub(crate) fn abs_distributions(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<(u32, u32)>,\n) {\n    crate::plot::REPORT_STATS\n        .iter()\n        .filter_map(|stat| {\n            measurements.distributions.get(*stat).and_then(|dist| {\n                measurements\n                    .absolute_estimates\n                    .get(*stat)\n                    .map(|est| (*stat, dist, est))\n            })\n        })\n        .for_each(|(statistic, distribution, estimate)| {\n            abs_distribution(\n                id,\n                context,\n                formatter,\n                statistic,\n                distribution,\n                estimate,\n                size,\n            );\n        });\n}\n\nfn rel_distribution(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    statistic: Statistic,\n    distribution: &Distribution<f64>,\n    estimate: &Estimate,\n    noise_threshold: f64,\n    size: Option<(u32, u32)>,\n) {\n    let ci = &estimate.confidence_interval;\n    let (lb, ub) = (ci.lower_bound, ci.upper_bound);\n\n    let start = lb - (ub - lb) / 9.;\n    let end = ub + (ub - lb) / 9.;\n    let (xs, ys) = kde::sweep(distribution, KDE_POINTS, Some((start, end)));\n    let xs_ = Sample::new(&xs);\n\n    // interpolate between two points of the KDE sweep to find the Y position at the point estimate.\n    let point = estimate.point_estimate;\n    let n_point = xs\n        .iter()\n        .position(|&x| x >= point)\n        .unwrap_or(ys.len() - 1)\n        .max(1);\n    let slope = (ys[n_point] - ys[n_point - 1]) / (xs[n_point] - xs[n_point - 1]);\n    let y_point = ys[n_point - 1] + (slope * (point - xs[n_point - 1]));\n\n    let start = xs.iter().enumerate().find(|&(_, &x)| x >= lb).unwrap().0;\n    let end = xs\n        .iter()\n        .enumerate()\n        .rev()\n        .find(|&(_, &x)| x <= ub)\n        .unwrap()\n        .0;\n    let len = end - start;\n\n    let x_min = xs_.min();\n    let x_max = xs_.max();\n\n    let (fc_start, fc_end) = if noise_threshold < x_min || -noise_threshold > x_max {\n        let middle = (x_min + x_max) / 2.;\n\n        (middle, middle)\n    } else {\n        (\n            if -noise_threshold < x_min {\n                x_min\n            } else {\n                -noise_threshold\n            },\n            if noise_threshold > x_max {\n                x_max\n            } else {\n                noise_threshold\n            },\n        )\n    };\n    let y_range = plotters::data::fitting_range(ys.iter());\n    let path = context.report_path(id, &format!(\"change/{}.svg\", statistic));\n    let root_area = SVGBackend::new(&path, size.unwrap_or(SIZE)).into_drawing_area();\n\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .caption(\n            format!(\"{}:{}\", id.as_title(), statistic),\n            (DEFAULT_FONT, 20),\n        )\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_min..x_max, y_range.clone())\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .x_desc(\"Relative change (%)\")\n        .y_desc(\"Density (a.u.)\")\n        .x_label_formatter(&|&v| pretty_print_float(v, true))\n        .y_label_formatter(&|&v| pretty_print_float(v, true))\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(LineSeries::new(\n            xs.iter().zip(ys.iter()).map(|(x, y)| (*x, *y)),\n            DARK_BLUE,\n        ))\n        .unwrap()\n        .label(\"Bootstrap distribution\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    chart\n        .draw_series(AreaSeries::new(\n            xs.iter()\n                .zip(ys.iter())\n                .skip(start)\n                .take(len)\n                .map(|(x, y)| (*x, *y)),\n            0.0,\n            DARK_BLUE.mix(0.25).filled().stroke_width(3),\n        ))\n        .unwrap()\n        .label(\"Confidence interval\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_BLUE.mix(0.25).filled())\n        });\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(point, 0.0), (point, y_point)],\n            DARK_BLUE.filled().stroke_width(3),\n        )))\n        .unwrap()\n        .label(\"Point estimate\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    chart\n        .draw_series(std::iter::once(Rectangle::new(\n            [(fc_start, y_range.start), (fc_end, y_range.end)],\n            DARK_RED.mix(0.1).filled(),\n        )))\n        .unwrap()\n        .label(\"Noise threshold\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_RED.mix(0.25).filled())\n        });\n    chart\n        .configure_series_labels()\n        .position(SeriesLabelPosition::UpperRight)\n        .draw()\n        .unwrap();\n}\n\npub(crate) fn rel_distributions(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    _measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<(u32, u32)>,\n) {\n    crate::plot::CHANGE_STATS.iter().for_each(|&statistic| {\n        rel_distribution(\n            id,\n            context,\n            statistic,\n            comparison.relative_distributions.get(statistic),\n            comparison.relative_estimates.get(statistic),\n            comparison.noise_threshold,\n            size,\n        );\n    });\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::*;\n\nuse std::path::Path;\n\npub(crate) fn iteration_times_figure(\n    title: Option<&str>,\n    path: &Path,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<(u32, u32)>,\n) {\n    let data = &measurements.avg_times;\n    let max_avg_time = data.max();\n    let mut scaled_y: Vec<_> = data.iter().map(|(f, _)| f).collect();\n    let unit = formatter.scale_values(max_avg_time, &mut scaled_y);\n    let scaled_y = Sample::new(&scaled_y);\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(path, size).into_drawing_area();\n\n    let mut cb = ChartBuilder::on(&root_area);\n    if let Some(title) = title {\n        cb.caption(title, (DEFAULT_FONT, 20));\n    }\n\n    let x_range = (1.0)..((data.len() + 1) as f64);\n    let y_range = plotters::data::fitting_range(scaled_y.iter());\n\n    let mut chart = cb\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_range, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .y_desc(format!(\"Average Iteration Time ({})\", unit))\n        .x_label_formatter(&|x| pretty_print_float(*x, true))\n        .light_line_style(TRANSPARENT)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(\n            (1..=data.len())\n                .zip(scaled_y.iter())\n                .map(|(x, y)| Circle::new((x as f64, *y), POINT_SIZE, DARK_BLUE.filled())),\n        )\n        .unwrap()\n        .label(\"Sample\")\n        .legend(|(x, y)| Circle::new((x + 10, y), POINT_SIZE, DARK_BLUE.filled()));\n\n    if title.is_some() {\n        chart\n            .configure_series_labels()\n            .position(SeriesLabelPosition::UpperLeft)\n            .draw()\n            .unwrap();\n    }\n}\n\npub(crate) fn iteration_times_comparison_figure(\n    title: Option<&str>,\n    path: &Path,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<(u32, u32)>,\n) {\n    let current_data = &measurements.avg_times;\n    let base_data = &comparison.base_avg_times;\n\n    let mut all_data: Vec<f64> = current_data.iter().map(|(f, _)| f).collect();\n    all_data.extend_from_slice(base_data);\n\n    let typical_value = Sample::new(&all_data).max();\n    let unit = formatter.scale_values(typical_value, &mut all_data);\n\n    let (scaled_current_y, scaled_base_y) = all_data.split_at(current_data.len());\n    let scaled_current_y = Sample::new(scaled_current_y);\n    let scaled_base_y = Sample::new(scaled_base_y);\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(path, size).into_drawing_area();\n\n    let mut cb = ChartBuilder::on(&root_area);\n    if let Some(title) = title {\n        cb.caption(title, (DEFAULT_FONT, 20));\n    }\n\n    let max_samples = current_data.len().max(base_data.len()) as f64;\n\n    let y_range = plotters::data::fitting_range(all_data.iter());\n\n    let mut chart = cb\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(0.0..max_samples, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .y_desc(format!(\"Average Iteration Time ({})\", unit))\n        .x_label_formatter(&|x| pretty_print_float(*x, true))\n        .light_line_style(TRANSPARENT)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(\n            (1..=current_data.len())\n                .zip(scaled_current_y.iter())\n                .map(|(x, y)| Circle::new((x as f64, *y), POINT_SIZE, DARK_BLUE.filled())),\n        )\n        .unwrap()\n        .label(\"Current\")\n        .legend(|(x, y)| Circle::new((x + 10, y), POINT_SIZE, DARK_BLUE.filled()));\n\n    chart\n        .draw_series(\n            (1..=base_data.len())\n                .zip(scaled_base_y.iter())\n                .map(|(x, y)| Circle::new((x as f64, *y), POINT_SIZE, DARK_RED.filled())),\n        )\n        .unwrap()\n        .label(\"Base\")\n        .legend(|(x, y)| Circle::new((x + 10, y), POINT_SIZE, DARK_RED.filled()));\n\n    if title.is_some() {\n        chart\n            .configure_series_labels()\n            .position(SeriesLabelPosition::UpperLeft)\n            .draw()\n            .unwrap();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::{LinePlotConfig, PlotContext, PlotData, Plotter};\nuse crate::measurement::ValueFormatter;\nuse crate::report::{BenchmarkId, ComparisonData, MeasurementData, ValueType};\nuse plotters::data::float::pretty_print_float;\nuse plotters::prelude::*;\n\nuse crate::kde;\nuse crate::stats::bivariate::Data;\nuse crate::stats::univariate::Sample;\n\nstatic DEFAULT_FONT: FontFamily = FontFamily::SansSerif;\nstatic KDE_POINTS: usize = 500;\nstatic SIZE: (u32, u32) = (960, 540);\nstatic POINT_SIZE: u32 = 3;\n\nconst DARK_BLUE: RGBColor = RGBColor(31, 120, 180);\nconst DARK_ORANGE: RGBColor = RGBColor(255, 127, 0);\nconst DARK_RED: RGBColor = RGBColor(227, 26, 28);\n\nmod distributions;\nmod iteration_times;\nmod pdf;\nmod regression;\nmod summary;\nmod t_test;\n\nfn convert_size(size: Option<(usize, usize)>) -> Option<(u32, u32)> {\n    if let Some((w, h)) = size {\n        return Some((w as u32, h as u32));\n    }\n    None\n}\n#[derive(Default)]\npub struct PlottersBackend;\n\n#[allow(unused_variables)]\nimpl Plotter for PlottersBackend {\n    fn pdf(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        if let Some(cmp) = data.comparison {\n            let (path, title) = if ctx.is_thumbnail {\n                (\n                    ctx.context.report_path(ctx.id, \"relative_pdf_small.svg\"),\n                    None,\n                )\n            } else {\n                (\n                    ctx.context.report_path(ctx.id, \"both/pdf.svg\"),\n                    Some(ctx.id.as_title()),\n                )\n            };\n            pdf::pdf_comparison_figure(\n                path.as_ref(),\n                title,\n                data.formatter,\n                data.measurements,\n                cmp,\n                convert_size(ctx.size),\n            );\n            return;\n        }\n        if ctx.is_thumbnail {\n            pdf::pdf_small(\n                ctx.id,\n                ctx.context,\n                data.formatter,\n                data.measurements,\n                convert_size(ctx.size),\n            );\n        } else {\n            pdf::pdf(\n                ctx.id,\n                ctx.context,\n                data.formatter,\n                data.measurements,\n                convert_size(ctx.size),\n            );\n        }\n    }\n\n    fn regression(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let (title, path) = match (data.comparison.is_some(), ctx.is_thumbnail) {\n            (true, true) => (\n                None,\n                ctx.context\n                    .report_path(ctx.id, \"relative_regression_small.svg\"),\n            ),\n            (true, false) => (\n                Some(ctx.id.as_title()),\n                ctx.context.report_path(ctx.id, \"both/regression.svg\"),\n            ),\n            (false, true) => (\n                None,\n                ctx.context.report_path(ctx.id, \"regression_small.svg\"),\n            ),\n            (false, false) => (\n                Some(ctx.id.as_title()),\n                ctx.context.report_path(ctx.id, \"regression.svg\"),\n            ),\n        };\n\n        if let Some(cmp) = data.comparison {\n            let base_data = Data::new(&cmp.base_iter_counts, &cmp.base_sample_times);\n            regression::regression_comparison_figure(\n                title,\n                path.as_path(),\n                data.formatter,\n                data.measurements,\n                cmp,\n                &base_data,\n                convert_size(ctx.size),\n            );\n        } else {\n            regression::regression_figure(\n                title,\n                path.as_path(),\n                data.formatter,\n                data.measurements,\n                convert_size(ctx.size),\n            );\n        }\n    }\n\n    fn iteration_times(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let (title, path) = match (data.comparison.is_some(), ctx.is_thumbnail) {\n            (true, true) => (\n                None,\n                ctx.context\n                    .report_path(ctx.id, \"relative_iteration_times_small.svg\"),\n            ),\n            (true, false) => (\n                Some(ctx.id.as_title()),\n                ctx.context.report_path(ctx.id, \"both/iteration_times.svg\"),\n            ),\n            (false, true) => (\n                None,\n                ctx.context.report_path(ctx.id, \"iteration_times_small.svg\"),\n            ),\n            (false, false) => (\n                Some(ctx.id.as_title()),\n                ctx.context.report_path(ctx.id, \"iteration_times.svg\"),\n            ),\n        };\n\n        if let Some(cmp) = data.comparison {\n            let base_data = Data::new(&cmp.base_iter_counts, &cmp.base_sample_times);\n            iteration_times::iteration_times_comparison_figure(\n                title,\n                path.as_path(),\n                data.formatter,\n                data.measurements,\n                cmp,\n                convert_size(ctx.size),\n            );\n        } else {\n            iteration_times::iteration_times_figure(\n                title,\n                path.as_path(),\n                data.formatter,\n                data.measurements,\n                convert_size(ctx.size),\n            );\n        }\n    }\n\n    fn abs_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        distributions::abs_distributions(\n            ctx.id,\n            ctx.context,\n            data.formatter,\n            data.measurements,\n            convert_size(ctx.size),\n        );\n    }\n\n    fn rel_distributions(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        distributions::rel_distributions(\n            ctx.id,\n            ctx.context,\n            data.measurements,\n            data.comparison.unwrap(),\n            convert_size(ctx.size),\n        );\n    }\n\n    fn line_comparison(\n        &mut self,\n        line_config: LinePlotConfig,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n        value_type: ValueType,\n    ) {\n        let path = (line_config.path)(&ctx);\n        summary::line_comparison(\n            line_config,\n            formatter,\n            ctx.id.as_title(),\n            all_curves,\n            &path,\n            value_type,\n            ctx.context.plot_config.summary_scale,\n        );\n    }\n\n    fn violin(\n        &mut self,\n        ctx: PlotContext<'_>,\n        formatter: &dyn ValueFormatter,\n        all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    ) {\n        let violin_path = ctx.violin_path();\n\n        summary::violin(\n            formatter,\n            ctx.id.as_title(),\n            all_curves,\n            &violin_path,\n            ctx.context.plot_config.summary_scale,\n        );\n    }\n\n    fn t_test(&mut self, ctx: PlotContext<'_>, data: PlotData<'_>) {\n        let title = ctx.id.as_title();\n        let path = ctx.context.report_path(ctx.id, \"change/t-test.svg\");\n        t_test::t_test(\n            path.as_path(),\n            title,\n            data.comparison.unwrap(),\n            convert_size(ctx.size),\n        );\n    }\n\n    fn wait(&mut self) {}\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::*;\nuse crate::report::ReportContext;\nuse plotters::data;\nuse std::path::Path;\n\npub(crate) fn pdf_comparison_figure(\n    path: &Path,\n    title: Option<&str>,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    size: Option<(u32, u32)>,\n) {\n    let base_avg_times = Sample::new(&comparison.base_avg_times);\n    let typical = base_avg_times.max().max(measurements.avg_times.max());\n    let mut scaled_base_avg_times: Vec<f64> = comparison.base_avg_times.clone();\n    let unit = formatter.scale_values(typical, &mut scaled_base_avg_times);\n    let scaled_base_avg_times = Sample::new(&scaled_base_avg_times);\n\n    let mut scaled_new_avg_times: Vec<f64> = (&measurements.avg_times as &Sample<f64>)\n        .iter()\n        .cloned()\n        .collect();\n    let _ = formatter.scale_values(typical, &mut scaled_new_avg_times);\n    let scaled_new_avg_times = Sample::new(&scaled_new_avg_times);\n\n    let base_mean = scaled_base_avg_times.mean();\n    let new_mean = scaled_new_avg_times.mean();\n\n    let (base_xs, base_ys, base_y_mean) =\n        kde::sweep_and_estimate(scaled_base_avg_times, KDE_POINTS, None, base_mean);\n    let (xs, ys, y_mean) =\n        kde::sweep_and_estimate(scaled_new_avg_times, KDE_POINTS, None, new_mean);\n\n    let x_range = data::fitting_range(base_xs.iter().chain(xs.iter()));\n    let y_range = data::fitting_range(base_ys.iter().chain(ys.iter()));\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(&path, (size.0, size.1)).into_drawing_area();\n\n    let mut cb = ChartBuilder::on(&root_area);\n\n    if let Some(title) = title {\n        cb.caption(title, (DEFAULT_FONT, 20));\n    }\n\n    let mut chart = cb\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_range, y_range.clone())\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .y_desc(\"Density (a.u.)\")\n        .x_desc(format!(\"Average Time ({})\", unit))\n        .x_label_formatter(&|&x| pretty_print_float(x, true))\n        .y_label_formatter(&|&y| pretty_print_float(y, true))\n        .x_labels(5)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(AreaSeries::new(\n            base_xs.iter().zip(base_ys.iter()).map(|(x, y)| (*x, *y)),\n            y_range.start,\n            DARK_RED.mix(0.5).filled(),\n        ))\n        .unwrap()\n        .label(\"Base PDF\")\n        .legend(|(x, y)| Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_RED.mix(0.5).filled()));\n\n    chart\n        .draw_series(AreaSeries::new(\n            xs.iter().zip(ys.iter()).map(|(x, y)| (*x, *y)),\n            y_range.start,\n            DARK_BLUE.mix(0.5).filled(),\n        ))\n        .unwrap()\n        .label(\"New PDF\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_BLUE.mix(0.5).filled())\n        });\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(base_mean, 0.0), (base_mean, base_y_mean)],\n            DARK_RED.filled().stroke_width(2),\n        )))\n        .unwrap()\n        .label(\"Base Mean\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_RED));\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(new_mean, 0.0), (new_mean, y_mean)],\n            DARK_BLUE.filled().stroke_width(2),\n        )))\n        .unwrap()\n        .label(\"New Mean\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    if title.is_some() {\n        chart.configure_series_labels().draw().unwrap();\n    }\n}\n\npub(crate) fn pdf_small(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<(u32, u32)>,\n) {\n    let avg_times = &*measurements.avg_times;\n    let typical = avg_times.max();\n    let mut scaled_avg_times: Vec<f64> = (avg_times as &Sample<f64>).iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_avg_times);\n    let scaled_avg_times = Sample::new(&scaled_avg_times);\n    let mean = scaled_avg_times.mean();\n\n    let (xs, ys, mean_y) = kde::sweep_and_estimate(scaled_avg_times, KDE_POINTS, None, mean);\n    let xs_ = Sample::new(&xs);\n    let ys_ = Sample::new(&ys);\n\n    let y_limit = ys_.max() * 1.1;\n\n    let path = context.report_path(id, \"pdf_small.svg\");\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(&path, (size.0, size.1)).into_drawing_area();\n\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(xs_.min()..xs_.max(), 0.0..y_limit)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .y_desc(\"Density (a.u.)\")\n        .x_desc(format!(\"Average Time ({})\", unit))\n        .x_label_formatter(&|&x| pretty_print_float(x, true))\n        .y_label_formatter(&|&y| pretty_print_float(y, true))\n        .x_labels(5)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(AreaSeries::new(\n            xs.iter().zip(ys.iter()).map(|(x, y)| (*x, *y)),\n            0.0,\n            DARK_BLUE.mix(0.25).filled(),\n        ))\n        .unwrap();\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(mean, 0.0), (mean, mean_y)],\n            DARK_BLUE.filled().stroke_width(2),\n        )))\n        .unwrap();\n}\n\npub(crate) fn pdf(\n    id: &BenchmarkId,\n    context: &ReportContext,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<(u32, u32)>,\n) {\n    let avg_times = &measurements.avg_times;\n    let typical = avg_times.max();\n    let mut scaled_avg_times: Vec<f64> = (avg_times as &Sample<f64>).iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_avg_times);\n    let scaled_avg_times = Sample::new(&scaled_avg_times);\n\n    let mean = scaled_avg_times.mean();\n\n    let iter_counts = measurements.iter_counts();\n    let &max_iters = iter_counts\n        .iter()\n        .max_by_key(|&&iters| iters as u64)\n        .unwrap();\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n    let y_scale = 10f64.powi(-exponent);\n\n    let y_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let (xs, ys) = kde::sweep(scaled_avg_times, KDE_POINTS, None);\n    let (lost, lomt, himt, hist) = avg_times.fences();\n    let mut fences = [lost, lomt, himt, hist];\n    let _ = formatter.scale_values(typical, &mut fences);\n    let [lost, lomt, himt, hist] = fences;\n\n    let path = context.report_path(id, \"pdf.svg\");\n\n    let xs_ = Sample::new(&xs);\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(&path, (size.0, size.1)).into_drawing_area();\n\n    let range = data::fitting_range(ys.iter());\n\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .caption(id.as_title(), (DEFAULT_FONT, 20))\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Right, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(xs_.min()..xs_.max(), 0.0..max_iters)\n        .unwrap()\n        .set_secondary_coord(xs_.min()..xs_.max(), 0.0..range.end);\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .y_desc(y_label)\n        .x_desc(format!(\"Average Time ({})\", unit))\n        .x_label_formatter(&|&x| pretty_print_float(x, true))\n        .y_label_formatter(&|&y| pretty_print_float(y * y_scale, true))\n        .draw()\n        .unwrap();\n\n    chart\n        .configure_secondary_axes()\n        .y_desc(\"Density (a.u.)\")\n        .x_label_formatter(&|&x| pretty_print_float(x, true))\n        .y_label_formatter(&|&y| pretty_print_float(y, true))\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_secondary_series(AreaSeries::new(\n            xs.iter().zip(ys.iter()).map(|(x, y)| (*x, *y)),\n            0.0,\n            DARK_BLUE.mix(0.5).filled(),\n        ))\n        .unwrap()\n        .label(\"PDF\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_BLUE.mix(0.5).filled())\n        });\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(mean, 0.0), (mean, max_iters)],\n            DARK_BLUE,\n        )))\n        .unwrap()\n        .label(\"Mean\")\n        .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], DARK_BLUE));\n\n    chart\n        .draw_series(vec![\n            PathElement::new(vec![(lomt, 0.0), (lomt, max_iters)], DARK_ORANGE),\n            PathElement::new(vec![(himt, 0.0), (himt, max_iters)], DARK_ORANGE),\n            PathElement::new(vec![(lost, 0.0), (lost, max_iters)], DARK_RED),\n            PathElement::new(vec![(hist, 0.0), (hist, max_iters)], DARK_RED),\n        ])\n        .unwrap();\n    use crate::stats::univariate::outliers::tukey::Label;\n\n    let mut draw_data_point_series =\n        |filter: &dyn Fn(&Label) -> bool, color: RGBAColor, name: &str| {\n            chart\n                .draw_series(\n                    avg_times\n                        .iter()\n                        .zip(scaled_avg_times.iter())\n                        .zip(iter_counts.iter())\n                        .filter_map(|(((_, label), t), i)| {\n                            if filter(&label) {\n                                Some(Circle::new((*t, *i), POINT_SIZE, color.filled()))\n                            } else {\n                                None\n                            }\n                        }),\n                )\n                .unwrap()\n                .label(name)\n                .legend(move |(x, y)| Circle::new((x + 10, y), POINT_SIZE, color.filled()));\n        };\n\n    draw_data_point_series(\n        &|l| !l.is_outlier(),\n        DARK_BLUE.to_rgba(),\n        \"\\\"Clean\\\" sample\",\n    );\n    draw_data_point_series(\n        &|l| l.is_mild(),\n        RGBColor(255, 127, 0).to_rgba(),\n        \"Mild outliers\",\n    );\n    draw_data_point_series(&|l| l.is_severe(), DARK_RED.to_rgba(), \"Severe outliers\");\n    chart.configure_series_labels().draw().unwrap();\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use super::*;\n\nuse std::path::Path;\n\nuse crate::estimate::{ConfidenceInterval, Estimate};\nuse crate::stats::bivariate::regression::Slope;\n\npub(crate) fn regression_figure(\n    title: Option<&str>,\n    path: &Path,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    size: Option<(u32, u32)>,\n) {\n    let slope_estimate = measurements.absolute_estimates.slope.as_ref().unwrap();\n    let slope_dist = measurements.distributions.slope.as_ref().unwrap();\n    let (lb, ub) =\n        slope_dist.confidence_interval(slope_estimate.confidence_interval.confidence_level);\n\n    let data = &measurements.data;\n    let (max_iters, typical) = (data.x().max(), data.y().max());\n    let mut scaled_y: Vec<f64> = data.y().iter().cloned().collect();\n    let unit = formatter.scale_values(typical, &mut scaled_y);\n    let scaled_y = Sample::new(&scaled_y);\n\n    let point_estimate = Slope::fit(&measurements.data).0;\n    let mut scaled_points = [point_estimate * max_iters, lb * max_iters, ub * max_iters];\n    let _ = formatter.scale_values(typical, &mut scaled_points);\n    let [point, lb, ub] = scaled_points;\n\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n\n    let x_scale = 10f64.powi(-exponent);\n    let x_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(path, size).into_drawing_area();\n\n    let mut cb = ChartBuilder::on(&root_area);\n    if let Some(title) = title {\n        cb.caption(title, (DEFAULT_FONT, 20));\n    }\n\n    let x_range = plotters::data::fitting_range(data.x().iter());\n    let y_range = plotters::data::fitting_range(scaled_y.iter());\n\n    let mut chart = cb\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_range, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .x_desc(x_label)\n        .y_desc(format!(\"Total sample time ({})\", unit))\n        .x_label_formatter(&|x| pretty_print_float(x * x_scale, true))\n        .light_line_style(TRANSPARENT)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(\n            data.x()\n                .iter()\n                .zip(scaled_y.iter())\n                .map(|(x, y)| Circle::new((*x, *y), POINT_SIZE, DARK_BLUE.filled())),\n        )\n        .unwrap()\n        .label(\"Sample\")\n        .legend(|(x, y)| Circle::new((x + 10, y), POINT_SIZE, DARK_BLUE.filled()));\n\n    chart\n        .draw_series(std::iter::once(PathElement::new(\n            vec![(0.0, 0.0), (max_iters, point)],\n            DARK_BLUE,\n        )))\n        .unwrap()\n        .label(\"Linear regression\")\n        .legend(|(x, y)| {\n            PathElement::new(\n                vec![(x, y), (x + 20, y)],\n                DARK_BLUE.filled().stroke_width(2),\n            )\n        });\n\n    chart\n        .draw_series(std::iter::once(Polygon::new(\n            vec![(0.0, 0.0), (max_iters, lb), (max_iters, ub)],\n            DARK_BLUE.mix(0.25).filled(),\n        )))\n        .unwrap()\n        .label(\"Confidence interval\")\n        .legend(|(x, y)| {\n            Rectangle::new([(x, y - 5), (x + 20, y + 5)], DARK_BLUE.mix(0.25).filled())\n        });\n\n    if title.is_some() {\n        chart\n            .configure_series_labels()\n            .position(SeriesLabelPosition::UpperLeft)\n            .draw()\n            .unwrap();\n    }\n}\n\npub(crate) fn regression_comparison_figure(\n    title: Option<&str>,\n    path: &Path,\n    formatter: &dyn ValueFormatter,\n    measurements: &MeasurementData<'_>,\n    comparison: &ComparisonData,\n    base_data: &Data<'_, f64, f64>,\n    size: Option<(u32, u32)>,\n) {\n    let data = &measurements.data;\n    let max_iters = base_data.x().max().max(data.x().max());\n    let typical = base_data.y().max().max(data.y().max());\n\n    let exponent = (max_iters.log10() / 3.).floor() as i32 * 3;\n    let x_scale = 10f64.powi(-exponent);\n\n    let x_label = if exponent == 0 {\n        \"Iterations\".to_owned()\n    } else {\n        format!(\"Iterations (x 10^{})\", exponent)\n    };\n\n    let Estimate {\n        confidence_interval:\n            ConfidenceInterval {\n                lower_bound: base_lb,\n                upper_bound: base_ub,\n                ..\n            },\n        point_estimate: base_point,\n        ..\n    } = comparison.base_estimates.slope.as_ref().unwrap();\n\n    let Estimate {\n        confidence_interval:\n            ConfidenceInterval {\n                lower_bound: lb,\n                upper_bound: ub,\n                ..\n            },\n        point_estimate: point,\n        ..\n    } = measurements.absolute_estimates.slope.as_ref().unwrap();\n\n    let mut points = [\n        base_lb * max_iters,\n        base_point * max_iters,\n        base_ub * max_iters,\n        lb * max_iters,\n        point * max_iters,\n        ub * max_iters,\n    ];\n    let unit = formatter.scale_values(typical, &mut points);\n    let [base_lb, base_point, base_ub, lb, point, ub] = points;\n\n    let y_max = point.max(base_point);\n\n    let size = size.unwrap_or(SIZE);\n    let root_area = SVGBackend::new(path, size).into_drawing_area();\n\n    let mut cb = ChartBuilder::on(&root_area);\n    if let Some(title) = title {\n        cb.caption(title, (DEFAULT_FONT, 20));\n    }\n\n    let mut chart = cb\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(0.0..max_iters, 0.0..y_max)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .x_desc(x_label)\n        .y_desc(format!(\"Total sample time ({})\", unit))\n        .x_label_formatter(&|x| pretty_print_float(x * x_scale, true))\n        .light_line_style(TRANSPARENT)\n        .draw()\n        .unwrap();\n\n    chart\n        .draw_series(vec![\n            PathElement::new(vec![(0.0, 0.0), (max_iters, base_point)], DARK_RED).into_dyn(),\n            Polygon::new(\n                vec![(0.0, 0.0), (max_iters, base_lb), (max_iters, base_ub)],\n                DARK_RED.mix(0.25).filled(),\n            )\n            .into_dyn(),\n        ])\n        .unwrap()\n        .label(\"Base Sample\")\n        .legend(|(x, y)| {\n            PathElement::new(vec![(x, y), (x + 20, y)], DARK_RED.filled().stroke_width(2))\n        });\n\n    chart\n        .draw_series(vec![\n            PathElement::new(vec![(0.0, 0.0), (max_iters, point)], DARK_BLUE).into_dyn(),\n            Polygon::new(\n                vec![(0.0, 0.0), (max_iters, lb), (max_iters, ub)],\n                DARK_BLUE.mix(0.25).filled(),\n            )\n            .into_dyn(),\n        ])\n        .unwrap()\n        .label(\"New Sample\")\n        .legend(|(x, y)| {\n            PathElement::new(\n                vec![(x, y), (x + 20, y)],\n                DARK_BLUE.filled().stroke_width(2),\n            )\n        });\n\n    if title.is_some() {\n        chart\n            .configure_series_labels()\n            .position(SeriesLabelPosition::UpperLeft)\n            .draw()\n            .unwrap();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use {\n    super::*,\n    crate::AxisScale,\n    itertools::Itertools,\n    plotters::coord::{\n        ranged1d::{AsRangedCoord, ValueFormatter as PlottersValueFormatter},\n        Shift,\n    },\n    std::{cmp::Ordering, path::Path},\n};\n\nconst NUM_COLORS: usize = 8;\nstatic COMPARISON_COLORS: [RGBColor; NUM_COLORS] = [\n    RGBColor(178, 34, 34),\n    RGBColor(46, 139, 87),\n    RGBColor(0, 139, 139),\n    RGBColor(255, 215, 0),\n    RGBColor(0, 0, 139),\n    RGBColor(220, 20, 60),\n    RGBColor(139, 0, 139),\n    RGBColor(0, 255, 127),\n];\n\npub(crate) fn line_comparison(\n    line_cfg: LinePlotConfig,\n    formatter: &dyn ValueFormatter,\n    title: &str,\n    all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    path: &Path,\n    value_type: ValueType,\n    axis_scale: AxisScale,\n) {\n    let (unit, series_data) = line_comparison_series_data(line_cfg, formatter, all_curves);\n\n    let x_range =\n        plotters::data::fitting_range(series_data.iter().flat_map(|(_, xs, _)| xs.iter()));\n    let y_range =\n        plotters::data::fitting_range(series_data.iter().flat_map(|(_, _, ys)| ys.iter()));\n    let root_area = SVGBackend::new(&path, SIZE)\n        .into_drawing_area()\n        .titled(&format!(\"{}: Comparison\", title), (DEFAULT_FONT, 20))\n        .unwrap();\n\n    match axis_scale {\n        AxisScale::Linear => draw_line_comparison_figure(\n            line_cfg,\n            root_area,\n            unit,\n            x_range,\n            y_range,\n            value_type,\n            series_data,\n        ),\n        AxisScale::Logarithmic => draw_line_comparison_figure(\n            line_cfg,\n            root_area,\n            unit,\n            x_range.log_scale(),\n            y_range.log_scale(),\n            value_type,\n            series_data,\n        ),\n    }\n}\n\nfn draw_line_comparison_figure<XR: AsRangedCoord<Value = f64>, YR: AsRangedCoord<Value = f64>>(\n    line_cfg: LinePlotConfig,\n    root_area: DrawingArea<SVGBackend, Shift>,\n    y_unit: &str,\n    x_range: XR,\n    y_range: YR,\n    value_type: ValueType,\n    data: Vec<(Option<&String>, Vec<f64>, Vec<f64>)>,\n) where\n    XR::CoordDescType: PlottersValueFormatter<f64>,\n    YR::CoordDescType: PlottersValueFormatter<f64>,\n{\n    let input_suffix = match value_type {\n        ValueType::Bytes => \" Size (Bytes)\",\n        ValueType::Elements => \" Size (Elements)\",\n        ValueType::Bits => \" Size (Bits)\",\n        ValueType::Value => \"\",\n    };\n\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (5).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_height().min(40))\n        .build_cartesian_2d(x_range, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .x_desc(format!(\"Input{}\", input_suffix))\n        .y_desc(format!(\"Average {} ({})\", line_cfg.label, y_unit))\n        .draw()\n        .unwrap();\n\n    for (id, (name, xs, ys)) in (0..).zip(data) {\n        let series = chart\n            .draw_series(\n                LineSeries::new(\n                    xs.into_iter().zip(ys),\n                    COMPARISON_COLORS[id % NUM_COLORS].filled(),\n                )\n                .point_size(POINT_SIZE),\n            )\n            .unwrap();\n        if let Some(name) = name {\n            series.label(name).legend(move |(x, y)| {\n                Rectangle::new(\n                    [(x, y - 5), (x + 20, y + 5)],\n                    COMPARISON_COLORS[id % NUM_COLORS].filled(),\n                )\n            });\n        }\n    }\n\n    chart\n        .configure_series_labels()\n        .position(SeriesLabelPosition::UpperLeft)\n        .draw()\n        .unwrap();\n}\n\n#[allow(clippy::type_complexity)]\nfn line_comparison_series_data<'a>(\n    line_cfg: LinePlotConfig,\n    formatter: &dyn ValueFormatter,\n    all_curves: &[&(&'a BenchmarkId, Vec<f64>)],\n) -> (&'static str, Vec<(Option<&'a String>, Vec<f64>, Vec<f64>)>) {\n    let (max_id, max) = all_curves\n        .iter()\n        .map(|&(id, data)| (*id, Sample::new(data).mean()))\n        .fold(None, |prev: Option<(&BenchmarkId, f64)>, next| match prev {\n            Some(prev) if prev.1 >= next.1 => Some(prev),\n            _ => Some(next),\n        })\n        .unwrap();\n\n    let mut max_formatted = [max];\n    let unit = (line_cfg.scale)(formatter, max_id, max, max_id, &mut max_formatted);\n\n    let mut series_data = vec![];\n\n    // This assumes the curves are sorted. It also assumes that the benchmark IDs all have numeric\n    // values or throughputs and that value is sensible (ie. not a mix of bytes and elements\n    // or whatnot)\n    for (key, group) in &all_curves.iter().chunk_by(|&&&(id, _)| &id.function_id) {\n        let mut tuples: Vec<_> = group\n            .map(|&&(id, ref sample)| {\n                // Unwrap is fine here because it will only fail if the assumptions above are not true\n                // ie. programmer error.\n                let x = id.as_number().unwrap();\n                let mut y = [Sample::new(sample).mean()];\n\n                (line_cfg.scale)(formatter, max_id, max, id, &mut y);\n\n                (x, y[0])\n            })\n            .collect();\n        tuples.sort_by(|&(ax, _), &(bx, _)| ax.partial_cmp(&bx).unwrap_or(Ordering::Less));\n        let function_name = key.as_ref();\n        let (xs, ys): (Vec<_>, Vec<_>) = tuples.into_iter().unzip();\n        series_data.push((function_name, xs, ys));\n    }\n    (unit, series_data)\n}\n\npub fn violin(\n    formatter: &dyn ValueFormatter,\n    title: &str,\n    all_curves: &[&(&BenchmarkId, Vec<f64>)],\n    path: &Path,\n    axis_scale: AxisScale,\n) {\n    let all_curves_vec = all_curves.iter().rev().cloned().collect::<Vec<_>>();\n    let all_curves: &[&(&BenchmarkId, Vec<f64>)] = &all_curves_vec;\n\n    let mut kdes = all_curves\n        .iter()\n        .map(|&&(id, ref sample)| {\n            let (x, mut y) = kde::sweep(Sample::new(sample), KDE_POINTS, None);\n            let y_max = Sample::new(&y).max();\n            for y in y.iter_mut() {\n                *y /= y_max;\n            }\n\n            (id.as_title(), x, y)\n        })\n        .collect::<Vec<_>>();\n\n    let mut xs = kdes\n        .iter()\n        .flat_map(|(_, x, _)| x.iter())\n        .filter(|&&x| x > 0.);\n    let (mut min, mut max) = {\n        let &first = xs.next().unwrap();\n        (first, first)\n    };\n    for &e in xs {\n        if e < min {\n            min = e;\n        } else if e > max {\n            max = e;\n        }\n    }\n    let mut dummy = [1.0];\n    let unit = formatter.scale_values(max, &mut dummy);\n    kdes.iter_mut().for_each(|&mut (_, ref mut xs, _)| {\n        formatter.scale_values(max, xs);\n    });\n\n    let mut x_range = plotters::data::fitting_range(kdes.iter().flat_map(|(_, xs, _)| xs.iter()));\n    x_range.start = 0.0;\n    let y_range = -0.5..all_curves.len() as f64 - 0.5;\n\n    let size = (960, 150 + (18 * all_curves.len() as u32));\n\n    let root_area = SVGBackend::new(&path, size)\n        .into_drawing_area()\n        .titled(&format!(\"{}: Violin plot\", title), (DEFAULT_FONT, 20))\n        .unwrap();\n\n    match axis_scale {\n        AxisScale::Linear => draw_violin_figure(root_area, unit, x_range, y_range, kdes),\n        AxisScale::Logarithmic => {\n            draw_violin_figure(root_area, unit, x_range.log_scale(), y_range, kdes);\n        }\n    }\n}\n\n#[allow(clippy::type_complexity)]\nfn draw_violin_figure<XR: AsRangedCoord<Value = f64>, YR: AsRangedCoord<Value = f64>>(\n    root_area: DrawingArea<SVGBackend, Shift>,\n    unit: &'static str,\n    x_range: XR,\n    y_range: YR,\n    data: Vec<(&str, Box<[f64]>, Box<[f64]>)>,\n) where\n    XR::CoordDescType: PlottersValueFormatter<f64>,\n    YR::CoordDescType: PlottersValueFormatter<f64>,\n{\n    let mut chart = ChartBuilder::on(&root_area)\n        .margin((5).percent())\n        .set_label_area_size(LabelAreaPosition::Left, (10).percent_width().min(60))\n        .set_label_area_size(LabelAreaPosition::Bottom, (5).percent_width().min(40))\n        .build_cartesian_2d(x_range, y_range)\n        .unwrap();\n\n    chart\n        .configure_mesh()\n        .disable_mesh()\n        .y_desc(\"Input\")\n        .x_desc(format!(\"Average time ({})\", unit))\n        .y_label_style((DEFAULT_FONT, 10))\n        .y_label_formatter(&|v: &f64| data[v.round() as usize].0.to_string())\n        .y_labels(data.len())\n        .draw()\n        .unwrap();\n\n    for (i, (_, x, y)) in data.into_iter().enumerate() {\n        let base = i as f64;\n\n        chart\n            .draw_series(AreaSeries::new(\n                x.iter().zip(y.iter()).map(|(x, y)| (*x, base + *y / 2.0)),\n                base,\n                DARK_BLUE,\n            ))\n            .unwrap();\n\n        chart\n            .draw_series(AreaSeries::new(\n                x.iter().zip(y.iter()).map(|(x, y)| (*x, base - *y / 2.0)),\n                base,\n                DARK_BLUE,\n            ))\n            .unwrap();\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Bivariate analysis\n\nmod bootstrap;\npub mod regression;\nmod resamples;\n\nuse crate::stats::bivariate::resamples::Resamples;\nuse crate::stats::float::Float;\nuse crate::stats::tuple::{Tuple, TupledDistributionsBuilder};\nuse crate::stats::univariate::Sample;\n#[cfg(feature = \"rayon\")]\nuse rayon::iter::{IntoParallelIterator, ParallelIterator};\n\n/// Bivariate `(X, Y)` data\n///\n/// Invariants:\n///\n/// - No `NaN`s in the data\n/// - At least two data points in the set\npub struct Data<'a, X, Y>(&'a [X], &'a [Y]);\n\nimpl<'a, X, Y> Copy for Data<'a, X, Y> {}\n\n#[allow(clippy::expl_impl_clone_on_copy)]\nimpl<'a, X, Y> Clone for Data<'a, X, Y> {\n    fn clone(&self) -> Data<'a, X, Y> {\n        *self\n    }\n}\n\nimpl<'a, X, Y> Data<'a, X, Y> {\n    /// Returns the length of the data set\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// Iterate over the data set\n    pub fn iter(&self) -> Pairs<'a, X, Y> {\n        Pairs {\n            data: *self,\n            state: 0,\n        }\n    }\n}\n\nimpl<'a, X, Y> Data<'a, X, Y>\nwhere\n    X: Float,\n    Y: Float,\n{\n    /// Creates a new data set from two existing slices\n    pub fn new(xs: &'a [X], ys: &'a [Y]) -> Data<'a, X, Y> {\n        assert!(\n            xs.len() == ys.len()\n                && xs.len() > 1\n                && xs.iter().all(|x| !x.is_nan())\n                && ys.iter().all(|y| !y.is_nan())\n        );\n\n        Data(xs, ys)\n    }\n\n    // TODO Remove the `T` parameter in favor of `S::Output`\n    /// Returns the bootstrap distributions of the parameters estimated by the `statistic`\n    ///\n    /// - Multi-threaded\n    /// - Time: `O(nresamples)`\n    /// - Memory: `O(nresamples)`\n    pub fn bootstrap<T, S>(&self, nresamples: usize, statistic: S) -> T::Distributions\n    where\n        S: Fn(Data<X, Y>) -> T + Sync,\n        T: Tuple + Send,\n        T::Distributions: Send,\n        T::Builder: Send,\n    {\n        #[cfg(feature = \"rayon\")]\n        {\n            (0..nresamples)\n                .into_par_iter()\n                .map_init(\n                    || Resamples::new(*self),\n                    |resamples, _| statistic(resamples.next()),\n                )\n                .fold(\n                    || T::Builder::new(0),\n                    |mut sub_distributions, sample| {\n                        sub_distributions.push(sample);\n                        sub_distributions\n                    },\n                )\n                .reduce(\n                    || T::Builder::new(0),\n                    |mut a, mut b| {\n                        a.extend(&mut b);\n                        a\n                    },\n                )\n                .complete()\n        }\n        #[cfg(not(feature = \"rayon\"))]\n        {\n            let mut resamples = Resamples::new(*self);\n            (0..nresamples)\n                .map(|_| statistic(resamples.next()))\n                .fold(T::Builder::new(0), |mut sub_distributions, sample| {\n                    sub_distributions.push(sample);\n                    sub_distributions\n                })\n                .complete()\n        }\n    }\n\n    /// Returns a view into the `X` data\n    pub fn x(&self) -> &'a Sample<X> {\n        Sample::new(self.0)\n    }\n\n    /// Returns a view into the `Y` data\n    pub fn y(&self) -> &'a Sample<Y> {\n        Sample::new(self.1)\n    }\n}\n\n/// Iterator over `Data`\npub struct Pairs<'a, X: 'a, Y: 'a> {\n    data: Data<'a, X, Y>,\n    state: usize,\n}\n\nimpl<'a, X, Y> Iterator for Pairs<'a, X, Y> {\n    type Item = (&'a X, &'a Y);\n\n    fn next(&mut self) -> Option<(&'a X, &'a Y)> {\n        if self.state < self.data.len() {\n            let i = self.state;\n            self.state += 1;\n\n            // This is safe because i will always be < self.data.{0,1}.len()\n            debug_assert!(i < self.data.0.len());\n            debug_assert!(i < self.data.1.len());\n            unsafe { Some((self.data.0.get_unchecked(i), self.data.1.get_unchecked(i))) }\n        } else {\n            None\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Regression analysis\n\nuse crate::stats::bivariate::Data;\nuse crate::stats::float::Float;\n\n/// A straight line that passes through the origin `y = m * x`\n#[derive(Clone, Copy)]\npub struct Slope<A>(pub A)\nwhere\n    A: Float;\n\nimpl<A> Slope<A>\nwhere\n    A: Float,\n{\n    /// Fits the data to a straight line that passes through the origin using ordinary least\n    /// squares\n    ///\n    /// - Time: `O(length)`\n    pub fn fit(data: &Data<'_, A, A>) -> Slope<A> {\n        let xs = data.0;\n        let ys = data.1;\n\n        let xy = crate::stats::dot(xs, ys);\n        let x2 = crate::stats::dot(xs, xs);\n\n        Slope(xy / x2)\n    }\n\n    /// Computes the goodness of fit (coefficient of determination) for this data set\n    ///\n    /// - Time: `O(length)`\n    pub fn r_squared(&self, data: &Data<'_, A, A>) -> A {\n        let _0 = A::cast(0);\n        let _1 = A::cast(1);\n        let m = self.0;\n        let xs = data.0;\n        let ys = data.1;\n\n        let n = A::cast(xs.len());\n        let y_bar = crate::stats::sum(ys) / n;\n\n        let mut ss_res = _0;\n        let mut ss_tot = _0;\n\n        for (&x, &y) in data.iter() {\n            ss_res = ss_res + (y - m * x).powi(2);\n            ss_tot = ss_res + (y - y_bar).powi(2);\n        }\n\n        _1 - ss_res / ss_tot\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::bivariate::Data;\nuse crate::stats::float::Float;\nuse crate::stats::rand_util::{new_rng, Rng};\n\npub struct Resamples<'a, X, Y>\nwhere\n    X: 'a + Float,\n    Y: 'a + Float,\n{\n    rng: Rng,\n    data: (&'a [X], &'a [Y]),\n    stage: Option<(Vec<X>, Vec<Y>)>,\n}\n\n#[allow(clippy::should_implement_trait)]\nimpl<'a, X, Y> Resamples<'a, X, Y>\nwhere\n    X: 'a + Float,\n    Y: 'a + Float,\n{\n    pub fn new(data: Data<'a, X, Y>) -> Resamples<'a, X, Y> {\n        Resamples {\n            rng: new_rng(),\n            data: (data.x(), data.y()),\n            stage: None,\n        }\n    }\n\n    pub fn next(&mut self) -> Data<'_, X, Y> {\n        let n = self.data.0.len();\n\n        match self.stage {\n            None => {\n                let mut stage = (Vec::with_capacity(n), Vec::with_capacity(n));\n\n                for _ in 0..n {\n                    let i = self.rng.rand_range(0u64..(self.data.0.len() as u64)) as usize;\n\n                    stage.0.push(self.data.0[i]);\n                    stage.1.push(self.data.1[i]);\n                }\n\n                self.stage = Some(stage);\n            }\n            Some(ref mut stage) => {\n                for i in 0..n {\n                    let j = self.rng.rand_range(0u64..(self.data.0.len() as u64)) as usize;\n\n                    stage.0[i] = self.data.0[j];\n                    stage.1[i] = self.data.1[j];\n                }\n            }\n        }\n\n        if let Some((ref x, ref y)) = self.stage {\n            Data(x, y)\n        } else {\n            unreachable!();\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Mixed bootstrap\n\nuse crate::stats::float::Float;\nuse crate::stats::tuple::{Tuple, TupledDistributionsBuilder};\nuse crate::stats::univariate::Resamples;\nuse crate::stats::univariate::Sample;\n#[cfg(feature = \"rayon\")]\nuse rayon::prelude::*;\n\n/// Performs a *mixed* two-sample bootstrap\npub fn bootstrap<A, T, S>(\n    a: &Sample<A>,\n    b: &Sample<A>,\n    nresamples: usize,\n    statistic: S,\n) -> T::Distributions\nwhere\n    A: Float,\n    S: Fn(&Sample<A>, &Sample<A>) -> T + Sync,\n    T: Tuple + Send,\n    T::Distributions: Send,\n    T::Builder: Send,\n{\n    let n_a = a.len();\n    let n_b = b.len();\n    let mut c = Vec::with_capacity(n_a + n_b);\n    c.extend_from_slice(a);\n    c.extend_from_slice(b);\n    let c = Sample::new(&c);\n\n    #[cfg(feature = \"rayon\")]\n    {\n        (0..nresamples)\n            .into_par_iter()\n            .map_init(\n                || Resamples::new(c),\n                |resamples, _| {\n                    let resample = resamples.next();\n                    let a: &Sample<A> = Sample::new(&resample[..n_a]);\n                    let b: &Sample<A> = Sample::new(&resample[n_a..]);\n\n                    statistic(a, b)\n                },\n            )\n            .fold(\n                || T::Builder::new(0),\n                |mut sub_distributions, sample| {\n                    sub_distributions.push(sample);\n                    sub_distributions\n                },\n            )\n            .reduce(\n                || T::Builder::new(0),\n                |mut a, mut b| {\n                    a.extend(&mut b);\n                    a\n                },\n            )\n            .complete()\n    }\n    #[cfg(not(feature = \"rayon\"))]\n    {\n        let mut resamples = Resamples::new(c);\n        (0..nresamples)\n            .map(|_| {\n                let resample = resamples.next();\n                let a: &Sample<A> = Sample::new(&resample[..n_a]);\n                let b: &Sample<A> = Sample::new(&resample[n_a..]);\n\n                statistic(a, b)\n            })\n            .fold(T::Builder::new(0), |mut sub_distributions, sample| {\n                sub_distributions.push(sample);\n                sub_distributions\n            })\n            .complete()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Univariate analysis\n\nmod bootstrap;\nmod percentiles;\nmod resamples;\nmod sample;\n\npub mod kde;\npub mod mixed;\npub mod outliers;\n\nuse crate::stats::float::Float;\nuse crate::stats::tuple::{Tuple, TupledDistributionsBuilder};\n#[cfg(feature = \"rayon\")]\nuse rayon::prelude::*;\nuse std::cmp;\n\nuse self::resamples::Resamples;\n\npub use self::percentiles::Percentiles;\npub use self::sample::Sample;\n\n/// Performs a two-sample bootstrap\n///\n/// - Multithreaded\n/// - Time: `O(nresamples)`\n/// - Memory: `O(nresamples)`\n#[allow(clippy::cast_lossless)]\npub fn bootstrap<A, B, T, S>(\n    a: &Sample<A>,\n    b: &Sample<B>,\n    nresamples: usize,\n    statistic: S,\n) -> T::Distributions\nwhere\n    A: Float,\n    B: Float,\n    S: Fn(&Sample<A>, &Sample<B>) -> T + Sync,\n    T: Tuple + Send,\n    T::Distributions: Send,\n    T::Builder: Send,\n{\n    let nresamples_sqrt = (nresamples as f64).sqrt().ceil() as usize;\n    let per_chunk = (nresamples + nresamples_sqrt - 1) / nresamples_sqrt;\n\n    #[cfg(feature = \"rayon\")]\n    {\n        (0..nresamples_sqrt)\n            .into_par_iter()\n            .map_init(\n                || (Resamples::new(a), Resamples::new(b)),\n                |(a_resamples, b_resamples), i| {\n                    let start = i * per_chunk;\n                    let end = cmp::min((i + 1) * per_chunk, nresamples);\n                    let a_resample = a_resamples.next();\n\n                    let mut sub_distributions: T::Builder =\n                        TupledDistributionsBuilder::new(end - start);\n\n                    for _ in start..end {\n                        let b_resample = b_resamples.next();\n                        sub_distributions.push(statistic(a_resample, b_resample));\n                    }\n                    sub_distributions\n                },\n            )\n            .reduce(\n                || T::Builder::new(0),\n                |mut a, mut b| {\n                    a.extend(&mut b);\n                    a\n                },\n            )\n            .complete()\n    }\n    #[cfg(not(feature = \"rayon\"))]\n    {\n        let mut a_resamples = Resamples::new(a);\n        let mut b_resamples = Resamples::new(b);\n        (0..nresamples_sqrt)\n            .map(|i| {\n                let start = i * per_chunk;\n                let end = cmp::min((i + 1) * per_chunk, nresamples);\n                let a_resample = a_resamples.next();\n\n                let mut sub_distributions: T::Builder =\n                    TupledDistributionsBuilder::new(end - start);\n\n                for _ in start..end {\n                    let b_resample = b_resamples.next();\n                    sub_distributions.push(statistic(a_resample, b_resample));\n                }\n                sub_distributions\n            })\n            .fold(T::Builder::new(0), |mut a, mut b| {\n                a.extend(&mut b);\n                a\n            })\n            .complete()\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use crate::stats::float::Float;\nuse cast::usize;\n\n/// A \"view\" into the percentiles of a sample\npub struct Percentiles<A>(Box<[A]>)\nwhere\n    A: Float;\n\n// TODO(rust-lang/rfcs#735) move this `impl` into a private percentiles module\nimpl<A> Percentiles<A>\nwhere\n    A: Float,\n    usize: cast::From<A, Output = Result<usize, cast::Error>>,\n{\n    /// Returns the percentile at `p`%\n    ///\n    /// Safety:\n    ///\n    /// - Make sure that `p` is in the range `[0, 100]`\n    unsafe fn at_unchecked(&self, p: A) -> A {\n        let _100 = A::cast(100);\n        debug_assert!(p >= A::cast(0) && p <= _100);\n        debug_assert!(!self.0.is_empty());\n        let len = self.0.len() - 1;\n\n        if p == _100 {\n            self.0[len]\n        } else {\n            let rank = (p / _100) * A::cast(len);\n            let integer = rank.floor();\n            let fraction = rank - integer;\n            let n = usize(integer).unwrap();\n            let &floor = self.0.get_unchecked(n);\n            let &ceiling = self.0.get_unchecked(n + 1);\n\n            floor + (ceiling - floor) * fraction\n        }\n    }\n\n    /// Returns the percentile at `p`%\n    ///\n    /// # Panics\n    ///\n    /// Panics if `p` is outside the closed `[0, 100]` range\n    pub fn at(&self, p: A) -> A {\n        let _0 = A::cast(0);\n        let _100 = A::cast(100);\n\n        assert!(p >= _0 && p <= _100);\n        assert!(!self.0.is_empty());\n\n        unsafe { self.at_unchecked(p) }\n    }\n\n    /// Returns the interquartile range\n    pub fn iqr(&self) -> A {\n        let q1 = self.at(A::cast(25));\n        let q3 = self.at(A::cast(75));\n\n        q3 - q1\n    }\n\n    /// Returns the 50th percentile\n    pub fn median(&self) -> A {\n        self.at(A::cast(50))\n    }\n\n    /// Returns the 25th, 50th and 75th percentiles\n    pub fn quartiles(&self) -> (A, A, A) {\n        (\n            self.at(A::cast(25)),\n            self.at(A::cast(50)),\n            self.at(A::cast(75)),\n        )\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::mem;\n\nuse crate::stats::float::Float;\nuse crate::stats::rand_util::{new_rng, Rng};\nuse crate::stats::univariate::Sample;\n\npub struct Resamples<'a, A>\nwhere\n    A: Float,\n{\n    rng: Rng,\n    sample: &'a [A],\n    stage: Option<Vec<A>>,\n}\n\n#[allow(clippy::should_implement_trait)]\nimpl<'a, A> Resamples<'a, A>\nwhere\n    A: 'a + Float,\n{\n    pub fn new(sample: &'a Sample<A>) -> Resamples<'a, A> {\n        let slice = sample;\n\n        Resamples {\n            rng: new_rng(),\n            sample: slice,\n            stage: None,\n        }\n    }\n\n    pub fn next(&mut self) -> &Sample<A> {\n        let n = self.sample.len();\n        let rng = &mut self.rng;\n\n        match self.stage {\n            None => {\n                let mut stage = Vec::with_capacity(n);\n\n                for _ in 0..n {\n                    let idx = rng.rand_range(0u64..(self.sample.len() as u64));\n                    stage.push(self.sample[idx as usize]);\n                }\n\n                self.stage = Some(stage);\n            }\n            Some(ref mut stage) => {\n                for elem in stage.iter_mut() {\n                    let idx = rng.rand_range(0u64..(self.sample.len() as u64));\n                    *elem = self.sample[idx as usize];\n                }\n            }\n        }\n\n        if let Some(ref v) = self.stage {\n            unsafe { mem::transmute::<&[A], &Sample<A>>(v) }\n        } else {\n            unreachable!();\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use quickcheck::quickcheck;\n    use quickcheck::TestResult;\n    use std::collections::HashSet;\n\n    use crate::stats::univariate::resamples::Resamples;\n    use crate::stats::univariate::Sample;\n\n    // Check that the resample is a subset of the sample\n    quickcheck! {\n        fn subset(size: u8, nresamples: u8) -> TestResult {\n            let size = size as usize;\n            let nresamples = nresamples as usize;\n            if size > 1 {\n                let v: Vec<_> = (0..size).map(|i| i as f32).collect();\n                let sample = Sample::new(&v);\n                let mut resamples = Resamples::new(sample);\n                let sample = v.iter().map(|&x| x as i64).collect::<HashSet<_>>();\n\n                TestResult::from_bool((0..nresamples).all(|_| {\n                    let resample = resamples.next()\n\n                        .iter()\n                        .map(|&x| x as i64)\n                        .collect::<HashSet<_>>();\n\n                    resample.is_subset(&sample)\n                }))\n            } else {\n                TestResult::discard()\n            }\n        }\n    }\n\n    #[test]\n    fn different_subsets() {\n        let size = 1000;\n        let v: Vec<_> = (0..size).map(|i| i as f32).collect();\n        let sample = Sample::new(&v);\n        let mut resamples = Resamples::new(sample);\n\n        // Hypothetically, we might see one duplicate, but more than one is likely to be a bug.\n        let mut num_duplicated = 0;\n        for _ in 0..1000 {\n            let sample_1 = resamples.next().iter().cloned().collect::<Vec<_>>();\n            let sample_2 = resamples.next().iter().cloned().collect::<Vec<_>>();\n\n            if sample_1 == sample_2 {\n                num_duplicated += 1;\n            }\n        }\n\n        if num_duplicated > 1 {\n            panic!(\"Found {} duplicate samples\", num_duplicated);\n        }\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::{mem, ops};\n\nuse crate::stats::float::Float;\nuse crate::stats::tuple::{Tuple, TupledDistributionsBuilder};\nuse crate::stats::univariate::Percentiles;\nuse crate::stats::univariate::Resamples;\n#[cfg(feature = \"rayon\")]\nuse rayon::prelude::*;\n\n/// A collection of data points drawn from a population\n///\n/// Invariants:\n///\n/// - The sample contains at least 2 data points\n/// - The sample contains no `NaN`s\n#[repr(transparent)]\npub struct Sample<A>([A]);\n\n// TODO(rust-lang/rfcs#735) move this `impl` into a private percentiles module\nimpl<A> Sample<A>\nwhere\n    A: Float,\n{\n    /// Creates a new sample from an existing slice\n    ///\n    /// # Panics\n    ///\n    /// Panics if `slice` contains any `NaN` or if `slice` has less than two elements\n    #[allow(clippy::new_ret_no_self)]\n    pub fn new(slice: &[A]) -> &Sample<A> {\n        assert!(slice.len() > 1 && slice.iter().all(|x| !x.is_nan()));\n\n        unsafe { mem::transmute(slice) }\n    }\n\n    /// Returns the biggest element in the sample\n    ///\n    /// - Time: `O(length)`\n    pub fn max(&self) -> A {\n        let mut elems = self.iter();\n\n        match elems.next() {\n            Some(&head) => elems.fold(head, |a, &b| a.max(b)),\n            // NB `unreachable!` because `Sample` is guaranteed to have at least one data point\n            None => unreachable!(),\n        }\n    }\n\n    /// Returns the arithmetic average of the sample\n    ///\n    /// - Time: `O(length)`\n    pub fn mean(&self) -> A {\n        let n = self.len();\n\n        self.sum() / A::cast(n)\n    }\n\n    /// Returns the median absolute deviation\n    ///\n    /// The `median` can be optionally passed along to speed up (2X) the computation\n    ///\n    /// - Time: `O(length)`\n    /// - Memory: `O(length)`\n    pub fn median_abs_dev(&self, median: Option<A>) -> A\n    where\n        usize: cast::From<A, Output = Result<usize, cast::Error>>,\n    {\n        let median = median.unwrap_or_else(|| self.percentiles().median());\n\n        // NB Although this operation can be SIMD accelerated, the gain is negligible because the\n        // bottle neck is the sorting operation which is part of the computation of the median\n        let abs_devs = self.iter().map(|&x| (x - median).abs()).collect::<Vec<_>>();\n\n        let abs_devs: &Self = Self::new(&abs_devs);\n\n        abs_devs.percentiles().median() * A::cast(1.4826)\n    }\n\n    /// Returns the median absolute deviation as a percentage of the median\n    ///\n    /// - Time: `O(length)`\n    /// - Memory: `O(length)`\n    pub fn median_abs_dev_pct(&self) -> A\n    where\n        usize: cast::From<A, Output = Result<usize, cast::Error>>,\n    {\n        let _100 = A::cast(100);\n        let median = self.percentiles().median();\n        let mad = self.median_abs_dev(Some(median));\n\n        (mad / median) * _100\n    }\n\n    /// Returns the smallest element in the sample\n    ///\n    /// - Time: `O(length)`\n    pub fn min(&self) -> A {\n        let mut elems = self.iter();\n\n        match elems.next() {\n            Some(&elem) => elems.fold(elem, |a, &b| a.min(b)),\n            // NB `unreachable!` because `Sample` is guaranteed to have at least one data point\n            None => unreachable!(),\n        }\n    }\n\n    /// Returns a \"view\" into the percentiles of the sample\n    ///\n    /// This \"view\" makes consecutive computations of percentiles much faster (`O(1)`)\n    ///\n    /// - Time: `O(N log N) where N = length`\n    /// - Memory: `O(length)`\n    pub fn percentiles(&self) -> Percentiles<A>\n    where\n        usize: cast::From<A, Output = Result<usize, cast::Error>>,\n    {\n        use std::cmp::Ordering;\n\n        // NB This function assumes that there are no `NaN`s in the sample\n        fn cmp<T>(a: &T, b: &T) -> Ordering\n        where\n            T: PartialOrd,\n        {\n            match a.partial_cmp(b) {\n                Some(o) => o,\n                // Arbitrary way to handle NaNs that should never happen\n                None => Ordering::Equal,\n            }\n        }\n\n        let mut v = self.to_vec().into_boxed_slice();\n        #[cfg(feature = \"rayon\")]\n        v.par_sort_unstable_by(cmp);\n        #[cfg(not(feature = \"rayon\"))]\n        v.sort_unstable_by(cmp);\n\n        // NB :-1: to intra-crate privacy rules\n        unsafe { mem::transmute(v) }\n    }\n\n    /// Returns the standard deviation of the sample\n    ///\n    /// The `mean` can be optionally passed along to speed up (2X) the computation\n    ///\n    /// - Time: `O(length)`\n    pub fn std_dev(&self, mean: Option<A>) -> A {\n        self.var(mean).sqrt()\n    }\n\n    /// Returns the standard deviation as a percentage of the mean\n    ///\n    /// - Time: `O(length)`\n    pub fn std_dev_pct(&self) -> A {\n        let _100 = A::cast(100);\n        let mean = self.mean();\n        let std_dev = self.std_dev(Some(mean));\n\n        (std_dev / mean) * _100\n    }\n\n    /// Returns the sum of all the elements of the sample\n    ///\n    /// - Time: `O(length)`\n    pub fn sum(&self) -> A {\n        crate::stats::sum(self)\n    }\n\n    /// Returns the t score between these two samples\n    ///\n    /// - Time: `O(length)`\n    pub fn t(&self, other: &Sample<A>) -> A {\n        let (x_bar, y_bar) = (self.mean(), other.mean());\n        let (s2_x, s2_y) = (self.var(Some(x_bar)), other.var(Some(y_bar)));\n        let n_x = A::cast(self.len());\n        let n_y = A::cast(other.len());\n        let num = x_bar - y_bar;\n        let den = (s2_x / n_x + s2_y / n_y).sqrt();\n\n        num / den\n    }\n\n    /// Returns the variance of the sample\n    ///\n    /// The `mean` can be optionally passed along to speed up (2X) the computation\n    ///\n    /// - Time: `O(length)`\n    pub fn var(&self, mean: Option<A>) -> A {\n        use std::ops::Add;\n\n        let mean = mean.unwrap_or_else(|| self.mean());\n        let slice = self;\n\n        let sum = slice\n            .iter()\n            .map(|&x| (x - mean).powi(2))\n            .fold(A::cast(0), Add::add);\n\n        sum / A::cast(slice.len() - 1)\n    }\n\n    // TODO Remove the `T` parameter in favor of `S::Output`\n    /// Returns the bootstrap distributions of the parameters estimated by the 1-sample statistic\n    ///\n    /// - Multi-threaded\n    /// - Time: `O(nresamples)`\n    /// - Memory: `O(nresamples)`\n    pub fn bootstrap<T, S>(&self, nresamples: usize, statistic: S) -> T::Distributions\n    where\n        S: Fn(&Sample<A>) -> T + Sync,\n        T: Tuple + Send,\n        T::Distributions: Send,\n        T::Builder: Send,\n    {\n        #[cfg(feature = \"rayon\")]\n        {\n            (0..nresamples)\n                .into_par_iter()\n                .map_init(\n                    || Resamples::new(self),\n                    |resamples, _| statistic(resamples.next()),\n                )\n                .fold(\n                    || T::Builder::new(0),\n                    |mut sub_distributions, sample| {\n                        sub_distributions.push(sample);\n                        sub_distributions\n                    },\n                )\n                .reduce(\n                    || T::Builder::new(0),\n                    |mut a, mut b| {\n                        a.extend(&mut b);\n                        a\n                    },\n                )\n                .complete()\n        }\n        #[cfg(not(feature = \"rayon\"))]\n        {\n            let mut resamples = Resamples::new(self);\n            (0..nresamples)\n                .map(|_| statistic(resamples.next()))\n                .fold(T::Builder::new(0), |mut sub_distributions, sample| {\n                    sub_distributions.push(sample);\n                    sub_distributions\n                })\n                .complete()\n        }\n    }\n\n    #[cfg(test)]\n    pub fn iqr(&self) -> A\n    where\n        usize: cast::From<A, Output = Result<usize, cast::Error>>,\n    {\n        self.percentiles().iqr()\n    }\n\n    #[cfg(test)]\n    pub fn median(&self) -> A\n    where\n        usize: cast::From<A, Output = Result<usize, cast::Error>>,\n    {\n        self.percentiles().median()\n    }\n}\n\nimpl<A> ops::Deref for Sample<A> {\n    type Target = [A];\n\n    fn deref(&self) -> &[A] {\n        &self.0\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Kernel density estimation\n\npub mod kernel;\n\nuse self::kernel::Kernel;\nuse crate::stats::float::Float;\nuse crate::stats::univariate::Sample;\n#[cfg(feature = \"rayon\")]\nuse rayon::prelude::*;\n\n/// Univariate kernel density estimator\npub struct Kde<'a, A, K>\nwhere\n    A: Float,\n    K: Kernel<A>,\n{\n    bandwidth: A,\n    kernel: K,\n    sample: &'a Sample<A>,\n}\n\nimpl<'a, A, K> Kde<'a, A, K>\nwhere\n    A: 'a + Float,\n    K: Kernel<A>,\n{\n    /// Creates a new kernel density estimator from the `sample`, using a kernel and estimating\n    /// the bandwidth using the method `bw`\n    pub fn new(sample: &'a Sample<A>, kernel: K, bw: Bandwidth) -> Kde<'a, A, K> {\n        Kde {\n            bandwidth: bw.estimate(sample),\n            kernel,\n            sample,\n        }\n    }\n\n    /// Returns the bandwidth used by the estimator\n    pub fn bandwidth(&self) -> A {\n        self.bandwidth\n    }\n\n    /// Maps the KDE over `xs`\n    ///\n    /// - Multihreaded\n    pub fn map(&self, xs: &[A]) -> Box<[A]> {\n        #[cfg(feature = \"rayon\")]\n        let iter = xs.par_iter();\n\n        #[cfg(not(feature = \"rayon\"))]\n        let iter = xs.iter();\n\n        iter.map(|&x| self.estimate(x))\n            .collect::<Vec<_>>()\n            .into_boxed_slice()\n    }\n\n    /// Estimates the probability density of `x`\n    pub fn estimate(&self, x: A) -> A {\n        let _0 = A::cast(0);\n        let slice = self.sample;\n        let h = self.bandwidth;\n        let n = A::cast(slice.len());\n\n        let sum = slice\n            .iter()\n            .fold(_0, |acc, &x_i| acc + self.kernel.evaluate((x - x_i) / h));\n\n        sum / (h * n)\n    }\n}\n\n/// Method to estimate the bandwidth\npub enum Bandwidth {\n    /// Use Silverman's rule of thumb to estimate the bandwidth from the sample\n    Silverman,\n}\n\nimpl Bandwidth {\n    fn estimate<A: Float>(self, sample: &Sample<A>) -> A {\n        match self {\n            Bandwidth::Silverman => {\n                let factor = A::cast(4. / 3.);\n                let exponent = A::cast(1. / 5.);\n                let n = A::cast(sample.len());\n                let sigma = sample.std_dev(None);\n\n                sigma * (factor / n).powf(exponent)\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmacro_rules! test {\n    ($ty:ident) => {\n        mod $ty {\n            use approx::relative_eq;\n            use quickcheck::quickcheck;\n            use quickcheck::TestResult;\n\n            use crate::stats::univariate::kde::kernel::Gaussian;\n            use crate::stats::univariate::kde::{Bandwidth, Kde};\n            use crate::stats::univariate::Sample;\n\n            // The [-inf inf] integral of the estimated PDF should be one\n            quickcheck! {\n                fn integral(size: u8, start: u8) -> TestResult {\n                    let size = size as usize;\n                    let start = start as usize;\n                    const DX: $ty = 1e-3;\n\n                    if let Some(v) = crate::stats::test::vec::<$ty>(size, start) {\n                        let slice = &v[start..];\n                        let data = Sample::new(slice);\n                        let kde = Kde::new(data, Gaussian, Bandwidth::Silverman);\n                        let h = kde.bandwidth();\n                        // NB Obviously a [-inf inf] integral is not feasible, but this range works\n                        // quite well\n                        let (a, b) = (data.min() - 5. * h, data.max() + 5. * h);\n\n                        let mut acc = 0.;\n                        let mut x = a;\n                        let mut y = kde.estimate(a);\n\n                        while x < b {\n                            acc += DX * y / 2.;\n\n                            x += DX;\n                            y = kde.estimate(x);\n\n                            acc += DX * y / 2.;\n                        }\n\n                        TestResult::from_bool(relative_eq!(acc, 1., epsilon = 2e-5))\n                    } else {\n                        TestResult::discard()\n                    }\n                }\n            }\n        }\n    };\n}\n\n#[cfg(test)]\nmod test {\n    test!(f32);\n    test!(f64);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Classification of outliers\n//!\n//! WARNING: There's no formal/mathematical definition of what an outlier actually is. Therefore,\n//! all outlier classifiers are *subjective*, however some classifiers that have become *de facto*\n//! standard are provided here.\n\npub mod tukey;"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "//! Tukey's method\n//!\n//! The original method uses two \"fences\" to classify the data. All the observations \"inside\" the\n//! fences are considered \"normal\", and the rest are considered outliers.\n//!\n//! The fences are computed from the quartiles of the sample, according to the following formula:\n//!\n//! ``` ignore\n//! // q1, q3 are the first and third quartiles\n//! let iqr = q3 - q1;  // The interquartile range\n//! let (f1, f2) = (q1 - 1.5 * iqr, q3 + 1.5 * iqr);  // the \"fences\"\n//!\n//! let is_outlier = |x| if x > f1 && x < f2 { true } else { false };\n//! ```\n//!\n//! The classifier provided here adds two extra outer fences:\n//!\n//! ``` ignore\n//! let (f3, f4) = (q1 - 3 * iqr, q3 + 3 * iqr);  // the outer \"fences\"\n//! ```\n//!\n//! The extra fences add a sense of \"severity\" to the classification. Data points outside of the\n//! outer fences are considered \"severe\" outliers, whereas points outside the inner fences are just\n//! \"mild\" outliers, and, as the original method, everything inside the inner fences is considered\n//! \"normal\" data.\n//!\n//! Some ASCII art for the visually oriented people:\n//!\n//! ``` ignore\n//!          LOW-ish                NORMAL-ish                 HIGH-ish\n//!         x   |       +    |  o o  o    o   o o  o  |        +   |   x\n//!             f3           f1                       f2           f4\n//!\n//! Legend:\n//! o: \"normal\" data (not an outlier)\n//! +: \"mild\" outlier\n//! x: \"severe\" outlier\n//! ```\n\nuse std::ops::{Deref, Index};\nuse std::slice;\n\nuse crate::stats::float::Float;\nuse crate::stats::univariate::Sample;\n\nuse self::Label::*;\n\n/// A classified/labeled sample.\n///\n/// The labeled data can be accessed using the indexing operator. The order of the data points is\n/// retained.\n///\n/// NOTE: Due to limitations in the indexing traits, only the label is returned. Once the\n/// `IndexGet` trait lands in stdlib, the indexing operation will return a `(data_point, label)`\n/// pair.\n#[derive(Clone, Copy)]\npub struct LabeledSample<'a, A>\nwhere\n    A: Float,\n{\n    fences: (A, A, A, A),\n    sample: &'a Sample<A>,\n}\n\nimpl<'a, A> LabeledSample<'a, A>\nwhere\n    A: Float,\n{\n    /// Returns the number of data points per label\n    ///\n    /// - Time: `O(length)`\n    #[allow(clippy::similar_names)]\n    pub fn count(&self) -> (usize, usize, usize, usize, usize) {\n        let (mut los, mut lom, mut noa, mut him, mut his) = (0, 0, 0, 0, 0);\n\n        for (_, label) in self {\n            match label {\n                LowSevere => {\n                    los += 1;\n                }\n                LowMild => {\n                    lom += 1;\n                }\n                NotAnOutlier => {\n                    noa += 1;\n                }\n                HighMild => {\n                    him += 1;\n                }\n                HighSevere => {\n                    his += 1;\n                }\n            }\n        }\n\n        (los, lom, noa, him, his)\n    }\n\n    /// Returns the fences used to classify the outliers\n    pub fn fences(&self) -> (A, A, A, A) {\n        self.fences\n    }\n\n    /// Returns an iterator over the labeled data\n    pub fn iter(&self) -> Iter<'a, A> {\n        Iter {\n            fences: self.fences,\n            iter: self.sample.iter(),\n        }\n    }\n}\n\nimpl<'a, A> Deref for LabeledSample<'a, A>\nwhere\n    A: Float,\n{\n    type Target = Sample<A>;\n\n    fn deref(&self) -> &Sample<A> {\n        self.sample\n    }\n}\n\n// FIXME Use the `IndexGet` trait\nimpl<'a, A> Index<usize> for LabeledSample<'a, A>\nwhere\n    A: Float,\n{\n    type Output = Label;\n\n    #[allow(clippy::similar_names)]\n    fn index(&self, i: usize) -> &Label {\n        static LOW_SEVERE: Label = LowSevere;\n        static LOW_MILD: Label = LowMild;\n        static HIGH_MILD: Label = HighMild;\n        static HIGH_SEVERE: Label = HighSevere;\n        static NOT_AN_OUTLIER: Label = NotAnOutlier;\n\n        let x = self.sample[i];\n        let (lost, lomt, himt, hist) = self.fences;\n\n        if x < lost {\n            &LOW_SEVERE\n        } else if x > hist {\n            &HIGH_SEVERE\n        } else if x < lomt {\n            &LOW_MILD\n        } else if x > himt {\n            &HIGH_MILD\n        } else {\n            &NOT_AN_OUTLIER\n        }\n    }\n}\n\nimpl<'a, A> IntoIterator for &LabeledSample<'a, A>\nwhere\n    A: Float,\n{\n    type Item = (A, Label);\n    type IntoIter = Iter<'a, A>;\n\n    fn into_iter(self) -> Iter<'a, A> {\n        self.iter()\n    }\n}\n\n/// Iterator over the labeled data\npub struct Iter<'a, A>\nwhere\n    A: Float,\n{\n    fences: (A, A, A, A),\n    iter: slice::Iter<'a, A>,\n}\n\nimpl<'a, A> Iterator for Iter<'a, A>\nwhere\n    A: Float,\n{\n    type Item = (A, Label);\n\n    #[allow(clippy::similar_names)]\n    fn next(&mut self) -> Option<(A, Label)> {\n        self.iter.next().map(|&x| {\n            let (lost, lomt, himt, hist) = self.fences;\n\n            let label = if x < lost {\n                LowSevere\n            } else if x > hist {\n                HighSevere\n            } else if x < lomt {\n                LowMild\n            } else if x > himt {\n                HighMild\n            } else {\n                NotAnOutlier\n            };\n\n            (x, label)\n        })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n/// Labels used to classify outliers\npub enum Label {\n    /// A \"mild\" outlier in the \"high\" spectrum\n    HighMild,\n    /// A \"severe\" outlier in the \"high\" spectrum\n    HighSevere,\n    /// A \"mild\" outlier in the \"low\" spectrum\n    LowMild,\n    /// A \"severe\" outlier in the \"low\" spectrum\n    LowSevere,\n    /// A normal data point\n    NotAnOutlier,\n}\n\nimpl Label {\n    /// Checks if the data point has an \"unusually\" high value\n    pub fn is_high(&self) -> bool {\n        matches!(*self, HighMild | HighSevere)\n    }\n\n    /// Checks if the data point is labeled as a \"mild\" outlier\n    pub fn is_mild(&self) -> bool {\n        matches!(*self, HighMild | LowMild)\n    }\n\n    /// Checks if the data point has an \"unusually\" low value\n    pub fn is_low(&self) -> bool {\n        matches!(*self, LowMild | LowSevere)\n    }\n\n    /// Checks if the data point is labeled as an outlier\n    pub fn is_outlier(&self) -> bool {\n        !matches!(*self, NotAnOutlier)\n    }\n\n    /// Checks if the data point is labeled as a \"severe\" outlier\n    pub fn is_severe(&self) -> bool {\n        matches!(*self, HighSevere | LowSevere)\n    }\n}\n\n/// Classifies the sample, and returns a labeled sample.\n///\n/// - Time: `O(N log N) where N = length`\npub fn classify<A>(sample: &Sample<A>) -> LabeledSample<'_, A>\nwhere\n    A: Float,\n    usize: cast::From<A, Output = Result<usize, cast::Error>>,\n{\n    let (q1, _, q3) = sample.percentiles().quartiles();\n    let iqr = q3 - q1;\n\n    // Mild\n    let k_m = A::cast(1.5_f32);\n    // Severe\n    let k_s = A::cast(3);\n\n    LabeledSample {\n        fences: (\n            q1 - k_s * iqr,\n            q1 - k_m * iqr,\n            q3 + k_m * iqr,\n            q3 + k_s * iqr,\n        ),\n        sample,\n    }\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::criterion_main;\n\nmod benchmarks;\n\ncriterion_main! {\n    benchmarks::compare_functions::fibonaccis,\n    benchmarks::external_process::benches,\n    benchmarks::iter_with_large_drop::benches,\n    benchmarks::iter_with_large_setup::benches,\n    benchmarks::iter_with_setup::benches,\n    benchmarks::with_inputs::benches,\n    benchmarks::special_characters::benches,\n    benchmarks::measurement_overhead::benches,\n    benchmarks::custom_measurement::benches,\n    benchmarks::sampling_mode::benches,\n    benchmarks::async_measurement_overhead::benches,\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{async_executor::FuturesExecutor, criterion_group, BatchSize, Criterion};\n\nfn some_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"async overhead\");\n    group.bench_function(\"iter\", |b| b.to_async(FuturesExecutor).iter(|| async { 1 }));\n    group.bench_function(\"iter_with_setup\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_with_setup(|| (), |_| async { 1 })\n    });\n    group.bench_function(\"iter_with_large_setup\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_with_large_setup(|| (), |_| async { 1 })\n    });\n    group.bench_function(\"iter_with_large_drop\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_with_large_drop(|| async { 1 })\n    });\n    group.bench_function(\"iter_batched_small_input\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_batched(|| (), |_| async { 1 }, BatchSize::SmallInput)\n    });\n    group.bench_function(\"iter_batched_large_input\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_batched(|| (), |_| async { 1 }, BatchSize::LargeInput)\n    });\n    group.bench_function(\"iter_batched_per_iteration\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_batched(|| (), |_| async { 1 }, BatchSize::PerIteration)\n    });\n    group.bench_function(\"iter_batched_ref_small_input\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_batched_ref(|| (), |_| async { 1 }, BatchSize::SmallInput)\n    });\n    group.bench_function(\"iter_batched_ref_large_input\", |b| {\n        b.to_async(FuturesExecutor)\n            .iter_batched_ref(|| (), |_| async { 1 }, BatchSize::LargeInput)\n    });\n    group.bench_function(\"iter_batched_ref_per_iteration\", |b| {\n        b.to_async(FuturesExecutor).iter_batched_ref(\n            || (),\n            |_| async { 1 },\n            BatchSize::PerIteration,\n        )\n    });\n    group.finish();\n}\n\ncriterion_group!(benches, some_benchmark);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, BenchmarkId, Criterion};\n\nfn fibonacci_slow(n: u64) -> u64 {\n    match n {\n        0 | 1 => 1,\n        n => fibonacci_slow(n - 1) + fibonacci_slow(n - 2),\n    }\n}\n\nfn fibonacci_fast(n: u64) -> u64 {\n    let mut a = 0;\n    let mut b = 1;\n\n    match n {\n        0 => b,\n        _ => {\n            for _ in 0..n {\n                let c = a + b;\n                a = b;\n                b = c;\n            }\n            b\n        }\n    }\n}\n\nfn compare_fibonaccis(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"Fibonacci\");\n\n    group.bench_with_input(\"Recursive\", &20, |b, i| b.iter(|| fibonacci_slow(*i)));\n    group.bench_with_input(\"Iterative\", &20, |b, i| b.iter(|| fibonacci_fast(*i)));\n}\nfn compare_fibonaccis_group(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"Fibonacci3\");\n    for i in 20..=21 {\n        group.bench_with_input(BenchmarkId::new(\"Recursive\", i), &i, |b, i| {\n            b.iter(|| fibonacci_slow(*i));\n        });\n        group.bench_with_input(BenchmarkId::new(\"Iterative\", i), &i, |b, i| {\n            b.iter(|| fibonacci_fast(*i));\n        });\n    }\n    group.finish();\n}\n\ncriterion_group!(fibonaccis, compare_fibonaccis, compare_fibonaccis_group,);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use {\n    criterion::{\n        criterion_group,\n        measurement::{Measurement, ValueFormatter},\n        Criterion, Throughput,\n    },\n    std::{\n        hint::black_box,\n        time::{Duration, Instant},\n    },\n};\n\nstruct HalfSecFormatter;\nimpl ValueFormatter for HalfSecFormatter {\n    fn format_value(&self, value: f64) -> String {\n        // The value will be in nanoseconds so we have to convert to half-seconds.\n        format!(\"{} s/2\", value * 2f64 * 10f64.powi(-9))\n    }\n\n    fn format_throughput(&self, throughput: &Throughput, value: f64) -> String {\n        match *throughput {\n            Throughput::Bytes(bytes) | Throughput::BytesDecimal(bytes) => {\n                format!(\"{} b/s/2\", (bytes as f64) / (value * 2f64 * 10f64.powi(-9)))\n            }\n            Throughput::Bits(bits) => {\n                format!(\n                    \"{} bits/s/2\",\n                    (bits as f64) / (value * 2f64 * 10f64.powi(-9))\n                )\n            }\n            Throughput::Elements(elems) => format!(\n                \"{} elem/s/2\",\n                (elems as f64) / (value * 2f64 * 10f64.powi(-9))\n            ),\n            Throughput::ElementsAndBytes { elements, bytes } => format!(\n                \"{} elem/s/2, {} b/s/2\",\n                (elements as f64) / (value * 2f64 * 10f64.powi(-9)),\n                (bytes as f64) / (value * 2f64 * 10f64.powi(-9))\n            ),\n        }\n    }\n\n    fn scale_values(&self, _typical: f64, values: &mut [f64]) -> &'static str {\n        for val in values {\n            *val *= 2f64 * 10f64.powi(-9);\n        }\n\n        \"s/2\"\n    }\n\n    fn scale_throughputs(\n        &self,\n        _typical: f64,\n        throughput: &Throughput,\n        values: &mut [f64],\n    ) -> &'static str {\n        match *throughput {\n            Throughput::Bytes(bytes) | Throughput::BytesDecimal(bytes) => {\n                for val in values {\n                    *val = (bytes as f64) / (*val * 2f64 * 10f64.powi(-9));\n                }\n\n                \"b/s/2\"\n            }\n            Throughput::Bits(bits) => {\n                for val in values {\n                    *val = (bits as f64) / (*val * 2f64 * 10f64.powi(-9));\n                }\n\n                \"bits/s/2\"\n            }\n            Throughput::Elements(elems) => {\n                for val in values {\n                    *val = (elems as f64) / (*val * 2f64 * 10f64.powi(-9));\n                }\n\n                \"elem/s/2\"\n            }\n            Throughput::ElementsAndBytes { elements, bytes: _ } => {\n                self.scale_throughputs(_typical, &Throughput::Elements(elements), values)\n            }\n        }\n    }\n\n    fn scale_for_machines(&self, values: &mut [f64]) -> &'static str {\n        for val in values {\n            *val *= 2f64 * 10f64.powi(-9);\n        }\n\n        \"s/2\"\n    }\n}\n\nconst NANOS_PER_SEC: u64 = 1_000_000_000;\n\n/// Silly \"measurement\" that is really just wall-clock time reported in half-seconds.\nstruct HalfSeconds;\nimpl Measurement for HalfSeconds {\n    type Intermediate = Instant;\n    type Value = Duration;\n\n    fn start(&self) -> Self::Intermediate {\n        Instant::now()\n    }\n    fn end(&self, i: Self::Intermediate) -> Self::Value {\n        i.elapsed()\n    }\n    fn add(&self, v1: &Self::Value, v2: &Self::Value) -> Self::Value {\n        *v1 + *v2\n    }\n    fn zero(&self) -> Self::Value {\n        Duration::from_secs(0)\n    }\n    fn to_f64(&self, val: &Self::Value) -> f64 {\n        let nanos = val.as_secs() * NANOS_PER_SEC + u64::from(val.subsec_nanos());\n        nanos as f64\n    }\n    fn formatter(&self) -> &dyn ValueFormatter {\n        &HalfSecFormatter\n    }\n}\n\nfn fibonacci_slow(n: u64) -> u64 {\n    match n {\n        0 | 1 => 1,\n        n => fibonacci_slow(n - 1) + fibonacci_slow(n - 2),\n    }\n}\n\nfn fibonacci_cycles(criterion: &mut Criterion<HalfSeconds>) {\n    criterion.bench_function(\"fibonacci_custom_measurement\", |bencher| {\n        bencher.iter(|| fibonacci_slow(black_box(10)));\n    });\n}\n\nfn alternate_measurement() -> Criterion<HalfSeconds> {\n    Criterion::default().with_measurement(HalfSeconds)\n}\n\ncriterion_group! {\n    name = benches;\n    config = alternate_measurement();\n    targets = fibonacci_cycles\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, Criterion};\nuse std::{\n    io::{BufRead, BufReader, Write},\n    process::{Command, Stdio},\n    str::FromStr,\n    time::Duration,\n};\n\nfn create_command() -> Command {\n    let mut command = Command::new(\"python3\");\n    command\n        .arg(\"benches/benchmarks/external_process.py\")\n        .arg(\"10\");\n    command\n}\n\nfn python_fibonacci(c: &mut Criterion) {\n    let has_python3 = Command::new(\"python3\")\n        .arg(\"--version\")\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .output()\n        .is_ok();\n\n    if has_python3 {\n        let mut process = create_command()\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()\n            .expect(\"Unable to start python process\");\n\n        let mut stdin = process\n            .stdin\n            .take()\n            .expect(\"Unable to get stdin for child process\");\n        let stdout = process\n            .stdout\n            .take()\n            .expect(\"Unable to get stdout for child process\");\n        let mut stdout = BufReader::new(stdout);\n        c.bench_function(\"fibonacci-python\", |b| {\n            b.iter_custom(|iters| {\n                writeln!(stdin, \"{}\", iters)\n                    .expect(\"Unable to send iteration count to child process\");\n                let mut line = String::new();\n                stdout\n                    .read_line(&mut line)\n                    .expect(\"Unable to read time from child process\");\n                let nanoseconds: u64 =\n                    u64::from_str(line.trim()).expect(\"Unable to parse time from child process\");\n                Duration::from_nanos(nanoseconds)\n            });\n        });\n\n        // Ensure that your child process terminates itself gracefully!\n        process.kill().expect(\"Unable to kill child process\");\n    }\n}\n\ncriterion_group!(benches, python_fibonacci);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, Criterion, Throughput};\nuse std::time::Duration;\n\nconst SIZE: usize = 1024 * 1024;\n\nfn large_drop(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"iter_with_large_drop\");\n    group.throughput(Throughput::Bytes(SIZE as u64));\n    group.bench_function(\"large_drop\", |b| {\n        let v: Vec<_> = (0..SIZE).map(|i| i as u8).collect();\n        b.iter_with_large_drop(|| v.clone());\n    });\n}\n\nfn small_drop(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"iter_with_large_drop\");\n    group.bench_function(\"small_drop\", |b| {\n        b.iter_with_large_drop(|| SIZE);\n    });\n}\n\nfn short_warmup() -> Criterion {\n    Criterion::default().warm_up_time(Duration::new(1, 0))\n}\n\ncriterion_group! {\n    name = benches;\n    config = short_warmup();\n    targets = large_drop, small_drop\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, BatchSize, Criterion, Throughput};\nuse std::time::Duration;\n\nconst SIZE: usize = 1024 * 1024;\n\nfn large_setup(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"iter_with_large_setup\");\n    group.throughput(Throughput::Bytes(SIZE as u64));\n    group.bench_function(\"large_setup\", |b| {\n        b.iter_batched(\n            || (0..SIZE).map(|i| i as u8).collect::<Vec<_>>(),\n            |v| v,\n            BatchSize::NumBatches(1),\n        );\n    });\n}\n\nfn small_setup(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"iter_with_large_setup\");\n    group.bench_function(\"small_setup\", |b| {\n        b.iter_batched(|| SIZE, |size| size, BatchSize::NumBatches(1));\n    });\n}\n\nfn short_warmup() -> Criterion {\n    Criterion::default().warm_up_time(Duration::new(1, 0))\n}\n\ncriterion_group! {\n    name = benches;\n    config = short_warmup();\n    targets = large_setup, small_setup\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, Criterion};\n\nconst SIZE: usize = 1024 * 1024;\n\nfn setup(c: &mut Criterion) {\n    c.bench_function(\"iter_with_setup\", |b| {\n        b.iter_with_setup(|| (0..SIZE).map(|i| i as u8).collect::<Vec<_>>(), |v| v);\n    });\n}\n\ncriterion_group!(benches, setup);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, BatchSize, Criterion};\n\nfn some_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"overhead\");\n    group.bench_function(\"iter\", |b| b.iter(|| 1));\n    group.bench_function(\"iter_with_setup\", |b| b.iter_with_setup(|| (), |_| 1));\n    group.bench_function(\"iter_with_large_setup\", |b| {\n        b.iter_batched(|| (), |_| 1, BatchSize::NumBatches(1));\n    });\n    group.bench_function(\"iter_with_large_drop\", |b| b.iter_with_large_drop(|| 1));\n    group.bench_function(\"iter_batched_small_input\", |b| {\n        b.iter_batched(|| (), |_| 1, BatchSize::SmallInput);\n    });\n    group.bench_function(\"iter_batched_large_input\", |b| {\n        b.iter_batched(|| (), |_| 1, BatchSize::LargeInput);\n    });\n    group.bench_function(\"iter_batched_per_iteration\", |b| {\n        b.iter_batched(|| (), |_| 1, BatchSize::PerIteration);\n    });\n    group.bench_function(\"iter_batched_ref_small_input\", |b| {\n        b.iter_batched_ref(|| (), |_| 1, BatchSize::SmallInput);\n    });\n    group.bench_function(\"iter_batched_ref_large_input\", |b| {\n        b.iter_batched_ref(|| (), |_| 1, BatchSize::LargeInput);\n    });\n    group.bench_function(\"iter_batched_ref_per_iteration\", |b| {\n        b.iter_batched_ref(|| (), |_| 1, BatchSize::PerIteration);\n    });\n    group.finish();\n}\n\ncriterion_group!(benches, some_benchmark);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "pub mod compare_functions;\npub mod custom_measurement;\npub mod external_process;\npub mod iter_with_large_drop;\npub mod iter_with_large_setup;\npub mod iter_with_setup;\npub mod measurement_overhead;\npub mod sampling_mode;\npub mod special_characters;\npub mod with_inputs;\n\n#[cfg(feature = \"async_futures\")]\npub mod async_measurement_overhead;\n\n#[cfg(not(feature = \"async_futures\"))]\npub mod async_measurement_overhead {\n    use criterion::{criterion_group, Criterion};\n    fn some_benchmark(_c: &mut Criterion) {}\n\n    criterion_group!(benches, some_benchmark);\n}"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, Criterion, SamplingMode};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn sampling_mode_tests(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"sampling_mode\");\n\n    group.sampling_mode(SamplingMode::Auto);\n    group.bench_function(\"Auto\", |bencher| {\n        bencher.iter(|| sleep(Duration::from_millis(0)));\n    });\n\n    group.sampling_mode(SamplingMode::Linear);\n    group.bench_function(\"Linear\", |bencher| {\n        bencher.iter(|| sleep(Duration::from_millis(0)));\n    });\n\n    group.sampling_mode(SamplingMode::Flat);\n    group.bench_function(\"Flat\", |bencher| {\n        bencher.iter(|| sleep(Duration::from_millis(10)));\n    });\n\n    group.finish();\n}\n\ncriterion_group!(benches, sampling_mode_tests,);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use criterion::{criterion_group, Criterion};\n\nfn some_benchmark(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"\\\"*group/\\\"\");\n    group.bench_function(\"\\\"*benchmark/\\\" '\", |b| b.iter(|| 1 + 1));\n    group.finish();\n}\n\ncriterion_group!(benches, some_benchmark);"}
{"prompt": "Write a Rust code snippet. Output only the code.", "gen": "use std::iter;\n\nuse criterion::{criterion_group, BenchmarkId, Criterion, Throughput};\n\nfn from_elem(c: &mut Criterion) {\n    static KB: usize = 1024;\n\n    let mut group = c.benchmark_group(\"from_elem\");\n    for size in [KB, 2 * KB, 4 * KB, 8 * KB, 16 * KB].iter() {\n        group.throughput(Throughput::Bytes(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {\n            b.iter(|| iter::repeat(0u8).take(size).collect::<Vec<_>>());\n        });\n    }\n    group.finish();\n\n    let mut group = c.benchmark_group(\"from_elem_decimal\");\n    for size in [KB, 2 * KB].iter() {\n        group.throughput(Throughput::BytesDecimal(*size as u64));\n        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {\n            b.iter(|| iter::repeat(0u8).take(size).collect::<Vec<_>>());\n        });\n    }\n    group.finish();\n\n    let mut group = c.benchmark_group(\"from_elem_dual_throughput\");\n    for size in [KB, 2 * KB].iter() {\n        group.throughput(Throughput::ElementsAndBytes {\n            elements: *size as u64,\n            bytes: 2 * *size as u64,\n        });\n        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {\n            b.iter(|| iter::repeat(0u16).take(size).collect::<Vec<_>>());\n        });\n    }\n    group.finish();\n}\n\ncriterion_group!(benches, from_elem);"}
