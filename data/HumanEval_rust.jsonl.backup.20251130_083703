{"task_id": "CodeGen/0", "prompt": "// Check if in given slice of numbers, any two numbers are closer to each other than\n// the given threshold.\n// Returns true if such a pair exists, false otherwise.\nfn has_close_elements(numbers: &[f32], threshold: f32) -> bool {", "canonical_solution": "numbers\n        .iter()\n        .enumerate()\n        .any(|(i, &a)| numbers[i + 1..].iter().any(|&b| (a - b).abs() < threshold))\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_has_close_elements() {\n            assert_eq!(\n                has_close_elements(&[11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3),\n                true\n            );\n            assert_eq!(\n                has_close_elements(&[1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05),\n                false\n            );\n            assert_eq!(has_close_elements(&[1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n            assert_eq!(has_close_elements(&[1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n            assert_eq!(\n                has_close_elements(&[1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1),\n                true\n            );\n            assert_eq!(has_close_elements(&[1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n            assert_eq!(has_close_elements(&[1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n            assert_eq!(has_close_elements(&[], 1.0), false);\n        }\n    }", "entry_point": "has_close_elements", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:04.874856"}
{"task_id": "CodeGen/1", "prompt": "// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n// separate those group into separate strings and return the vector of those.\n// Separate groups are balanced(each open brace is properly closed) and not nested within each other\n// Ignore any spaces in the input string.\nfn separate_paren_groups(paren_string: &str) -> Vec<String>{", "canonical_solution": "let mut result: Vec<String> = vec![];\n    let mut current_string: String = String::new();\n    let mut current_depth: u32 = 0;\n\n    for c in paren_string.chars() {\n        if c == '(' {\n            current_depth += 1;\n            current_string.push(c);\n        } else if c == ')' {\n            current_depth -= 1;\n            current_string.push(c);\n\n            if current_depth == 0 {\n                result.push(current_string.clone());\n                current_string.clear()\n            }\n        }\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_separate_paren_groups() {\n            assert_eq!(\n                separate_paren_groups(\"(()()) ((())) () ((())()())\"),\n                vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n            );\n            assert_eq!(\n                separate_paren_groups(\"() (()) ((())) (((())))\"),\n                vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n            );\n            assert_eq!(\n                separate_paren_groups(\"(()(())((())))\"),\n                vec![\"(()(())((())))\"]\n            );\n            assert_eq!(\n                separate_paren_groups(\"( ) (( )) (( )( ))\"),\n                vec![\"()\", \"(())\", \"(()())\"]\n            );\n        }\n    }", "entry_point": "separate_paren_groups", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:05.343815"}
{"task_id": "CodeGen/2", "prompt": "// Given a positive floating point number, it can be decomposed into\n// and integer part(largest integer smaller than given number) and decimals\n// (leftover part always smaller than 1).\n//\n// Return the decimal part of the number.\nfn truncate_number(number: &f32) -> f32{", "canonical_solution": "number % 1.0\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_truncate_number() {\n            assert!((truncate_number(&3.5) - 0.5).abs() < 0.000001);\n            let t1: f32 = 1.33 - 0.33;\n            assert!(truncate_number(&t1) < 0.000001);\n            let t2: f32 = 123.456 - 0.456;\n            assert!(truncate_number(&t2) < 0.000001);\n        }\n    }", "entry_point": "truncate_number", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:05.804956"}
{"task_id": "CodeGen/3", "prompt": "// Given a slice of deposit and withdrawal operations on a bank account starting with\n// zero balance, detect if the balance ever falls below zero.\n// Returns true if the balance goes negative at any point, false otherwise.\nfn below_zero(operations: &[i32]) -> bool {", "canonical_solution": "operations\n        .iter()\n        .scan(0, |balance, &op| {\n            *balance += op;\n            Some(*balance)\n        })\n        .any(|balance| balance < 0)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_below_zero() {\n            assert_eq!(below_zero(&[]), false);\n            assert_eq!(below_zero(&[1, 2, -3, 1, 2, -3]), false);\n            assert_eq!(below_zero(&[1, 2, -4, 5, 6]), true);\n            assert_eq!(below_zero(&[1, -1, 2, -2, 5, -5, 4, -4]), false);\n            assert_eq!(below_zero(&[1, -1, 2, -2, 5, -5, 4, -5]), true);\n            assert_eq!(below_zero(&[1, -2, 2, -2, 5, -5, 4, -4]), true);\n        }\n    }", "entry_point": "below_zero", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:06.246108"}
{"task_id": "CodeGen/4", "prompt": "// For a given vector of input numbers, calculate Mean Absolute Deviation\n// around the mean of this dataset.\n// Mean Absolute Deviation is the average absolute difference between each\n// element and a centerpoint(mean in this case):\n// MAD = average | x - x_mean |\nfn mean_absolute_deviation(numbers: &[f32]) -> f32{", "canonical_solution": "let mean: f32 = numbers.iter().fold(0.0, |acc: f32, x: &f32| acc + x) / numbers.len() as f32;\n    numbers.iter().map(|x: &f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_mean_absolute_deviation() {\n            assert!(mean_absolute_deviation(&[1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n            assert!(mean_absolute_deviation(&vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n            assert!(mean_absolute_deviation(&vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n        }\n    }", "entry_point": "mean_absolute_deviation", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:06.677845"}
{"task_id": "CodeGen/5", "prompt": "// Insert a number 'delimeter' between every two consecutive elements of input Vec `numbers'\nfn intersperse(numbers: &[u32], delimeter: u32) -> Vec<u32>{", "canonical_solution": "let mut res: Vec<u32> = vec![];\n    numbers.iter().for_each(|item: &u32| {\n        res.push(*item);\n        res.push(delimeter);\n    });\n    res.pop();\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_intersperse() {\n            assert!(intersperse(&[], 7) == vec![]);\n            assert!(intersperse(&vec![5, 6, 3, 2], 8) == vec![5, 8, 6, 8, 3, 8, 2]);\n            assert!(intersperse(&vec![2, 2, 2], 2) == vec![2, 2, 2, 2, 2]);\n        }\n    }", "entry_point": "intersperse", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:07.115787"}
{"task_id": "CodeGen/6", "prompt": "// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while((())) has three.\nfn parse_nested_parens(paren_string: &str) -> Vec<i32>{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/6\n\n// BEGIN_PROMPT\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while((())) has three.\nuse std::cmp::max;\n\nfn parse_nested_parens(paren_string: &str) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut result: Vec<i32> = vec![];\n    let mut depth: i32 = 0;\n    let mut max_depth: i32 = 0;\n\n    for splits in paren_string.split(' ') {\n        for c in splits.chars() {\n            if c == '(' {\n                depth = depth + 1;\n                max_depth = max(depth, max_depth);\n            } else {\n                depth = depth - 1;\n            }\n        }\n\n        if depth == 0 {\n            result.push(max_depth);\n            max_depth = 0;\n        }\n    }\n\n    result\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "parse_nested_parens", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:07.559158"}
{"task_id": "CodeGen/8", "prompt": "// For a given vector of integers, return a tuple consisting of a sum and a product of all the integers in a Vec.\n// Empty sum should be equal to 0 and empty product should be equal to 1.\nfn sum_product(numbers: Vec<i32>) -> (i32,i32){", "canonical_solution": "let sum = |xs: &Vec<i32>| {\n        xs.iter().fold(0, |mut sum, &val| {\n            sum += val;\n            sum\n        })\n    };\n    let product = |xs: &Vec<i32>| {\n        xs.iter().fold(1, |mut prod, &val| {\n            prod *= val;\n            prod\n        })\n    };\n    (sum(&numbers), product(&numbers))\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sum_product() {\n            assert!(sum_product(vec![]) == (0, 1));\n            assert!(sum_product(vec![1, 1, 1]) == (3, 1));\n            assert!(sum_product(vec![100, 0]) == (100, 0));\n            assert!(sum_product(vec![3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7));\n            assert!(sum_product(vec![10]) == (10, 10));\n        }\n    }", "entry_point": "sum_product", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:08.464465"}
{"task_id": "CodeGen/9", "prompt": "// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\nfn rolling_max(numbers: Vec<i32>) -> Vec<i32>{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/9\n\n// BEGIN_PROMPT\n// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n// in the sequence.\nuse std::cmp::max;\n\nfn rolling_max(numbers: Vec<i32>) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut running_max: Option<i32> = None;\n    let mut result: Vec<i32> = vec![];\n\n    for n in numbers {\n        if running_max == None {\n            running_max = Some(n);\n        } else {\n            running_max = max(running_max, Some(n));\n        }\n\n        result.push(running_max.expect(\"invariant: always Some\"));\n    }\n    result\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "rolling_max", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:08.901853"}
{"task_id": "CodeGen/10", "prompt": "// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfn is_palindrome_10(str: &str) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/10\n\n// BEGIN_PROMPT\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfn is_palindrome_10(str: &str) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let s: String = str.chars().rev().collect();\n    s == str\n}\n\nfn make_palindrome(str: &str) -> String {\n    let mut i: usize = 0;\n    for i in 0..str.len() {\n        let rstr: &str = &str[i..];\n        if is_palindrome_10(rstr) {\n            let nstr: &str = &str[0..i];\n            let n2str: String = nstr.chars().rev().collect();\n            return str.to_string() + &n2str;\n        }\n    }\n    let n2str: String = str.chars().rev().collect();\n    str.to_string() + &n2str\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_palindrome_10", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:09.392710"}
{"task_id": "CodeGen/12", "prompt": "// Given a slice of strings, return the longest one.\n// Returns the first string if multiple have the same maximum length.\n// Returns None if the input slice is empty.\nfn longest(strings: &[String]) -> Option<String> {", "canonical_solution": "strings.iter().max_by_key(|s| s.len()).cloned()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_longest() {\n            assert_eq!(longest(&[]), None);\n            assert_eq!(\n                longest(&[\"x\".to_string(), \"y\".to_string(), \"z\".to_string()]),\n                Some(\"x\".to_string())\n            );\n            assert_eq!(\n                longest(&[\n                    \"x\".to_string(),\n                    \"yyy\".to_string(),\n                    \"zzzz\".to_string(),\n                    \"www\".to_string(),\n                    \"kkkk\".to_string(),\n                    \"abc\".to_string()\n                ]),\n                Some(\"zzzz\".to_string())\n            );\n        }\n    }", "entry_point": "longest", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:10.231773"}
{"task_id": "CodeGen/13", "prompt": "// Return the greatest common divisor of two positive integers using Euclid's algorithm.\nfn greatest_common_divisor(mut a: i32, mut b: i32) -> i32 {", "canonical_solution": "while b > 0 {\n        (a, b) = (b, a % b);\n    }\n    a\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_greatest_common_divisor() {\n            assert_eq!(greatest_common_divisor(3, 7), 1);\n            assert_eq!(greatest_common_divisor(10, 15), 5);\n            assert_eq!(greatest_common_divisor(49, 14), 7);\n            assert_eq!(greatest_common_divisor(144, 60), 12);\n            assert_eq!(greatest_common_divisor(1, 1), 1);\n            assert_eq!(greatest_common_divisor(100, 50), 50);\n        }\n    }", "entry_point": "greatest_common_divisor", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:10.681765"}
{"task_id": "CodeGen/14", "prompt": "// Return vector of all prefixes from shortest to longest of the input string\nfn all_prefixes(string: &str) -> Vec<String>{", "canonical_solution": "let mut res: Vec<String> = vec![];\n    let mut res_str: String = String::new();\n\n    for c in string.chars() {\n        res_str.push(c);\n        res.push(res_str.clone());\n    }\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_all_prefixes() {\n            let v_empty: Vec<String> = vec![];\n            assert!(all_prefixes(\"\") == v_empty);\n            assert!(all_prefixes(\"asdfgh\") == vec![\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"]);\n            assert!(all_prefixes(\"WWW\") == vec![\"W\", \"WW\", \"WWW\"]);\n        }\n    }", "entry_point": "all_prefixes", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:11.133281"}
{"task_id": "CodeGen/15", "prompt": "// Return a string containing space-delimited numbers starting from 0 upto n inclusive.\nfn string_sequence(n: i32) -> String{", "canonical_solution": "let mut res: String = String::new();\n\n    for number in 0..n + 1 {\n        res = res + &number.to_string() + \" \";\n    }\n\n    res.trim_end().to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_string_sequence() {\n            assert!(string_sequence(0) == \"0\".to_string());\n            assert!(string_sequence(3) == \"0 1 2 3\".to_string());\n            assert!(string_sequence(10) == \"0 1 2 3 4 5 6 7 8 9 10\".to_string());\n        }\n    }", "entry_point": "string_sequence", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:11.573170"}
{"task_id": "CodeGen/16", "prompt": "// Count the number of distinct characters in a string, treating uppercase and lowercase\n// as the same character.\nfn count_distinct_characters(s: &str) -> usize {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/16\n\n// BEGIN_PROMPT\n// Count the number of distinct characters in a string, treating uppercase and lowercase\n// as the same character.\nfn count_distinct_characters(s: &str) -> usize {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    s.chars()\n        .map(|c| c.to_ascii_lowercase())\n        .collect::<std::collections::HashSet<_>>()\n        .len()\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "count_distinct_characters", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:12.011247"}
{"task_id": "CodeGen/17", "prompt": "// Input to this function is a string representing musical notes in a special ASCII format.\n// Your task is to parse this string and return vector of integers corresponding to how many beats does each\n// not last.\n//\n// Here is a legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n// '.|' - quater note, lasts one beat\nfn parse_music(music_string: &str) -> Vec<i32>{", "canonical_solution": "let map = |x: &str| match x {\n        \"o\" => 4,\n        \"o|\" => 2,\n        \".|\" => 1,\n        _ => 0,\n    };\n    music_string\n        .split(\" \")\n        .map(|x: &str| map(&x.to_string()))\n        .filter(|x: &i32| x != &0)\n        .collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_parse_music() {\n            assert!(parse_music(\" \") == []);\n            assert!(parse_music(\"o o o o\") == vec![4, 4, 4, 4]);\n            assert!(parse_music(\".| .| .| .|\") == vec![1, 1, 1, 1]);\n            assert!(parse_music(\"o| o| .| .| o o o o\") == vec![2, 2, 1, 1, 4, 4, 4, 4]);\n            assert!(parse_music(\"o| .| o| .| o o| o o|\") == vec![2, 1, 2, 1, 4, 2, 4, 2]);\n        }\n    }", "entry_point": "parse_music", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:12.472473"}
{"task_id": "CodeGen/19", "prompt": "// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\nfn sort_numbers(numbers: &str) -> String {", "canonical_solution": "let str_to_i32 = |x: &str| match x {\n        \"zero\" => 0,\n        \"one\" => 1,\n        \"two\" => 2,\n        \"three\" => 3,\n        \"four\" => 4,\n        \"five\" => 5,\n        \"six\" => 6,\n        \"seven\" => 7,\n        \"eight\" => 8,\n        \"nine\" => 9,\n        _ => 1000,\n    };\n\n    let i32_to_str = |x: &i32| match x {\n        0 => \"zero\".to_string(),\n        1 => \"one\".to_string(),\n        2 => \"two\".to_string(),\n        3 => \"three\".to_string(),\n        4 => \"four\".to_string(),\n        5 => \"five\".to_string(),\n        6 => \"six\".to_string(),\n        7 => \"seven\".to_string(),\n        8 => \"eight\".to_string(),\n        9 => \"nine\".to_string(),\n        _ => \"none\".to_string(),\n    };\n\n    let mut nmbrs: Vec<i32> = numbers\n        .split_ascii_whitespace()\n        .map(|x: &str| str_to_i32(x))\n        .collect();\n    nmbrs.sort();\n    let res: String = nmbrs.iter().map(|x: &i32| i32_to_str(x) + \" \").collect();\n    res.trim_end().to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sort_numbers() {\n            assert!(sort_numbers(\"\") == \"\".to_string());\n            assert!(sort_numbers(\"three\") == \"three\".to_string());\n            assert!(sort_numbers(\"three five nine\") == \"three five nine\");\n            assert!(\n                sort_numbers(\"five zero four seven nine eight\")\n                    == \"zero four five seven eight nine\".to_string()\n            );\n            assert!(\n                sort_numbers(\"six five four three two one zero\")\n                    == \"zero one two three four five six\".to_string()\n            );\n        }\n    }", "entry_point": "sort_numbers", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:13.367505"}
{"task_id": "CodeGen/20", "prompt": "// From a supplied vector of numbers(of length at least two) select and return two that are the closest to each\n// other and return them in order(smaller number, larger number).\nfn find_closest_elements(numbers: &[f32]) -> (f32,f32){", "canonical_solution": "let mut closest_pair = (0.0, 0.0);\n    let mut distance: Option<f32> = None;\n\n    for (idx, elem) in numbers.iter().enumerate() {\n        for (idx2, elem2) in numbers.iter().enumerate() {\n            if idx != idx2 {\n                if distance == None {\n                    distance = Some((elem - elem2).abs());\n                    if *elem < *elem2 {\n                        closest_pair = (*elem, *elem2);\n                    } else {\n                        closest_pair = (*elem2, *elem);\n                    }\n                } else {\n                    let new_distance: f32 = (elem - elem2).abs();\n                    if new_distance < distance.expect(\"unexpected None/Err\") {\n                        distance = Some(new_distance);\n\n                        if *elem < *elem2 {\n                            closest_pair = (*elem, *elem2);\n                        } else {\n                            closest_pair = (*elem2, *elem);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    closest_pair\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_find_closest_elements() {\n            assert!(find_closest_elements(&[1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0));\n            assert!(find_closest_elements(&vec![1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9));\n            assert!(find_closest_elements(&vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2));\n            assert!(find_closest_elements(&vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0));\n            assert!(find_closest_elements(&vec![1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1));\n        }\n    }", "entry_point": "find_closest_elements", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:13.816009"}
{"task_id": "CodeGen/21", "prompt": "// Given vector of numbers(of at least two elements), apply a linear transform to that Vec,\n// such that the smallest number will become 0 and the largest will become 1\nfn rescale_to_unit(numbers: &[f32]) -> Vec<f32> {", "canonical_solution": "let min_number = *numbers\n        .iter()\n        .min_by(|a, b| a.partial_cmp(b).expect(\"unexpected None/Err\"))\n        .expect(\"unexpected None/Err\");\n    let max_number = *numbers\n        .iter()\n        .max_by(|a, b| a.partial_cmp(b).expect(\"unexpected None/Err\"))\n        .expect(\"unexpected None/Err\");\n    numbers\n        .iter()\n        .map(|x: &f32| (x - min_number) / (max_number - min_number))\n        .collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_rescale_to_unit() {\n            assert!(rescale_to_unit(&[2.0, 49.9]) == [0.0, 1.0]);\n            assert!(rescale_to_unit(&vec![100.0, 49.9]) == [1.0, 0.0]);\n            assert!(rescale_to_unit(&vec![1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]);\n            assert!(rescale_to_unit(&vec![2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]);\n            assert!(\n                rescale_to_unit(&vec![12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n            );\n        }\n    }", "entry_point": "rescale_to_unit", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:14.273015"}
{"task_id": "CodeGen/22", "prompt": "// Filter given vector of any Rust values only for integers\nfn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/22\n\n// BEGIN_PROMPT\n// Filter given vector of any Rust values only for integers\nuse std::any::Any;\n\nfn filter_integers(values: Vec<Box<dyn Any>>) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut out: Vec<i32> = Vec::new();\n    for value in values {\n        if let Some(i) = value.downcast_ref::<i32>() {\n            out.push(*i);\n        }\n    }\n    out\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "filter_integers", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:14.713933"}
{"task_id": "CodeGen/23", "prompt": "// Return length of given string\nfn strlen(strings: &str) -> i32{", "canonical_solution": "strings.len() as i32\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_strlen() {\n            assert!(strlen(\"\") == 0);\n            assert!(strlen(\"x\") == 1);\n            assert!(strlen(\"asdasnakj\") == 9);\n        }\n    }", "entry_point": "strlen", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:15.143223"}
{"task_id": "CodeGen/24", "prompt": "// For a given number n, find the largest number that divides n evenly, smaller than n\nfn largest_divisor(n: i32) -> i32{", "canonical_solution": "let mut res: i32 = 0;\n    let sqn = 1..n;\n\n    for i in sqn.rev() {\n        if n % i == 0 {\n            res = i;\n            break;\n        }\n    }\n\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_largest_divisor() {\n            assert!(largest_divisor(3) == 1);\n            assert!(largest_divisor(7) == 1);\n            assert!(largest_divisor(10) == 5);\n            assert!(largest_divisor(100) == 50);\n            assert!(largest_divisor(49) == 7);\n        }\n    }", "entry_point": "largest_divisor", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:15.571553"}
{"task_id": "CodeGen/25", "prompt": "// Return vector of prime factors of given integer in the order from smallest to largest.\n// Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n// Input number should be equal to the product of all factors\nfn factorize(n: i32) -> Vec<i32> {", "canonical_solution": "let mut n = n;\n    let mut factors = vec![];\n    let mut divisor = 2;\n    while divisor * divisor <= n {\n        while n % divisor == 0 {\n            factors.push(divisor);\n            n = n / divisor;\n        }\n        divisor = divisor + 1;\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_factorize() {\n            assert_eq!(factorize(2), vec![2]);\n            assert_eq!(factorize(4), vec![2, 2]);\n            assert_eq!(factorize(8), vec![2, 2, 2]);\n            assert_eq!(factorize(3 * 19), vec![3, 19]);\n            assert_eq!(factorize(3 * 19 * 3 * 19), vec![3, 3, 19, 19]);\n            assert_eq!(\n                factorize(3 * 19 * 3 * 19 * 3 * 19),\n                vec![3, 3, 3, 19, 19, 19]\n            );\n            assert_eq!(factorize(3 * 19 * 19 * 19), vec![3, 19, 19, 19]);\n            assert_eq!(factorize(3 * 2 * 3), vec![2, 3, 3]);\n        }\n    }", "entry_point": "factorize", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:16.025623"}
{"task_id": "CodeGen/26", "prompt": "// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\nfn remove_duplicates(numbers: Vec<i32>) -> Vec<i32>{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/26\n\n// BEGIN_PROMPT\n// From a vector of integers, remove all elements that occur more than once.\n// Keep order of elements left the same as in the input.\nuse std::collections::HashMap;\n\nfn remove_duplicates(numbers: Vec<i32>) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut m: HashMap<i32, i32> = HashMap::new();\n\n    for n in &numbers {\n        *m.entry(*n).or_default() += 1;\n    }\n    let res: Vec<i32> = numbers\n        .into_iter()\n        .filter(|x| m.get(x) == Some(&1))\n        .collect();\n    res\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "remove_duplicates", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:16.467187"}
{"task_id": "CodeGen/27", "prompt": "// For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\npub fn flip_case(string: &str) -> String{", "canonical_solution": "string\n        .chars()\n        .into_iter()\n        .fold(String::new(), |res: String, c: char| {\n            if c.is_ascii_lowercase() {\n                return res + &c.to_uppercase().to_string();\n            } else {\n                return res + &c.to_ascii_lowercase().to_string();\n            }\n        })\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_flip_case() {\n            assert!(flip_case(\"\") == \"\".to_string());\n            assert!(flip_case(\"Hello!\") == \"hELLO!\".to_string());\n            assert!(\n                flip_case(\"These violent delights have violent ends\")\n                    == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\".to_string()\n            );\n        }\n    }", "entry_point": "flip_case", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:16.898774"}
{"task_id": "CodeGen/28", "prompt": "// Concatenate vector of strings into a single string\nfn concatenate(strings: &[String]) -> String{", "canonical_solution": "strings\n        .iter()\n        .fold(String::new(), |res: String, x: &String| {\n            res + &x.to_string()\n        })\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_concatenate() {\n            assert!(concatenate(&[]) == \"\".to_string());\n            assert!(\n                concatenate(&vec![\"x\".to_string(), \"y\".to_string(), \"z\".to_string()])\n                    == \"xyz\".to_string()\n            );\n            assert!(\n                concatenate(&vec![\n                    \"x\".to_string(),\n                    \"y\".to_string(),\n                    \"z\".to_string(),\n                    \"w\".to_string(),\n                    \"k\".to_string()\n                ]) == \"xyzwk\".to_string()\n            );\n        }\n    }", "entry_point": "concatenate", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:17.367664"}
{"task_id": "CodeGen/30", "prompt": "// Return only positive numbers in the Vec.\nfn get_positive(numbers: Vec<i32>) -> Vec<i32>{", "canonical_solution": "numbers.into_iter().filter(|n| n.is_positive()).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_get_positive() {\n            assert!(get_positive(vec![-1, -2, 4, 5, 6]) == [4, 5, 6]);\n            assert!(\n                get_positive(vec![5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])\n                    == [5, 3, 2, 3, 3, 9, 123, 1]\n            );\n            assert!(get_positive(vec![-1, -2]) == []);\n            assert!(get_positive(vec![]) == []);\n        }\n    }", "entry_point": "get_positive", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:18.267860"}
{"task_id": "CodeGen/31", "prompt": "// Check if a number is prime.\n// Returns false for numbers less than 2.\nfn is_prime(n: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/31\n\n// BEGIN_PROMPT\n// Check if a number is prime.\n// Returns false for numbers less than 2.\nfn is_prime(n: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if n < 2 {\n        return false;\n    }\n    !(2..=(n as f32).sqrt() as i32).any(|i| n % i == 0)\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_prime", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:18.714018"}
{"task_id": "CodeGen/34", "prompt": "// Return sorted unique elements in a list\nfn unique(nmbs: Vec<i32>)  -> Vec<i32>{", "canonical_solution": "let mut res: Vec<i32> = nmbs.clone();\n    res.sort();\n    res.dedup();\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_unique() {\n            assert!(unique(vec![5, 3, 5, 2, 3, 3, 9, 0, 123]) == vec![0, 2, 3, 5, 9, 123]);\n        }\n    }", "entry_point": "unique", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:20.050811"}
{"task_id": "CodeGen/35", "prompt": "// Return maximum element in the Vec.\nfn maximum(nmbs: &[i32]) -> i32{", "canonical_solution": "*nmbs.iter().max().expect(\"unexpected None/Err\")\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_maximum() {\n            assert!(maximum(&[1, 2, 3]) == 3);\n            assert!(maximum(&vec![5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124);\n        }\n    }", "entry_point": "maximum", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:20.476009"}
{"task_id": "CodeGen/36", "prompt": "// Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\nfn fizz_buzz(n: i32) -> i32{", "canonical_solution": "let mut ns: Vec<i32> = vec![];\n\n    for i in 0..n {\n        if i % 11 == 0 || i % 13 == 0 {\n            ns.push(i);\n        }\n    }\n\n    let s: String = ns\n        .into_iter()\n        .fold(String::new(), |s: String, n: i32| s + &n.to_string());\n    let mut ans: i32 = 0;\n\n    for c in s.chars() {\n        if c == '7' {\n            ans += 1;\n        }\n    }\n    ans\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_fizz_buzz() {\n            assert!(fizz_buzz(50) == 0);\n            assert!(fizz_buzz(78) == 2);\n            assert!(fizz_buzz(79) == 3);\n            assert!(fizz_buzz(100) == 3);\n            assert!(fizz_buzz(200) == 6);\n            assert!(fizz_buzz(4000) == 192);\n            assert!(fizz_buzz(10000) == 639);\n            assert!(fizz_buzz(100000) == 8026);\n        }\n    }", "entry_point": "fizz_buzz", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:20.915446"}
{"task_id": "CodeGen/37", "prompt": "// This function takes a Vec l and returns a Vec l' such that\n// l' is identical to l in the odd indicies, while its values at the even indicies are equal\n// to the values of the even indicies of l, but sorted.\nfn sort_even(nmbs: &[i32]) -> Vec<i32>{", "canonical_solution": "let mut even = vec![];\n    let mut out: Vec<i32> = vec![];\n\n    for (indx, elem) in nmbs.iter().enumerate() {\n        if indx % 2 == 0 {\n            even.push(elem)\n        }\n    }\n    even.sort();\n    let mut indx_t: usize = 0;\n\n    for i in 0..nmbs.len() {\n        if i % 2 == 0 {\n            if indx_t < even.len() {\n                out.push(*even[indx_t]);\n                indx_t += 1;\n            }\n        } else {\n            out.push(nmbs[i]);\n        }\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sort_even() {\n            assert_eq!(sort_even(&[1, 2, 3]), vec![1, 2, 3]);\n            assert_eq!(\n                sort_even(&vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\n                vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\n            );\n            assert_eq!(\n                sort_even(&vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\n                vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]\n            );\n        }\n    }", "entry_point": "sort_even", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:21.357904"}
{"task_id": "CodeGen/39", "prompt": "// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfn prime_fib(n: i32) -> i32 {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/39\n\n// BEGIN_PROMPT\n// prime_fib returns n-th number that is a Fibonacci number and it's also prime.\nfn prime_fib(n: i32) -> i32 {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut f1 = 1;\n    let mut f2 = 2;\n    let mut count = 0;\n    while count < n {\n        f1 = f1 + f2;\n        let m = f1;\n        f1 = f2;\n        f2 = m;\n        let mut isprime = true;\n        for w in 2..(f1 as f32).sqrt() as i32 + 1 {\n            if f1 % w == 0 {\n                isprime = false;\n                break;\n            }\n        }\n        if isprime {\n            count += 1;\n        }\n        if count == n {\n            return f1;\n        }\n    }\n    0\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "prime_fib", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:22.252966"}
{"task_id": "CodeGen/40", "prompt": "// triples_sum_to_zero takes a vector of integers as an input.\n// it returns True if there are three distinct elements in the Vec that\n// sum to zero, and False otherwise.\nfn triples_sum_to_zero(nmbs: &[i32]) -> bool{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/40\n\n// BEGIN_PROMPT\n// triples_sum_to_zero takes a vector of integers as an input.\n// it returns True if there are three distinct elements in the Vec that\n// sum to zero, and False otherwise.\nfn triples_sum_to_zero(nmbs: &[i32]) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    for i in 0..nmbs.len() {\n        for j in i + 1..nmbs.len() {\n            for k in j + 1..nmbs.len() {\n                if *nmbs.get(i).expect(\"index in bounds\")\n                    + *nmbs.get(j).expect(\"index in bounds\")\n                    + *nmbs.get(k).expect(\"index in bounds\")\n                    == 0\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "triples_sum_to_zero", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:22.694764"}
{"task_id": "CodeGen/41", "prompt": "// Imagine a road that's a perfectly straight infinitely long line.\n// n cars are driving left to right;  simultaneously, a different set of n cars\n// are driving right to left.   The two sets of cars start out being very far from\n// each other.  All cars move in the same speed.  Two cars are said to collide\n// when a car that's moving left to right hits a car that's moving right to left.\n// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n// in their trajectory as if they did not collide.\n//\n// This function outputs the number of such collisions.\nfn car_race_collision(n: i32)-> i32{", "canonical_solution": "n * n\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_car_race_collision() {\n            assert!(car_race_collision(2) == 4);\n            assert!(car_race_collision(3) == 9);\n            assert!(car_race_collision(4) == 16);\n            assert!(car_race_collision(8) == 64);\n            assert!(car_race_collision(10) == 100);\n        }\n    }", "entry_point": "car_race_collision", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:23.127257"}
{"task_id": "CodeGen/42", "prompt": "// Return a new Vec with each element incremented by 1.\nfn incr_list(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "numbers.iter().map(|&n| n + 1).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_incr_list() {\n            assert_eq!(incr_list(&[]), vec![]);\n            assert_eq!(incr_list(&[3, 2, 1]), vec![4, 3, 2]);\n            assert_eq!(\n                incr_list(&[5, 2, 5, 2, 3, 3, 9, 0, 123]),\n                vec![6, 3, 6, 3, 4, 4, 10, 1, 124]\n            );\n        }\n    }", "entry_point": "incr_list", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:23.598412"}
{"task_id": "CodeGen/43", "prompt": "// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns True if there are two distinct elements in the Vec that\n// sum to zero, and False otherwise.\nfn pairs_sum_to_zero(l: &[i32]) -> bool{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/43\n\n// BEGIN_PROMPT\n// pairs_sum_to_zero takes a vector of integers as an input.\n// it returns True if there are two distinct elements in the Vec that\n// sum to zero, and False otherwise.\nfn pairs_sum_to_zero(l: &[i32]) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    for (i, l1) in l.iter().enumerate() {\n        for j in i + 1..l.len() {\n            if l1 + l[j] == 0 {\n                return true;\n            }\n        }\n    }\n\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "pairs_sum_to_zero", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:24.076882"}
{"task_id": "CodeGen/44", "prompt": "// Change numerical base of input number x to base.\n// return string representation after the conversion.\n// base numbers are less than 10.\nfn change_base(x: i32, base: i32) -> String{", "canonical_solution": "let mut ret: String = \"\".to_string();\n    let mut x1 = x;\n\n    while x1 > 0 {\n        ret = (x1 % base).to_string() + &ret;\n        x1 = x1 / base;\n    }\n    ret\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_change_base() {\n            assert!(change_base(8, 3) == \"22\".to_string());\n            assert!(change_base(9, 3) == \"100\".to_string());\n            assert!(change_base(234, 2) == \"11101010\".to_string());\n            assert!(change_base(16, 2) == \"10000\".to_string());\n            assert!(change_base(8, 2) == \"1000\".to_string());\n            assert!(change_base(7, 2) == \"111\".to_string());\n        }\n    }", "entry_point": "change_base", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:24.540926"}
{"task_id": "CodeGen/45", "prompt": "// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\nfn triangle_area(a: i32, h: i32) -> f64{", "canonical_solution": "(a * h) as f64 / 2.0\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_triangle_area() {\n            assert!(triangle_area(5, 3) == 7.5);\n            assert!(triangle_area(2, 2) == 2.0);\n            assert!(triangle_area(10, 8) == 40.0);\n        }\n    }", "entry_point": "triangle_area", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:25.000440"}
{"task_id": "CodeGen/46", "prompt": "// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\nfn fib4(n: i32) -> i32{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/46\n\n// BEGIN_PROMPT\n// The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n// fib4(0) -> 0\n// fib4(1) -> 0\n// fib4(2) -> 2\n// fib4(3) -> 0\n// fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n// Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\nfn fib4(n: i32) -> i32 {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut results: Vec<i32> = vec![0, 0, 2, 0];\n\n    if n < 4 {\n        return *results.get(n as usize).expect(\"index in bounds\");\n    }\n\n    for _ in 4..n + 1 {\n        results.push(\n            results.get(results.len() - 1).expect(\"index in bounds\")\n                + results.get(results.len() - 2).expect(\"index in bounds\")\n                + results.get(results.len() - 3).expect(\"index in bounds\")\n                + results.get(results.len() - 4).expect(\"index in bounds\"),\n        );\n        results.remove(0);\n    }\n\n    *results.get(results.len() - 1).expect(\"index in bounds\")\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "fib4", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:25.453105"}
{"task_id": "CodeGen/47", "prompt": "// Return median of elements in the Vec l.\nfn median(l: Vec<i32>) -> f64{", "canonical_solution": "let mut res: Vec<i32> = l.clone();\n    res.sort();\n    if res.len() % 2 == 1 {\n        return *res.get(res.len() / 2).expect(\"index in bounds\") as f64;\n    } else {\n        (res.get(res.len() / 2 - 1).expect(\"index in bounds\")\n            + res.get(res.len() / 2).expect(\"index in bounds\")) as f64\n            / 2.0\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_median() {\n            assert!(median(vec![3, 1, 2, 4, 5]) == 3.0);\n            assert!(median(vec![-10, 4, 6, 1000, 10, 20]) == 8.0);\n            assert!(median(vec![5]) == 5.0);\n            assert!(median(vec![6, 5]) == 5.5);\n            assert!(median(vec![8, 1, 3, 9, 9, 2, 7]) == 7.0);\n        }\n    }", "entry_point": "median", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:25.929509"}
{"task_id": "CodeGen/48", "prompt": "// Check if a string is a palindrome(reads the same forwards and backwards).\nfn is_palindrome(text: &str) -> bool {", "canonical_solution": "text.chars().eq(text.chars().rev())\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_is_palindrome() {\n            assert_eq!(is_palindrome(\"\"), true);\n            assert_eq!(is_palindrome(\"aba\"), true);\n            assert_eq!(is_palindrome(\"aaaaa\"), true);\n            assert_eq!(is_palindrome(\"zbcd\"), false);\n            assert_eq!(is_palindrome(\"xywyx\"), true);\n            assert_eq!(is_palindrome(\"xywyz\"), false);\n            assert_eq!(is_palindrome(\"xywzx\"), false);\n        }\n    }", "entry_point": "is_palindrome", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:26.374569"}
{"task_id": "CodeGen/49", "prompt": "// Return 2^n modulo p(be aware of numerics).\nfn modp(n: i32, p: i32) -> i32 {", "canonical_solution": "if n == 0 {\n        return 1;\n    } else {\n        (modp(n - 1, p) * 2) % p\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_modp() {\n            assert!(modp(3, 5) == 3);\n            assert!(modp(1101, 101) == 2);\n            assert!(modp(0, 101) == 1);\n            assert!(modp(3, 11) == 8);\n            assert!(modp(100, 101) == 1);\n            assert!(modp(30, 5) == 4);\n            assert!(modp(31, 5) == 3);\n        }\n    }", "entry_point": "modp", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:26.818777"}
{"task_id": "CodeGen/51", "prompt": "// remove_vowels is a function that takes string and returns string without vowels.\nfn remove_vowels(text: &str) -> String {", "canonical_solution": "let vowels = \"AEIOUaeiou\";\n    let mut out = String::new();\n    for c in text.chars() {\n        if !vowels.contains(c) {\n            out.push(c);\n        }\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_remove_vowels() {\n            assert!(remove_vowels(\"\") == \"\");\n            assert!(remove_vowels(\"abcdef\\nghijklm\") == \"bcdf\\nghjklm\");\n            assert!(remove_vowels(\"fedcba\") == \"fdcb\");\n            assert!(remove_vowels(\"eeeee\") == \"\");\n            assert!(remove_vowels(\"acBAA\") == \"cB\");\n            assert!(remove_vowels(\"EcBOO\") == \"cB\");\n            assert!(remove_vowels(\"ybcd\") == \"ybcd\");\n        }\n    }", "entry_point": "remove_vowels", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:27.743384"}
{"task_id": "CodeGen/52", "prompt": "// Return True if all numbers in the Vec l are below threshold t.\nfn below_threshold(l: Vec<i32>, t: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/52\n\n// BEGIN_PROMPT\n// Return True if all numbers in the Vec l are below threshold t.\nfn below_threshold(l: Vec<i32>, t: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    for i in l {\n        if i >= t {\n            return false;\n        }\n    }\n    true\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "below_threshold", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:28.193212"}
{"task_id": "CodeGen/54", "prompt": "// Check if two strings contain the same set of unique characters.\n// Case sensitive comparison.\nfn same_chars(s1: &str, s2: &str) -> bool {", "canonical_solution": "let set1: std::collections::HashSet<char> = s1.chars().collect();\n    let set2: std::collections::HashSet<char> = s2.chars().collect();\n    set1 == set2\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_same_chars() {\n            assert_eq!(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"), true);\n            assert_eq!(same_chars(\"abcd\", \"dddddddabc\"), true);\n            assert_eq!(same_chars(\"dddddddabc\", \"abcd\"), true);\n            assert_eq!(same_chars(\"eabcd\", \"dddddddabc\"), false);\n            assert_eq!(same_chars(\"abcd\", \"dddddddabcf\"), false);\n            assert_eq!(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"), false);\n            assert_eq!(same_chars(\"aabb\", \"aaccc\"), false);\n        }\n    }", "entry_point": "same_chars", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:29.083469"}
{"task_id": "CodeGen/56", "prompt": "// brackets is a string of \"<\" and \">\".\n// return True if every opening bracket has a corresponding closing bracket.\nfn correct_bracketing(bkts:&str) -> bool{", "canonical_solution": "let mut level: i32 = 0;\n\n    for i in 0..bkts.len() {\n        if bkts.chars().nth(i).expect(\"unexpected None/Err\") == '<' {\n            level += 1;\n        }\n\n        if bkts.chars().nth(i).expect(\"unexpected None/Err\") == '>' {\n            level -= 1;\n        }\n\n        if level < 0 {\n            return false;\n        }\n    }\n    if level != 0 {\n        return false;\n    }\n    true\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_correct_bracketing() {\n            assert!(correct_bracketing(\"<>\"));\n            assert!(correct_bracketing(\"<<><>>\"));\n            assert!(correct_bracketing(\"<><><<><>><>\"));\n            assert!(correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"));\n            assert!(!(correct_bracketing(\"<<<><>>>>\")));\n            assert!(!(correct_bracketing(\"><<>\")));\n            assert!(!(correct_bracketing(\"<\")));\n            assert!(!(correct_bracketing(\"<<<<\")));\n            assert!(!(correct_bracketing(\">\")));\n            assert!(!(correct_bracketing(\"<<>\")));\n            assert!(!(correct_bracketing(\"<><><<><>><>><<>\")));\n            assert!(!(correct_bracketing(\"<><><<><>><>>><>\")));\n        }\n    }", "entry_point": "correct_bracketing", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:29.960878"}
{"task_id": "CodeGen/57", "prompt": "// Return True is Vec elements are monotonically increasing or decreasing.\nfn monotonic( l: Vec<i32>) -> bool{", "canonical_solution": "let mut l1: Vec<i32> = l.clone();\n    let mut l2: Vec<i32> = l.clone();\n    l2.sort();\n    l2.reverse();\n    l1.sort();\n\n    if l == l1 || l == l2 {\n        return true;\n    }\n    false\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_monotonic() {\n            assert!(monotonic(vec![1, 2, 4, 10]) == true);\n            assert!(monotonic(vec![1, 2, 4, 20]) == true);\n            assert!(monotonic(vec![1, 20, 4, 10]) == false);\n            assert!(monotonic(vec![4, 1, 0, -10]) == true);\n            assert!(monotonic(vec![4, 1, 1, 0]) == true);\n            assert!(monotonic(vec![1, 2, 3, 2, 5, 60]) == false);\n            assert!(monotonic(vec![1, 2, 3, 4, 5, 60]) == true);\n            assert!(monotonic(vec![9, 9, 9, 9]) == true);\n        }\n    }", "entry_point": "monotonic", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:30.393451"}
{"task_id": "CodeGen/58", "prompt": "// Return sorted unique common elements between two lists.\nfn common(lst1: &[i32], lst2: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut result: Vec<i32> = lst1\n        .iter()\n        .filter(|&n| lst2.contains(n))\n        .copied()\n        .collect::<std::collections::HashSet<_>>()\n        .into_iter()\n        .collect();\n    result.sort_unstable();\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_common() {\n            assert_eq!(\n                common(&[1, 4, 3, 34, 653, 2, 5], &[5, 7, 1, 5, 9, 653, 121]),\n                vec![1, 5, 653]\n            );\n            assert_eq!(common(&[5, 3, 2, 8], &[3, 2]), vec![2, 3]);\n            assert_eq!(common(&[4, 3, 2, 8], &[3, 2, 4]), vec![2, 3, 4]);\n            assert_eq!(common(&[4, 3, 2, 8], &[]), vec![]);\n        }\n    }", "entry_point": "common", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:30.857014"}
{"task_id": "CodeGen/59", "prompt": "// Return the largest prime factor of n. Assume n > 1 and is not a prime.\nfn largest_prime_factor(n: i32) -> i32{", "canonical_solution": "let mut n1 = n.clone();\n    for i in 2..n1 {\n        while n1 % i == 0 && n1 > i {\n            n1 = n1 / i;\n        }\n    }\n    n1\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_largest_prime_factor() {\n            assert!(largest_prime_factor(15) == 5);\n            assert!(largest_prime_factor(27) == 3);\n            assert!(largest_prime_factor(63) == 7);\n            assert!(largest_prime_factor(330) == 11);\n            assert!(largest_prime_factor(13195) == 29);\n        }\n    }", "entry_point": "largest_prime_factor", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:31.299030"}
{"task_id": "CodeGen/60", "prompt": "// sum_to_n is a function that sums numbers from 1 to n.\nfn sum_to_n(n: i32) -> i32 {", "canonical_solution": "n * (n + 1) / 2\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sum_to_n() {\n            assert!(sum_to_n(1) == 1);\n            assert!(sum_to_n(6) == 21);\n            assert!(sum_to_n(11) == 66);\n            assert!(sum_to_n(30) == 465);\n            assert!(sum_to_n(100) == 5050);\n        }\n    }", "entry_point": "sum_to_n", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:31.744436"}
{"task_id": "CodeGen/61", "prompt": "// brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\nfn correct_bracketing_parenthesis(bkts:&str) -> bool{", "canonical_solution": "let mut level: i32 = 0;\n\n    for i in 0..bkts.len() {\n        if bkts.chars().nth(i).expect(\"unexpected None/Err\") == '(' {\n            level += 1;\n        }\n\n        if bkts.chars().nth(i).expect(\"unexpected None/Err\") == ')' {\n            level -= 1;\n        }\n\n        if level < 0 {\n            return false;\n        }\n    }\n    if level != 0 {\n        return false;\n    }\n    true\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_correct_bracketing_parenthesis() {\n            assert!(correct_bracketing_parenthesis(\"()\"));\n            assert!(correct_bracketing_parenthesis(\"(()())\"));\n            assert!(correct_bracketing_parenthesis(\"()()(()())()\"));\n            assert!(correct_bracketing_parenthesis(\"()()((()()())())(()()(()))\"));\n            assert!(!(correct_bracketing_parenthesis(\"((()())))\")));\n            assert!(!(correct_bracketing_parenthesis(\")(()\")));\n            assert!(!(correct_bracketing_parenthesis(\"(\")));\n            assert!(!(correct_bracketing_parenthesis(\"((((\")));\n            assert!(!(correct_bracketing_parenthesis(\")\")));\n            assert!(!(correct_bracketing_parenthesis(\"(()\")));\n            assert!(!(correct_bracketing_parenthesis(\"()()(()())())(()\")));\n            assert!(!(correct_bracketing_parenthesis(\"()()(()())()))()\")));\n        }\n    }", "entry_point": "correct_bracketing_parenthesis", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:32.167479"}
{"task_id": "CodeGen/62", "prompt": "// xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2] * x^2 + ....\n// Return derivative of this polynomial in the same form.\nfn derivative(xs: &[i32]) -> Vec<i32>{", "canonical_solution": "let mut res: Vec<i32> = vec![];\n    for i in 1..xs.len() {\n        res.push(i as i32 * xs.get(i).expect(\"index in bounds\"));\n    }\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_derivative() {\n            assert!(derivative(&[3, 1, 2, 4, 5]) == vec![1, 4, 12, 20]);\n            assert!(derivative(&vec![1, 2, 3]) == vec![2, 6]);\n            assert!(derivative(&vec![3, 2, 1]) == vec![2, 2]);\n            assert!(derivative(&vec![3, 2, 1, 0, 4]) == vec![2, 2, 0, 16]);\n            assert!(derivative(&vec![1]) == vec![]);\n        }\n    }", "entry_point": "derivative", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:32.632391"}
{"task_id": "CodeGen/64", "prompt": "// Write a function vowels_count which takes a string representing\n// a word as input and returns the number of vowels in the string.\n// Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is at the end of the given word.\nfn vowels_count(s:&str) -> i32 {", "canonical_solution": "let vowels: &str = \"aeiouAEIOU\";\n    let mut count: i32 = 0;\n\n    for i in 0..s.len() {\n        let c: char = s.chars().nth(i).expect(\"unexpected None/Err\");\n        if vowels.contains(c) {\n            count += 1;\n        }\n    }\n    if s.chars().nth(s.len() - 1).expect(\"unexpected None/Err\") == 'y'\n        || s.chars().nth(s.len() - 1).expect(\"unexpected None/Err\") == 'Y'\n    {\n        count += 1;\n    }\n\n    count\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_vowels_count() {\n            assert!(vowels_count(\"abcde\") == 2);\n            assert!(vowels_count(\"Alone\") == 3);\n            assert!(vowels_count(\"key\") == 2);\n            assert!(vowels_count(\"bye\") == 1);\n            assert!(vowels_count(\"keY\") == 2);\n            assert!(vowels_count(\"bYe\") == 1);\n            assert!(vowels_count(\"ACEDY\") == 3);\n        }\n    }", "entry_point": "vowels_count", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:33.538081"}
{"task_id": "CodeGen/66", "prompt": "// Task\n// Write a function that takes a string as input and returns the sum of the upper characters only'\n// ASCII codes.\nfn digitSum(s:&str) -> i32{", "canonical_solution": "s.chars()\n        .into_iter()\n        .filter(|c: &char| c.is_uppercase())\n        .map(|c: char| c as i32)\n        .sum()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_digitSum() {\n            assert!(digitSum(\"\") == 0);\n            assert!(digitSum(\"abAB\") == 131);\n            assert!(digitSum(\"abcCd\") == 67);\n            assert!(digitSum(\"helloE\") == 69);\n            assert!(digitSum(\"woArBld\") == 131);\n            assert!(digitSum(\"aAaaaXa\") == 153);\n            assert!(digitSum(\" How are yOu?\") == 151);\n            assert!(digitSum(\"You arE Very Smart\") == 327);\n        }\n    }", "entry_point": "digitSum", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:34.427192"}
{"task_id": "CodeGen/68", "prompt": "// \"Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n//\n// The plucked node should be returned in a Vec, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n//\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfn pluck(arr: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut out: Vec<i32> = vec![];\n\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 && (out.len() == 0 || arr[i] < out[0]) {\n            out = vec![arr[i], i as i32];\n        }\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_pluck() {\n            assert!(pluck(&[4, 2, 3]) == vec![2, 1]);\n            assert!(pluck(&vec![1, 2, 3]) == vec![2, 1]);\n            assert!(pluck(&vec![]) == vec![]);\n            assert!(pluck(&vec![5, 0, 3, 0, 4, 2]) == vec![0, 1]);\n            assert!(pluck(&vec![1, 2, 3, 0, 5, 3]) == vec![0, 3]);\n            assert!(pluck(&vec![5, 4, 8, 4, 8]) == vec![4, 1]);\n            assert!(pluck(&vec![7, 6, 7, 1]) == vec![6, 1]);\n            assert!(pluck(&vec![7, 9, 7, 1]) == vec![]);\n        }\n    }", "entry_point": "pluck", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:35.334386"}
{"task_id": "CodeGen/69", "prompt": "// You are given a non-empty vector of positive integers. Return the greatest integer that is greater than\n// zero, and has a frequency greater than or equal to the value of the integer itself.\n// The frequency of an integer is the number of times it appears in the Vec.\n// If no such a value exist, return -1.\nfn search(lst: &[i32]) -> i32 {", "canonical_solution": "let mut freq: Vec<Vec<i32>> = Vec::new();\n    let mut max = -1;\n    for i in 0..lst.len() {\n        let mut has = false;\n        for j in 0..freq.len() {\n            if lst[i] == freq[j][0] {\n                freq[j][1] += 1;\n                has = true;\n                if freq[j][1] >= freq[j][0] && freq[j][0] > max {\n                    max = freq[j][0];\n                }\n            }\n        }\n        if !has {\n            freq.push(vec![lst[i], 1]);\n            if max == -1 && lst[i] == 1 {\n                max = 1;\n            }\n        }\n    }\n    max\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_search() {\n            assert!(search(&[5, 5, 5, 5, 1]) == 1);\n            assert!(search(&vec![4, 1, 4, 1, 4, 4]) == 4);\n            assert!(search(&vec![3, 3]) == -1);\n            assert!(search(&vec![8, 8, 8, 8, 8, 8, 8, 8]) == 8);\n            assert!(search(&vec![2, 3, 3, 2, 2]) == 2);\n            assert!(\n                search(&vec![\n                    2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1\n                ]) == 1\n            );\n            assert!(search(&vec![3, 2, 8, 2]) == 2);\n            assert!(search(&vec![6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1);\n            assert!(search(&vec![8, 8, 3, 6, 5, 6, 4]) == -1);\n            assert!(\n                search(&vec![\n                    6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9\n                ]) == 1\n            );\n            assert!(search(&vec![1, 9, 10, 1, 3]) == 1);\n            assert!(\n                search(&vec![\n                    6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10\n                ]) == 5\n            );\n            assert!(search(&vec![1]) == 1);\n            assert!(\n                search(&vec![\n                    8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5\n                ]) == 4\n            );\n            assert!(\n                search(&vec![\n                    2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10\n                ]) == 2\n            );\n            assert!(search(&vec![1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1);\n            assert!(\n                search(&vec![\n                    9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10,\n                    2, 8, 10, 9, 4\n                ]) == 4\n            );\n            assert!(\n                search(&vec![\n                    2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7\n                ]) == 4\n            );\n            assert!(\n                search(&vec![\n                    9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1\n                ]) == 2\n            );\n            assert!(\n                search(&vec![\n                    5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8\n                ]) == -1\n            );\n            assert!(search(&vec![10]) == -1);\n            assert!(search(&vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2);\n            assert!(search(&vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1);\n            assert!(\n                search(&vec![\n                    7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6\n                ]) == 1\n            );\n            assert!(search(&vec![3, 10, 10, 9, 2]) == -1);\n        }\n    }", "entry_point": "search", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:35.785628"}
{"task_id": "CodeGen/71", "prompt": "// Given the lengths of the three sides of a triangle. Return the area of\n// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n// Otherwise return -1\n// Three sides make a valid triangle when the sum of any two sides is greater\n// than the third side.\nfn triangle_area_f64(a:f64, b:f64, c:f64) -> f64{", "canonical_solution": "if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n    let h: f64 = (a + b + c) / 2.0;\n    let mut area: f64;\n    area = f64::powf(h * (h - a) * (h - b) * (h - c), 0.5);\n    area\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_triangle_area_f64() {\n            assert!(f64::abs(triangle_area_f64(3.0, 4.0, 5.0) - 6.00) < 0.01);\n            assert!(f64::abs(triangle_area_f64(1.0, 2.0, 10.0) + 1.0) < 0.01);\n            assert!(f64::abs(triangle_area_f64(4.0, 8.0, 5.0) - 8.18) < 0.01);\n            assert!(f64::abs(triangle_area_f64(2.0, 2.0, 2.0) - 1.73) < 0.01);\n            assert!(f64::abs(triangle_area_f64(1.0, 2.0, 3.0) + 1.0) < 0.01);\n            assert!(f64::abs(triangle_area_f64(10.0, 5.0, 7.0) - 16.25) < 0.01);\n            assert!(f64::abs(triangle_area_f64(2.0, 6.0, 3.0) + 1.0) < 0.01);\n            assert!(f64::abs(triangle_area_f64(1.0, 1.0, 1.0) - 0.43) < 0.01);\n            assert!(f64::abs(triangle_area_f64(2.0, 2.0, 10.0) + 1.0) < 0.01);\n        }\n    }", "entry_point": "triangle_area_f64", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:36.707753"}
{"task_id": "CodeGen/73", "prompt": "// Given an array arr of integers, find the minimum number of elements that\n// need to be changed to make the array palindromic. A palindromic array is an array that\n// is read the same backwards and forwards. In one change, you can change one element to any other element.\nfn smallest_change(arr: &[i32]) -> i32{", "canonical_solution": "let mut ans: i32 = 0;\n    for i in 0..arr.len() / 2 {\n        if arr[i] != arr[arr.len() - i - 1] {\n            ans += 1\n        }\n    }\n    ans\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_smallest_change() {\n            assert!(smallest_change(&[1, 2, 3, 5, 4, 7, 9, 6]) == 4);\n            assert!(smallest_change(&vec![1, 2, 3, 4, 3, 2, 2]) == 1);\n            assert!(smallest_change(&vec![1, 4, 2]) == 1);\n            assert!(smallest_change(&vec![1, 4, 4, 2]) == 1);\n            assert!(smallest_change(&vec![1, 2, 3, 2, 1]) == 0);\n            assert!(smallest_change(&vec![3, 1, 1, 3]) == 0);\n            assert!(smallest_change(&vec![1]) == 0);\n            assert!(smallest_change(&vec![0, 1]) == 1);\n        }\n    }", "entry_point": "smallest_change", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:37.584615"}
{"task_id": "CodeGen/74", "prompt": "// Write a function that accepts two lists of strings and returns the Vec that has\n// total number of chars in the all strings of the Vec less than the other Vec.\n//\n// if the two lists have the same number of chars, return the first Vec.\nfn total_match(lst1: Vec<&str>, lst2: Vec<&str>) -> Vec<String>{", "canonical_solution": "let total_1: usize = lst1\n        .iter()\n        .fold(0, |acc: usize, str: &&str| acc + str.chars().count());\n    let total_2: usize = lst2\n        .iter()\n        .fold(0, |acc: usize, str: &&str| acc + str.chars().count());\n\n    if total_1 <= total_2 {\n        return lst1.into_iter().map(|x| x.to_string()).collect();\n    } else {\n        lst2.into_iter().map(|x| x.to_string()).collect()\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_total_match() {\n            let v_empty: Vec<String> = vec![];\n            assert!(total_match(vec![], vec![]) == v_empty);\n            assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hi\", \"hi\"]) == vec![\"hi\", \"hi\"]);\n            assert!(\n                total_match(vec![\"hi\", \"admin\"], vec![\"hi\", \"hi\", \"admin\", \"project\"])\n                    == vec![\"hi\", \"admin\"]\n            );\n            assert!(total_match(vec![\"4\"], vec![\"1\", \"2\", \"3\", \"4\", \"5\"]) == vec![\"4\"]);\n            assert!(total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"Hi\"]) == vec![\"hI\", \"Hi\"]);\n            assert!(\n                total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"hi\", \"hi\"]) == vec![\"hI\", \"hi\", \"hi\"]\n            );\n            assert!(\n                total_match(vec![\"hi\", \"admin\"], vec![\"hI\", \"hi\", \"hii\"]) == vec![\"hi\", \"admin\"]\n            );\n            assert!(total_match(vec![], vec![\"this\"]) == v_empty);\n            assert!(total_match(vec![\"this\"], vec![]) == v_empty);\n        }\n    }", "entry_point": "total_match", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:38.029849"}
{"task_id": "CodeGen/75", "prompt": "// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that(a) is less then 100.\nfn is_multiply_prime(a: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/75\n\n// BEGIN_PROMPT\n// Write a function that returns true if the given number is the multiplication of 3 prime numbers\n// and false otherwise.\n// Knowing that(a) is less then 100.\nfn is_multiply_prime(a: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut a1 = a;\n    let mut num = 0;\n    for i in 2..a {\n        while a1 % i == 0 && a1 > i {\n            a1 /= i;\n            num += 1;\n        }\n    }\n    if num == 2 {\n        return true;\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_multiply_prime", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:38.467880"}
{"task_id": "CodeGen/76", "prompt": "// Your task is to write a function that returns true if a number x is a simple\n// power of n and false in other cases.\n// x is a simple power of n if n**int=x\nfn is_simple_power(x: i32, n: i32) -> bool{", "canonical_solution": "let mut p: i32 = 1;\n    let mut count: i32 = 0;\n\n    while p <= x && count < 100 {\n        if p == x {\n            return true;\n        };\n        p = p * n;\n        count += 1;\n    }\n    false\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_is_simple_power() {\n            assert!(is_simple_power(1, 4) == true);\n            assert!(is_simple_power(2, 2) == true);\n            assert!(is_simple_power(8, 2) == true);\n            assert!(is_simple_power(3, 2) == false);\n            assert!(is_simple_power(3, 1) == false);\n            assert!(is_simple_power(5, 3) == false);\n            assert!(is_simple_power(16, 2) == true);\n            assert!(is_simple_power(143214, 16) == false);\n            assert!(is_simple_power(4, 2) == true);\n            assert!(is_simple_power(9, 3) == true);\n            assert!(is_simple_power(16, 4) == true);\n            assert!(is_simple_power(24, 2) == false);\n            assert!(is_simple_power(128, 4) == false);\n            assert!(is_simple_power(12, 6) == false);\n            assert!(is_simple_power(1, 1) == true);\n            assert!(is_simple_power(1, 12) == true);\n        }\n    }", "entry_point": "is_simple_power", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:38.929346"}
{"task_id": "CodeGen/77", "prompt": "// Write a function that takes an integer a and returns True\n// if this ingeger is a cube of some integer number.\n// Note: you may assume the input is always valid.\nfn iscuber(a: i32) -> bool{", "canonical_solution": "let a1: f64 = i32::abs(a) as f64;\n    let sqrt_3 = f64::powf(a1, 1.0 / 3.0).ceil();\n\n    i32::pow(sqrt_3 as i32, 3) == a1 as i32\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_iscuber() {\n            assert!(iscuber(1) == true);\n            assert!(iscuber(2) == false);\n            assert!(iscuber(-1) == true);\n            assert!(iscuber(64) == true);\n            assert!(iscuber(180) == false);\n            assert!(iscuber(1000) == true);\n            assert!(iscuber(0) == true);\n            assert!(iscuber(1729) == false);\n        }\n    }", "entry_point": "iscuber", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:39.374357"}
{"task_id": "CodeGen/78", "prompt": "// You have been tasked to write a function that receives\n// a hexadecimal number as a string and counts the number of hexadecimal\n// digits that are primes(prime number, or a prime, is a natural number\n// greater than 1 that is not a product of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n// So you have to determine a number of the following digits: 2, 3, 5, 7,\n// B(=decimal 11), D(=decimal 13).\n// Note: you may assume the input is always correct or empty string,\n// and symbols A,B,C,D,E,F are always uppercase.\nfn hex_key(num:&str) -> i32{", "canonical_solution": "let primes: Vec<&str> = vec![\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"];\n    let mut total: i32 = 0;\n    for i in 0..num.len() {\n        if primes.contains(&num.get(i..i + 1).expect(\"index in bounds\")) {\n            total += 1;\n        }\n    }\n    total\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_hex_key() {\n            assert!(hex_key(\"AB\") == 1);\n            assert!(hex_key(\"1077E\") == 2);\n            assert!(hex_key(\"ABED1A33\") == 4);\n            assert!(hex_key(\"2020\") == 2);\n            assert!(hex_key(\"123456789ABCDEF0\") == 6);\n            assert!(hex_key(\"112233445566778899AABBCCDDEEFF00\") == 12);\n            assert!(hex_key(\"\") == 0);\n        }\n    }", "entry_point": "hex_key", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:39.915285"}
{"task_id": "CodeGen/79", "prompt": "// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n//\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\nfn decimal_to_binary(decimal: i32) -> String{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/79\n\n// BEGIN_PROMPT\n// You will be given a number in decimal form and your task is to convert it to\n// binary format. The function should return a string, with each character representing a binary\n// number. Each character in the string will be '0' or '1'.\n//\n// There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n// The extra characters are there to help with the format.\nfn decimal_to_binary(decimal: i32) -> String {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut d_cp = decimal;\n    let mut out: String = String::from(\"\");\n    if d_cp == 0 {\n        return \"db0db\".to_string();\n    }\n    while d_cp > 0 {\n        out = (d_cp % 2).to_string() + &out;\n        d_cp = d_cp / 2;\n    }\n    out = \"db\".to_string() + &out + &\"db\".to_string();\n    out\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "decimal_to_binary", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:40.387468"}
{"task_id": "CodeGen/81", "prompt": "// It is the last week of the semester and the teacher has to give the grades\n// to students. The teacher has been making her own algorithm for grading.\n// The only problem is, she has lost the code she used for grading.\n// She has given you a vector of GPAs for some students and you have to write\n// a function that can output a vector of letter grades using the following table:\n// GPA       |    Letter grade\n// 4.0                A+\n// > 3.7                A\n// > 3.3                A-\n// > 3.0                B+\n// > 2.7                B\n// > 2.3                B-\n// > 2.0                C+\n// > 1.7                C\n// > 1.3                C-\n// > 1.0                D+\n// > 0.7                D\n// > 0.0                D-\n// 0.0                E\nfn numerical_letter_grade(grades: &[f64]) -> Vec<String>{", "canonical_solution": "let mut res: Vec<String> = vec![];\n    for (i, gpa) in grades.iter().enumerate() {\n        if gpa == &4.0 {\n            res.push(\"A+\".to_string());\n        } else if gpa > &3.7 {\n            res.push(\"A\".to_string());\n        } else if gpa > &3.3 {\n            res.push(\"A-\".to_string());\n        } else if gpa > &3.0 {\n            res.push(\"B+\".to_string());\n        } else if gpa > &2.7 {\n            res.push(\"B\".to_string());\n        } else if gpa > &2.3 {\n            res.push(\"B-\".to_string());\n        } else if gpa > &2.0 {\n            res.push(\"C+\".to_string());\n        } else if gpa > &1.7 {\n            res.push(\"C\".to_string());\n        } else if gpa > &1.3 {\n            res.push(\"C-\".to_string());\n        } else if gpa > &1.0 {\n            res.push(\"D+\".to_string());\n        } else if gpa > &0.7 {\n            res.push(\"D\".to_string());\n        } else if gpa > &0.0 {\n            res.push(\"D-\".to_string());\n        } else {\n            res.push(\"E\".to_string());\n        }\n    }\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_numerical_letter_grade() {\n            assert!(\n                numerical_letter_grade(&[4.0, 3.0, 1.7, 2.0, 3.5])\n                    == vec![\"A+\", \"B\", \"C-\", \"C\", \"A-\"]\n            );\n            assert!(numerical_letter_grade(&vec![1.2]) == vec![\"D+\"]);\n            assert!(numerical_letter_grade(&vec![0.5]) == vec![\"D-\"]);\n            assert!(numerical_letter_grade(&vec![0.0]) == vec![\"E\"]);\n            assert!(\n                numerical_letter_grade(&vec![1.0, 0.3, 1.5, 2.8, 3.3])\n                    == vec![\"D\", \"D-\", \"C-\", \"B\", \"B+\"]\n            );\n            assert!(numerical_letter_grade(&vec![0.0, 0.7]) == vec![\"E\", \"D-\"]);\n        }\n    }", "entry_point": "numerical_letter_grade", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:41.303782"}
{"task_id": "CodeGen/83", "prompt": "// Given a positive integer n, return the count of the numbers of n-digit\n// positive integers that start or end with 1.\nfn starts_one_ends(n: i32) -> i32{", "canonical_solution": "if n == 1 {\n        return 1;\n    };\n    18 * i32::pow(10, (n - 2) as u32)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_starts_one_ends() {\n            assert!(starts_one_ends(1) == 1);\n            assert!(starts_one_ends(2) == 18);\n            assert!(starts_one_ends(3) == 180);\n            assert!(starts_one_ends(4) == 1800);\n            assert!(starts_one_ends(5) == 18000);\n        }\n    }", "entry_point": "starts_one_ends", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:42.198401"}
{"task_id": "CodeGen/84", "prompt": "// Given a positive integer N, return the total sum of its digits in binary.\n//\n// Variables:\n// @N integer\n// Constraints: 0  N  10000.\n// Output:\n// a string of binary number\nfn solve(n: i32) -> String{", "canonical_solution": "let sum: i32 = n.to_string().chars().into_iter().fold(0, |acc, c| {\n        acc + c.to_digit(10).expect(\"unexpected None/Err\") as i32\n    });\n    format!(\"{sum:b}\")\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_solve() {\n            assert!(solve(1000) == \"1\");\n            assert!(solve(150) == \"110\");\n            assert!(solve(147) == \"1100\");\n            assert!(solve(333) == \"1001\");\n            assert!(solve(963) == \"10010\");\n        }\n    }", "entry_point": "solve", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:42.669752"}
{"task_id": "CodeGen/85", "prompt": "// Given a non-empty vector of integers lst. add the even elements that are at odd indices..\nfn add_even_odd(lst: &[i32]) -> i32{", "canonical_solution": "let mut sum: i32 = 0;\n\n    for (indx, elem) in lst.iter().enumerate() {\n        if indx % 2 == 1 {\n            if elem % 2 == 0 {\n                sum += elem\n            }\n        }\n    }\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_add_even_odd() {\n            assert!(add_even_odd(&[4, 88]) == 88);\n            assert!(add_even_odd(&vec![4, 5, 6, 7, 2, 122]) == 122);\n            assert!(add_even_odd(&vec![4, 0, 6, 7]) == 0);\n            assert!(add_even_odd(&vec![4, 4, 6, 8]) == 12);\n        }\n    }", "entry_point": "add_even_odd", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:43.111990"}
{"task_id": "CodeGen/86", "prompt": "// Write a function that takes a string and returns an ordered version of it.\n// Ordered version of string, is a string where all words(separated by space)\n// are replaced by a new word where all the characters arranged in\n// ascending order based on ascii value.\n// Note: You should keep the order of words and blank spaces in the sentence.\nfn anti_shuffle(s:&str) -> String{", "canonical_solution": "let mut res: String = String::new();\n\n    for i in s.split_ascii_whitespace() {\n        let mut str: Vec<char> = i.chars().into_iter().collect();\n        str.sort_by(|a, b| (*a as u32).cmp(&(*b as u32)));\n        let str_sorted: String = str.into_iter().collect();\n        res.push_str(&(str_sorted + &\" \".to_string()));\n    }\n    res = res.trim_end().to_string();\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_anti_shuffle() {\n            assert!(anti_shuffle(\"Hi\") == \"Hi\".to_string());\n            assert!(anti_shuffle(\"hello\") == \"ehllo\".to_string());\n            assert!(anti_shuffle(\"number\") == \"bemnru\".to_string());\n            assert!(anti_shuffle(\"abcd\") == \"abcd\".to_string());\n            assert!(anti_shuffle(\"Hello World!!!\") == \"Hello !!!Wdlor\".to_string());\n            assert!(anti_shuffle(\"\") == \"\".to_string());\n            assert!(\n                anti_shuffle(\"Hi. My name is Mister Robot. How are you?\")\n                    == \".Hi My aemn is Meirst .Rboot How aer ?ouy\".to_string()\n            );\n        }\n    }", "entry_point": "anti_shuffle", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:43.566954"}
{"task_id": "CodeGen/89", "prompt": "// Create a function encrypt that takes a string as an argument and\n// returns a string encrypted with the alphabet being rotated.\n// The alphabet should be rotated in a manner such that the letters\n// shift down by two multiplied to two places.\nfn encrypt(s:&str) -> String{", "canonical_solution": "let d: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\n        .to_string()\n        .chars()\n        .into_iter()\n        .collect();\n    let mut out: String = String::new();\n    for c in s.chars() {\n        if d.contains(&c) {\n            let indx: usize =\n                (d.iter().position(|x| c == *x).expect(\"unexpected None/Err\") + 2 * 2) % 26;\n            out += &d[indx].to_string();\n        } else {\n            out += &c.to_string();\n        }\n    }\n\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_encrypt() {\n            assert!(encrypt(\"hi\") == \"lm\");\n            assert!(encrypt(\"asdfghjkl\") == \"ewhjklnop\");\n            assert!(encrypt(\"gf\") == \"kj\");\n            assert!(encrypt(\"et\") == \"ix\");\n            assert!(encrypt(\"faewfawefaewg\") == \"jeiajeaijeiak\");\n            assert!(encrypt(\"hellomyfriend\") == \"lippsqcjvmirh\");\n            assert!(\n                encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")\n                    == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\n            );\n            assert!(encrypt(\"a\") == \"e\");\n        }\n    }", "entry_point": "encrypt", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:44.966287"}
{"task_id": "CodeGen/92", "prompt": "// Create a function that takes 3 numbers.\n// Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n// Returns false in any other cases.\nfn any_int(a:f64, b:f64, c:f64) -> bool{", "canonical_solution": "if a.fract() == 0.0 && b.fract() == 0.0 && c.fract() == 0.0 {\n        return a + b == c || a + c == b || b + c == a;\n    } else {\n        false\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_any_int() {\n            assert!(any_int(2.0, 3.0, 1.0) == true);\n            assert!(any_int(2.5, 2.0, 3.0) == false);\n            assert!(any_int(1.5, 5.0, 3.5) == false);\n            assert!(any_int(2.0, 6.0, 2.0) == false);\n            assert!(any_int(4.0, 2.0, 2.0) == true);\n            assert!(any_int(2.2, 2.2, 2.2) == false);\n            assert!(any_int(-4.0, 6.0, 2.0) == true);\n            assert!(any_int(2.0, 1.0, 1.0) == true);\n            assert!(any_int(3.0, 4.0, 7.0) == true);\n            assert!(any_int(3.01, 4.0, 7.0) == false);\n        }\n    }", "entry_point": "any_int", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:46.306075"}
{"task_id": "CodeGen/93", "prompt": "// Write a function that takes a message, and encodes in such a\n// way that it swaps case of all letters, replaces all vowels in\n// the message with the letter that appears 2 places ahead of that\n// vowel in the english alphabet.\n// Assume only letters.\nfn encode(message:&str) -> String{", "canonical_solution": "let mut res: String = String::new();\n    let v: Vec<char> = \"aeiouAEIOU\".to_string().chars().into_iter().collect();\n    let d: Vec<char> = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        .to_string()\n        .chars()\n        .into_iter()\n        .collect();\n\n    for (indx, elem) in message.chars().into_iter().enumerate() {\n        let mut c = elem.to_string();\n\n        if v.contains(&elem) {\n            let indx: usize = d\n                .iter()\n                .position(|x| &elem == x)\n                .expect(\"unexpected None/Err\");\n            c = d[indx + 2 as usize].to_string();\n        }\n\n        if elem.is_uppercase() {\n            c = c.to_lowercase().to_string();\n        } else {\n            c = c.to_uppercase().to_string();\n        }\n        res.push_str(&c);\n    }\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_encode() {\n            assert!(encode(\"TEST\") == \"tgst\");\n            assert!(encode(\"Mudasir\") == \"mWDCSKR\");\n            assert!(encode(\"YES\") == \"ygs\");\n            assert!(encode(\"This is a message\") == \"tHKS KS C MGSSCGG\");\n            assert!(encode(\"I DoNt KnOw WhAt tO WrItE\") == \"k dQnT kNqW wHcT Tq wRkTg\");\n        }\n    }", "entry_point": "encode", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:46.766111"}
{"task_id": "CodeGen/94", "prompt": "// You are given a vector of integers.\n// You need to find the largest prime value and return the sum of its digits.\nfn skjkasdkd(lst: &[i32]) -> i32{", "canonical_solution": "let mut largest = 0;\n    for i in 0..lst.len() {\n        if lst[i] > largest {\n            let mut prime = true;\n            let mut j = 2;\n            while j * j <= lst[i] {\n                if lst[i] % j == 0 {\n                    prime = false;\n                }\n                j += 1;\n            }\n\n            if prime {\n                largest = lst[i];\n            }\n        }\n    }\n    let mut sum: i32 = 0;\n    let mut s: String = String::new();\n    s = largest.to_string();\n\n    for n in s.chars().into_iter() {\n        sum += n.to_digit(10).expect(\"unexpected None/Err\") as i32;\n    }\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_skjkasdkd() {\n            assert!(\n                skjkasdkd(&[\n                    0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3\n                ]) == 10\n            );\n            assert!(\n                skjkasdkd(&vec![\n                    1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1\n                ]) == 25\n            );\n            assert!(\n                skjkasdkd(&vec![\n                    1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3\n                ]) == 13\n            );\n            assert!(skjkasdkd(&vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11);\n            assert!(skjkasdkd(&vec![0, 81, 12, 3, 1, 21]) == 3);\n            assert!(skjkasdkd(&vec![0, 8, 1, 2, 1, 7]) == 7);\n            assert!(skjkasdkd(&vec![8191]) == 19);\n            assert!(skjkasdkd(&vec![8191, 123456, 127, 7]) == 19);\n            assert!(skjkasdkd(&vec![127, 97, 8192]) == 10);\n        }\n    }", "entry_point": "skjkasdkd", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:47.234077"}
{"task_id": "CodeGen/96", "prompt": "// Implement a function that takes an non-negative integer and returns an array of the first n\n// integers that are prime numbers and less than n.\nfn count_up_to(n: i32) -> Vec<i32> {", "canonical_solution": "let mut primes: Vec<i32> = vec![];\n\n    for i in 2..n {\n        let mut is_prime: bool = true;\n\n        for j in 2..i {\n            if i % j == 0 {\n                is_prime = false;\n                break;\n            }\n        }\n        if is_prime {\n            primes.push(i);\n        }\n    }\n    primes\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_count_up_to() {\n            assert!(count_up_to(5) == vec![2, 3]);\n            assert!(count_up_to(6) == vec![2, 3, 5]);\n            assert!(count_up_to(7) == vec![2, 3, 5]);\n            assert!(count_up_to(10) == vec![2, 3, 5, 7]);\n            assert!(count_up_to(0) == vec![]);\n            assert!(count_up_to(22) == vec![2, 3, 5, 7, 11, 13, 17, 19]);\n            assert!(count_up_to(1) == vec![]);\n            assert!(count_up_to(18) == vec![2, 3, 5, 7, 11, 13, 17]);\n            assert!(count_up_to(47) == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]);\n            assert!(\n                count_up_to(101)\n                    == vec![\n                        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n                        73, 79, 83, 89, 97\n                    ]\n            );\n        }\n    }", "entry_point": "count_up_to", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:48.169654"}
{"task_id": "CodeGen/97", "prompt": "// Complete the function that takes two integers and returns\n// the product of their unit digits.\n// Assume the input is always valid.\nfn multiply(a: i32, b: i32) -> i32{", "canonical_solution": "(i32::abs(a) % 10) * (i32::abs(b) % 10)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_multiply() {\n            assert!(multiply(148, 412) == 16);\n            assert!(multiply(19, 28) == 72);\n            assert!(multiply(2020, 1851) == 0);\n            assert!(multiply(14, -15) == 20);\n            assert!(multiply(76, 67) == 42);\n            assert!(multiply(17, 27) == 49);\n            assert!(multiply(0, 1) == 0);\n            assert!(multiply(0, 0) == 0);\n        }\n    }", "entry_point": "multiply", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:48.604341"}
{"task_id": "CodeGen/98", "prompt": "// Given a string s, count the number of uppercase vowels in even indices.\nfn count_upper(s:&str) -> i32 {", "canonical_solution": "let uvowel: &str = \"AEIOU\";\n    let mut count: i32 = 0;\n\n    for (indx, elem) in s.chars().into_iter().enumerate() {\n        if indx % 2 == 0 {\n            if uvowel.contains(elem) {\n                count += 1;\n            }\n        }\n    }\n    count\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_count_upper() {\n            assert!(count_upper(\"aBCdEf\") == 1);\n            assert!(count_upper(\"abcdefg\") == 0);\n            assert!(count_upper(\"dBBE\") == 0);\n            assert!(count_upper(\"B\") == 0);\n            assert!(count_upper(\"U\") == 1);\n            assert!(count_upper(\"\") == 0);\n            assert!(count_upper(\"EEEE\") == 2);\n        }\n    }", "entry_point": "count_upper", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:49.054046"}
{"task_id": "CodeGen/100", "prompt": "// Given a positive integer n, you have to make a pile of n levels of stones.\n// The first level has n stones.\n// The number of stones in the next level is:\n// - the next odd number if n is odd.\n// - the next even number if n is even.\n// Return the number of stones in each level in a Vec, where element at index\n// i represents the number of stones in the level(i+1).\nfn make_a_pile(n: i32) -> Vec<i32>{", "canonical_solution": "let mut out: Vec<i32> = vec![n];\n\n    for i in 1..n {\n        out.push(out[out.len() - 1] + 2);\n    }\n\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_make_a_pile() {\n            assert!(make_a_pile(3) == vec![3, 5, 7]);\n            assert!(make_a_pile(4) == vec![4, 6, 8, 10]);\n            assert!(make_a_pile(5) == vec![5, 7, 9, 11, 13]);\n            assert!(make_a_pile(6) == vec![6, 8, 10, 12, 14, 16]);\n            assert!(make_a_pile(8) == vec![8, 10, 12, 14, 16, 18, 20, 22]);\n        }\n    }", "entry_point": "make_a_pile", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:49.931373"}
{"task_id": "CodeGen/101", "prompt": "// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\nfn words_string(s:&str) -> Vec<String> {", "canonical_solution": "s.split(|c: char| c == ',' || c.is_whitespace())\n        .filter(|x| x != &\"\")\n        .map(|x| x.to_string())\n        .collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_words_string() {\n            assert!(words_string(\"Hi, my name is John\") == vec![\"Hi\", \"my\", \"name\", \"is\", \"John\"]);\n            assert!(\n                words_string(\"One, two, three, four, five, six\")\n                    == vec![\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n            );\n            assert!(words_string(\"Hi, my name\") == vec![\"Hi\", \"my\", \"name\"]);\n            assert!(\n                words_string(\"One,, two, three, four, five, six,\")\n                    == vec![\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n            );\n            let v_empty: Vec<String> = vec![];\n            assert!(words_string(\"\") == v_empty);\n            assert!(words_string(\"ahmed , gamal\") == vec![\"ahmed\", \"gamal\"]);\n        }\n    }", "entry_point": "words_string", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:50.381288"}
{"task_id": "CodeGen/102", "prompt": "// This function takes two positive numbers x and y and returns the\n// biggest even integer number that is in the range [x, y] inclusive. If\n// there's no such number, then the function should return -1.\nfn choose_num(x: i32, y: i32) -> i32{", "canonical_solution": "if y < x {\n        return -1;\n    }\n    if y == x && y % 2 == 1 {\n        return -1;\n    }\n    if y % 2 == 1 {\n        return y - 1;\n    }\n    y\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_choose_num() {\n            assert!(choose_num(12, 15) == 14);\n            assert!(choose_num(13, 12) == -1);\n            assert!(choose_num(33, 12354) == 12354);\n            assert!(choose_num(6, 29) == 28);\n            assert!(choose_num(27, 10) == -1);\n            assert!(choose_num(7, 7) == -1);\n            assert!(choose_num(546, 546) == 546);\n        }\n    }", "entry_point": "choose_num", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:50.806890"}
{"task_id": "CodeGen/103", "prompt": "// You are given two positive integers n and m, and your task is to compute the\n// average of the integers from n through m(including n and m).\n// Round the answer to the nearest integer and convert that to binary.\n// If n is greater than m, return -1.\nfn rounded_avg(n: i32, m: i32) -> String{", "canonical_solution": "if n > m {\n        return \"-1\".to_string();\n    };\n    let mut num: i32 = (m + n) / 2;\n    let mut out: String = String::from(\"\");\n    while num > 0 {\n        out = (num % 2).to_string() + &out;\n        num = num / 2;\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_rounded_avg() {\n            assert!(rounded_avg(1, 5) == \"11\");\n            assert!(rounded_avg(7, 13) == \"1010\");\n            assert!(rounded_avg(964, 977) == \"1111001010\");\n            assert!(rounded_avg(996, 997) == \"1111100100\");\n            assert!(rounded_avg(560, 851) == \"1011000001\");\n            assert!(rounded_avg(185, 546) == \"101101101\");\n            assert!(rounded_avg(362, 496) == \"110101101\");\n            assert!(rounded_avg(350, 902) == \"1001110010\");\n            assert!(rounded_avg(197, 233) == \"11010111\");\n            assert!(rounded_avg(7, 5) == \"-1\");\n            assert!(rounded_avg(5, 1) == \"-1\");\n            assert!(rounded_avg(5, 5) == \"101\");\n        }\n    }", "entry_point": "rounded_avg", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:51.238682"}
{"task_id": "CodeGen/104", "prompt": "// Given a vector of positive integers x. return a sorted vector of all\n// elements that hasn't any even digit.\n//\n// Note: Returned Vec should be sorted in increasing order.\nfn unique_digits(x: Vec<i32>) -> Vec<i32>{", "canonical_solution": "let mut res: Vec<i32> = vec![];\n    for (_, elem) in x.into_iter().enumerate() {\n        let mut elem_cp: i32 = elem;\n        let mut u: bool = true;\n        if elem == 0 {\n            u = false;\n        }\n        while elem_cp > 0 && u {\n            if elem_cp % 2 == 0 {\n                u = false;\n            }\n            elem_cp = elem_cp / 10;\n        }\n        if u {\n            res.push(elem)\n        };\n    }\n    res.sort();\n    res\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_unique_digits() {\n            assert!(unique_digits(vec![15, 33, 1422, 1]) == vec![1, 15, 33]);\n            assert!(unique_digits(vec![152, 323, 1422, 10]) == vec![]);\n            assert!(unique_digits(vec![12345, 2033, 111, 151]) == vec![111, 151]);\n            assert!(unique_digits(vec![135, 103, 31]) == vec![31, 135]);\n        }\n    }", "entry_point": "unique_digits", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:51.695666"}
{"task_id": "CodeGen/105", "prompt": "// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\nfn by_length(arr: Vec<i32>) -> Vec<String>{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/105\n\n// BEGIN_PROMPT\n// Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n// reverse the resulting array, and then replace each digit by its corresponding name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\nuse std::collections::HashMap;\n\nfn by_length(arr: Vec<i32>) -> Vec<String> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut res: Vec<String> = vec![];\n    let mut arr_cp: Vec<i32> = arr.clone();\n    arr_cp.sort();\n    arr_cp.reverse();\n    let map: HashMap<i32, &str> = HashMap::from([\n        (0, \"Zero\"),\n        (1, \"One\"),\n        (2, \"Two\"),\n        (3, \"Three\"),\n        (4, \"Four\"),\n        (5, \"Five\"),\n        (6, \"Six\"),\n        (7, \"Seven\"),\n        (8, \"Eight\"),\n        (9, \"Nine\"),\n    ]);\n\n    for elem in arr_cp {\n        if elem >= 1 && elem <= 9 {\n            res.push(map.get(&elem).expect(\"index in bounds\").to_string());\n        }\n    }\n\n    res\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "by_length", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:52.144090"}
{"task_id": "CodeGen/106", "prompt": "// Implement the function f that takes n as a parameter,\n// and returns a vector of size n, such that the value of the element at index i is the factorial of i if i is even\n// or the sum of numbers from 1 to i otherwise.\n// i starts from 1.\n// the factorial of i is the multiplication of the numbers from 1 to i(1 * 2 * ... * i).\nfn f(n: i32) -> Vec<i32>{", "canonical_solution": "let mut sum: i32 = 0;\n    let mut prod: i32 = 1;\n    let mut out: Vec<i32> = vec![];\n\n    for i in 1..n + 1 {\n        sum += i;\n        prod *= i;\n\n        if i % 2 == 0 {\n            out.push(prod);\n        } else {\n            out.push(sum)\n        };\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_f() {\n            assert!(f(5) == vec![1, 2, 6, 24, 15]);\n            assert!(f(7) == vec![1, 2, 6, 24, 15, 720, 28]);\n            assert!(f(1) == vec![1]);\n            assert!(f(3) == vec![1, 2, 6]);\n        }\n    }", "entry_point": "f", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:52.568885"}
{"task_id": "CodeGen/107", "prompt": "// Given a positive integer n, return a tuple that has the number of even and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n//\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned tuple has the number of even and odd integer palindromes respectively.\nfn even_odd_palindrome(n: i32) -> (i32, i32) {", "canonical_solution": "let mut even = 0;\n    let mut odd = 0;\n\n    for i in 1..n + 1 {\n        let mut w: String = i.to_string();\n        let mut p: String = w.chars().rev().collect();\n\n        if w == p && i % 2 == 1 {\n            odd += 1;\n        }\n        if w == p && i % 2 == 0 {\n            even += 1;\n        }\n    }\n    (even, odd)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_even_odd_palindrome() {\n            assert!(even_odd_palindrome(123) == (8, 13));\n            assert!(even_odd_palindrome(12) == (4, 6));\n            assert!(even_odd_palindrome(3) == (1, 2));\n            assert!(even_odd_palindrome(63) == (6, 8));\n            assert!(even_odd_palindrome(25) == (5, 6));\n            assert!(even_odd_palindrome(19) == (4, 6));\n            assert!(even_odd_palindrome(9) == (4, 5));\n            assert!(even_odd_palindrome(1) == (0, 1));\n        }\n    }", "entry_point": "even_odd_palindrome", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:53.051013"}
{"task_id": "CodeGen/108", "prompt": "// Write a function count_nums which takes an array of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\nfn count_nums(n: Vec<i32>) -> i32{", "canonical_solution": "let mut num: i32 = 0;\n\n    for nmbr in n {\n        if nmbr > 0 {\n            num += 1;\n        } else {\n            let mut sum: i32 = 0;\n            let mut w: i32;\n            w = i32::abs(nmbr);\n\n            while w >= 10 {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if sum > 0 {\n                num += 1;\n            }\n        }\n    }\n    num\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_count_nums() {\n            assert!(count_nums(vec![]) == 0);\n            assert!(count_nums(vec![-1, -2, 0]) == 0);\n            assert!(count_nums(vec![1, 1, 2, -2, 3, 4, 5]) == 6);\n            assert!(count_nums(vec![1, 6, 9, -6, 0, 1, 5]) == 5);\n            assert!(count_nums(vec![1, 100, 98, -7, 1, -1]) == 4);\n            assert!(count_nums(vec![12, 23, 34, -45, -56, 0]) == 5);\n            assert!(count_nums(vec![-0, 1]) == 1);\n            assert!(count_nums(vec![1]) == 1);\n        }\n    }", "entry_point": "count_nums", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:53.488129"}
{"task_id": "CodeGen/110", "prompt": "// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n//\n// It is assumed that the input lists will be non-empty.\nfn exchange(lst1: &[i32], lst2: &[i32]) -> String{", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/110\n\n// BEGIN_PROMPT\n// In this problem, you will implement a function that takes two lists of numbers,\n// and determines whether it is possible to perform an exchange of elements\n// between them to make lst1 a vector of only even numbers.\n// There is no limit on the number of exchanged elements between lst1 and lst2.\n// If it is possible to exchange elements between the lst1 and lst2 to make\n// all the elements of lst1 to be even, return \"YES\".\n// Otherwise, return \"NO\".\n//\n// It is assumed that the input lists will be non-empty.\nfn exchange(lst1: &[i32], lst2: &[i32]) -> String {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut num = 0;\n    for i in 0..lst1.len() {\n        if lst1[i] % 2 == 0 {\n            num += 1;\n        }\n    }\n    for i in 0..lst2.len() {\n        if lst2[i] % 2 == 0 {\n            num += 1;\n        }\n    }\n    if num >= lst1.len() {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "exchange", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:54.409090"}
{"task_id": "CodeGen/113", "prompt": "// Given a vector of strings, where each string consists of only digits, return a vector.\n// Each element i of the output should be \"the number of odd elements in the\n// string i of the input.\" where all the i's should be replaced by the number\n// of odd digits in the i'th string of the input.\nfn odd_count(lst: &[&str]) -> Vec<String>{", "canonical_solution": "let mut out: Vec<String> = Vec::new();\n    for i in 0..lst.len() {\n        let mut sum = 0;\n        for j in 0..lst[i].len() {\n            if lst[i].chars().nth(j).expect(\"unexpected None/Err\") >= '0'\n                && lst[i].chars().nth(j).expect(\"unexpected None/Err\") <= '9'\n                && lst[i]\n                    .chars()\n                    .nth(j)\n                    .expect(\"unexpected None/Err\")\n                    .to_digit(10)\n                    .expect(\"unexpected None/Err\")\n                    % 2\n                    == 1\n            {\n                sum += 1;\n            }\n        }\n        let mut s = \"the number of odd elements in the string i of the input.\".to_string();\n        let mut s2 = \"\".to_string();\n        for j in 0..s.len() {\n            if s.chars().nth(j).expect(\"unexpected None/Err\") == 'i' {\n                s2.push_str(&sum.to_string());\n            } else {\n                s2.push(s.chars().nth(j).expect(\"unexpected None/Err\"));\n            }\n        }\n        out.push(s2);\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_odd_count() {\n            assert!(\n                odd_count(&[\"1234567\"])\n                    == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n            );\n            assert!(\n                odd_count(&vec![\"3\", \"11111111\"])\n                    == [\n                        \"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n                        \"the number of odd elements 8n the str8ng 8 of the 8nput.\"\n                    ]\n            );\n            assert!(\n                odd_count(&vec![\"271\", \"137\", \"314\"])\n                    == [\n                        \"the number of odd elements 2n the str2ng 2 of the 2nput.\",\n                        \"the number of odd elements 3n the str3ng 3 of the 3nput.\",\n                        \"the number of odd elements 2n the str2ng 2 of the 2nput.\"\n                    ]\n            );\n        }\n    }", "entry_point": "odd_count", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:55.768302"}
{"task_id": "CodeGen/114", "prompt": "// Given an array of integers nums, find the minimum sum of any non-empty sub-array\n// of nums.\nfn min_sub_array_sum(nums: &[i64]) -> i64 {", "canonical_solution": "let mut current = nums[0];\n    let mut min = nums[0];\n    for i in 1..nums.len() {\n        if current < 0 {\n            current = current + nums[i];\n        } else {\n            current = nums[i];\n        }\n        if current < min {\n            min = current;\n        }\n    }\n    min\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_min_sub_array_sum() {\n            assert!(min_sub_array_sum(&[2, 3, 4, 1, 2, 4]) == 1);\n            assert!(min_sub_array_sum(&vec![-1, -2, -3]) == -6);\n            assert!(min_sub_array_sum(&vec![-1, -2, -3, 2, -10]) == -14);\n            assert!(min_sub_array_sum(&vec![-9999999999999999]) == -9999999999999999);\n            assert!(min_sub_array_sum(&vec![0, 10, 20, 1000000]) == 0);\n            assert!(min_sub_array_sum(&vec![-1, -2, -3, 10, -5]) == -6);\n            assert!(min_sub_array_sum(&vec![100, -1, -2, -3, 10, -5]) == -6);\n            assert!(min_sub_array_sum(&vec![10, 11, 13, 8, 3, 4]) == 3);\n            assert!(min_sub_array_sum(&vec![100, -33, 32, -1, 0, -2]) == -33);\n            assert!(min_sub_array_sum(&vec![-10]) == -10);\n            assert!(min_sub_array_sum(&vec![7]) == 7);\n            assert!(min_sub_array_sum(&vec![1, -1]) == -1);\n        }\n    }", "entry_point": "min_sub_array_sum", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:56.208108"}
{"task_id": "CodeGen/116", "prompt": "// In this Kata, you have to sort an array of non-negative integers according to\n// number of ones in their binary representation in ascending order.\n// For similar number of ones, sort based on decimal value.\nfn sort_array_1(arr: Vec<i32>) -> Vec<i32>{", "canonical_solution": "let mut arr_cp = arr.clone();\n    let mut bin = vec![];\n    let mut m;\n\n    for i in 0..arr_cp.len() {\n        let mut b = 0;\n        let mut n = arr_cp[i].abs();\n        while n > 0 {\n            b += n % 2;\n            n = n / 2;\n        }\n        bin.push(b);\n    }\n    for i in 0..arr_cp.len() {\n        for j in 1..arr_cp.len() {\n            if bin[j] < bin[j - 1] || (bin[j] == bin[j - 1] && arr_cp[j] < arr_cp[j - 1]) {\n                m = arr_cp[j];\n                arr_cp[j] = arr_cp[j - 1];\n                arr_cp[j - 1] = m;\n                m = bin[j];\n                bin[j] = bin[j - 1];\n                bin[j - 1] = m;\n            }\n        }\n    }\n    arr_cp\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sort_array_1() {\n            assert!(sort_array_1(vec![1, 5, 2, 3, 4]) == vec![1, 2, 4, 3, 5]);\n            assert!(sort_array_1(vec![-2, -3, -4, -5, -6]) == vec![-4, -2, -6, -5, -3]);\n            assert!(sort_array_1(vec![1, 0, 2, 3, 4]) == vec![0, 1, 2, 4, 3]);\n            assert!(sort_array_1(vec![]) == vec![]);\n            assert!(\n                sort_array_1(vec![2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])\n                    == vec![2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n            );\n            assert!(sort_array_1(vec![3, 6, 44, 12, 32, 5]) == vec![32, 3, 5, 6, 12, 44]);\n            assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);\n            assert!(sort_array_1(vec![2, 4, 8, 16, 32]) == vec![2, 4, 8, 16, 32]);\n        }\n    }", "entry_point": "sort_array_1", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:57.135375"}
{"task_id": "CodeGen/117", "prompt": "// Given a string s and a natural number n, you have been tasked to implement\n// a function that returns a vector of all words from string s that contain exactly\n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty Vec.\n// Note: you may assume the input string contains only letters and spaces.\nfn select_words(s:&str, n: i32) -> Vec<String>{", "canonical_solution": "let vowels = \"aeiouAEIOU\";\n    let mut current = String::new();\n    let mut out = Vec::new();\n    let mut numc = 0;\n    let mut s = s.to_string();\n    s.push(' ');\n    for i in 0..s.len() {\n        if s.chars().nth(i).expect(\"unexpected None/Err\") == ' ' {\n            if numc == n {\n                out.push(current);\n            }\n            current = String::new();\n            numc = 0;\n        } else {\n            current.push(s.chars().nth(i).expect(\"unexpected None/Err\"));\n            if (s.chars().nth(i).expect(\"unexpected None/Err\") >= 'A'\n                && s.chars().nth(i).expect(\"unexpected None/Err\") <= 'Z')\n                || (s.chars().nth(i).expect(\"unexpected None/Err\") >= 'a'\n                    && s.chars().nth(i).expect(\"unexpected None/Err\") <= 'z')\n            {\n                if !vowels.contains(s.chars().nth(i).expect(\"unexpected None/Err\")) {\n                    numc += 1;\n                }\n            }\n        }\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_select_words() {\n            assert_eq!(select_words(\"Mary had a little lamb\", 4), vec![\"little\"]);\n            assert_eq!(\n                select_words(\"Mary had a little lamb\", 3),\n                vec![\"Mary\", \"lamb\"]\n            );\n            let v_empty: Vec<&str> = vec![];\n            assert_eq!(select_words(\"simple white space\", 2), v_empty);\n            assert_eq!(select_words(\"Hello world\", 4), vec![\"world\"]);\n            assert_eq!(select_words(\"Uncle sam\", 3), vec![\"Uncle\"]);\n            assert_eq!(select_words(\"\", 4), v_empty);\n            assert_eq!(select_words(\"a b c d e f\", 1), vec![\"b\", \"c\", \"d\", \"f\"]);\n        }\n    }", "entry_point": "select_words", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:57.585741"}
{"task_id": "CodeGen/121", "prompt": "// Given a non-empty vector of integers, return the sum of all of the odd elements that are in even positions.\nfn solutions(lst: &[i32]) -> i32 {", "canonical_solution": "let mut sum = 0;\n    for (indx, elem) in lst.iter().enumerate() {\n        if indx % 2 == 0 {\n            if elem % 2 == 1 {\n                sum += elem;\n            }\n        }\n    }\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_solutions() {\n            assert_eq!(solutions(&[5, 8, 7, 1]), 12);\n            assert_eq!(solutions(&vec![3, 3, 3, 3, 3]), 9);\n            assert_eq!(solutions(&vec![30, 13, 24, 321]), 0);\n            assert_eq!(solutions(&vec![5, 9]), 5);\n            assert_eq!(solutions(&vec![2, 4, 8]), 0);\n            assert_eq!(solutions(&vec![30, 13, 23, 32]), 23);\n            assert_eq!(solutions(&vec![3, 13, 2, 9]), 3);\n        }\n    }", "entry_point": "solutions", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:59.302604"}
{"task_id": "CodeGen/122", "prompt": "// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most two digits from the first k elements of arr.\n//\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\nfn add_elements(arr: &[i32], k: i32) -> i32 {", "canonical_solution": "let mut sum = 0;\n    for i in 0..k {\n        if arr[i as usize] >= -99 && arr[i as usize] <= 99 {\n            sum += arr[i as usize];\n        }\n    }\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_add_elements() {\n            assert_eq!(add_elements(&[1, -2, -3, 41, 57, 76, 87, 88, 99], 3), -4);\n            assert_eq!(add_elements(&vec![111, 121, 3, 4000, 5, 6], 2), 0);\n            assert_eq!(add_elements(&vec![11, 21, 3, 90, 5, 6, 7, 8, 9], 4), 125);\n            assert_eq!(add_elements(&vec![111, 21, 3, 4000, 5, 6, 7, 8, 9], 4), 24);\n            assert_eq!(add_elements(&vec![1], 1), 1);\n        }\n    }", "entry_point": "add_elements", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:05:59.748057"}
{"task_id": "CodeGen/123", "prompt": "// Given a positive integer n, return a sorted Vec that has the odd numbers in collatz sequence.\n//\n// The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n// as follows: start with any positive integer n. Then each term is obtained from the\n// previous term as follows: if the previous term is even, the next term is one half of\n// the previous term. If the previous term is odd, the next term is 3 times the previous\n// term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n//\n// Note:\n// 1. Collatz(1) is [1].\n// 2. returned Vec sorted in increasing order.\nfn get_odd_collatz(n: i32) -> Vec<i32> {", "canonical_solution": "let mut out = vec![1];\n    let mut n = n;\n    while n != 1 {\n        if n % 2 == 1 {\n            out.push(n);\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n    out.sort();\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_get_odd_collatz() {\n            assert_eq!(get_odd_collatz(14), vec![1, 5, 7, 11, 13, 17]);\n            assert_eq!(get_odd_collatz(5), vec![1, 5]);\n            assert_eq!(get_odd_collatz(12), vec![1, 3, 5]);\n            assert_eq!(get_odd_collatz(1), vec![1]);\n        }\n    }", "entry_point": "get_odd_collatz", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:00.198965"}
{"task_id": "CodeGen/125", "prompt": "// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nfn split_words(txt: &str) -> Vec<String> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/125\n\n// BEGIN_PROMPT\n// Given a string of words, return a vector of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nuse std::collections::HashMap;\n\nfn split_words(txt: &str) -> Vec<String> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut out: Vec<String> = Vec::new();\n    let alphabet: HashMap<char, i32> = HashMap::from([\n        ('a', 0),\n        ('b', 1),\n        ('c', 2),\n        ('d', 3),\n        ('e', 4),\n        ('f', 5),\n        ('g', 6),\n        ('h', 7),\n        ('i', 8),\n        ('j', 9),\n        ('k', 10),\n        ('l', 11),\n        ('m', 12),\n        ('n', 13),\n        ('o', 14),\n        ('p', 15),\n        ('q', 16),\n        ('r', 17),\n        ('s', 18),\n        ('t', 19),\n        ('u', 20),\n        ('v', 21),\n        ('w', 22),\n        ('x', 23),\n        ('y', 24),\n        ('z', 25),\n    ]);\n\n    if txt.contains(' ') {\n        out = txt\n            .split_whitespace()\n            .into_iter()\n            .map(|c| c.to_string())\n            .collect();\n    } else if txt.contains(',') {\n        out = txt.split(',').into_iter().map(|c| c.to_string()).collect();\n    } else {\n        let count = txt\n            .chars()\n            .into_iter()\n            .filter(|c| c.is_ascii_lowercase())\n            .filter(|c| alphabet.get(c).expect(\"index in bounds\") % 2 == 1)\n            .count();\n        out.push(count.to_string());\n    }\n\n    out\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "split_words", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:01.129122"}
{"task_id": "CodeGen/128", "prompt": "// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return None for empty arr.\nfn prod_signs(arr: Vec<i32>) -> i32 {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/128\n\n// BEGIN_PROMPT\n// You are given an array arr of integers and you need to return\n// sum of magnitudes of integers multiplied by product of all signs\n// of each number in the array, represented by 1, -1 or 0.\n// Note: return None for empty arr.\nfn prod_signs(arr: Vec<i32>) -> i32 {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if arr.is_empty() {\n        return -32768;\n    }\n    let mut sum = 0;\n    let mut prods = 1;\n    for i in arr {\n        sum += i.abs();\n        if i == 0 {\n            prods = 0;\n        }\n        if i < 0 {\n            prods = -prods;\n        }\n    }\n    sum * prods\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "prod_signs", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:02.511914"}
{"task_id": "CodeGen/130", "prompt": "// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a vector of the\n// first n + 1 numbers of the Tribonacci sequence.\nfn tri(n: i32) -> Vec<i32> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/130\n\n// BEGIN_PROMPT\n// Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n// the last couple centuries. However, what people don't know is Tribonacci sequence.\n// Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) = 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3) = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8\n// You are given a non-negative integer number n, you have to a return a vector of the\n// first n + 1 numbers of the Tribonacci sequence.\nfn tri(n: i32) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut out = vec![1, 3];\n    if n == 0 {\n        return vec![1];\n    }\n    for i in 2..=n {\n        if i % 2 == 0 {\n            out.push(1 + i / 2);\n        } else {\n            out.push(out[(i - 1) as usize] + out[(i - 2) as usize] + 1 + (i + 1) / 2);\n        }\n    }\n    out\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "tri", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:03.453231"}
{"task_id": "CodeGen/131", "prompt": "// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\nfn digits(n: i32) -> i32 {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/131\n\n// BEGIN_PROMPT\n// Given a positive integer n, return the product of the odd digits.\n// Return 0 if all digits are even.\nfn digits(n: i32) -> i32 {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut prod: i32 = 1;\n    let mut has = 0;\n    let s = n.to_string();\n    for i in 0..s.len() {\n        if s.chars()\n            .nth(i)\n            .expect(\"unexpected None/Err\")\n            .to_digit(10)\n            .expect(\"unexpected None/Err\")\n            % 2\n            == 1\n        {\n            has = 1;\n            prod = prod\n                * (s.chars()\n                    .nth(i)\n                    .expect(\"unexpected None/Err\")\n                    .to_digit(10)\n                    .expect(\"unexpected None/Err\")) as i32;\n        }\n    }\n    if has == 0 {\n        return 0;\n    }\n    prod\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "digits", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:03.895262"}
{"task_id": "CodeGen/132", "prompt": "// Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\nfn is_nested(str: &str) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/132\n\n// BEGIN_PROMPT\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return True if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\nfn is_nested(str: &str) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut count = 0;\n    let mut maxcount = 0;\n    for i in 0..str.len() {\n        if str.chars().nth(i).expect(\"unexpected None/Err\") == '[' {\n            count += 1;\n        }\n        if str.chars().nth(i).expect(\"unexpected None/Err\") == ']' {\n            count -= 1;\n        }\n        if count < 0 {\n            count = 0;\n        }\n        if count > maxcount {\n            maxcount = count;\n        }\n        if count <= maxcount - 2 {\n            return true;\n        }\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_nested", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:04.344787"}
{"task_id": "CodeGen/133", "prompt": "// \"\n// This function will take a vector of integers. For all entries in the Vec, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the Vec whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\nfn sum_squares(lst: &[f32]) -> i32 {", "canonical_solution": "let mut sum: f32 = 0.0;\n    for i in 0..lst.len() {\n        sum = sum + (lst[i].ceil() * lst[i].ceil());\n    }\n    sum as i32\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sum_squares() {\n            assert_eq!(sum_squares(&[1.0, 2.0, 3.0]), 14);\n            assert_eq!(sum_squares(&vec![1.0, 2.0, 3.0]), 14);\n            assert_eq!(sum_squares(&vec![1.0, 3.0, 5.0, 7.0]), 84);\n            assert_eq!(sum_squares(&vec![1.4, 4.2, 0.0]), 29);\n            assert_eq!(sum_squares(&vec![-2.4, 1.0, 1.0]), 6);\n            assert_eq!(sum_squares(&vec![100.0, 1.0, 15.0, 2.0]), 10230);\n            assert_eq!(sum_squares(&vec![10000.0, 10000.0]), 200000000);\n            assert_eq!(sum_squares(&vec![-1.4, 4.6, 6.3]), 75);\n            assert_eq!(sum_squares(&vec![-1.4, 17.9, 18.9, 19.9]), 1086);\n            assert_eq!(sum_squares(&vec![0.0]), 0);\n            assert_eq!(sum_squares(&vec![-1.0]), 1);\n            assert_eq!(sum_squares(&vec![-1.0, 1.0, 0.0]), 2);\n        }\n    }", "entry_point": "sum_squares", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:04.801507"}
{"task_id": "CodeGen/135", "prompt": "// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given array will not contain\n// duplicate values.\nfn can_arrange(arr: &[i32]) -> i32 {", "canonical_solution": "let mut max: i32 = -1;\n    for i in 0..arr.len() {\n        if arr[i] <= i as i32 {\n            max = i as i32;\n        }\n    }\n    max\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_can_arrange() {\n            assert_eq!(can_arrange(&[1, 2, 4, 3, 5]), 3);\n            assert_eq!(can_arrange(&vec![1, 2, 4, 5]), -1);\n            assert_eq!(can_arrange(&vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n            assert_eq!(can_arrange(&vec![4, 8, 5, 7, 3]), 4);\n            assert_eq!(can_arrange(&vec![]), -1);\n        }\n    }", "entry_point": "can_arrange", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:05.643570"}
{"task_id": "CodeGen/136", "prompt": "// Create a function that returns a tuple(a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a Vec.\n// If there is no negative or positive integers, return them as None.\nfn largest_smallest_integers(lst: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut maxneg = 0;\n    let mut minpos = 0;\n    for i in 0..lst.len() {\n        if lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg) {\n            maxneg = lst[i];\n        }\n        if lst[i] > 0 && (minpos == 0 || lst[i] < minpos) {\n            minpos = lst[i];\n        }\n    }\n    vec![maxneg, minpos]\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_largest_smallest_integers() {\n            assert_eq!(largest_smallest_integers(&[2, 4, 1, 3, 5, 7]), vec![0, 1]);\n            assert_eq!(\n                largest_smallest_integers(&vec![2, 4, 1, 3, 5, 7, 0]),\n                vec![0, 1]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![1, 3, 2, 4, 5, 6, -2]),\n                vec![-2, 1]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![4, 5, 3, 6, 2, 7, -7]),\n                vec![-7, 2]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![7, 3, 8, 4, 9, 2, 5, -9]),\n                vec![-9, 2]\n            );\n            assert_eq!(largest_smallest_integers(&vec![]), vec![0, 0]);\n            assert_eq!(largest_smallest_integers(&vec![0]), vec![0, 0]);\n            assert_eq!(\n                largest_smallest_integers(&vec![-1, -3, -5, -6]),\n                vec![-1, 0]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![-1, -3, -5, -6, 0]),\n                vec![-1, 0]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![-6, -4, -4, -3, 1]),\n                vec![-3, 1]\n            );\n            assert_eq!(\n                largest_smallest_integers(&vec![-6, -4, -4, -3, -100, 1]),\n                vec![-3, 1]\n            );\n        }\n    }", "entry_point": "largest_smallest_integers", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:06.080129"}
{"task_id": "CodeGen/138", "prompt": "// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\nfn is_equal_to_sum_even(n: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/138\n\n// BEGIN_PROMPT\n// Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\nfn is_equal_to_sum_even(n: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if n % 2 == 0 && n >= 8 {\n        return true;\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_equal_to_sum_even", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:06.943443"}
{"task_id": "CodeGen/139", "prompt": "// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n//\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\nfn special_factorial(n: i32) -> i64 {", "canonical_solution": "let mut fact = 1;\n    let mut bfact: i64 = 1;\n    for i in 1..=n {\n        fact = fact * i;\n        bfact = bfact * fact as i64;\n    }\n    bfact\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_special_factorial() {\n            assert_eq!(special_factorial(4), 288);\n            assert_eq!(special_factorial(5), 34560);\n            assert_eq!(special_factorial(7), 125411328000);\n            assert_eq!(special_factorial(1), 1);\n        }\n    }", "entry_point": "special_factorial", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:07.367095"}
{"task_id": "CodeGen/140", "prompt": "// Given a string text, replace all spaces in it with underscores,\n// and if a string has more than 2 consecutive spaces,\n// then replace all consecutive spaces with -\nfn fix_spaces(text: &str) -> String {", "canonical_solution": "let mut out = String::new();\n    let mut spacelen = 0;\n    for c in text.chars() {\n        if c == ' ' {\n            spacelen += 1;\n        } else {\n            if spacelen == 1 {\n                out.push('_');\n            }\n            if spacelen == 2 {\n                out.push_str(\"__\");\n            }\n            if spacelen > 2 {\n                out.push('-');\n            }\n            spacelen = 0;\n            out.push(c);\n        }\n    }\n    if spacelen == 1 {\n        out.push('_');\n    }\n    if spacelen == 2 {\n        out.push_str(\"__\");\n    }\n    if spacelen > 2 {\n        out.push('-');\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_fix_spaces() {\n            assert_eq!(fix_spaces(\"Example\"), \"Example\");\n            assert_eq!(fix_spaces(\"Mudasir Hanif \"), \"Mudasir_Hanif_\");\n            assert_eq!(\n                fix_spaces(\"Yellow Yellow  Dirty  Fellow\"),\n                \"Yellow_Yellow__Dirty__Fellow\"\n            );\n            assert_eq!(fix_spaces(\"Exa   mple\"), \"Exa-mple\");\n            assert_eq!(fix_spaces(\"   Exa 1 2 2 mple\"), \"-Exa_1_2_2_mple\");\n        }\n    }", "entry_point": "fix_spaces", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:07.797496"}
{"task_id": "CodeGen/142", "prompt": "// \"\n// This function will take a vector of integers. For all entries in the Vec, the function shall square the integer entry if its index is a\n// multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n// change the entries in the Vec whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\nfn sum_squares_142(lst: &[i32]) -> i32 {", "canonical_solution": "let mut sum = 0;\n    for i in 0..lst.len() {\n        if i % 3 == 0 {\n            sum += lst[i] * lst[i];\n        } else if i % 4 == 0 {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_sum_squares_142() {\n            assert_eq!(sum_squares_142(&[1, 2, 3]), 6);\n            assert_eq!(sum_squares_142(&vec![1, 4, 9]), 14);\n            assert_eq!(sum_squares_142(&vec![]), 0);\n            assert_eq!(sum_squares_142(&vec![1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n            assert_eq!(\n                sum_squares_142(&vec![-1, -1, -1, -1, -1, -1, -1, -1, -1]),\n                -3\n            );\n            assert_eq!(sum_squares_142(&vec![0]), 0);\n            assert_eq!(sum_squares_142(&vec![-1, -5, 2, -1, -5]), -126);\n            assert_eq!(sum_squares_142(&vec![-56, -99, 1, 0, -2]), 3030);\n            assert_eq!(sum_squares_142(&vec![-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n            assert_eq!(\n                sum_squares_142(&vec![\n                    -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37\n                ]),\n                -14196\n            );\n            assert_eq!(\n                sum_squares_142(&vec![\n                    -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4,\n                    10\n                ]),\n                -1448\n            );\n        }\n    }", "entry_point": "sum_squares_142", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:08.720507"}
{"task_id": "CodeGen/143", "prompt": "// You are given a string representing a sentence,\n// the sentence contains some words separated by a space,\n// and you have to return a string that contains the words from the original sentence,\n// whose lengths are prime numbers,\n// the order of the words in the new string should be the same as the original one.\n//\n// Constraints:\n// * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfn words_in_sentence(sentence: &str) -> String {", "canonical_solution": "let mut out = String::new();\n    let mut current = String::new();\n    let mut sentence = sentence.to_string();\n    sentence.push(' ');\n\n    for i in 0..sentence.len() {\n        if sentence.chars().nth(i).expect(\"unexpected None/Err\") != ' ' {\n            current.push(sentence.chars().nth(i).expect(\"unexpected None/Err\"));\n        } else {\n            let mut isp = true;\n            let l = current.len();\n            if l < 2 {\n                isp = false;\n            }\n            for j in 2..(l as f64).sqrt() as usize + 1 {\n                if l % j == 0 {\n                    isp = false;\n                }\n            }\n            if isp {\n                out.push_str(&current);\n                out.push(' ');\n            }\n            current = String::new();\n        }\n    }\n    if out.len() > 0 {\n        out.pop();\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_words_in_sentence() {\n            assert_eq!(words_in_sentence(\"This is a test\"), \"is\");\n            assert_eq!(words_in_sentence(\"lets go for swimming\"), \"go for\");\n            assert_eq!(\n                words_in_sentence(\"there is no place available here\"),\n                \"there is no place\"\n            );\n            assert_eq!(words_in_sentence(\"Hi I am Hussein\"), \"Hi am Hussein\");\n            assert_eq!(words_in_sentence(\"go for it\"), \"go for it\");\n            assert_eq!(words_in_sentence(\"here\"), \"\");\n            assert_eq!(words_in_sentence(\"here is\"), \"is\");\n        }\n    }", "entry_point": "words_in_sentence", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:09.167714"}
{"task_id": "CodeGen/144", "prompt": "// Your task is to implement a function that will simplify the expression\n// x * n. The function returns True if x * n evaluates to a whole number and False\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n//\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\nfn simplify(x: &str, n: &str) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/144\n\n// BEGIN_PROMPT\n// Your task is to implement a function that will simplify the expression\n// x * n. The function returns True if x * n evaluates to a whole number and False\n// otherwise. Both x and n, are string representation of a fraction, and have the following format,\n// <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n//\n// You can assume that x, and n are valid fractions, and do not have zero as denominator.\nfn simplify(x: &str, n: &str) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut i = 0;\n    for i in 0..x.len() {\n        if x.chars().nth(i).expect(\"unexpected None/Err\") == '/' {\n            a = x\n                .chars()\n                .take(i)\n                .collect::<String>()\n                .parse::<i32>()\n                .expect(\"unexpected None/Err\");\n            b = x\n                .chars()\n                .skip(i + 1)\n                .collect::<String>()\n                .parse::<i32>()\n                .expect(\"unexpected None/Err\");\n        }\n    }\n    for i in 0..n.len() {\n        if n.chars().nth(i).expect(\"unexpected None/Err\") == '/' {\n            c = n\n                .chars()\n                .take(i)\n                .collect::<String>()\n                .parse::<i32>()\n                .expect(\"unexpected None/Err\");\n            d = n\n                .chars()\n                .skip(i + 1)\n                .collect::<String>()\n                .parse::<i32>()\n                .expect(\"unexpected None/Err\");\n        }\n    }\n    if (a * c) % (b * d) == 0 {\n        return true;\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "simplify", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:09.632197"}
{"task_id": "CodeGen/146", "prompt": "// Write a function that takes an array of numbers as input and returns\n// the number of elements in the array that are greater than 10 and both\n// first and last digits of a number are odd(1, 3, 5, 7, 9).\nfn special_filter(nums: &[i32]) -> i32 {", "canonical_solution": "let mut num = 0;\n    for i in 0..nums.len() {\n        if nums[i] > 10 {\n            let w = nums[i].to_string();\n            if w.chars()\n                .nth(0)\n                .expect(\"unexpected None/Err\")\n                .to_digit(10)\n                .expect(\"unexpected None/Err\")\n                % 2\n                == 1\n                && w.chars()\n                    .last()\n                    .expect(\"unexpected None/Err\")\n                    .to_digit(10)\n                    .expect(\"unexpected None/Err\")\n                    % 2\n                    == 1\n            {\n                num += 1;\n            }\n        }\n    }\n    num\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_special_filter() {\n            assert_eq!(special_filter(&[5, -2, 1, -5]), 0);\n            assert_eq!(special_filter(&vec![15, -73, 14, -15]), 1);\n            assert_eq!(special_filter(&vec![33, -2, -3, 45, 21, 109]), 2);\n            assert_eq!(special_filter(&vec![43, -12, 93, 125, 121, 109]), 4);\n            assert_eq!(special_filter(&vec![71, -2, -33, 75, 21, 19]), 3);\n            assert_eq!(special_filter(&vec![1]), 0);\n            assert_eq!(special_filter(&vec![]), 0);\n        }\n    }", "entry_point": "special_filter", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:10.661373"}
{"task_id": "CodeGen/147", "prompt": "// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i(1  i  n), the value of a[i] = i * i - i + 1.\n// Return the number of triples(a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\nfn get_matrix_triples(n: i32) -> i32 {", "canonical_solution": "let mut a = vec![];\n    let mut sum = vec![vec![0, 0, 0]];\n    let mut sum2 = vec![vec![0, 0, 0]];\n\n    for i in 1..=n {\n        a.push((i * i - i + 1) % 3);\n        sum.push(sum[sum.len() - 1].clone());\n        sum[i as usize][a[i as usize - 1] as usize] += 1;\n    }\n\n    for times in 1..3 {\n        for i in 1..=n {\n            sum2.push(sum2[sum2.len() - 1].clone());\n            if i >= 1 {\n                for j in 0..=2 {\n                    sum2[i as usize][(a[i as usize - 1] + j) as usize % 3] +=\n                        sum[i as usize - 1][j as usize];\n                }\n            }\n        }\n        sum = sum2.clone();\n        sum2 = vec![vec![0, 0, 0]];\n    }\n\n    sum[n as usize][0]\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_get_matrix_triples() {\n            assert_eq!(get_matrix_triples(5), 1);\n            assert_eq!(get_matrix_triples(6), 4);\n            assert_eq!(get_matrix_triples(10), 36);\n            assert_eq!(get_matrix_triples(100), 53361);\n        }\n    }", "entry_point": "get_matrix_triples", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:11.156130"}
{"task_id": "CodeGen/148", "prompt": "// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\nfn bf(planet1: &str, planet2: &str) -> Vec<String> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/148\n\n// BEGIN_PROMPT\n// There are eight planets in our solar system: the closerst to the Sun\n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2.\n// The function should return a tuple containing all planets whose orbits are\n// located between the orbit of planet1 and the orbit of planet2, sorted by\n// the proximity to the sun.\n// The function should return an empty tuple if planet1 or planet2\n// are not correct planet names.\nfn bf(planet1: &str, planet2: &str) -> Vec<String> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let planets = vec![\n        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\",\n    ];\n    let mut pos1: i32 = -1;\n    let mut pos2: i32 = -1;\n    let mut m;\n    for m in 0..planets.len() {\n        if planets[m] == planet1 {\n            pos1 = m as i32;\n        }\n        if planets[m] == planet2 {\n            pos2 = m as i32;\n        }\n    }\n    if pos1 == -1 || pos2 == -1 {\n        return vec![];\n    }\n    if pos1 > pos2 {\n        m = pos1;\n        pos1 = pos2;\n        pos2 = m;\n    }\n    let mut out = vec![];\n    for m in pos1 + 1..pos2 {\n        out.push(planets[m as usize].to_string());\n    }\n    out\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "bf", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:11.601800"}
{"task_id": "CodeGen/150", "prompt": "// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\nfn x_or_y(n: i32, x: i32, y: i32) -> i32 {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/150\n\n// BEGIN_PROMPT\n// A simple program which should return the value of x if n is\n// a prime number and should return the value of y otherwise.\nfn x_or_y(n: i32, x: i32, y: i32) -> i32 {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    let mut isp = true;\n    if n < 2 {\n        isp = false;\n    }\n    for i in 2..=n / 2 {\n        if n % i == 0 {\n            isp = false;\n        }\n    }\n    if isp {\n        return x;\n    }\n    y\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "x_or_y", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:12.480462"}
{"task_id": "CodeGen/152", "prompt": "// I think we all remember that feeling when the result of some long-awaited\n// event is finally known. The feelings and thoughts you have at that moment are\n// definitely worth noting down and comparing.\n// Your task is to determine if a person correctly guessed the results of a number of matches.\n// You are given two arrays of scores and guesses of equal length, where each index shows a match.\n// Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n// the value is 0, and if not, the value is the absolute difference between the guess and the score.\nfn compare(game: &[i32], guess: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut out: Vec<i32> = Vec::new();\n    for i in 0..game.len() {\n        out.push(i32::abs(game[i] - guess[i]));\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_compare() {\n            assert_eq!(\n                compare(&[1, 2, 3, 4, 5, 1], &vec![1, 2, 3, 4, 2, -2]),\n                vec![0, 0, 0, 0, 3, 3]\n            );\n            assert_eq!(\n                compare(&[0, 5, 0, 0, 0, 4], &vec![4, 1, 1, 0, 0, -2]),\n                vec![4, 4, 1, 0, 0, 6]\n            );\n            assert_eq!(\n                compare(&vec![1, 2, 3, 4, 5, 1], &vec![1, 2, 3, 4, 2, -2]),\n                vec![0, 0, 0, 0, 3, 3]\n            );\n            assert_eq!(\n                compare(&vec![0, 0, 0, 0, 0, 0], &vec![0, 0, 0, 0, 0, 0]),\n                vec![0, 0, 0, 0, 0, 0]\n            );\n            assert_eq!(compare(&vec![1, 2, 3], &vec![-1, -2, -3]), vec![2, 4, 6]);\n            assert_eq!(\n                compare(&vec![1, 2, 3, 5], &vec![-1, 2, 3, 4]),\n                vec![2, 0, 0, 1]\n            );\n        }\n    }", "entry_point": "compare", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:13.359664"}
{"task_id": "CodeGen/153", "prompt": "// You will be given the name of a class(a string) and a vector of extensions.\n// The extensions are to be used to load additional classes to the class. The\n// strength of the extension is as follows: Let CAP be the number of the uppercase\n// letters in the extension's name, and let SM be the number of lowercase letters\n// in the extension's name, the strength is given by the fraction CAP - SM.\n// You should find the strongest extension and return a string in this\n// format: ClassName.StrongestExtensionName.\n// If there are two or more extensions with the same strength, you should\n// choose the one that comes first in the Vec.\n// For example, if you are given \"Slices\" as the class and a vector of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n// (its strength is -1).\nfn strongest_extension(class_name: &str, extensions: &[&str]) -> String {", "canonical_solution": "let mut strongest = \"\";\n    let mut max = -1000;\n    for i in 0..extensions.len() {\n        let mut strength = 0;\n        for j in 0..extensions[i].len() {\n            let chr = extensions[i].chars().nth(j).expect(\"unexpected None/Err\");\n            if chr >= 'A' && chr <= 'Z' {\n                strength += 1;\n            }\n            if chr >= 'a' && chr <= 'z' {\n                strength -= 1;\n            }\n        }\n        if strength > max {\n            max = strength;\n            strongest = extensions[i];\n        }\n    }\n    format!(\"{}.{}\", class_name, strongest)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_strongest_extension() {\n            assert_eq!(\n                strongest_extension(\"Watashi\", &vec![\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\n                \"Watashi.eIGHt8OKe\"\n            );\n            assert_eq!(\n                strongest_extension(\n                    \"Boku123\",\n                    &vec![\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]\n                ),\n                \"Boku123.YEs.WeCaNe\"\n            );\n            assert_eq!(\n                strongest_extension(\n                    \"__YESIMHERE\",\n                    &vec![\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]\n                ),\n                \"__YESIMHERE.NuLl__\"\n            );\n            assert_eq!(\n                strongest_extension(\"K\", &vec![\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\n                \"K.TAR\"\n            );\n            assert_eq!(\n                strongest_extension(\"__HAHA\", &vec![\"Tab\", \"123\", \"781345\", \"-_-\"]),\n                \"__HAHA.123\"\n            );\n            assert_eq!(\n                strongest_extension(\n                    \"YameRore\",\n                    &vec![\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]\n                ),\n                \"YameRore.okIWILL123\"\n            );\n            assert_eq!(\n                strongest_extension(\"finNNalLLly\", &vec![\"Die\", \"NowW\", \"Wow\", \"WoW\"]),\n                \"finNNalLLly.WoW\"\n            );\n            assert_eq!(strongest_extension(\"_\", &vec![\"Bb\", \"91245\"]), \"_.Bb\");\n            assert_eq!(\n                strongest_extension(\"Sp\", &vec![\"671235\", \"Bb\"]),\n                \"Sp.671235\"\n            );\n        }\n    }", "entry_point": "strongest_extension", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:13.791695"}
{"task_id": "CodeGen/154", "prompt": "// You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\nfn cycpattern_check(a: &str, b: &str) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/154\n\n// BEGIN_PROMPT\n// You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\nfn cycpattern_check(a: &str, b: &str) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    for i in 0..b.len() {\n        let rotate = format!(\"{}{}\", &b[i..], &b[..i]);\n        if a.contains(&rotate) {\n            return true;\n        }\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "cycpattern_check", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:14.212525"}
{"task_id": "CodeGen/155", "prompt": "// Given an integer. return a tuple that has the number of even and odd digits respectively.\nfn even_odd_count(num: i32) -> Vec<i32> {", "canonical_solution": "let w = num.abs().to_string();\n    let mut n1 = 0;\n    let mut n2 = 0;\n    for i in 0..w.len() {\n        if w.chars()\n            .nth(i)\n            .expect(\"unexpected None/Err\")\n            .to_digit(10)\n            .expect(\"unexpected None/Err\")\n            % 2\n            == 1\n        {\n            n1 += 1;\n        } else {\n            n2 += 1;\n        }\n    }\n    vec![n2, n1]\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_even_odd() {\n            assert_eq!(even_odd_count(7), vec![0, 1]);\n            assert_eq!(even_odd_count(-78), vec![1, 1]);\n            assert_eq!(even_odd_count(3452), vec![2, 2]);\n            assert_eq!(even_odd_count(346211), vec![3, 3]);\n            assert_eq!(even_odd_count(-345821), vec![3, 3]);\n            assert_eq!(even_odd_count(-2), vec![1, 0]);\n            assert_eq!(even_odd_count(-45347), vec![2, 3]);\n            assert_eq!(even_odd_count(0), vec![1, 0]);\n        }\n    }", "entry_point": "even_odd_count", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:14.674135"}
{"task_id": "CodeGen/156", "prompt": "// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\nfn int_to_mini_roman(number: i32) -> String {", "canonical_solution": "let mut current = String::new();\n    let mut number = number;\n    let rep = vec![\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\",\n    ];\n    let num = vec![1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    let mut pos = 0;\n    while number > 0 {\n        while number >= num[pos] {\n            current.push_str(rep[pos]);\n            number -= num[pos];\n        }\n        if number > 0 {\n            pos += 1;\n        }\n    }\n    current\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_int_to_mini_roman() {\n            assert_eq!(int_to_mini_roman(19), \"xix\");\n            assert_eq!(int_to_mini_roman(152), \"clii\");\n            assert_eq!(int_to_mini_roman(251), \"ccli\");\n            assert_eq!(int_to_mini_roman(426), \"cdxxvi\");\n            assert_eq!(int_to_mini_roman(500), \"d\");\n            assert_eq!(int_to_mini_roman(1), \"i\");\n            assert_eq!(int_to_mini_roman(4), \"iv\");\n            assert_eq!(int_to_mini_roman(43), \"xliii\");\n            assert_eq!(int_to_mini_roman(90), \"xc\");\n            assert_eq!(int_to_mini_roman(94), \"xciv\");\n            assert_eq!(int_to_mini_roman(532), \"dxxxii\");\n            assert_eq!(int_to_mini_roman(900), \"cm\");\n            assert_eq!(int_to_mini_roman(994), \"cmxciv\");\n            assert_eq!(int_to_mini_roman(1000), \"m\");\n        }\n    }", "entry_point": "int_to_mini_roman", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:15.112810"}
{"task_id": "CodeGen/157", "prompt": "// Given the lengths of the three sides of a triangle. Return True if the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\nfn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/157\n\n// BEGIN_PROMPT\n// Given the lengths of the three sides of a triangle. Return True if the three\n// sides form a right-angled triangle, False otherwise.\n// A right-angled triangle is a triangle in which one angle is right angle or\n// 90 degree.\nfn right_angle_triangle(a: f32, b: f32, c: f32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if (a * a + b * b - c * c).abs() < 1e-4\n        || (a * a + c * c - b * b).abs() < 1e-4\n        || (b * b + c * c - a * a).abs() < 1e-4\n    {\n        return true;\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "right_angle_triangle", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:15.553061"}
{"task_id": "CodeGen/159", "prompt": "// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return an array of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n//\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n//\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n//\n// Have fun :)\nfn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: CodeGen/159\n\n// BEGIN_PROMPT\n// You're a hungry rabbit, and you already have eaten a certain number of carrots,\n// but now you need to eat more carrots to complete the day's meals.\n// you should return an array of [ total number of eaten carrots after your meals,\n// the number of carrots left after your meals ]\n// if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n//\n// Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n// @need : integer\n// the number of carrots that you need to eat.\n// @remaining : integer\n// the number of remaining carrots thet exist in stock\n//\n// Constrain:\n// * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n//\n// Have fun :)\nfn eat(number: i32, need: i32, remaining: i32) -> Vec<i32> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if need > remaining {\n        return vec![number + remaining, 0];\n    }\n    vec![number + need, remaining - need]\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "eat", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:16.430565"}
{"task_id": "CodeGen/161", "prompt": "// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa,\n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\nfn solve_161(s: &str) -> String {", "canonical_solution": "let mut nletter = 0;\n    let mut out = String::new();\n    for c in s.chars() {\n        let mut w = c;\n        if w >= 'A' && w <= 'Z' {\n            w = w.to_ascii_lowercase();\n        } else if w >= 'a' && w <= 'z' {\n            w = w.to_ascii_uppercase();\n        } else {\n            nletter += 1;\n        }\n        out.push(w);\n    }\n    if nletter == s.len() {\n        out.chars().rev().collect()\n    } else {\n        out\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_solve_161() {\n            assert_eq!(solve_161(\"AsDf\"), \"aSdF\");\n            assert_eq!(solve_161(\"1234\"), \"4321\");\n            assert_eq!(solve_161(\"ab\"), \"AB\");\n            assert_eq!(solve_161(\"#a@C\"), \"#A@c\");\n            assert_eq!(solve_161(\"#AsdfW^45\"), \"#aSDFw^45\");\n            assert_eq!(solve_161(\"#6@2\"), \"2@6#\");\n            assert_eq!(solve_161(\"#$a^D\"), \"#$A^d\");\n            assert_eq!(solve_161(\"#ccc\"), \"#CCC\");\n        }\n    }", "entry_point": "solve_161", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:17.327288"}
{"task_id": "CodeGen/163", "prompt": "// Given two positive integers a and b, return the even digits between a\n// and b, in ascending order.\nfn generate_integers(a: i32, b: i32) -> Vec<i32> {", "canonical_solution": "let mut a = a;\n    let mut b = b;\n    let mut m;\n\n    if b < a {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    let mut out = vec![];\n    for i in a..=b {\n        if i < 10 && i % 2 == 0 {\n            out.push(i);\n        }\n    }\n    out\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_generate_integers() {\n            assert_eq!(generate_integers(2, 10), vec![2, 4, 6, 8]);\n            assert_eq!(generate_integers(10, 2), vec![2, 4, 6, 8]);\n            assert_eq!(generate_integers(132, 2), vec![2, 4, 6, 8]);\n            assert_eq!(generate_integers(17, 89), vec![]);\n        }\n    }", "entry_point": "generate_integers", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:18.243781"}
{"task_id": "Explain/0", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn has_close_elements(numbers: &[f32], threshold: f32) -> bool {\n//     numbers.iter()\n//         .enumerate()\n//         .any(|(i, &a)| {\n//             numbers[i + 1..]\n//                 .iter()\n//                 .any(|&b| (a - b).abs() < threshold)\n//         })\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function checks if any two numbers in a slice are closer to each other than a given threshold. It compares each number with all subsequent numbers using nested iterators, calculating the absolute difference and returning true if any pair is within the threshold.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(explanation.to_lowercase().contains(\"two numbers\"));\n            assert!(\n                explanation.to_lowercase().contains(\"threshold\")\n                    || explanation.to_lowercase().contains(\"closer\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"check\")\n                    || explanation.to_lowercase().contains(\"compar\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:43.139227"}
{"task_id": "Explain/1", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn longest(strings: &[String]) -> Option<String> {\n//     strings.iter()\n//         .max_by_key(|s| s.len())\n//         .cloned()\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function finds the longest string in a slice. It iterates through the strings, compares their lengths to find the maximum, and returns a cloned copy of the longest one. If the slice is empty, it returns None.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(\n                explanation.to_lowercase().contains(\"longest\")\n                    || explanation.to_lowercase().contains(\"maximum\")\n            );\n            assert!(explanation.to_lowercase().contains(\"string\"));\n            assert!(\n                explanation.to_lowercase().contains(\"none\")\n                    || explanation.to_lowercase().contains(\"empty\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:43.610392"}
{"task_id": "Explain/2", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn greatest_common_divisor(mut a: i32, mut b: i32) -> i32 {\n//     while b > 0 {\n//         (a, b) = (b, a % b);\n//     }\n//     a\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function calculates the greatest common divisor(GCD) of two integers using Euclid's algorithm. It repeatedly replaces the larger number with the remainder of dividing it by the smaller number until one becomes zero, then returns the other.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(\n                explanation\n                    .to_lowercase()\n                    .contains(\"greatest common divisor\")\n                    || explanation.to_lowercase().contains(\"gcd\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"euclid\")\n                    || explanation.to_lowercase().contains(\"algorithm\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"remainder\")\n                    || explanation.to_lowercase().contains(\"modulo\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:44.088443"}
{"task_id": "Explain/3", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn is_prime(n: i32) -> bool {\n//     if n < 2 {\n//         return false;\n//     }\n//     !(2..=(n as f32).sqrt() as i32).any(|i| n % i == 0)\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function checks if a number is prime by testing if it's divisible by any number from 2 up to its square root. Numbers less than 2 are not prime. It returns true if no divisors are found, meaning the number is prime.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(explanation.to_lowercase().contains(\"prime\"));\n            assert!(\n                explanation.to_lowercase().contains(\"divisor\")\n                    || explanation.to_lowercase().contains(\"divisi\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"square root\")\n                    || explanation.to_lowercase().contains(\"sqrt\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:44.567235"}
{"task_id": "Explain/4", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn is_palindrome(text: &str) -> bool {\n//     text.chars().eq(text.chars().rev())\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function checks if a string is a palindrome by comparing its characters with the reversed sequence. It uses iterator comparison to test if the string reads the same forwards and backwards, returning true if so.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(explanation.to_lowercase().contains(\"palindrome\"));\n            assert!(\n                explanation.to_lowercase().contains(\"revers\")\n                    || explanation.to_lowercase().contains(\"backward\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"same\")\n                    || explanation.to_lowercase().contains(\"equal\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:45.040777"}
{"task_id": "Explain/5", "prompt": "// Explain what the following Rust function does in simple terms:\n// fn common(lst1: &[i32], lst2: &[i32]) -> Vec<i32> {\n//     let mut result: Vec<i32> = lst1.iter()\n//         .filter(|&n| lst2.contains(n))\n//         .copied()\n//         .collect::<std::collections::HashSet<_>>()\n//         .into_iter()\n//         .collect();\n//     result.sort_unstable();\n//     result\n// }\n// Return a concise explanation as a string.\nfn explain() -> String {", "canonical_solution": "\"This function finds common elements between two lists. It filters the first list to keep only elements present in the second list, removes duplicates using a HashSet, and returns the unique common elements in sorted order.\".to_string()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_explain() {\n            let explanation = explain();\n            assert!(\n                explanation.to_lowercase().contains(\"common\")\n                    || explanation.to_lowercase().contains(\"both\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"sorted\")\n                    || explanation.to_lowercase().contains(\"order\")\n            );\n            assert!(\n                explanation.to_lowercase().contains(\"unique\")\n                    || explanation.to_lowercase().contains(\"duplicate\")\n            );\n        }\n    }", "entry_point": "explain", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:45.520612"}
{"task_id": "Fix/0", "prompt": "// This code produces error E0382: borrow of moved value\n// Error: cannot borrow `numbers` as immutable because it was previously moved\n// fn has_close_elements(numbers: &[f32], threshold: f32) -> bool {\n//     let first = find_first_close(numbers, threshold);\n//     let second = check_duplicates(numbers); // ERROR: numbers was moved\n//     first || second\n// }\n// Fix the code to use borrowing instead of moving.\nfn has_close_elements(numbers: &[f32], threshold: f32) -> bool {", "canonical_solution": "numbers\n        .iter()\n        .enumerate()\n        .any(|(i, &a)| numbers[i + 1..].iter().any(|&b| (a - b).abs() < threshold))\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_has_close_elements() {\n            let nums = vec![1.0, 2.0, 3.0];\n            assert_eq!(has_close_elements(&nums, 0.5), false);\n            // nums can still be used here because we only borrowed it\n            assert_eq!(nums.len(), 3);\n        }\n    }", "entry_point": "has_close_elements", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:32.889454"}
{"task_id": "Fix/1", "prompt": "// This code produces error E0308: mismatched types\n// Error: expected `bool`, found `()`\n// fn below_zero(operations: &[i32]) -> bool {\n//     operations.iter().scan(0, |balance, &op| {\n//         *balance += op;\n//         if *balance < 0 {\n//             return true; // ERROR: returns from closure, not function\n//         }\n//     });\n// }\n// Fix the code to properly return a bool from the function.\nfn below_zero(operations: &[i32]) -> bool {", "canonical_solution": "operations\n        .iter()\n        .scan(0, |balance, &op| {\n            *balance += op;\n            Some(*balance)\n        })\n        .any(|balance| balance < 0)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_below_zero() {\n            assert_eq!(below_zero(&[1, 2, -4]), true);\n            assert_eq!(below_zero(&[1, 2, 3]), false);\n        }\n    }", "entry_point": "below_zero", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:33.351844"}
{"task_id": "Fix/2", "prompt": "// This code produces error E0507: cannot move out of borrowed content\n// Error: cannot move out of `*s` which is behind a shared reference\n// fn longest(strings: &[String]) -> Option<String> {\n//     strings.iter()\n//         .max_by_key(|s| s.len())\n//         .map(|s| *s) // ERROR: trying to move String\n// }\n// Fix the code to clone the string instead of moving it.\nfn longest(strings: &[String]) -> Option<String> {", "canonical_solution": "strings.iter().max_by_key(|s| s.len()).cloned()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_longest() {\n            let strs = vec![\"x\".to_string(), \"yyy\".to_string()];\n            assert_eq!(longest(&strs), Some(\"yyy\".to_string()));\n            // strs can still be used because we cloned, not moved\n            assert_eq!(strs.len(), 2);\n        }\n    }", "entry_point": "longest", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:33.821048"}
{"task_id": "Fix/3", "prompt": "// This code produces error E0384: cannot assign twice to immutable variable\n// Error: cannot assign to `a` as it is not declared as mutable\n// fn greatest_common_divisor(a: i32, b: i32) -> i32 {\n//     while b > 0 {\n//         (a, b) = (b, a % b); // ERROR: a and b are not mutable\n//     }\n//     a\n// }\n// Fix the code by making the parameters mutable.\nfn greatest_common_divisor(mut a: i32, mut b: i32) -> i32 {", "canonical_solution": "while b > 0 {\n        (a, b) = (b, a % b);\n    }\n    a\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_greatest_common_divisor() {\n            assert_eq!(greatest_common_divisor(10, 15), 5);\n            assert_eq!(greatest_common_divisor(144, 60), 12);\n        }\n    }", "entry_point": "greatest_common_divisor", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:34.273564"}
{"task_id": "Fix/4", "prompt": "// This code produces error E0277: the trait `FromIterator<char>` is not implemented for `HashSet<_>`\n// Error: type annotations needed, cannot infer type for type parameter `S`\n// fn count_distinct_characters(s: &str) -> usize {\n//     s.chars()\n//         .map(|c| c.to_ascii_lowercase())\n//         .collect::<HashSet<_>>() // ERROR: missing type annotation\n//         .len()\n// }\n// Fix by adding the full path to HashSet.\nfn count_distinct_characters(s: &str) -> usize {", "canonical_solution": "s.chars()\n        .map(|c| c.to_ascii_lowercase())\n        .collect::<std::collections::HashSet<_>>()\n        .len()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_count_distinct_characters() {\n            assert_eq!(count_distinct_characters(\"abcde\"), 5);\n            assert_eq!(count_distinct_characters(\"aAaA\"), 1);\n        }\n    }", "entry_point": "count_distinct_characters", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:34.732230"}
{"task_id": "Fix/5", "prompt": "// This code produces inefficiency and potential overflow:\n// Warning: checking all numbers up to n-1 is very slow for large primes\n// fn is_prime(n: i32) -> bool {\n//     if n < 2 { return false; }\n//     for k in 2..n { // Inefficient: should only check to sqrt(n)\n//         if n % k == 0 {\n//             return false;\n//         }\n//     }\n//     true\n// }\n// Optimize by checking only up to the square root of n.\nfn is_prime(n: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: Fix/5\n\n// BEGIN_PROMPT\n// This code produces inefficiency and potential overflow:\n// Warning: checking all numbers up to n-1 is very slow for large primes\n// fn is_prime(n: i32) -> bool {\n//     if n < 2 { return false; }\n//     for k in 2..n { // Inefficient: should only check to sqrt(n)\n//         if n % k == 0 {\n//             return false;\n//         }\n//     }\n//     true\n// }\n// Optimize by checking only up to the square root of n.\nfn is_prime(n: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if n < 2 {\n        return false;\n    }\n    !(2..=(n as f32).sqrt() as i32).any(|i| n % i == 0)\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_prime", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:35.191539"}
{"task_id": "Fix/6", "prompt": "// This code produces error E0308: mismatched types\n// Error: expected `Vec<i32>`, found `Map<Iter<'_, i32>, [closure]>`\n// fn incr_list(numbers: &[i32]) -> Vec<i32> {\n//     numbers.iter()\n//         .map(|&n| n + 1) // ERROR: forgot to collect()\n// }\n// Fix by adding collect() to materialize the iterator into a Vec.\nfn incr_list(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "numbers.iter().map(|&n| n + 1).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_incr_list() {\n            assert_eq!(incr_list(&[3, 2, 1]), vec![4, 3, 2]);\n        }\n    }", "entry_point": "incr_list", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:35.650168"}
{"task_id": "Fix/7", "prompt": "// This code produces error E0277: the trait `PartialEq<Rev<Chars>>` is not implemented\n// Error: can't compare `Chars<'_>` with `Rev<Chars<'_>>`\n// fn is_palindrome(text: &str) -> bool {\n//     text.chars() == text.chars().rev() // ERROR: can't compare iterators with ==\n// }\n// Fix by using the eq() method to compare iterator elements.\nfn is_palindrome(text: &str) -> bool {", "canonical_solution": "text.chars().eq(text.chars().rev())\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_is_palindrome() {\n            assert_eq!(is_palindrome(\"aba\"), true);\n            assert_eq!(is_palindrome(\"abc\"), false);\n        }\n    }", "entry_point": "is_palindrome", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:36.117808"}
{"task_id": "Fix/8", "prompt": "// This code produces error E0599: no method named `dedup` found for type `HashSet<char>`\n// Error: HashSet doesn't have a dedup method because it already ensures uniqueness\n// fn same_chars(s1: &str, s2: &str) -> bool {\n//     let mut set1: HashSet<char> = s1.chars().collect();\n//     set1.dedup(); // ERROR: HashSet doesn't need dedup\n//     let mut set2: HashSet<char> = s2.chars().collect();\n//     set2.dedup(); // ERROR: HashSet doesn't need dedup\n//     set1 == set2\n// }\n// Fix by removing dedup calls since HashSet already guarantees uniqueness.\nfn same_chars(s1: &str, s2: &str) -> bool {", "canonical_solution": "let set1: std::collections::HashSet<char> = s1.chars().collect();\n    let set2: std::collections::HashSet<char> = s2.chars().collect();\n    set1 == set2\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_same_chars() {\n            assert_eq!(same_chars(\"abcd\", \"dcba\"), true);\n            assert_eq!(same_chars(\"abc\", \"abd\"), false);\n        }\n    }", "entry_point": "same_chars", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:36.584180"}
{"task_id": "Fix/9", "prompt": "// This code has performance issues with duplicates:\n// Issue: Contains duplicates in result, should use HashSet\n// fn common(lst1: &[i32], lst2: &[i32]) -> Vec<i32> {\n//     let mut result: Vec<i32> = lst1.iter()\n//         .filter(|&n| lst2.contains(n))\n//         .copied()\n//         .collect();\n//     result.sort_unstable();\n//     result // BUG: may contain duplicates\n// }\n// Fix by adding HashSet deduplication step.\nfn common(lst1: &[i32], lst2: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut result: Vec<i32> = lst1\n        .iter()\n        .filter(|&n| lst2.contains(n))\n        .copied()\n        .collect::<std::collections::HashSet<_>>()\n        .into_iter()\n        .collect();\n    result.sort_unstable();\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_common() {\n            assert_eq!(common(&[1, 1, 2, 2], &[1, 2]), vec![1, 2]);\n            assert_eq!(common(&[5, 5, 3, 2], &[3, 2]), vec![2, 3]);\n        }\n    }", "entry_point": "common", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:37.050205"}
{"task_id": "Fix/10", "entry_point": "repeat_message", "prompt": "// This code tried to repeat a message but moved the String and then borrowed it again,\n// causing borrow checker errors(E0382). Rewrite it so it takes a string slice and builds\n// a new String safely.\nfn repeat_message(msg: &str, times: usize) -> String {", "canonical_solution": "let mut result = String::new();\n    for _ in 0..times {\n        result.push_str(msg);\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn repeat_examples() {\n            assert_eq!(repeat_message(\"hi\", 3), \"hihihi\");\n            assert_eq!(repeat_message(\"x\", 1), \"x\");\n            assert_eq!(repeat_message(\"test\", 0), \"\");\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:37.506075"}
{"task_id": "Fix/11", "entry_point": "increment_both", "prompt": "// A previous version of this function took two simultaneous mutable borrows from the same\n// slice and failed with error E0499. Fix it so it safely increments the first two elements,\n// if they exist.\nfn increment_both(values: &mut [i32]) {", "canonical_solution": "if values.len() >= 1 {\n        values[0] += 1;\n    }\n    if values.len() >= 2 {\n        values[1] += 1;\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn increment_examples() {\n            let mut data = [1, 2, 3];\n            increment_both(&mut data);\n            assert_eq!(data, [2, 3, 3]);\n\n            let mut one = [10];\n            increment_both(&mut one);\n            assert_eq!(one, [11]);\n\n            let mut empty: [i32; 0] = [];\n            increment_both(&mut empty);\n            assert_eq!(empty, []);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:37.995743"}
{"task_id": "Fix/12", "entry_point": "safe_divide", "prompt": "// A previous version of this function panicked on divide-by-zero. Fix it so that it returns\n// None when `b` is zero and Some(result) otherwise.\nfn safe_divide(a: i32, b: i32) -> Option<i32> {", "canonical_solution": "if b == 0 { None } else { Some(a / b) }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn safe_divide_examples() {\n            assert_eq!(safe_divide(10, 2), Some(5));\n            assert_eq!(safe_divide(3, 0), None);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:38.453447"}
{"task_id": "Fix/13", "entry_point": "first_char", "prompt": "// A previous version of this function tried to return a `&str` pointing into a temporary\n// String created inside the function, causing lifetime errors. Fix it so that it returns\n// an owned String instead.\nfn first_char(text: &str) -> String {", "canonical_solution": "match text.chars().next() {\n        Some(ch) => ch.to_string(),\n        None => String::new(),\n    }\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn first_char_examples() {\n            assert_eq!(first_char(\"rust\"), \"r\");\n            assert_eq!(first_char(\"\"), \"\");\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:38.919961"}
{"task_id": "Fix/14", "entry_point": "collect_lengths", "prompt": "// A previous version of this function used `.map(|s| s.len()).collect()` without specifying\n// the collection type, leading to type inference errors. Fix it so it collects into Vec<usize>.\nfn collect_lengths(items: &[String]) -> Vec<usize> {", "canonical_solution": "items.iter().map(|s| s.len()).collect::<Vec<usize>>()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn collect_lengths_examples() {\n            let items = vec![String::from(\"a\"), String::from(\"rust\")];\n            assert_eq!(collect_lengths(&items), vec![1, 4]);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:39.385206"}
{"task_id": "Fix/15", "entry_point": "to_uppercase_owned", "prompt": "// A broken version of this function tried to return `&str` pointing to a temporary String\n// created by `text.to_uppercase()`, causing lifetime errors. Fix it so it returns\n// an owned String instead.\nfn to_uppercase_owned(text: &str) -> String {", "canonical_solution": "text.to_uppercase()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn uppercase_examples() {\n            assert_eq!(to_uppercase_owned(\"rust\"), \"RUST\");\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:39.844342"}
{"task_id": "Fix/16", "entry_point": "clamp_to_byte", "prompt": "// A previous version of this function mixed signed and unsigned integers and produced\n// type mismatch errors(E0308). Fix it so it clamps an i32 into the 0..=255 range and\n// returns it as a u8.\nfn clamp_to_byte(value: i32) -> u8 {", "canonical_solution": "let clamped = if value < 0 {\n        0\n    } else if value > 255 {\n        255\n    } else {\n        value\n    };\n    clamped as u8\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn clamp_examples() {\n            assert_eq!(clamp_to_byte(-10), 0);\n            assert_eq!(clamp_to_byte(10), 10);\n            assert_eq!(clamp_to_byte(300), 255);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:40.305499"}
{"task_id": "Fix/17", "entry_point": "safe_index", "prompt": "// A previous version of this function indexed directly into the slice and panicked when\n// the index was out of bounds. Fix it so it returns None when the index is invalid, and\n// Some(value) otherwise.\nfn safe_index(numbers: &[i32], index: usize) -> Option<i32> {", "canonical_solution": "numbers.get(index).copied()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn safe_index_examples() {\n            let data = [10, 20, 30];\n            assert_eq!(safe_index(&data, 1), Some(20));\n            assert_eq!(safe_index(&data, 3), None);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:40.772685"}
{"task_id": "Fix/18", "entry_point": "sum_u32", "prompt": "// A previous version of this function summed u32 values into an i32 accumulator,\n// causing type mismatches. Fix it so that it uses u64 for the accumulator and returns u64.\nfn sum_u32(values: &[u32]) -> u64 {", "canonical_solution": "values.iter().map(|&v| v as u64).sum()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn sum_u32_examples() {\n            let values = [1_u32, 2, 3];\n            assert_eq!(sum_u32(&values), 6);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:41.249381"}
{"task_id": "Fix/19", "entry_point": "unique_strings", "prompt": "// A previous version of this function pushed elements into the result vector while\n// iterating with indices, which was error-prone. Fix it so that it uses a HashSet\n// to track seen items and returns a Vec<String> of unique items in their first-seen order.\nfn unique_strings(items: &[String]) -> Vec<String> {", "canonical_solution": "use std::collections::HashSet;\n\n    let mut seen = HashSet::new();\n    let mut result = Vec::new();\n    for item in items {\n        if seen.insert(item) {\n            result.push(item.clone());\n        }\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn unique_strings_examples() {\n            let items = vec![\n                String::from(\"a\"),\n                String::from(\"b\"),\n                String::from(\"a\"),\n                String::from(\"c\"),\n            ];\n            let result = unique_strings(&items);\n            assert_eq!(\n                result,\n                vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\"),]\n            );\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:41.729967"}
{"task_id": "Fix/20", "entry_point": "parse_or_default", "prompt": "// A previous version of this function used `s.parse::<i32>().unwrap()` and panicked on\n// invalid input. Fix it so that it returns 0 when parsing fails.\nfn parse_or_default(s: &str) -> i32 {", "canonical_solution": "s.parse::<i32>().unwrap_or(0)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn parse_or_default_examples() {\n            assert_eq!(parse_or_default(\"10\"), 10);\n            assert_eq!(parse_or_default(\"abc\"), 0);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:42.204749"}
{"task_id": "Fix/21", "entry_point": "last_char", "prompt": "// A previous version of this function attempted to index directly into a String by byte\n// offset to get the last character, which is not valid for UTF-8 and caused logic errors.\n// Fix it so that it returns the last Unicode scalar value as an Option<char>.\nfn last_char(text: &str) -> Option<char> {", "canonical_solution": "text.chars().rev().next()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn last_char_examples() {\n            assert_eq!(last_char(\"rust\"), Some('t'));\n            assert_eq!(last_char(\"\"), None);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:42.670187"}
{"task_id": "Transform/0", "prompt": "// Transform this code to use iterator methods instead of manual nested loops:\n// The function should check if any two numbers in a slice are closer than a threshold.\n// Original pattern:\n//   for i in 0..numbers.len() {\n//       for j in i + 1..numbers.len() {\n//           if(numbers[i] - numbers[j]).abs() < threshold { return true; }\n//       }\n//   }\n// Transform to use iterator chains with any() and enumerate().\nfn has_close_elements(numbers: &[f32], threshold: f32) -> bool {", "canonical_solution": "numbers\n        .iter()\n        .enumerate()\n        .any(|(i, &a)| numbers[i + 1..].iter().any(|&b| (a - b).abs() < threshold))\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_has_close_elements() {\n            assert_eq!(has_close_elements(&[11.0, 2.0, 3.9, 4.0], 0.3), true);\n            assert_eq!(has_close_elements(&[1.0, 2.0, 3.9], 0.05), false);\n            assert_eq!(has_close_elements(&[], 1.0), false);\n        }\n    }", "entry_point": "has_close_elements", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:18.682895"}
{"task_id": "Transform/1", "prompt": "// Transform this imperative code to use functional iterator patterns:\n// Original:\n//   let mut balance = 0;\n//   for op in operations {\n//       balance += op;\n//       if balance < 0 {\n//           return true;\n//       }\n//   }\n//   false\n// Transform to use scan() and any() methods.\nfn below_zero(operations: &[i32]) -> bool {", "canonical_solution": "operations\n        .iter()\n        .scan(0, |balance, &op| {\n            *balance += op;\n            Some(*balance)\n        })\n        .any(|balance| balance < 0)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_below_zero() {\n            assert_eq!(below_zero(&[1, 2, -4, 5, 6]), true);\n            assert_eq!(below_zero(&[1, 2, 3]), false);\n            assert_eq!(below_zero(&[]), false);\n        }\n    }", "entry_point": "below_zero", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:19.122071"}
{"task_id": "Transform/2", "prompt": "// Transform this code to use Option combinators instead of manual checks:\n// Original:\n//   if strings.is_empty() {\n//       return None;\n//   }\n//   let mut max_len = 0;\n//   let mut result = String::new();\n//   for s in strings {\n//       if s.len() > max_len {\n//           result = s.clone();\n//           max_len = s.len();\n//       }\n//   }\n//   Some(result)\n// Transform to use max_by_key() iterator method.\nfn longest(strings: &[String]) -> Option<String> {", "canonical_solution": "strings.iter().max_by_key(|s| s.len()).cloned()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_longest() {\n            assert_eq!(longest(&[]), None);\n            assert_eq!(\n                longest(&[\"x\".to_string(), \"yyy\".to_string()]),\n                Some(\"yyy\".to_string())\n            );\n        }\n    }", "entry_point": "longest", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:19.563419"}
{"task_id": "Transform/3", "prompt": "// Transform this recursive GCD implementation to an iterative one:\n// Original:\n//   fn gcd(a: i32, b: i32) -> i32 {\n//       if b == 0 {\n//           a\n//       } else {\n//           gcd(b, a % b)\n//       }\n//   }\n// Transform to use a while loop with tuple destructuring.\nfn greatest_common_divisor(mut a: i32, mut b: i32) -> i32 {", "canonical_solution": "while b > 0 {\n        (a, b) = (b, a % b);\n    }\n    a\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_greatest_common_divisor() {\n            assert_eq!(greatest_common_divisor(10, 15), 5);\n            assert_eq!(greatest_common_divisor(49, 14), 7);\n            assert_eq!(greatest_common_divisor(144, 60), 12);\n        }\n    }", "entry_point": "greatest_common_divisor", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:19.990659"}
{"task_id": "Transform/4", "prompt": "// Transform this code to use iterator methods and return usize instead of i32:\n// Original:\n//   let mut res = HashSet::new();\n//   for c in str.chars() {\n//       res.insert(c.to_ascii_lowercase());\n//   }\n//   res.len() as i32\n// Transform to use a single iterator chain with map and collect.\nfn count_distinct_characters(s: &str) -> usize {", "canonical_solution": "s.chars()\n        .map(|c| c.to_ascii_lowercase())\n        .collect::<std::collections::HashSet<_>>()\n        .len()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_count_distinct_characters() {\n            assert_eq!(count_distinct_characters(\"abcde\"), 5);\n            assert_eq!(count_distinct_characters(\"aAaA\"), 1);\n            assert_eq!(count_distinct_characters(\"\"), 0);\n        }\n    }", "entry_point": "count_distinct_characters", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:20.438781"}
{"task_id": "Transform/5", "prompt": "// Transform this imperative prime check to use iterator methods:\n// Original:\n//   if n < 2 {\n//       return false;\n//   }\n//   for k in 2..n {\n//       if n % k == 0 {\n//           return false;\n//       }\n//   }\n//   true\n// Transform to use range with any() and optimize by only checking up to sqrt(n).\nfn is_prime(n: i32) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: Transform/5\n\n// BEGIN_PROMPT\n// Transform this imperative prime check to use iterator methods:\n// Original:\n//   if n < 2 {\n//       return false;\n//   }\n//   for k in 2..n {\n//       if n % k == 0 {\n//           return false;\n//       }\n//   }\n//   true\n// Transform to use range with any() and optimize by only checking up to sqrt(n).\nfn is_prime(n: i32) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if n < 2 {\n        return false;\n    }\n    !(2..=(n as f32).sqrt() as i32).any(|i| n % i == 0)\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "entry_point": "is_prime", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:20.887317"}
{"task_id": "Transform/6", "prompt": "// Transform this manual loop to use iterator map:\n// Original:\n//   let mut result = Vec::new();\n//   for &n in Vec {\n//       result.push(n + 1);\n//   }\n//   result\n// Transform to use a single iterator chain.\nfn incr_list(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "numbers.iter().map(|&n| n + 1).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_incr_list() {\n            assert_eq!(incr_list(&[3, 2, 1]), vec![4, 3, 2]);\n            assert_eq!(incr_list(&[]), vec![]);\n        }\n    }", "entry_point": "incr_list", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:21.314059"}
{"task_id": "Transform/7", "prompt": "// Transform this manual string reversal check to use iterator comparison:\n// Original:\n//   let reversed: &str = text.chars().rev().collect();\n//   reversed == text\n// Transform to use the eq() method to compare iterators directly without allocation.\nfn is_palindrome(text: &str) -> bool {", "canonical_solution": "text.chars().eq(text.chars().rev())\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_is_palindrome() {\n            assert_eq!(is_palindrome(\"aba\"), true);\n            assert_eq!(is_palindrome(\"abc\"), false);\n            assert_eq!(is_palindrome(\"\"), true);\n        }\n    }", "entry_point": "is_palindrome", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:21.741952"}
{"task_id": "Transform/8", "prompt": "// Transform this code to construct HashSets directly from iterators:\n// Original:\n//   let mut v1: Vec<char> = str1.chars().collect();\n//   v1.sort();\n//   v1.dedup();\n//   let mut v2: Vec<char> = str2.chars().collect();\n//   v2.sort();\n//   v2.dedup();\n//   v1 == v2\n// Transform to use HashSet::from_iter or collect directly.\nfn same_chars(s1: &str, s2: &str) -> bool {", "canonical_solution": "let set1: std::collections::HashSet<char> = s1.chars().collect();\n    let set2: std::collections::HashSet<char> = s2.chars().collect();\n    set1 == set2\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_same_chars() {\n            assert_eq!(same_chars(\"abcd\", \"dddddddabc\"), true);\n            assert_eq!(same_chars(\"eabcd\", \"dddddddabc\"), false);\n        }\n    }", "entry_point": "same_chars", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:22.170516"}
{"task_id": "Transform/9", "prompt": "// Transform this code to use HashSet for deduplication instead of manual dedup:\n// Original:\n//   let mut res: Vec<i32> = lst1.into_iter()\n//       .filter(|n| lst2.contains(n))\n//       .collect();\n//   res.sort();\n//   res.dedup();\n//   res\n// Transform to collect into HashSet first, then back to Vec and sort.\nfn common(lst1: &[i32], lst2: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut result: Vec<i32> = lst1\n        .iter()\n        .filter(|&n| lst2.contains(n))\n        .copied()\n        .collect::<std::collections::HashSet<_>>()\n        .into_iter()\n        .collect();\n    result.sort_unstable();\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn test_common() {\n            assert_eq!(common(&[5, 3, 2, 8], &[3, 2]), vec![2, 3]);\n            assert_eq!(common(&[4, 3, 2, 8], &[3, 2, 4]), vec![2, 3, 4]);\n        }\n    }", "entry_point": "common", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:22.614786"}
{"task_id": "Transform/10", "entry_point": "sum_positive", "prompt": "// Transform this function to use iterator methods instead of a manual loop.\n// The function should return the sum of all positive integers in the slice.\n// Negative numbers and zero should be ignored.\nfn sum_positive(numbers: &[i32]) -> i32 {", "canonical_solution": "let sum: i32 = numbers.iter().copied().filter(|&n| n > 0).sum();\n    sum\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn basic_cases() {\n            assert_eq!(sum_positive(&[1, 2, 3]), 6);\n            assert_eq!(sum_positive(&[-1, 0, 5, -3, 2]), 7);\n            assert_eq!(sum_positive(&[-5, -1, 0]), 0);\n            assert_eq!(sum_positive(&[]), 0);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:23.043226"}
{"task_id": "Transform/11", "entry_point": "count_long_words", "prompt": "// Transform this function to use iterator methods instead of indexing.\n// The function should count how many words in the string have length at least `min_len`.\n// Words are separated by ASCII whitespace.\nfn count_long_words(text: &str, min_len: usize) -> usize {", "canonical_solution": "text.split_whitespace()\n        .filter(|w| w.len() >= min_len)\n        .count()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn count_various_lengths() {\n            assert_eq!(count_long_words(\"one two three four\", 3), 3);\n            assert_eq!(count_long_words(\"one two three four\", 5), 0);\n            assert_eq!(count_long_words(\"rust language\", 4), 2);\n            assert_eq!(count_long_words(\"\", 1), 0);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:23.469644"}
{"task_id": "Transform/12", "entry_point": "unique_sorted", "prompt": "// Transform this function to use iterator-friendly patterns.\n// The function should return a new vector containing the unique values from the input,\n// sorted in ascending order.\nfn unique_sorted(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut v: Vec<i32> = numbers.to_vec();\n    v.sort();\n    v.dedup();\n    v\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn unique_and_sorted() {\n            assert_eq!(unique_sorted(&[3, 1, 2, 3, 2]), vec![1, 2, 3]);\n            assert_eq!(unique_sorted(&[]), Vec::<i32>::new());\n            assert_eq!(unique_sorted(&[1, 1, 1]), vec![1]);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:23.893455"}
{"task_id": "Transform/13", "entry_point": "product_of_nonzero", "prompt": "// Transform this function to use iterator `fold` instead of a mutable accumulator.\n// The function should return the product of all non-zero integers in the slice.\n// If there are no non-zero elements, it should return 1.\nfn product_of_nonzero(numbers: &[i32]) -> i32 {", "canonical_solution": "numbers\n        .iter()\n        .copied()\n        .filter(|&n| n != 0)\n        .fold(1, |acc, n| acc * n)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn product_examples() {\n            assert_eq!(product_of_nonzero(&[1, 2, 3]), 6);\n            assert_eq!(product_of_nonzero(&[0, 2, 0, 3]), 6);\n            assert_eq!(product_of_nonzero(&[0, 0, 0]), 1);\n            assert_eq!(product_of_nonzero(&[]), 1);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:24.323307"}
{"task_id": "Transform/14", "entry_point": "collect_even_indices", "prompt": "// Transform this function to use `iter().enumerate()` and `filter_map`.\n// The function should return the indices of all even numbers in the slice.\nfn collect_even_indices(numbers: &[i32]) -> Vec<usize> {", "canonical_solution": "numbers\n        .iter()\n        .enumerate()\n        .filter_map(|(idx, &value)| if value % 2 == 0 { Some(idx) } else { None })\n        .collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn indices_of_even_numbers() {\n            assert_eq!(collect_even_indices(&[1, 2, 3, 4, 5]), vec![1, 3]);\n            assert_eq!(collect_even_indices(&[2, 4, 6]), vec![0, 1, 2]);\n            assert_eq!(collect_even_indices(&[1, 3, 5]), Vec::<usize>::new());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:24.784349"}
{"task_id": "Transform/16", "entry_point": "join_with_comma", "prompt": "// Transform this function to use iterator-based string building instead of manual indexing.\n// The function should join the given slice of string slices with a comma.\n// For example, [\"a\", \"b\", \"c\"] becomes \"a,b,c\".\nfn join_with_comma(parts: &[&str]) -> String {", "canonical_solution": "let mut result = String::new();\n    for (i, part) in parts.iter().enumerate() {\n        if i > 0 {\n            result.push(',');\n        }\n        result.push_str(part);\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn join_examples() {\n            assert_eq!(join_with_comma(&[\"a\", \"b\", \"c\"]), \"a,b,c\");\n            assert_eq!(join_with_comma(&[\"single\"]), \"single\");\n            assert_eq!(join_with_comma(&[]), \"\");\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:25.702886"}
{"task_id": "Transform/17", "entry_point": "filter_non_empty", "prompt": "// Transform this function to use `iter().filter()` and `cloned()` instead of a manual loop.\n// The function should return a new vector containing only the non-empty strings.\nfn filter_non_empty(items: &[String]) -> Vec<String> {", "canonical_solution": "items.iter().filter(|s| !s.is_empty()).cloned().collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn filter_strings() {\n            let items = vec![String::from(\"hello\"), String::new(), String::from(\"world\")];\n            let result = filter_non_empty(&items);\n            assert_eq!(result, vec![String::from(\"hello\"), String::from(\"world\")]);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:26.150362"}
{"task_id": "Transform/18", "entry_point": "index_of_max", "prompt": "// Transform this function to use `iter().enumerate().max_by_key`.\n// The function should return the index of the maximum element in the slice,\n// or None if the slice is empty.\nfn index_of_max(numbers: &[i32]) -> Option<usize> {", "canonical_solution": "numbers\n        .iter()\n        .enumerate()\n        .max_by_key(|&(_, value)| value)\n        .map(|(idx, _)| idx)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn max_index_examples() {\n            assert_eq!(index_of_max(&[1, 3, 2]), Some(1));\n            assert_eq!(index_of_max(&[-5, -1, -3]), Some(1));\n            assert_eq!(index_of_max(&[]), None);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:26.595708"}
{"task_id": "Transform/19", "entry_point": "count_char", "prompt": "// Transform this function to use iterators over characters.\n// The function should count how many times the character `ch` appears in `text`.\nfn count_char(text: &str, ch: char) -> usize {", "canonical_solution": "text.chars().filter(|&c| c == ch).count()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn count_char_examples() {\n            assert_eq!(count_char(\"banana\", 'a'), 3);\n            assert_eq!(count_char(\"banana\", 'b'), 1);\n            assert_eq!(count_char(\"banana\", 'x'), 0);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:27.026075"}
{"task_id": "Transform/20", "entry_point": "flatten_slices", "prompt": "// Transform this function to use `flat_map` instead of nested loops.\n// The function should flatten a slice of integer slices into a single vector.\nfn flatten_slices(slices: &[&[i32]]) -> Vec<i32> {", "canonical_solution": "slices\n        .iter()\n        .flat_map(|slice| slice.iter().copied())\n        .collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn flatten_examples() {\n            let a = [1, 2];\n            let b = [3];\n            let c = [4, 5];\n            let slices: [&[i32]; 3] = [&a, &b, &c];\n            assert_eq!(flatten_slices(&slices), vec![1, 2, 3, 4, 5]);\n            let empty: [&[i32]; 0] = [];\n            assert_eq!(flatten_slices(&empty), Vec::<i32>::new());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:27.462091"}
{"task_id": "Transform/21", "entry_point": "sum_of_squares", "prompt": "// Transform this function to use `map` and `sum`.\n// The function should return the sum of squares of all integers in the slice.\nfn sum_of_squares(numbers: &[i32]) -> i32 {", "canonical_solution": "numbers.iter().map(|&n| n * n).sum()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn squares_sum() {\n            assert_eq!(sum_of_squares(&[1, 2, 3]), 14);\n            assert_eq!(sum_of_squares(&[-1, 1]), 2);\n            assert_eq!(sum_of_squares(&[]), 0);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:27.918162"}
{"task_id": "Transform/22", "entry_point": "find_first_even", "prompt": "// Transform this function to use `iter().copied().find`.\n// The function should return the first even number in the slice, or None if none exists.\nfn find_first_even(numbers: &[i32]) -> Option<i32> {", "canonical_solution": "numbers.iter().copied().find(|n| n % 2 == 0)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn find_even_examples() {\n            assert_eq!(find_first_even(&[1, 3, 4, 6]), Some(4));\n            assert_eq!(find_first_even(&[2, 3, 4]), Some(2));\n            assert_eq!(find_first_even(&[1, 3, 5]), None);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:28.361058"}
{"task_id": "Transform/23", "entry_point": "remove_negative", "prompt": "// Transform this function to use `filter`.\n// The function should return a new vector containing only the non-negative integers.\nfn remove_negative(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "numbers.iter().copied().filter(|&n| n >= 0).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn filter_negative_examples() {\n            assert_eq!(remove_negative(&[-1, 0, 3, -5, 4]), vec![0, 3, 4]);\n            assert_eq!(remove_negative(&[-1, -2]), Vec::<i32>::new());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:28.798517"}
{"task_id": "Transform/24", "entry_point": "average_non_empty", "prompt": "// Transform this function to use iterator methods.\n// Return the average of the numbers as `Some(f64)` if the slice is non-empty,\n// or `None` if it is empty.\nfn average_non_empty(numbers: &[f64]) -> Option<f64> {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: Transform/24\n\n// BEGIN_PROMPT\n// Transform this function to use iterator methods.\n// Return the average of the numbers as `Some(f64)` if the slice is non-empty,\n// or `None` if it is empty.\nfn average_non_empty(numbers: &[f64]) -> Option<f64> {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    if numbers.is_empty() {\n        return None;\n    }\n    let sum: f64 = numbers.iter().copied().sum();\n    let count = numbers.len() as f64;\n    Some(sum / count)\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:29.240706"}
{"task_id": "Transform/25", "entry_point": "concat_with_space", "prompt": "// Transform this function to build the result string using iterator methods.\n// The function should concatenate the given vector of strings separated by a single space.\nfn concat_with_space(words: &[String]) -> String {", "canonical_solution": "let mut result = String::new();\n    for (i, word) in words.iter().enumerate() {\n        if i > 0 {\n            result.push(' ');\n        }\n        result.push_str(word);\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn concat_examples() {\n            let words = vec![String::from(\"hello\"), String::from(\"world\")];\n            assert_eq!(concat_with_space(&words), \"hello world\");\n            let empty: Vec<String> = Vec::new();\n            assert_eq!(concat_with_space(&empty), \"\");\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:29.685462"}
{"task_id": "Transform/26", "entry_point": "take_while_positive", "prompt": "// Transform this function to use `iter().take_while`.\n// The function should return a vector of numbers from the slice prefix until the first\n// non-positive(<= 0) element is encountered(which is not included).\nfn take_while_positive(numbers: &[i32]) -> Vec<i32> {", "canonical_solution": "numbers.iter().copied().take_while(|&n| n > 0).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn take_while_examples() {\n            assert_eq!(take_while_positive(&[1, 2, 3, 0, 4]), vec![1, 2, 3]);\n            assert_eq!(take_while_positive(&[0, 1, 2]), Vec::<i32>::new());\n            assert_eq!(take_while_positive(&[1, 2, 3]), vec![1, 2, 3]);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:30.111925"}
{"task_id": "Transform/27", "entry_point": "partition_even_odd", "prompt": "// Transform this function to use `partition` on an iterator.\n// The function should return a pair of vectors: (even_numbers, odd_numbers).\nfn partition_even_odd(numbers: &[i32]) -> (Vec<i32>, Vec<i32>) {", "canonical_solution": "let (even, odd): (Vec<i32>, Vec<i32>) = numbers.iter().copied().partition(|n| n % 2 == 0);\n    (even, odd)\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn partition_examples() {\n            let (even, odd) = partition_even_odd(&[1, 2, 3, 4]);\n            assert_eq!(even, vec![2, 4]);\n            assert_eq!(odd, vec![1, 3]);\n            let (even2, odd2) = partition_even_odd(&[]);\n            assert!(even2.is_empty() && odd2.is_empty());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:30.545323"}
{"task_id": "Transform/28", "entry_point": "has_duplicate", "prompt": "// Transform this function to use a HashSet with iterator methods.\n// The function should return true if the slice contains any duplicate string.\nfn has_duplicate(items: &[String]) -> bool {", "canonical_solution": "// AUTO-GENERATED FROM HumanEval JSONL\n// DO NOT EDIT BY HAND\n// Task: Transform/28\n\n// BEGIN_PROMPT\n// Transform this function to use a HashSet with iterator methods.\n// The function should return true if the slice contains any duplicate string.\nfn has_duplicate(items: &[String]) -> bool {\n    // END_PROMPT\n\n    // BEGIN_CANONICAL_SOLUTION\n    use std::collections::HashSet;\n\n    let mut seen = HashSet::new();\n    for item in items {\n        if !seen.insert(item) {\n            return true;\n        }\n    }\n    false\n}\n\n// END_CANONICAL_SOLUTION", "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // BEGIN_TESTS\n\n    ", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:31.002533"}
{"task_id": "Transform/29", "entry_point": "merge_sorted", "prompt": "// Transform this function to use iterator-style merging of two sorted slices.\n// Both input slices are sorted in ascending order. The function should return a new\n// vector containing all elements from both slices, also in ascending order.\nfn merge_sorted(a: &[i32], b: &[i32]) -> Vec<i32> {", "canonical_solution": "let mut result = Vec::with_capacity(a.len() + b.len());\n    let mut i = 0;\n    let mut j = 0;\n    while i < a.len() && j < b.len() {\n        if a[i] <= b[j] {\n            result.push(a[i]);\n            i += 1;\n        } else {\n            result.push(b[j]);\n            j += 1;\n        }\n    }\n    if i < a.len() {\n        result.extend_from_slice(&a[i..]);\n    }\n    if j < b.len() {\n        result.extend_from_slice(&b[j..]);\n    }\n    result\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn merge_examples() {\n            assert_eq!(merge_sorted(&[1, 3, 5], &[2, 4, 6]), vec![1, 2, 3, 4, 5, 6]);\n            assert_eq!(merge_sorted(&[], &[1, 2]), vec![1, 2]);\n            assert_eq!(merge_sorted(&[1, 2], &[]), vec![1, 2]);\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:31.484626"}
{"task_id": "Transform/30", "entry_point": "filter_map_parse_ints", "prompt": "// Transform this function to use `filter_map`.\n// The function should parse each string as an i32 and keep only the successful parses.\nfn filter_map_parse_ints(parts: &[&str]) -> Vec<i32> {", "canonical_solution": "parts.iter().filter_map(|s| s.parse::<i32>().ok()).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn parse_examples() {\n            assert_eq!(filter_map_parse_ints(&[\"1\", \"x\", \"2\"]), vec![1, 2]);\n            assert_eq!(filter_map_parse_ints(&[\"a\", \"b\"]), Vec::<i32>::new());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:31.956488"}
{"task_id": "Transform/31", "entry_point": "zip_and_add", "prompt": "// Transform this function to use `iter().zip`.\n// The function should return a vector where each element is the sum of the corresponding\n// elements from `a` and `b`. The length of the result is the minimum of the two slices.\nfn zip_and_add(a: &[i32], b: &[i32]) -> Vec<i32> {", "canonical_solution": "a.iter().zip(b.iter()).map(|(&x, &y)| x + y).collect()\n}", "test": "#[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[test]\n        fn zip_add_examples() {\n            assert_eq!(zip_and_add(&[1, 2, 3], &[4, 5, 6]), vec![5, 7, 9]);\n            assert_eq!(zip_and_add(&[1, 2], &[10]), vec![11]);\n            assert_eq!(zip_and_add(&[], &[1, 2, 3]), Vec::<i32>::new());\n        }\n    }", "typechecked": true, "rustfmt_style_edition": "2024", "processed_date": "2025-11-30T01:06:32.424695"}
